{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"CHANGELOG-v0/","text":"Change log # See upgrade notes for helpful information when upgrading from previous versions. Attention PSRule v0 is a prior release. For more information see v2 release notes. Please check out our upgrade notes to get prepared for upgrading to the latest version. v0.22.0 # What's changed since v0.21.0: Engine features: Added HasFields assertion helper to check all fields exist. #578 Updated HasField to check if any of the specified fields exist. #578 General improvements: Input format detection now includes .jsonc and .markdown file extensions. #575 Improved support for cross module rule dependencies. #248 Rule dependencies are now automatically imported. Bug fixes: Fixed handling for null or empty arrays with StartsWith , Contains , EndsWith , In , and NotIn . #579 What's changed since pre-release v0.22.0-B2010014: No additional changes. v0.22.0-B2010014 (pre-release) # What's changed since v0.21.0: Engine features: Added HasFields assertion helper to check all fields exist. #578 Updated HasField to check if any of the specified fields exist. #578 General improvements: Input format detection now includes .jsonc and .markdown file extensions. #575 Improved support for cross module rule dependencies. #248 Rule dependencies are now automatically imported. Bug fixes: Fixed handling for null or empty arrays with StartsWith , Contains , EndsWith , In , and NotIn . #579 v0.21.0 # What's changed since v0.20.0: Engine features: Added support for formatting results as markdown. #474 Use -OutputFormat Markdown or configure Output.Format to output markdown. To format as either detail or summary, use the -As parameter or configure Output.As . Added character case assertion helpers IsLower , and IsUpper . #555 IsLower checks that all letters in a field value are lowercase. IsUpper checks that all letters in a field value are uppercase. General improvements: Numerical strings can be converted with numeric assertion helpers. #550 Added outcome Output.Outcome as a configurable option. #552 Added help links and default snippets to schemas. #561 Improved rule error reporting by including rule and source location. #565 Engineering: Bump Manatee.Json from 13.0.2 to 13.0.3. #563 Bug fixes: Fixed NUnit report reasons should be escaped in markdown. #471 Fixed reporting of error when rule error is handled. #564 Additionally rules can use -ErrorAction Ignore to ignore non-exception errors. Fixed first exception stops other rules from being processed. #566 What's changed since pre-release v0.21.0-B2010010: No additional changes. v0.21.0-B2010010 (pre-release) # What's changed since pre-release v0.21.0-B2010003: General improvements: Improved rule error reporting by including rule and source location. #565 v0.21.0-B2010003 (pre-release) # What's changed since pre-release v0.21.0-B2009016: General improvements: Added help links and default snippets to schemas. #561 Engineering: Bump Manatee.Json from 13.0.2 to 13.0.3. #563 Bug fixes: Fixed reporting of error when rule error is handled. #564 Additionally rules can use -ErrorAction Ignore to ignore non-exception errors. Fixed first exception stops other rules from being processed. #566 v0.21.0-B2009016 (pre-release) # What's changed since pre-release v0.21.0-B2009006: Engine features: Added character case assertion helpers IsLower , and IsUpper . #555 IsLower checks that all letters in a field value are lowercase. IsUpper checks that all letters in a field value are uppercase. Bug fixes: Fixed NUnit report reasons should be escaped in markdown. #471 v0.21.0-B2009006 (pre-release) # What's changed since v0.20.0: Engine features: Added support for formatting results as markdown. #474 Use -OutputFormat Markdown or configure Output.Format to output markdown. To format as either detail or summary, use the -As parameter or configure Output.As . General improvements: Numerical strings can be converted with numeric assertion helpers. #550 Added outcome Output.Outcome as a configurable option. #552 v0.20.0 # What's changed since v0.19.0: Engine features: Added support for scanning repository files. #524 Added File input type ( -InputType File ) to scan for files without deserializing them. Added Input.PathIgnore option to ignore files. When using the File input type path specs in .gitignore are ignored. Added Get-PSRuleTarget cmdlet to read input files and return raw objects. #525 This cmdlet can be used to troubleshoot PSRule input issues. Baselines can now be flagged as obsolete. #499 Set the metadata.annotations.obsolete property to true to flag a baseline as obsolete. When an obsolete baseline is used, a warning will be generated. Added file assertion helpers FileHeader , and FilePath . #534 FileHeader checks for a comment header in the file. FilePath checks that a file path (optionally with suffixes) exist. General improvements: Added automatic binding for Rule object. #542 Engineering: Warn when deprecated $Rule properties are used. #536 #545 First usage of deprecated property generates a warning. Rule using deprecated property is flagged in debug output. Bump YamlDotNet dependency to v8.1.2. #439 Bug fixes: Fixed out of bounds exception when empty markdown documentation is used. #516 What's changed since pre-release v0.20.0-B2009013: Bug fixes: Fixed excessive obsolete property warnings. #545 v0.20.0-B2009013 (pre-release) # What's changed since pre-release v0.20.0-B2009007: General improvements: Added automatic binding for Rule object. #542 Bug fixes: Fixed InputFileInfo Type property causes downstream binding issues. #541 v0.20.0-B2009007 (pre-release) # What's changed since pre-release v0.20.0-B2008010: Engine features: Added file assertion helpers FileHeader , and FilePath . #534 FileHeader checks for a comment header in the file. FilePath checks that a file path (optionally with suffixes) exist. Engineering: Warn when deprecated $Rule properties are used. #536 Bug fixes: Fixed out of bounds exception when empty markdown documentation is used. #516 Fixed lines breaks in RepositoryInfo target name with git ref. #538 v0.20.0-B2008010 (pre-release) # What's changed since pre-release v0.20.0-B2008002: Engine features: Baselines can now be flagged as obsolete. #499 Set the metadata.annotations.obsolete property to true to flag a baseline as obsolete. When an obsolete baseline is used, a warning will be generated. Engineering: Bump YamlDotNet dependency to v8.1.2. #439 v0.20.0-B2008002 (pre-release) # What's changed since v0.19.0: Engine features: Added support for scanning repository files. #524 Added File input type ( -InputType File ) to scan for files without deserializing them. Added Input.PathIgnore option to ignore files. When using the File input type path specs in .gitignore are ignored. Added Get-PSRuleTarget cmdlet to read input files and return raw objects. #525 This cmdlet can be used to troubleshoot PSRule input issues. v0.19.0 # What's changed since v0.18.1: Engine features: Added Reason method to assertion results. #500 This new method, streamlines setting custom reasons particularly with formatted strings. The Reason method replaces any previously set reasons with a custom string. Optional arguments can be provided to be included in string formatting. Improvements to assertion methods. Added regular expression assertion helpers Match , and NotMatch . #502 Added collection assertion helpers In , and NotIn . #501 Added module version constraints. #498 The module versions that PSRule uses can be constrained. Bug fixes: Fixed styling for no rule files warning with Assert-PSRule . #484 Fixed actual value in reason for numeric comparison assertion method. #505 What's changed since pre-release v0.19.0-B2007030: No additional changes. v0.19.0-B2007030 (pre-release) # Bug fixes: Fixed Assert.In unable to compare PSObject wrapped array items. #512 v0.19.0-B2007023 (pre-release) # Engine features: Added Reason method to assertion results. #500 This new method, streamlines setting custom reasons particularly with formatted strings. The Reason method replaces any previously set reasons with a custom string. Optional arguments can be provided to be included in string formatting. Improvements to assertion methods. Added regular expression assertion helpers Match , and NotMatch . #502 Added collection assertion helpers In , and NotIn . #501 Added module version constraints. #498 The module versions that PSRule uses can be constrained. Bug fixes: Fixed styling for no rule files warning with Assert-PSRule . #484 Fixed actual value in reason for numeric comparison assertion method. #505 v0.18.1 # What's changed since v0.18.0: Bug fixes: Fixed unable to read properties for .NET DynamicObject . #491 Fixed read of JSON input format with null array item. #490 Fixed Csv output format with summary for Invoke-PSRule . #486 v0.19.0-B2006027 (pre-release) # Bug fixes: Fixed unable to read properties for .NET DynamicObject . #491 Fixed read of JSON input format with null array item. #490 v0.19.0-B2006018 (pre-release) # Bug fixes: Fixed Csv output format with summary for Invoke-PSRule . #486 v0.18.0 # What's changed since v0.17.0: General improvements: Improved Assert-PSRule output formatting. #472 Added recommendation and reasons for AzurePipelines and GitHubActions styles. Summary line is has been updated to include synopsis instead of reasons. Bug fixes: Fixed binding with ModuleConfig . #468 Fixed recommendation output with client style. #467 What's changed since pre-release v0.18.0-B2005015: No additional changes. v0.18.0-B2005015 (pre-release) # General improvements: Improved Assert-PSRule output formatting. #472 Added recommendation and reasons for AzurePipelines and GitHubActions styles. Summary line is has been updated to include synopsis instead of reasons. Bug fixes: Fixed binding with ModuleConfig . #468 Fixed recommendation output with client style. #467 v0.17.0 # What's changed since v0.16.0: General improvements: Improved Assert-PSRule output formatting. Added recommendation and reasons for Client and Plain styles. #456 Added support for configuration of default module options. #459 binding and configuration options can be set to a default value. Updated New-PSRuleOption parameter sets and help based on updates to module config. Added support for module fallback culture. #441 Bug fixes: Fixed resource schema to include useQualifiedName and nameSeparator option. #458 What's changed since pre-release v0.17.0-B2005010: No additional changes. v0.17.0-B2005010 (pre-release) # General improvements: Improved Assert-PSRule output formatting. Added recommendation and reasons for Client and Plain styles. #456 Added support for configuration of default module options. #459 binding and configuration options can be set to a default value. Updated New-PSRuleOption parameter sets and help based on updates to module config. Added support for module fallback culture. #441 Bug fixes: Fixed resource schema to include useQualifiedName and nameSeparator option. #458 v0.16.0 # What's changed since v0.15.0: General improvements: Added configuration option Output.Culture for setting culture. #442 Improved handling of fields to allow the input object to be referenced with . . #437 Bug fixes: Fixed numeric comparison assertion with non-int types. #436 Fixed output culture option ignored. #449 What's changed since pre-release v0.16.0-B2003027: No additional changes. v0.16.0-B2003027 (pre-release) # Bug fixes: Fixed output culture option ignored. #449 v0.16.0-B2003022 (pre-release) # General improvements: Added configuration option Output.Culture for setting culture. #442 Improved handling of fields to allow the input object to be referenced with . . #437 Bug fixes: Fixed numeric comparison assertion with non-int types. #436 v0.15.0 # What's changed since v0.14.0: Engine features: Added -ResultVariable to store results from Assert-PSRule into a variable. #412 General improvements: Added recommendation to failure message of NUnit results. #421 Bug fixes: Fixed handling of v in field value with $Assert.Version . #429 Fixed handling of warning action preference with Assert-PSRule . #428 Fixed parent culture unwind with POSIX. #414 Fixed output of warning with Assert-PSRule . #417 Fixed NUnit report to include a failure element when reason is not specified. #420 What's changed since pre-release v0.15.0-B2002031: No additional changes. v0.15.0-B2002031 (pre-release) # Fixed handling of v in field value with $Assert.Version . #429 Fixed handling of warning action preference with Assert-PSRule . #428 v0.15.0-B2002019 (pre-release) # Added -ResultVariable to store results from Assert-PSRule into a variable. #412 v0.15.0-B2002012 (pre-release) # Fixed output of warning with Assert-PSRule . #417 Fixed NUnit report to include a failure element when reason is not specified. #420 Added recommendation to failure message of NUnit results. #421 v0.15.0-B2002005 (pre-release) # Fixed parent culture unwind with POSIX. #414 v0.14.0 # What's changed since v0.13.0: Engine features: Added support for qualified target names. #395 Added options Binding.UseQualifiedName and Binding.NameSeparator . See about_PSRule_Options for details. Added assertion method HasJsonSchema to check if a JSON schema is referenced. #398 See about_PSRule_Assert for usage details. Added file content helper for reading objects from files. #399 The method GetContent of $PSRule can be used to read files as objects. See about_PSRule_Variables for usage details. General improvements: Improved reporting on runtime errors in rule blocks. #239 Improved NUnit results to include a failure message based on reported reasons. #404 Bug fixes: Fixed wide formatting of rules with Get-PSRule . #407 Fixed TargetName hash serialization for base types. #406 Fixed output not generated with Assert-PSRule and Stop. #405 Fixed NUnit results incorrectly reporting that the test had not executed. #403 What's changed since pre-release v0.14.0-B2002003: No additional changes v0.14.0-B2002003 (pre-release) # Fixed wide formatting of rules with Get-PSRule . #407 Fixed TargetName hash serialization for base types. #406 Fixed output not generated with Assert-PSRule and Stop. #405 Fixed NUnit results incorrectly reporting that the test had not executed. #403 Improved NUnit results to include a failure message based on reported reasons. #404 Improved reporting on runtime errors in rule blocks. #239 v0.14.0-B2001020 (pre-release) # Added support for qualified target names. #395 Added options Binding.UseQualifiedName and Binding.NameSeparator . See about_PSRule_Options for details. Added assertion method HasJsonSchema to check if a JSON schema is referenced. #398 See about_PSRule_Assert for usage details. Added file content helper for reading objects from files. #399 The method GetContent of $PSRule can be used to read files as objects. See about_PSRule_Variables for usage details. v0.13.0 # What's changed since v0.12.0: Engine features: Improvements to rule help and documentation. #382 #316 Added links and notes sections to help. Added -Full switch to Get-PSRuleHelp to display links and notes sections. Added support for using a parent culture in rule help. Rule help will use parent culture when a more specific culture is not available. Added input format for reading PowerShell data .psd1 files. #368 PowerShellData has been added to Input.Format . See about_PSRule_Options for details. Added custom rule data to results. #322 $PSRule.Data can be used to set custom data during rule execution that is included in output. See about_PSRule_Variables for usage details. Improvements to assertion methods. #386 #374 #387 #344 #353 #357 Added support for assertion methods to be used within script pre-conditions. Added numeric comparison assertion helpers Greater , GreaterOrEqual , Less and LessOrEqual . Added semantic version assertion helper Version . Added string affix assertion helpers StartsWith , EndsWith and Contains . See about_PSRule_Assert for usage details. Improvements to output logging and formatting for Assert-PSRule . Formatting now includes errors and warnings using style. Added PSRule banner with module information. Added rule success summary. General improvements: Added aliases for -OutputFormat ( -o ) and -Module ( -m ) parameters. #384 Added WithReason to append/ replace reasons from assertion result. #354 Added configuration helper for strings arrays. #363 Bug fixes: Fixed JSON de-serialization fails with single object. #379 Fixed stack overflow when parsing malformed JSON. #380 What's changed since pre-release v0.13.0-B2001013: No additional changes. v0.13.0-B2001013 (pre-release) # Fixed JSON de-serialization fails with single object. #379 Fixed stack overflow when parsing malformed JSON. #380 Added rule documentation links and notes to help. #382 Added -Full switch to Get-PSRuleHelp to display links and notes sections. Added aliases for -OutputFormat ( -o ) and -Module ( -m ) parameters. #384 Improved numeric comparison assertion helpers to support strings. #387 Methods Greater , GreaterOrEqual , Less and LessOrEqual now also check string length. Added support for assertion methods to be used within script pre-conditions. #386 v0.13.0-B1912043 (pre-release) # Added input format for reading PowerShell data .psd1 files. #368 PowerShellData has been added to Input.Format . See about_PSRule_Options for details. Added numeric comparison assertion helpers. #374 Added methods Greater , GreaterOrEqual , Less and LessOrEqual . See about_PSRule_Assert for usage details. v0.13.0-B1912027 (pre-release) # Added configuration helper for strings arrays. #363 Added support for using a parent culture in rule help. #316 Rule help will use parent culture when a more specific culture is not available. Added custom rule data to results. #322 $PSRule.Data can be used to set custom data during rule execution that is included in output. See about_PSRule_Variables for usage details. v0.13.0-B1912012 (pre-release) # Improves output logging and formatting for Assert-PSRule. #357 Formatting now includes errors and warnings using style. Added PSRule banner with module information. Added rule success summary. v0.13.0-B1912005 (pre-release) # Added semantic version assertion helper Version . #344 Added string affix assertion helpers. #353 Added methods StartsWith , EndsWith and Contains . See about_PSRule_Assert for usage details. Added WithReason to append/ replace reasons from assertion result. #354 v0.12.0 # What's changed since v0.11.0: Engine features: Added -All option to Exists keyword. #331 Added custom field binding. #321 Added new option Binding.Field available in baselines to configure binding. General improvements: Added filtering for rules against a baseline with Get-PSRule . #345 Added parameter alias -f for -InputPath . #340 -f was added to Invoke-PSRule , Assert-PSRule and Test-PSRuleTarget cmdlets. Important change : Added $PSRule generic context variable. #341 Deprecated TargetName , TargetType and TargetObject properties on $Rule . Use TargetName , TargetType and TargetObject on $PSRule instead. Properties TargetName , TargetType and TargetObject on $Rule will be removed in the future. Going forward $Rule will only contain properties that relate to the current rule context. Bug fixes: Fixed key has already been added for default baseline. #349 Fixed multiple value tag filtering. #346 Fixed TargetType fall back to type name. #339 Fixed NUnit serialization issue for unprocessed rules. #332 What's changed since pre-release v0.12.0-B1912007: Fixed key has already been added for default baseline. #349 v0.12.0-B1912007 (pre-release) # Fixed multiple value tag filtering. #346 Added filtering for rules against a baseline with Get-PSRule . #345 v0.12.0-B1912002 (pre-release) # Fixed TargetType fall back to type name. #339 Added custom field binding. #321 Added new option Binding.Field available in baselines to configure binding. Added parameter alias -f for -InputPath . #340 -f was added to Invoke-PSRule , Assert-PSRule and Test-PSRuleTarget cmdlets. Important change : Added $PSRule generic context variable. #341 Deprecated TargetName , TargetType and TargetObject properties on $Rule . Use TargetName , TargetType and TargetObject on $PSRule instead. Properties TargetName , TargetType and TargetObject on $Rule will be removed in the future. Going forward $Rule will only contain properties that relate to the current rule context. v0.12.0-B1911013 (pre-release) # Fixed NUnit serialization issue for unprocessed rules. #332 Added -All option to Exists keyword. #331 v0.11.0 # What's changed since v0.10.0: General improvements: Added -TargetType parameter to filter input objects by target type. #176 This parameter applies to Invoke-PSRule , Assert-PSRule and Test-PSRuleTarget . Bug fixes: Fixed null reference exception when bound property is null. #323 Fixed missing Markdown input format in options schema. #315 Breaking change : Unprocessed object results are not returned from Test-PSRuleTarget by default. #318 Previously unprocessed objects returned $True , now unprocessed objects return no result. Use -Outcome All to return $True for unprocessed objects the same as <= v0.10.0. What's changed since pre-release v0.11.0-B1911002: No additional changes. v0.11.0-B1911002 (pre-release) # Fixed null reference exception when bound property is null. #323 v0.11.0-B1910014 (pre-release) # Fixed missing Markdown input format in options schema. #315 Added -TargetType parameter to filter input objects by target type. #176 This parameter applies to Invoke-PSRule , Assert-PSRule and Test-PSRuleTarget . Breaking change : Unprocessed object results are not returned from Test-PSRuleTarget by default. #318 Previously unprocessed objects returned $True , now unprocessed objects return no result. Use -Outcome All to return $True for unprocessed objects the same as <= v0.10.0. v0.10.0 # What's changed since v0.9.0: General improvements: Added source note properties to input objects read from disk with -InputPath . #302 Engine features: Added assertion helper for checking field default value. #289 Added dependency DependsOn information to results from Get-PSRule . #210 To include dependencies that would normally be filtered out use -IncludeDependencies . Added input format for reading markdown front matter. #301 Markdown front matter is deserialized and evaluated as an object. Added Assert-PSRule cmdlet to improve integration into CI processes. #290 Added Output.Style option to support output in the following styles: Client/ Plain - Output returns easy to read log of rule pass/ fail. Azure Pipelines - Report rule failures as errors collected by Azure Pipelines. GitHub Actions - Reports rule failures as errors collected by GitHub Actions. Bug fixes: Fix Get-PSRuleHelp -Online in constrained language mode. #296 Breaking change : Removed previously deprecated alias Hint for Recommend . #165 Use the Recommend keyword instead. What's changed since pre-release v0.10.0-B1910036: No additional changes. v0.10.0-B1910036 (pre-release) # Added dependency DependsOn information to results from Get-PSRule . #210 To include dependencies that would normally be filtered out use -IncludeDependencies . Added input format for reading markdown front matter. #301 Markdown front matter is deserialized and evaluated as an object. Added source note properties to input objects read from disk with -InputPath . #302 Breaking change : Removed previously deprecated alias Hint for Recommend . #165 Use the Recommend keyword instead. v0.10.0-B1910025 (pre-release) # Fix Get-PSRuleHelp -Online in constrained language mode. #296 Added Assert-PSRule cmdlet to improve integration into CI processes. #290 Added Output.Style option to support output in the following styles: Client/ Plain - Output returns easy to read log of rule pass/ fail. Azure Pipelines - Report rule failures as errors collected by Azure Pipelines. GitHub Actions - Reports rule failures as errors collected by GitHub Actions. v0.10.0-B1910011 (pre-release) # Added assertion helper for checking field default value. #289 v0.9.0 # What's changed since v0.8.0: General improvements: Improve feedback of parsing errors. #185 Updated Get-PSRuleHelp to include help within the current path by default. #197 Engine features: Added support for a wildcard match using the Within keyword. #272 Added rule info display name. #276 Added support for matching an array of tag values. #282 Added named baselines. Now baselines are a separate resource that can be individually used. Baselines can be packaged within module. Modules can specify a default baseline in module manifest. Target binding options ( Binding ) are now part of baselines. See about_PSRule_Baseline for more information. Bug fixes: Fix can not serialize nested System.IO.DirectoryInfo property. #281 Fix ModuleName not displayed in Get-PSRuleHelp list. #275 Fix outcome reported when error or exception is raised. #211 Breaking change : Baseline improvements, fundamentally changes how baselines work. #274 Previously, baselines were specified as workspace options. The previous baseline options property has been renamed to rule . The previous configuration property is now a top level option. What's changed since pre-release v0.9.0-B190905: No additional changes v0.9.0-B190905 (pre-release) # Added support for matching an array of tag values. #282 Updated Get-PSRuleHelp to include help within the current path by default. #197 Fix can not serialize nested System.IO.DirectoryInfo property. #281 Fix export of Like parameter for Within keyword. #279 Breaking change : Added named baselines. This changes how baselines work. #274 Previously, baselines were specified as workspace options. Now, baselines are a separate resource that can be individually used. Additionally: Baselines can be packaged within module. Modules can specify a default baseline in module manifest. Target binding options ( Binding ) are now part of baselines. The previous baseline options property has been renamed to rule . The previous configuration property is now a top level option. See about_PSRule_Baseline for more information. v0.9.0-B190819 (pre-release) # Added support for a wildcard match using the Within keyword. #272 Added rule info display name. #276 Fix ModuleName not displayed in Get-PSRuleHelp list. #275 v0.9.0-B190810 (pre-release) # Improve feedback of parsing errors. #185 Fix outcome reported when error or exception is raised. #211 v0.8.0 # What's changed since v0.7.0: General improvements: PSRule options are now displayed as YAML instead of a complex object. #233 Add detection for improper keyword use. #203 Automatically load rule modules. #218 Added support for debug messages and Write-Debug in rule definitions. #146 Added Logging.LimitDebug and Logging.LimitVerbose options to limit logging to named scopes. #235 Engine features: Added per object reason for failing rules. #200 Keywords Exists , Match , Within and TypeOf automatically add a reason when they fail. Custom reason can be set for keywords Exists , Match , Within and TypeOf with -Reason . Added Reason keyword to add to reason for custom logic. Added wide output display for Invoke-PSRule which include the reason why rule failed. To use wide output use the -OutputFormat Wide parameter. Renamed -Message parameter to -Text on the Recommend keyword. The -Message is an alias of -Text and will be deprecated in the future. Added assertion helper $Assert for extensibility. #250 Add built-in assertions for HasField , HasFieldValue and NullOrEmpty . Add JSON schema assertion method JsonSchema . #42 Bug fixes: Fix rule synopsis comment capture. #214 Fix YAML options file discovery issue in dotted directory. #232 Fix comparison of wrapped types and null with Within . #237 Breaking change : Use rule references consistent with cmdlet fully qualified syntax. #217 Rule names have to be unique within the current execution path or within a module. Previously rule names only had to be unique within a single file. Previously the filename.rule.ps1/RuleName was required to reference rules across files. This is no longer required because rule names are unique. You can reference a rule from a loaded module by using the syntax ModuleName\\RuleName . What's changed since pre-release v0.8.0-B190806: Fix export of assertion helper variable $Assert . #262 v0.8.0-B190806 (pre-release) # Fix module reloading with different versions. #254 Fix not finding rules in current path by default. #256 Fix rule synopsis comment capture. #214 v0.8.0-B190742 (pre-release) # Fix inconsistent handling of $PWD . #249 Add detection for improper keyword use. #203 Automatically load rule modules. #218 Added assertion helper $Assert for extensibility. #250 Add built-in assertions for HasField , HasFieldValue and NullOrEmpty . Add JSON schema assertion method JsonSchema . #42 Breaking change : Use rule references consistent with cmdlet fully qualified syntax. #217 Rule names have to be unique within the current execution path or within a module. Previously rule names only had to be unique within a single file. Previously the filename.rule.ps1/RuleName was required to reference rules across files. This is no longer required because rule names are unique. You can reference a rule from a loaded module by using the syntax ModuleName\\RuleName . v0.8.0-B190716 (pre-release) # Added per object reason for failing rules. #200 The keywords Exists , Match , Within and TypeOf automatically add a reason when they fail. Added -Reason parameter to Exists , Match , Within and TypeOf keywords to allow a custom reason to be set. Added Reason keyword to add to reason for custom logic. Added wide output display for Invoke-PSRule which include the reason why rule failed. To use wide output use the -OutputFormat Wide parameter. Renamed -Message parameter to -Text on the Recommend keyword. The -Message is an alias of -Text and will be deprecated in the future. v0.8.0-B190708 (pre-release) # Fix YAML options file discovery issue in dotted directory. #232 Fix comparison of wrapped types and null with Within . #237 PSRule options are now displayed as YAML instead of a complex object. #233 Added support for debug messages and Write-Debug in rule definitions. #146 Added Logging.LimitDebug and Logging.LimitVerbose options to limit logging to named scopes. #235 v0.7.0 # What's changed since v0.6.0: Fix reading nested arrays from JSON input. #223 Fix comparison of non-string types with Within . #226 Fix circular rule dependency issue. #190 Fix rule DependsOn parameter allows null. #191 Fix error message when attempting to use the rule keyword in a rule definition. #189 Fix TargetName binding when TargetName or Name property is null. #202 Fix handling of non-boolean results in rules. Rule is failed with more specific error message. #187 #224 Include .ps1 files that are specified directly with -Path , instead of only .Rule.ps1 files. #182 Improved warning message displayed when no Rule.ps1 files are founds. Added support for Invoke-PSRule to return CSV formatted results. #169 To generate CSV results use the -OutputFormat Csv parameter. Added Output.Path option to allow output to be saved directly to file. Added Output.Encoding option configure encoding used to write to file. By default, UTF-8 encoding without BOM is used. Invoke-PSRule cmdlet also provides a parameter -OutputPath to write results to file. Reordered cmdlet parameters to improve usage of frequently used parameters. #175 -Module parameter will tab-complete with imported rule modules. Added culture support for PowerShell informational messages. #158 A new $LocalizedData variable can be used within rule definitions. Added -Not switch to Within and Match keywords to allow negative comparison. #208 Improve discovery of rule tags. #209 Add wide format -OutputFormat Wide to Get-PSRule to allow output of rule tags. Breaking change : Changed rule filtering by tag to be case-insensitive. #204 Previously tag value was case-sensitive, however this is confusing since PowerShell is case-insensitive by default. Breaking change : Rule time is recorded in milliseconds instead of seconds. #192 What's changed since pre-release v0.7.0-B190664: No additional changes. v0.7.0-B190664 (pre-release) # Fix reading nested arrays from JSON input. #223 Fix comparison of non-string types with Within . #226 Improve handling of null rule result. #224 v0.7.0-B190652 (pre-release) # Fix TargetName binding when TargetName or Name property is null. #202 Add culture support for PowerShell informational messages. #158 A new $LocalizedData variable can be used within rule definitions. Add -Not switch to Within and Match keywords to allow negative comparison. #208 Improve discovery of rule tags. #209 Add wide format -OutputFormat Wide to Get-PSRule to allow output of rule tags. Breaking change : Change rule filtering by tag to be case-insensitive. #204 Previously tag value was case-sensitive, however this is confusing since PowerShell is case-insensitive by default. v0.7.0-B190633 (pre-release) # Fix circular rule dependency issue. #190 Fix rule DependsOn parameter allows null. #191 Fix error message when attempting to use the rule keyword in a rule definition. #189 Breaking change : Rule time is recorded in milliseconds instead of seconds. #192 v0.7.0-B190624 (pre-release) # Fix handling of non-boolean results in rules. Rule is failed with more specific error message. #187 Include .ps1 files that are specified directly with -Path , instead of only .rule.ps1 files. #182 Improved warning message displayed when no Rule.ps1 files are founds. v0.7.0-B190613 (pre-release) # Added support for Invoke-PSRule to return CSV formatted results. #169 To generate CSV results use the -OutputFormat Csv parameter. Added Output.Path option to allow output to be saved directly to file. Added Output.Encoding option configure encoding used to write to file. By default, UTF-8 encoding without BOM is used. Invoke-PSRule cmdlet also provides a parameter -OutputPath to write results to file. Reordered cmdlet parameters to improve usage of frequently used parameters. #175 -Module parameter will tab-complete with imported rule modules. v0.6.0 # What's changed since v0.5.0: Fix operation is not supported on this platform failure. #152 Fix FullName cannot be found on this object error. #149 Fix discovery of rules within paths that contain spaces fails. #168 Added rule documentation, which allows additional rule information to be stored in markdown files. #157 Rule documentation also adds culture support. #18 Rule documentation can be accessed like help with the Get-PSRuleHelp cmdlet. Added annotations, which are non-indexed metadata stored in rule documentation. #148 Annotations can contain a link to online version of the documentation. #147 Important change : Changed Hint keyword to Recommend to align with rule documentation. #165 Use of Hint keyword is deprecated and will be removed in a future release. Currently Hint is aliased to Recommend for compatibility. Breaking change : Changed rule properties to align with rule documentation. #164 Rule Synopsis , is a brief summary of the rule and Description is a detailed purpose of the rule. Description: metadata keyword used in comment help is now Synopsis: , use of Description: will set synopsis. Description metadata keyword is deprecated and will be removed in a future update. Output property Message on rule results is now Recommendation . What's changed since pre-release v0.6.0-B190627: Fix discovery of rules within paths that contain spaces fails. #168 Fix exporting of Recommend keyword and Hint alias. #171 v0.6.0-B190627 (pre-release) # Important change : Changed Hint keyword to Recommend to align with rule documentation. #165 Use of Hint keyword is deprecated and will be removed in a future release. Currently Hint is aliased to Recommend for compatibility. Breaking change : Changed rule properties to align with rule documentation. #164 Rule Synopsis , is a brief summary of the rule and Description is a detailed purpose of the rule. Description: metadata keyword used in comment help is now Synopsis: , use of Description: will set synopsis. Description metadata keyword is deprecated and will be removed in a future update. Output property Message on rule results is now Recommendation . v0.6.0-B190614 (pre-release) # Added rule documentation, which allows additional rule information to be stored in markdown files. #157 Rule documentation also adds culture support. #18 Rule documentation can be accessed like help with the Get-PSRuleHelp cmdlet. Added annotations, which are non-indexed metadata stored in rule documentation. #148 Annotations can contain a link to online version of the documentation. #147 v0.6.0-B190514 (pre-release) # Fix operation is not supported on this platform failure. #152 Fix FullName cannot be found on this object error. #149 v0.5.0 # What's changed since v0.4.0: Fix PSRule options schema usage of additionalProperties. #136 Fix null reference exception when traversing null field. #123 Fix missing help topics for options and variables. #125 Improved handling of default YAML options file. #137 Added support for Invoke-PSRule to return NUnit3 formatted results. #129 To generate NUnit3 results use the -OutputFormat NUnit3 parameter. Added Set-PSRuleOption cmdlet to configure YAML options file. #135 Added parameters to New-PSRuleOption to configure common options. #134 Additional parameters are an alternative to using a -Option hashtable. What's changed since pre-release v0.5.0-B190423: Fix schema conformance of -OutputFormat NUnit3 to NUnit report schema. #141 Fix PSRule options schema usage of additionalProperties. #136 v0.5.0-B190423 (pre-release) # Added support for Invoke-PSRule to return NUnit3 formatted results. #129 To generate NUnit3 results use the -OutputFormat NUnit3 parameter. Added Set-PSRuleOption cmdlet to configure YAML options file. #135 Added parameters to New-PSRuleOption to configure common options. #134 Additional parameters are an alternative to using a -Option hashtable. Improved handling of default YAML options file. #137 v0.5.0-B190405 (pre-release) # Fix null reference exception when traversing null field. #123 Fix missing help topics for options and variables. #125 v0.4.0 # What's changed since v0.3.0: Fix incorrect JSON de-serialization. #109 #111 Added support for using -InputPath instead of using -InputObject to handle serialized objects. #106 -Format is automatically detected for .yaml , .yml and .json file extensions. Added -OutputFormat parameter to serialize output from Invoke-PSRule as YAML or JSON. #29 Added support for logging pass or fail outcomes to a data stream such as Error, Warning or Information. #97 Breaking change : Deprecated usage of the -TargetName parameter on the Hint keyword has been removed. #81 What's changed since pre-release v0.4.0-B190328: No additional changes. v0.4.0-B190328 (pre-release) # Fix summary is not correctly serialized with JSON or YAML output format. #116 Fix missing properties on serialized YAML output. #115 Fix incorrect property name case of YAML serialized results. #114 v0.4.0-B190320 (pre-release) # Fix incorrect JSON de-serialization of nested arrays. #109 Fix incorrect JSON de-serialization of non-object arrays. #111 v0.4.0-B190311 (pre-release) # Added support for using -InputPath instead of using -InputObject to handle serialized objects. #106 -Format is automatically detected for .yaml , .yml and .json file extensions. Added -OutputFormat parameter to serialize output from Invoke-PSRule . #29 Added support for logging pass or fail outcomes to a data stream such as Error, Warning or Information. #97 Breaking change : Deprecated usage of the -TargetName parameter on the Hint keyword has been removed. #81 v0.3.0 # What's changed since v0.2.0: Added support for pipelining with Exists , Within , Match and TypeOf keywords #90 Added support for packaging rules in modules #16 Import objects from YAML or JSON format #75 Added support for input de-serialization from FileInfo objects #95 Support nested TargetObjects #77 Export variables to improve authoring experience #83 Binding improvements: Added object type binding and dynamic filtering for rules #82 Added support for indexed and quoted field names #86 Added support for case-sensitive binding operations #87 Binding ignores case by default. Set option Binding.CaseSensitive to true to enable case-sensitivity. Support TargetName binding of nested properties #71 Added online help links to keywords #72 Added schema for PSRule options #74 Important change : The -TargetName parameter of the Hint keyword has been deprecated #81 -TargetName parameter not longer sets the pipeline object TargetName and generates a warning instead. The -TargetName will be completely removed in v0.4.0 , at which time using the parameter will generate an error. Breaking change : Changed parameter alias for -Path from -f to -p #99 What's changed since pre-release v0.3.0-B190231: Added support for input de-serialization from FileInfo objects #95 Breaking change : Changed parameter alias for -Path from -f to -p #99 v0.3.0-B190231 (pre-release) # Added support for pipelining with Exists , Within , Match and TypeOf keywords #90 Fix empty YAML object causes format de-serialize to fail #92 v0.3.0-B190224 (pre-release) # Export variables to improve authoring experience #83 Added support for packaging rules in modules #16 Added support for indexed and quoted field names #86 Added object type binding and dynamic filtering for rules #82 Added support for case-sensitive binding operations #87 Binding ignores case by default. Set option Binding.CaseSensitive to true to enable case-sensitivity. Important change : The -TargetName parameter of the Hint keyword has been deprecated #81 -TargetName parameter not longer sets the pipeline object TargetName and generates a warning instead. The -TargetName will be completely removed in v0.4.0 , at which time using the parameter will generate an error. v0.3.0-B190208 (pre-release) # Added online help links to keywords #72 Added schema for PSRule options #74 Import objects from YAML or JSON format #75 Support TargetName binding of nested properties #71 Support nested TargetObjects #77 v0.2.0 # What's changed since v0.1.0: Added support for cross-platform environments (Windows, Linux and macOS) #49 Added support for nested field names with Exists , Within and Match keywords #60 Added support for rule configuration using baselines #17 Use rule description when hint message not set #61 Allow objects to be suppressed by TargetName for individual rules #13 Allow binding of TargetName to custom property #44 Custom functions can be used to bind TargetName #44 Objects that are unable to bind a TargetName will use a SHA1 object hash for TargetName #44 Added Test-PSRuleTarget command to return an overall $True or $False after evaluating rules for an object #30 Improve reporting of inconclusive results and objects that are not processed by any rule #46 Inconclusive results and objects not processed will return a warning by default. Fix propagation of informational messages to host from rule scripts and definitions #48 Fix Get-PSRule generates exception when no .rule.ps1 scripts exist in path #53 Fix LocalizedData.PathNotFound warning when no .rule.ps1 scripts exist in path #54 What's changed since pre-release v0.2.0-B190121: No additional changes. v0.2.0-B190121 (pre-release) # Added support for nested field names with Exists , Within and Match keywords #60 Added support for rule configuration using baselines #17 Use rule description when hint message not set #61 v0.2.0-B190113 (pre-release) # Fix Get-PSRule generates exception when no .rule.ps1 scripts exist in path #53 Fix LocalizedData.PathNotFound warning when no .rule.ps1 scripts exist in path #54 Breaking change : Renamed Test-PSRule cmdlet to Test-PSRuleTarget which aligns more closely to the verb-noun naming standard #57 v0.2.0-B190105 (pre-release) # Allow objects to be suppressed by TargetName for individual rules #13 Allow binding of TargetName to custom property #44 Custom functions can be used to bind TargetName #44 Objects that are unable to bind a TargetName will use a SHA1 object hash for TargetName #44 Added Test-PSRule command to return an overall $True or $False after evaluating rules for an object #30 Improve reporting of inconclusive results and objects that are not processed by any rule #46 Inconclusive results and objects not processed will return a warning by default. Fix propagation of informational messages to host from rule scripts and definitions #48 Added support for cross-platform environments (Windows, Linux and macOS) #49 v0.1.0 # Initial release What's changed since pre-release v0.1.0-B181235: Fix outcome filtering of summary results #33 Fix target object counter in verbose logging #35 Fix hashtable keys should be handled as fields #36 v0.1.0-B181235 (pre-release) # RuleId and RuleName are now independent. Rules are created with a name, and the RuleId is generated based on rule name and file name Rules with the same name can exist and be cross linked with DependsOn, as long a the script file name is different Added -Not to Exists keyword Improved verbose logging of Exists , AllOf , AnyOf keywords and core engine Breaking change : Renamed outcome filtering parameters to align to type name and increase clarity Invoke-PSRule has a -Outcome parameter instead of -Status -Outcome supports values of Pass , Fail , Error , None , Processed and All v0.1.0-B181222 (pre-release) # Added rule tags to results to enable grouping and sorting #14 Added support to check for rule tag existence. Use * for tag value on -Tag parameter with Invoke-PSRule and Get-PSRule Added option to report rule summary using -As parameter of Invoke-PSRule #12 v0.1.0-B181212 (pre-release) # Initial pre-release.","title":"v0"},{"location":"CHANGELOG-v0/#change-log","text":"See upgrade notes for helpful information when upgrading from previous versions. Attention PSRule v0 is a prior release. For more information see v2 release notes. Please check out our upgrade notes to get prepared for upgrading to the latest version.","title":"Change log"},{"location":"CHANGELOG-v0/#v0220","text":"What's changed since v0.21.0: Engine features: Added HasFields assertion helper to check all fields exist. #578 Updated HasField to check if any of the specified fields exist. #578 General improvements: Input format detection now includes .jsonc and .markdown file extensions. #575 Improved support for cross module rule dependencies. #248 Rule dependencies are now automatically imported. Bug fixes: Fixed handling for null or empty arrays with StartsWith , Contains , EndsWith , In , and NotIn . #579 What's changed since pre-release v0.22.0-B2010014: No additional changes.","title":"v0.22.0"},{"location":"CHANGELOG-v0/#v0220-b2010014-pre-release","text":"What's changed since v0.21.0: Engine features: Added HasFields assertion helper to check all fields exist. #578 Updated HasField to check if any of the specified fields exist. #578 General improvements: Input format detection now includes .jsonc and .markdown file extensions. #575 Improved support for cross module rule dependencies. #248 Rule dependencies are now automatically imported. Bug fixes: Fixed handling for null or empty arrays with StartsWith , Contains , EndsWith , In , and NotIn . #579","title":"v0.22.0-B2010014 (pre-release)"},{"location":"CHANGELOG-v0/#v0210","text":"What's changed since v0.20.0: Engine features: Added support for formatting results as markdown. #474 Use -OutputFormat Markdown or configure Output.Format to output markdown. To format as either detail or summary, use the -As parameter or configure Output.As . Added character case assertion helpers IsLower , and IsUpper . #555 IsLower checks that all letters in a field value are lowercase. IsUpper checks that all letters in a field value are uppercase. General improvements: Numerical strings can be converted with numeric assertion helpers. #550 Added outcome Output.Outcome as a configurable option. #552 Added help links and default snippets to schemas. #561 Improved rule error reporting by including rule and source location. #565 Engineering: Bump Manatee.Json from 13.0.2 to 13.0.3. #563 Bug fixes: Fixed NUnit report reasons should be escaped in markdown. #471 Fixed reporting of error when rule error is handled. #564 Additionally rules can use -ErrorAction Ignore to ignore non-exception errors. Fixed first exception stops other rules from being processed. #566 What's changed since pre-release v0.21.0-B2010010: No additional changes.","title":"v0.21.0"},{"location":"CHANGELOG-v0/#v0210-b2010010-pre-release","text":"What's changed since pre-release v0.21.0-B2010003: General improvements: Improved rule error reporting by including rule and source location. #565","title":"v0.21.0-B2010010 (pre-release)"},{"location":"CHANGELOG-v0/#v0210-b2010003-pre-release","text":"What's changed since pre-release v0.21.0-B2009016: General improvements: Added help links and default snippets to schemas. #561 Engineering: Bump Manatee.Json from 13.0.2 to 13.0.3. #563 Bug fixes: Fixed reporting of error when rule error is handled. #564 Additionally rules can use -ErrorAction Ignore to ignore non-exception errors. Fixed first exception stops other rules from being processed. #566","title":"v0.21.0-B2010003 (pre-release)"},{"location":"CHANGELOG-v0/#v0210-b2009016-pre-release","text":"What's changed since pre-release v0.21.0-B2009006: Engine features: Added character case assertion helpers IsLower , and IsUpper . #555 IsLower checks that all letters in a field value are lowercase. IsUpper checks that all letters in a field value are uppercase. Bug fixes: Fixed NUnit report reasons should be escaped in markdown. #471","title":"v0.21.0-B2009016 (pre-release)"},{"location":"CHANGELOG-v0/#v0210-b2009006-pre-release","text":"What's changed since v0.20.0: Engine features: Added support for formatting results as markdown. #474 Use -OutputFormat Markdown or configure Output.Format to output markdown. To format as either detail or summary, use the -As parameter or configure Output.As . General improvements: Numerical strings can be converted with numeric assertion helpers. #550 Added outcome Output.Outcome as a configurable option. #552","title":"v0.21.0-B2009006 (pre-release)"},{"location":"CHANGELOG-v0/#v0200","text":"What's changed since v0.19.0: Engine features: Added support for scanning repository files. #524 Added File input type ( -InputType File ) to scan for files without deserializing them. Added Input.PathIgnore option to ignore files. When using the File input type path specs in .gitignore are ignored. Added Get-PSRuleTarget cmdlet to read input files and return raw objects. #525 This cmdlet can be used to troubleshoot PSRule input issues. Baselines can now be flagged as obsolete. #499 Set the metadata.annotations.obsolete property to true to flag a baseline as obsolete. When an obsolete baseline is used, a warning will be generated. Added file assertion helpers FileHeader , and FilePath . #534 FileHeader checks for a comment header in the file. FilePath checks that a file path (optionally with suffixes) exist. General improvements: Added automatic binding for Rule object. #542 Engineering: Warn when deprecated $Rule properties are used. #536 #545 First usage of deprecated property generates a warning. Rule using deprecated property is flagged in debug output. Bump YamlDotNet dependency to v8.1.2. #439 Bug fixes: Fixed out of bounds exception when empty markdown documentation is used. #516 What's changed since pre-release v0.20.0-B2009013: Bug fixes: Fixed excessive obsolete property warnings. #545","title":"v0.20.0"},{"location":"CHANGELOG-v0/#v0200-b2009013-pre-release","text":"What's changed since pre-release v0.20.0-B2009007: General improvements: Added automatic binding for Rule object. #542 Bug fixes: Fixed InputFileInfo Type property causes downstream binding issues. #541","title":"v0.20.0-B2009013 (pre-release)"},{"location":"CHANGELOG-v0/#v0200-b2009007-pre-release","text":"What's changed since pre-release v0.20.0-B2008010: Engine features: Added file assertion helpers FileHeader , and FilePath . #534 FileHeader checks for a comment header in the file. FilePath checks that a file path (optionally with suffixes) exist. Engineering: Warn when deprecated $Rule properties are used. #536 Bug fixes: Fixed out of bounds exception when empty markdown documentation is used. #516 Fixed lines breaks in RepositoryInfo target name with git ref. #538","title":"v0.20.0-B2009007 (pre-release)"},{"location":"CHANGELOG-v0/#v0200-b2008010-pre-release","text":"What's changed since pre-release v0.20.0-B2008002: Engine features: Baselines can now be flagged as obsolete. #499 Set the metadata.annotations.obsolete property to true to flag a baseline as obsolete. When an obsolete baseline is used, a warning will be generated. Engineering: Bump YamlDotNet dependency to v8.1.2. #439","title":"v0.20.0-B2008010 (pre-release)"},{"location":"CHANGELOG-v0/#v0200-b2008002-pre-release","text":"What's changed since v0.19.0: Engine features: Added support for scanning repository files. #524 Added File input type ( -InputType File ) to scan for files without deserializing them. Added Input.PathIgnore option to ignore files. When using the File input type path specs in .gitignore are ignored. Added Get-PSRuleTarget cmdlet to read input files and return raw objects. #525 This cmdlet can be used to troubleshoot PSRule input issues.","title":"v0.20.0-B2008002 (pre-release)"},{"location":"CHANGELOG-v0/#v0190","text":"What's changed since v0.18.1: Engine features: Added Reason method to assertion results. #500 This new method, streamlines setting custom reasons particularly with formatted strings. The Reason method replaces any previously set reasons with a custom string. Optional arguments can be provided to be included in string formatting. Improvements to assertion methods. Added regular expression assertion helpers Match , and NotMatch . #502 Added collection assertion helpers In , and NotIn . #501 Added module version constraints. #498 The module versions that PSRule uses can be constrained. Bug fixes: Fixed styling for no rule files warning with Assert-PSRule . #484 Fixed actual value in reason for numeric comparison assertion method. #505 What's changed since pre-release v0.19.0-B2007030: No additional changes.","title":"v0.19.0"},{"location":"CHANGELOG-v0/#v0190-b2007030-pre-release","text":"Bug fixes: Fixed Assert.In unable to compare PSObject wrapped array items. #512","title":"v0.19.0-B2007030 (pre-release)"},{"location":"CHANGELOG-v0/#v0190-b2007023-pre-release","text":"Engine features: Added Reason method to assertion results. #500 This new method, streamlines setting custom reasons particularly with formatted strings. The Reason method replaces any previously set reasons with a custom string. Optional arguments can be provided to be included in string formatting. Improvements to assertion methods. Added regular expression assertion helpers Match , and NotMatch . #502 Added collection assertion helpers In , and NotIn . #501 Added module version constraints. #498 The module versions that PSRule uses can be constrained. Bug fixes: Fixed styling for no rule files warning with Assert-PSRule . #484 Fixed actual value in reason for numeric comparison assertion method. #505","title":"v0.19.0-B2007023 (pre-release)"},{"location":"CHANGELOG-v0/#v0181","text":"What's changed since v0.18.0: Bug fixes: Fixed unable to read properties for .NET DynamicObject . #491 Fixed read of JSON input format with null array item. #490 Fixed Csv output format with summary for Invoke-PSRule . #486","title":"v0.18.1"},{"location":"CHANGELOG-v0/#v0190-b2006027-pre-release","text":"Bug fixes: Fixed unable to read properties for .NET DynamicObject . #491 Fixed read of JSON input format with null array item. #490","title":"v0.19.0-B2006027 (pre-release)"},{"location":"CHANGELOG-v0/#v0190-b2006018-pre-release","text":"Bug fixes: Fixed Csv output format with summary for Invoke-PSRule . #486","title":"v0.19.0-B2006018 (pre-release)"},{"location":"CHANGELOG-v0/#v0180","text":"What's changed since v0.17.0: General improvements: Improved Assert-PSRule output formatting. #472 Added recommendation and reasons for AzurePipelines and GitHubActions styles. Summary line is has been updated to include synopsis instead of reasons. Bug fixes: Fixed binding with ModuleConfig . #468 Fixed recommendation output with client style. #467 What's changed since pre-release v0.18.0-B2005015: No additional changes.","title":"v0.18.0"},{"location":"CHANGELOG-v0/#v0180-b2005015-pre-release","text":"General improvements: Improved Assert-PSRule output formatting. #472 Added recommendation and reasons for AzurePipelines and GitHubActions styles. Summary line is has been updated to include synopsis instead of reasons. Bug fixes: Fixed binding with ModuleConfig . #468 Fixed recommendation output with client style. #467","title":"v0.18.0-B2005015 (pre-release)"},{"location":"CHANGELOG-v0/#v0170","text":"What's changed since v0.16.0: General improvements: Improved Assert-PSRule output formatting. Added recommendation and reasons for Client and Plain styles. #456 Added support for configuration of default module options. #459 binding and configuration options can be set to a default value. Updated New-PSRuleOption parameter sets and help based on updates to module config. Added support for module fallback culture. #441 Bug fixes: Fixed resource schema to include useQualifiedName and nameSeparator option. #458 What's changed since pre-release v0.17.0-B2005010: No additional changes.","title":"v0.17.0"},{"location":"CHANGELOG-v0/#v0170-b2005010-pre-release","text":"General improvements: Improved Assert-PSRule output formatting. Added recommendation and reasons for Client and Plain styles. #456 Added support for configuration of default module options. #459 binding and configuration options can be set to a default value. Updated New-PSRuleOption parameter sets and help based on updates to module config. Added support for module fallback culture. #441 Bug fixes: Fixed resource schema to include useQualifiedName and nameSeparator option. #458","title":"v0.17.0-B2005010 (pre-release)"},{"location":"CHANGELOG-v0/#v0160","text":"What's changed since v0.15.0: General improvements: Added configuration option Output.Culture for setting culture. #442 Improved handling of fields to allow the input object to be referenced with . . #437 Bug fixes: Fixed numeric comparison assertion with non-int types. #436 Fixed output culture option ignored. #449 What's changed since pre-release v0.16.0-B2003027: No additional changes.","title":"v0.16.0"},{"location":"CHANGELOG-v0/#v0160-b2003027-pre-release","text":"Bug fixes: Fixed output culture option ignored. #449","title":"v0.16.0-B2003027 (pre-release)"},{"location":"CHANGELOG-v0/#v0160-b2003022-pre-release","text":"General improvements: Added configuration option Output.Culture for setting culture. #442 Improved handling of fields to allow the input object to be referenced with . . #437 Bug fixes: Fixed numeric comparison assertion with non-int types. #436","title":"v0.16.0-B2003022 (pre-release)"},{"location":"CHANGELOG-v0/#v0150","text":"What's changed since v0.14.0: Engine features: Added -ResultVariable to store results from Assert-PSRule into a variable. #412 General improvements: Added recommendation to failure message of NUnit results. #421 Bug fixes: Fixed handling of v in field value with $Assert.Version . #429 Fixed handling of warning action preference with Assert-PSRule . #428 Fixed parent culture unwind with POSIX. #414 Fixed output of warning with Assert-PSRule . #417 Fixed NUnit report to include a failure element when reason is not specified. #420 What's changed since pre-release v0.15.0-B2002031: No additional changes.","title":"v0.15.0"},{"location":"CHANGELOG-v0/#v0150-b2002031-pre-release","text":"Fixed handling of v in field value with $Assert.Version . #429 Fixed handling of warning action preference with Assert-PSRule . #428","title":"v0.15.0-B2002031 (pre-release)"},{"location":"CHANGELOG-v0/#v0150-b2002019-pre-release","text":"Added -ResultVariable to store results from Assert-PSRule into a variable. #412","title":"v0.15.0-B2002019 (pre-release)"},{"location":"CHANGELOG-v0/#v0150-b2002012-pre-release","text":"Fixed output of warning with Assert-PSRule . #417 Fixed NUnit report to include a failure element when reason is not specified. #420 Added recommendation to failure message of NUnit results. #421","title":"v0.15.0-B2002012 (pre-release)"},{"location":"CHANGELOG-v0/#v0150-b2002005-pre-release","text":"Fixed parent culture unwind with POSIX. #414","title":"v0.15.0-B2002005 (pre-release)"},{"location":"CHANGELOG-v0/#v0140","text":"What's changed since v0.13.0: Engine features: Added support for qualified target names. #395 Added options Binding.UseQualifiedName and Binding.NameSeparator . See about_PSRule_Options for details. Added assertion method HasJsonSchema to check if a JSON schema is referenced. #398 See about_PSRule_Assert for usage details. Added file content helper for reading objects from files. #399 The method GetContent of $PSRule can be used to read files as objects. See about_PSRule_Variables for usage details. General improvements: Improved reporting on runtime errors in rule blocks. #239 Improved NUnit results to include a failure message based on reported reasons. #404 Bug fixes: Fixed wide formatting of rules with Get-PSRule . #407 Fixed TargetName hash serialization for base types. #406 Fixed output not generated with Assert-PSRule and Stop. #405 Fixed NUnit results incorrectly reporting that the test had not executed. #403 What's changed since pre-release v0.14.0-B2002003: No additional changes","title":"v0.14.0"},{"location":"CHANGELOG-v0/#v0140-b2002003-pre-release","text":"Fixed wide formatting of rules with Get-PSRule . #407 Fixed TargetName hash serialization for base types. #406 Fixed output not generated with Assert-PSRule and Stop. #405 Fixed NUnit results incorrectly reporting that the test had not executed. #403 Improved NUnit results to include a failure message based on reported reasons. #404 Improved reporting on runtime errors in rule blocks. #239","title":"v0.14.0-B2002003 (pre-release)"},{"location":"CHANGELOG-v0/#v0140-b2001020-pre-release","text":"Added support for qualified target names. #395 Added options Binding.UseQualifiedName and Binding.NameSeparator . See about_PSRule_Options for details. Added assertion method HasJsonSchema to check if a JSON schema is referenced. #398 See about_PSRule_Assert for usage details. Added file content helper for reading objects from files. #399 The method GetContent of $PSRule can be used to read files as objects. See about_PSRule_Variables for usage details.","title":"v0.14.0-B2001020 (pre-release)"},{"location":"CHANGELOG-v0/#v0130","text":"What's changed since v0.12.0: Engine features: Improvements to rule help and documentation. #382 #316 Added links and notes sections to help. Added -Full switch to Get-PSRuleHelp to display links and notes sections. Added support for using a parent culture in rule help. Rule help will use parent culture when a more specific culture is not available. Added input format for reading PowerShell data .psd1 files. #368 PowerShellData has been added to Input.Format . See about_PSRule_Options for details. Added custom rule data to results. #322 $PSRule.Data can be used to set custom data during rule execution that is included in output. See about_PSRule_Variables for usage details. Improvements to assertion methods. #386 #374 #387 #344 #353 #357 Added support for assertion methods to be used within script pre-conditions. Added numeric comparison assertion helpers Greater , GreaterOrEqual , Less and LessOrEqual . Added semantic version assertion helper Version . Added string affix assertion helpers StartsWith , EndsWith and Contains . See about_PSRule_Assert for usage details. Improvements to output logging and formatting for Assert-PSRule . Formatting now includes errors and warnings using style. Added PSRule banner with module information. Added rule success summary. General improvements: Added aliases for -OutputFormat ( -o ) and -Module ( -m ) parameters. #384 Added WithReason to append/ replace reasons from assertion result. #354 Added configuration helper for strings arrays. #363 Bug fixes: Fixed JSON de-serialization fails with single object. #379 Fixed stack overflow when parsing malformed JSON. #380 What's changed since pre-release v0.13.0-B2001013: No additional changes.","title":"v0.13.0"},{"location":"CHANGELOG-v0/#v0130-b2001013-pre-release","text":"Fixed JSON de-serialization fails with single object. #379 Fixed stack overflow when parsing malformed JSON. #380 Added rule documentation links and notes to help. #382 Added -Full switch to Get-PSRuleHelp to display links and notes sections. Added aliases for -OutputFormat ( -o ) and -Module ( -m ) parameters. #384 Improved numeric comparison assertion helpers to support strings. #387 Methods Greater , GreaterOrEqual , Less and LessOrEqual now also check string length. Added support for assertion methods to be used within script pre-conditions. #386","title":"v0.13.0-B2001013 (pre-release)"},{"location":"CHANGELOG-v0/#v0130-b1912043-pre-release","text":"Added input format for reading PowerShell data .psd1 files. #368 PowerShellData has been added to Input.Format . See about_PSRule_Options for details. Added numeric comparison assertion helpers. #374 Added methods Greater , GreaterOrEqual , Less and LessOrEqual . See about_PSRule_Assert for usage details.","title":"v0.13.0-B1912043 (pre-release)"},{"location":"CHANGELOG-v0/#v0130-b1912027-pre-release","text":"Added configuration helper for strings arrays. #363 Added support for using a parent culture in rule help. #316 Rule help will use parent culture when a more specific culture is not available. Added custom rule data to results. #322 $PSRule.Data can be used to set custom data during rule execution that is included in output. See about_PSRule_Variables for usage details.","title":"v0.13.0-B1912027 (pre-release)"},{"location":"CHANGELOG-v0/#v0130-b1912012-pre-release","text":"Improves output logging and formatting for Assert-PSRule. #357 Formatting now includes errors and warnings using style. Added PSRule banner with module information. Added rule success summary.","title":"v0.13.0-B1912012 (pre-release)"},{"location":"CHANGELOG-v0/#v0130-b1912005-pre-release","text":"Added semantic version assertion helper Version . #344 Added string affix assertion helpers. #353 Added methods StartsWith , EndsWith and Contains . See about_PSRule_Assert for usage details. Added WithReason to append/ replace reasons from assertion result. #354","title":"v0.13.0-B1912005 (pre-release)"},{"location":"CHANGELOG-v0/#v0120","text":"What's changed since v0.11.0: Engine features: Added -All option to Exists keyword. #331 Added custom field binding. #321 Added new option Binding.Field available in baselines to configure binding. General improvements: Added filtering for rules against a baseline with Get-PSRule . #345 Added parameter alias -f for -InputPath . #340 -f was added to Invoke-PSRule , Assert-PSRule and Test-PSRuleTarget cmdlets. Important change : Added $PSRule generic context variable. #341 Deprecated TargetName , TargetType and TargetObject properties on $Rule . Use TargetName , TargetType and TargetObject on $PSRule instead. Properties TargetName , TargetType and TargetObject on $Rule will be removed in the future. Going forward $Rule will only contain properties that relate to the current rule context. Bug fixes: Fixed key has already been added for default baseline. #349 Fixed multiple value tag filtering. #346 Fixed TargetType fall back to type name. #339 Fixed NUnit serialization issue for unprocessed rules. #332 What's changed since pre-release v0.12.0-B1912007: Fixed key has already been added for default baseline. #349","title":"v0.12.0"},{"location":"CHANGELOG-v0/#v0120-b1912007-pre-release","text":"Fixed multiple value tag filtering. #346 Added filtering for rules against a baseline with Get-PSRule . #345","title":"v0.12.0-B1912007 (pre-release)"},{"location":"CHANGELOG-v0/#v0120-b1912002-pre-release","text":"Fixed TargetType fall back to type name. #339 Added custom field binding. #321 Added new option Binding.Field available in baselines to configure binding. Added parameter alias -f for -InputPath . #340 -f was added to Invoke-PSRule , Assert-PSRule and Test-PSRuleTarget cmdlets. Important change : Added $PSRule generic context variable. #341 Deprecated TargetName , TargetType and TargetObject properties on $Rule . Use TargetName , TargetType and TargetObject on $PSRule instead. Properties TargetName , TargetType and TargetObject on $Rule will be removed in the future. Going forward $Rule will only contain properties that relate to the current rule context.","title":"v0.12.0-B1912002 (pre-release)"},{"location":"CHANGELOG-v0/#v0120-b1911013-pre-release","text":"Fixed NUnit serialization issue for unprocessed rules. #332 Added -All option to Exists keyword. #331","title":"v0.12.0-B1911013 (pre-release)"},{"location":"CHANGELOG-v0/#v0110","text":"What's changed since v0.10.0: General improvements: Added -TargetType parameter to filter input objects by target type. #176 This parameter applies to Invoke-PSRule , Assert-PSRule and Test-PSRuleTarget . Bug fixes: Fixed null reference exception when bound property is null. #323 Fixed missing Markdown input format in options schema. #315 Breaking change : Unprocessed object results are not returned from Test-PSRuleTarget by default. #318 Previously unprocessed objects returned $True , now unprocessed objects return no result. Use -Outcome All to return $True for unprocessed objects the same as <= v0.10.0. What's changed since pre-release v0.11.0-B1911002: No additional changes.","title":"v0.11.0"},{"location":"CHANGELOG-v0/#v0110-b1911002-pre-release","text":"Fixed null reference exception when bound property is null. #323","title":"v0.11.0-B1911002 (pre-release)"},{"location":"CHANGELOG-v0/#v0110-b1910014-pre-release","text":"Fixed missing Markdown input format in options schema. #315 Added -TargetType parameter to filter input objects by target type. #176 This parameter applies to Invoke-PSRule , Assert-PSRule and Test-PSRuleTarget . Breaking change : Unprocessed object results are not returned from Test-PSRuleTarget by default. #318 Previously unprocessed objects returned $True , now unprocessed objects return no result. Use -Outcome All to return $True for unprocessed objects the same as <= v0.10.0.","title":"v0.11.0-B1910014 (pre-release)"},{"location":"CHANGELOG-v0/#v0100","text":"What's changed since v0.9.0: General improvements: Added source note properties to input objects read from disk with -InputPath . #302 Engine features: Added assertion helper for checking field default value. #289 Added dependency DependsOn information to results from Get-PSRule . #210 To include dependencies that would normally be filtered out use -IncludeDependencies . Added input format for reading markdown front matter. #301 Markdown front matter is deserialized and evaluated as an object. Added Assert-PSRule cmdlet to improve integration into CI processes. #290 Added Output.Style option to support output in the following styles: Client/ Plain - Output returns easy to read log of rule pass/ fail. Azure Pipelines - Report rule failures as errors collected by Azure Pipelines. GitHub Actions - Reports rule failures as errors collected by GitHub Actions. Bug fixes: Fix Get-PSRuleHelp -Online in constrained language mode. #296 Breaking change : Removed previously deprecated alias Hint for Recommend . #165 Use the Recommend keyword instead. What's changed since pre-release v0.10.0-B1910036: No additional changes.","title":"v0.10.0"},{"location":"CHANGELOG-v0/#v0100-b1910036-pre-release","text":"Added dependency DependsOn information to results from Get-PSRule . #210 To include dependencies that would normally be filtered out use -IncludeDependencies . Added input format for reading markdown front matter. #301 Markdown front matter is deserialized and evaluated as an object. Added source note properties to input objects read from disk with -InputPath . #302 Breaking change : Removed previously deprecated alias Hint for Recommend . #165 Use the Recommend keyword instead.","title":"v0.10.0-B1910036 (pre-release)"},{"location":"CHANGELOG-v0/#v0100-b1910025-pre-release","text":"Fix Get-PSRuleHelp -Online in constrained language mode. #296 Added Assert-PSRule cmdlet to improve integration into CI processes. #290 Added Output.Style option to support output in the following styles: Client/ Plain - Output returns easy to read log of rule pass/ fail. Azure Pipelines - Report rule failures as errors collected by Azure Pipelines. GitHub Actions - Reports rule failures as errors collected by GitHub Actions.","title":"v0.10.0-B1910025 (pre-release)"},{"location":"CHANGELOG-v0/#v0100-b1910011-pre-release","text":"Added assertion helper for checking field default value. #289","title":"v0.10.0-B1910011 (pre-release)"},{"location":"CHANGELOG-v0/#v090","text":"What's changed since v0.8.0: General improvements: Improve feedback of parsing errors. #185 Updated Get-PSRuleHelp to include help within the current path by default. #197 Engine features: Added support for a wildcard match using the Within keyword. #272 Added rule info display name. #276 Added support for matching an array of tag values. #282 Added named baselines. Now baselines are a separate resource that can be individually used. Baselines can be packaged within module. Modules can specify a default baseline in module manifest. Target binding options ( Binding ) are now part of baselines. See about_PSRule_Baseline for more information. Bug fixes: Fix can not serialize nested System.IO.DirectoryInfo property. #281 Fix ModuleName not displayed in Get-PSRuleHelp list. #275 Fix outcome reported when error or exception is raised. #211 Breaking change : Baseline improvements, fundamentally changes how baselines work. #274 Previously, baselines were specified as workspace options. The previous baseline options property has been renamed to rule . The previous configuration property is now a top level option. What's changed since pre-release v0.9.0-B190905: No additional changes","title":"v0.9.0"},{"location":"CHANGELOG-v0/#v090-b190905-pre-release","text":"Added support for matching an array of tag values. #282 Updated Get-PSRuleHelp to include help within the current path by default. #197 Fix can not serialize nested System.IO.DirectoryInfo property. #281 Fix export of Like parameter for Within keyword. #279 Breaking change : Added named baselines. This changes how baselines work. #274 Previously, baselines were specified as workspace options. Now, baselines are a separate resource that can be individually used. Additionally: Baselines can be packaged within module. Modules can specify a default baseline in module manifest. Target binding options ( Binding ) are now part of baselines. The previous baseline options property has been renamed to rule . The previous configuration property is now a top level option. See about_PSRule_Baseline for more information.","title":"v0.9.0-B190905 (pre-release)"},{"location":"CHANGELOG-v0/#v090-b190819-pre-release","text":"Added support for a wildcard match using the Within keyword. #272 Added rule info display name. #276 Fix ModuleName not displayed in Get-PSRuleHelp list. #275","title":"v0.9.0-B190819 (pre-release)"},{"location":"CHANGELOG-v0/#v090-b190810-pre-release","text":"Improve feedback of parsing errors. #185 Fix outcome reported when error or exception is raised. #211","title":"v0.9.0-B190810 (pre-release)"},{"location":"CHANGELOG-v0/#v080","text":"What's changed since v0.7.0: General improvements: PSRule options are now displayed as YAML instead of a complex object. #233 Add detection for improper keyword use. #203 Automatically load rule modules. #218 Added support for debug messages and Write-Debug in rule definitions. #146 Added Logging.LimitDebug and Logging.LimitVerbose options to limit logging to named scopes. #235 Engine features: Added per object reason for failing rules. #200 Keywords Exists , Match , Within and TypeOf automatically add a reason when they fail. Custom reason can be set for keywords Exists , Match , Within and TypeOf with -Reason . Added Reason keyword to add to reason for custom logic. Added wide output display for Invoke-PSRule which include the reason why rule failed. To use wide output use the -OutputFormat Wide parameter. Renamed -Message parameter to -Text on the Recommend keyword. The -Message is an alias of -Text and will be deprecated in the future. Added assertion helper $Assert for extensibility. #250 Add built-in assertions for HasField , HasFieldValue and NullOrEmpty . Add JSON schema assertion method JsonSchema . #42 Bug fixes: Fix rule synopsis comment capture. #214 Fix YAML options file discovery issue in dotted directory. #232 Fix comparison of wrapped types and null with Within . #237 Breaking change : Use rule references consistent with cmdlet fully qualified syntax. #217 Rule names have to be unique within the current execution path or within a module. Previously rule names only had to be unique within a single file. Previously the filename.rule.ps1/RuleName was required to reference rules across files. This is no longer required because rule names are unique. You can reference a rule from a loaded module by using the syntax ModuleName\\RuleName . What's changed since pre-release v0.8.0-B190806: Fix export of assertion helper variable $Assert . #262","title":"v0.8.0"},{"location":"CHANGELOG-v0/#v080-b190806-pre-release","text":"Fix module reloading with different versions. #254 Fix not finding rules in current path by default. #256 Fix rule synopsis comment capture. #214","title":"v0.8.0-B190806 (pre-release)"},{"location":"CHANGELOG-v0/#v080-b190742-pre-release","text":"Fix inconsistent handling of $PWD . #249 Add detection for improper keyword use. #203 Automatically load rule modules. #218 Added assertion helper $Assert for extensibility. #250 Add built-in assertions for HasField , HasFieldValue and NullOrEmpty . Add JSON schema assertion method JsonSchema . #42 Breaking change : Use rule references consistent with cmdlet fully qualified syntax. #217 Rule names have to be unique within the current execution path or within a module. Previously rule names only had to be unique within a single file. Previously the filename.rule.ps1/RuleName was required to reference rules across files. This is no longer required because rule names are unique. You can reference a rule from a loaded module by using the syntax ModuleName\\RuleName .","title":"v0.8.0-B190742 (pre-release)"},{"location":"CHANGELOG-v0/#v080-b190716-pre-release","text":"Added per object reason for failing rules. #200 The keywords Exists , Match , Within and TypeOf automatically add a reason when they fail. Added -Reason parameter to Exists , Match , Within and TypeOf keywords to allow a custom reason to be set. Added Reason keyword to add to reason for custom logic. Added wide output display for Invoke-PSRule which include the reason why rule failed. To use wide output use the -OutputFormat Wide parameter. Renamed -Message parameter to -Text on the Recommend keyword. The -Message is an alias of -Text and will be deprecated in the future.","title":"v0.8.0-B190716 (pre-release)"},{"location":"CHANGELOG-v0/#v080-b190708-pre-release","text":"Fix YAML options file discovery issue in dotted directory. #232 Fix comparison of wrapped types and null with Within . #237 PSRule options are now displayed as YAML instead of a complex object. #233 Added support for debug messages and Write-Debug in rule definitions. #146 Added Logging.LimitDebug and Logging.LimitVerbose options to limit logging to named scopes. #235","title":"v0.8.0-B190708 (pre-release)"},{"location":"CHANGELOG-v0/#v070","text":"What's changed since v0.6.0: Fix reading nested arrays from JSON input. #223 Fix comparison of non-string types with Within . #226 Fix circular rule dependency issue. #190 Fix rule DependsOn parameter allows null. #191 Fix error message when attempting to use the rule keyword in a rule definition. #189 Fix TargetName binding when TargetName or Name property is null. #202 Fix handling of non-boolean results in rules. Rule is failed with more specific error message. #187 #224 Include .ps1 files that are specified directly with -Path , instead of only .Rule.ps1 files. #182 Improved warning message displayed when no Rule.ps1 files are founds. Added support for Invoke-PSRule to return CSV formatted results. #169 To generate CSV results use the -OutputFormat Csv parameter. Added Output.Path option to allow output to be saved directly to file. Added Output.Encoding option configure encoding used to write to file. By default, UTF-8 encoding without BOM is used. Invoke-PSRule cmdlet also provides a parameter -OutputPath to write results to file. Reordered cmdlet parameters to improve usage of frequently used parameters. #175 -Module parameter will tab-complete with imported rule modules. Added culture support for PowerShell informational messages. #158 A new $LocalizedData variable can be used within rule definitions. Added -Not switch to Within and Match keywords to allow negative comparison. #208 Improve discovery of rule tags. #209 Add wide format -OutputFormat Wide to Get-PSRule to allow output of rule tags. Breaking change : Changed rule filtering by tag to be case-insensitive. #204 Previously tag value was case-sensitive, however this is confusing since PowerShell is case-insensitive by default. Breaking change : Rule time is recorded in milliseconds instead of seconds. #192 What's changed since pre-release v0.7.0-B190664: No additional changes.","title":"v0.7.0"},{"location":"CHANGELOG-v0/#v070-b190664-pre-release","text":"Fix reading nested arrays from JSON input. #223 Fix comparison of non-string types with Within . #226 Improve handling of null rule result. #224","title":"v0.7.0-B190664 (pre-release)"},{"location":"CHANGELOG-v0/#v070-b190652-pre-release","text":"Fix TargetName binding when TargetName or Name property is null. #202 Add culture support for PowerShell informational messages. #158 A new $LocalizedData variable can be used within rule definitions. Add -Not switch to Within and Match keywords to allow negative comparison. #208 Improve discovery of rule tags. #209 Add wide format -OutputFormat Wide to Get-PSRule to allow output of rule tags. Breaking change : Change rule filtering by tag to be case-insensitive. #204 Previously tag value was case-sensitive, however this is confusing since PowerShell is case-insensitive by default.","title":"v0.7.0-B190652 (pre-release)"},{"location":"CHANGELOG-v0/#v070-b190633-pre-release","text":"Fix circular rule dependency issue. #190 Fix rule DependsOn parameter allows null. #191 Fix error message when attempting to use the rule keyword in a rule definition. #189 Breaking change : Rule time is recorded in milliseconds instead of seconds. #192","title":"v0.7.0-B190633 (pre-release)"},{"location":"CHANGELOG-v0/#v070-b190624-pre-release","text":"Fix handling of non-boolean results in rules. Rule is failed with more specific error message. #187 Include .ps1 files that are specified directly with -Path , instead of only .rule.ps1 files. #182 Improved warning message displayed when no Rule.ps1 files are founds.","title":"v0.7.0-B190624 (pre-release)"},{"location":"CHANGELOG-v0/#v070-b190613-pre-release","text":"Added support for Invoke-PSRule to return CSV formatted results. #169 To generate CSV results use the -OutputFormat Csv parameter. Added Output.Path option to allow output to be saved directly to file. Added Output.Encoding option configure encoding used to write to file. By default, UTF-8 encoding without BOM is used. Invoke-PSRule cmdlet also provides a parameter -OutputPath to write results to file. Reordered cmdlet parameters to improve usage of frequently used parameters. #175 -Module parameter will tab-complete with imported rule modules.","title":"v0.7.0-B190613 (pre-release)"},{"location":"CHANGELOG-v0/#v060","text":"What's changed since v0.5.0: Fix operation is not supported on this platform failure. #152 Fix FullName cannot be found on this object error. #149 Fix discovery of rules within paths that contain spaces fails. #168 Added rule documentation, which allows additional rule information to be stored in markdown files. #157 Rule documentation also adds culture support. #18 Rule documentation can be accessed like help with the Get-PSRuleHelp cmdlet. Added annotations, which are non-indexed metadata stored in rule documentation. #148 Annotations can contain a link to online version of the documentation. #147 Important change : Changed Hint keyword to Recommend to align with rule documentation. #165 Use of Hint keyword is deprecated and will be removed in a future release. Currently Hint is aliased to Recommend for compatibility. Breaking change : Changed rule properties to align with rule documentation. #164 Rule Synopsis , is a brief summary of the rule and Description is a detailed purpose of the rule. Description: metadata keyword used in comment help is now Synopsis: , use of Description: will set synopsis. Description metadata keyword is deprecated and will be removed in a future update. Output property Message on rule results is now Recommendation . What's changed since pre-release v0.6.0-B190627: Fix discovery of rules within paths that contain spaces fails. #168 Fix exporting of Recommend keyword and Hint alias. #171","title":"v0.6.0"},{"location":"CHANGELOG-v0/#v060-b190627-pre-release","text":"Important change : Changed Hint keyword to Recommend to align with rule documentation. #165 Use of Hint keyword is deprecated and will be removed in a future release. Currently Hint is aliased to Recommend for compatibility. Breaking change : Changed rule properties to align with rule documentation. #164 Rule Synopsis , is a brief summary of the rule and Description is a detailed purpose of the rule. Description: metadata keyword used in comment help is now Synopsis: , use of Description: will set synopsis. Description metadata keyword is deprecated and will be removed in a future update. Output property Message on rule results is now Recommendation .","title":"v0.6.0-B190627 (pre-release)"},{"location":"CHANGELOG-v0/#v060-b190614-pre-release","text":"Added rule documentation, which allows additional rule information to be stored in markdown files. #157 Rule documentation also adds culture support. #18 Rule documentation can be accessed like help with the Get-PSRuleHelp cmdlet. Added annotations, which are non-indexed metadata stored in rule documentation. #148 Annotations can contain a link to online version of the documentation. #147","title":"v0.6.0-B190614 (pre-release)"},{"location":"CHANGELOG-v0/#v060-b190514-pre-release","text":"Fix operation is not supported on this platform failure. #152 Fix FullName cannot be found on this object error. #149","title":"v0.6.0-B190514 (pre-release)"},{"location":"CHANGELOG-v0/#v050","text":"What's changed since v0.4.0: Fix PSRule options schema usage of additionalProperties. #136 Fix null reference exception when traversing null field. #123 Fix missing help topics for options and variables. #125 Improved handling of default YAML options file. #137 Added support for Invoke-PSRule to return NUnit3 formatted results. #129 To generate NUnit3 results use the -OutputFormat NUnit3 parameter. Added Set-PSRuleOption cmdlet to configure YAML options file. #135 Added parameters to New-PSRuleOption to configure common options. #134 Additional parameters are an alternative to using a -Option hashtable. What's changed since pre-release v0.5.0-B190423: Fix schema conformance of -OutputFormat NUnit3 to NUnit report schema. #141 Fix PSRule options schema usage of additionalProperties. #136","title":"v0.5.0"},{"location":"CHANGELOG-v0/#v050-b190423-pre-release","text":"Added support for Invoke-PSRule to return NUnit3 formatted results. #129 To generate NUnit3 results use the -OutputFormat NUnit3 parameter. Added Set-PSRuleOption cmdlet to configure YAML options file. #135 Added parameters to New-PSRuleOption to configure common options. #134 Additional parameters are an alternative to using a -Option hashtable. Improved handling of default YAML options file. #137","title":"v0.5.0-B190423 (pre-release)"},{"location":"CHANGELOG-v0/#v050-b190405-pre-release","text":"Fix null reference exception when traversing null field. #123 Fix missing help topics for options and variables. #125","title":"v0.5.0-B190405 (pre-release)"},{"location":"CHANGELOG-v0/#v040","text":"What's changed since v0.3.0: Fix incorrect JSON de-serialization. #109 #111 Added support for using -InputPath instead of using -InputObject to handle serialized objects. #106 -Format is automatically detected for .yaml , .yml and .json file extensions. Added -OutputFormat parameter to serialize output from Invoke-PSRule as YAML or JSON. #29 Added support for logging pass or fail outcomes to a data stream such as Error, Warning or Information. #97 Breaking change : Deprecated usage of the -TargetName parameter on the Hint keyword has been removed. #81 What's changed since pre-release v0.4.0-B190328: No additional changes.","title":"v0.4.0"},{"location":"CHANGELOG-v0/#v040-b190328-pre-release","text":"Fix summary is not correctly serialized with JSON or YAML output format. #116 Fix missing properties on serialized YAML output. #115 Fix incorrect property name case of YAML serialized results. #114","title":"v0.4.0-B190328 (pre-release)"},{"location":"CHANGELOG-v0/#v040-b190320-pre-release","text":"Fix incorrect JSON de-serialization of nested arrays. #109 Fix incorrect JSON de-serialization of non-object arrays. #111","title":"v0.4.0-B190320 (pre-release)"},{"location":"CHANGELOG-v0/#v040-b190311-pre-release","text":"Added support for using -InputPath instead of using -InputObject to handle serialized objects. #106 -Format is automatically detected for .yaml , .yml and .json file extensions. Added -OutputFormat parameter to serialize output from Invoke-PSRule . #29 Added support for logging pass or fail outcomes to a data stream such as Error, Warning or Information. #97 Breaking change : Deprecated usage of the -TargetName parameter on the Hint keyword has been removed. #81","title":"v0.4.0-B190311 (pre-release)"},{"location":"CHANGELOG-v0/#v030","text":"What's changed since v0.2.0: Added support for pipelining with Exists , Within , Match and TypeOf keywords #90 Added support for packaging rules in modules #16 Import objects from YAML or JSON format #75 Added support for input de-serialization from FileInfo objects #95 Support nested TargetObjects #77 Export variables to improve authoring experience #83 Binding improvements: Added object type binding and dynamic filtering for rules #82 Added support for indexed and quoted field names #86 Added support for case-sensitive binding operations #87 Binding ignores case by default. Set option Binding.CaseSensitive to true to enable case-sensitivity. Support TargetName binding of nested properties #71 Added online help links to keywords #72 Added schema for PSRule options #74 Important change : The -TargetName parameter of the Hint keyword has been deprecated #81 -TargetName parameter not longer sets the pipeline object TargetName and generates a warning instead. The -TargetName will be completely removed in v0.4.0 , at which time using the parameter will generate an error. Breaking change : Changed parameter alias for -Path from -f to -p #99 What's changed since pre-release v0.3.0-B190231: Added support for input de-serialization from FileInfo objects #95 Breaking change : Changed parameter alias for -Path from -f to -p #99","title":"v0.3.0"},{"location":"CHANGELOG-v0/#v030-b190231-pre-release","text":"Added support for pipelining with Exists , Within , Match and TypeOf keywords #90 Fix empty YAML object causes format de-serialize to fail #92","title":"v0.3.0-B190231 (pre-release)"},{"location":"CHANGELOG-v0/#v030-b190224-pre-release","text":"Export variables to improve authoring experience #83 Added support for packaging rules in modules #16 Added support for indexed and quoted field names #86 Added object type binding and dynamic filtering for rules #82 Added support for case-sensitive binding operations #87 Binding ignores case by default. Set option Binding.CaseSensitive to true to enable case-sensitivity. Important change : The -TargetName parameter of the Hint keyword has been deprecated #81 -TargetName parameter not longer sets the pipeline object TargetName and generates a warning instead. The -TargetName will be completely removed in v0.4.0 , at which time using the parameter will generate an error.","title":"v0.3.0-B190224 (pre-release)"},{"location":"CHANGELOG-v0/#v030-b190208-pre-release","text":"Added online help links to keywords #72 Added schema for PSRule options #74 Import objects from YAML or JSON format #75 Support TargetName binding of nested properties #71 Support nested TargetObjects #77","title":"v0.3.0-B190208 (pre-release)"},{"location":"CHANGELOG-v0/#v020","text":"What's changed since v0.1.0: Added support for cross-platform environments (Windows, Linux and macOS) #49 Added support for nested field names with Exists , Within and Match keywords #60 Added support for rule configuration using baselines #17 Use rule description when hint message not set #61 Allow objects to be suppressed by TargetName for individual rules #13 Allow binding of TargetName to custom property #44 Custom functions can be used to bind TargetName #44 Objects that are unable to bind a TargetName will use a SHA1 object hash for TargetName #44 Added Test-PSRuleTarget command to return an overall $True or $False after evaluating rules for an object #30 Improve reporting of inconclusive results and objects that are not processed by any rule #46 Inconclusive results and objects not processed will return a warning by default. Fix propagation of informational messages to host from rule scripts and definitions #48 Fix Get-PSRule generates exception when no .rule.ps1 scripts exist in path #53 Fix LocalizedData.PathNotFound warning when no .rule.ps1 scripts exist in path #54 What's changed since pre-release v0.2.0-B190121: No additional changes.","title":"v0.2.0"},{"location":"CHANGELOG-v0/#v020-b190121-pre-release","text":"Added support for nested field names with Exists , Within and Match keywords #60 Added support for rule configuration using baselines #17 Use rule description when hint message not set #61","title":"v0.2.0-B190121 (pre-release)"},{"location":"CHANGELOG-v0/#v020-b190113-pre-release","text":"Fix Get-PSRule generates exception when no .rule.ps1 scripts exist in path #53 Fix LocalizedData.PathNotFound warning when no .rule.ps1 scripts exist in path #54 Breaking change : Renamed Test-PSRule cmdlet to Test-PSRuleTarget which aligns more closely to the verb-noun naming standard #57","title":"v0.2.0-B190113 (pre-release)"},{"location":"CHANGELOG-v0/#v020-b190105-pre-release","text":"Allow objects to be suppressed by TargetName for individual rules #13 Allow binding of TargetName to custom property #44 Custom functions can be used to bind TargetName #44 Objects that are unable to bind a TargetName will use a SHA1 object hash for TargetName #44 Added Test-PSRule command to return an overall $True or $False after evaluating rules for an object #30 Improve reporting of inconclusive results and objects that are not processed by any rule #46 Inconclusive results and objects not processed will return a warning by default. Fix propagation of informational messages to host from rule scripts and definitions #48 Added support for cross-platform environments (Windows, Linux and macOS) #49","title":"v0.2.0-B190105 (pre-release)"},{"location":"CHANGELOG-v0/#v010","text":"Initial release What's changed since pre-release v0.1.0-B181235: Fix outcome filtering of summary results #33 Fix target object counter in verbose logging #35 Fix hashtable keys should be handled as fields #36","title":"v0.1.0"},{"location":"CHANGELOG-v0/#v010-b181235-pre-release","text":"RuleId and RuleName are now independent. Rules are created with a name, and the RuleId is generated based on rule name and file name Rules with the same name can exist and be cross linked with DependsOn, as long a the script file name is different Added -Not to Exists keyword Improved verbose logging of Exists , AllOf , AnyOf keywords and core engine Breaking change : Renamed outcome filtering parameters to align to type name and increase clarity Invoke-PSRule has a -Outcome parameter instead of -Status -Outcome supports values of Pass , Fail , Error , None , Processed and All","title":"v0.1.0-B181235 (pre-release)"},{"location":"CHANGELOG-v0/#v010-b181222-pre-release","text":"Added rule tags to results to enable grouping and sorting #14 Added support to check for rule tag existence. Use * for tag value on -Tag parameter with Invoke-PSRule and Get-PSRule Added option to report rule summary using -As parameter of Invoke-PSRule #12","title":"v0.1.0-B181222 (pre-release)"},{"location":"CHANGELOG-v0/#v010-b181212-pre-release","text":"Initial pre-release.","title":"v0.1.0-B181212 (pre-release)"},{"location":"CHANGELOG-v1/","text":"Change log # See upgrade notes for helpful information when upgrading from previous versions. Important notes : YAML resources will require an apiVersion from PSRule v2. #648 Setting the default module baseline requires a module configuration from PSRule v2. #809 Resource names have naming restrictions introduced from PSRule v2. #1012 Attention PSRule v1 is a prior release. For more information see v2 release notes. Please check out our upgrade notes to get prepared for upgrading to the latest version. v1.11.1 # What's changed since v1.11.1: Bug fixes: Fixed broken documentation links. #980 v1.11.0 # What's changed since v1.10.0: General improvements: Added version expression to check semantic version constraints. #861 See about_PSRule_Expressions for details. Added hasDefault expression to check field default value. #870 See about_PSRule_Expressions for details. Bug fixes: Fixed GetReason() not returning results for a failed assertion. #874 What's changed since pre-release v1.11.0-B2112016: No additional changes. v1.11.0-B2112016 (pre-release) # What's changed since v1.10.0: General improvements: Added version expression to check semantic version constraints. #861 See about_PSRule_Expressions for details. Added hasDefault expression to check field default value. #870 See about_PSRule_Expressions for details. Bug fixes: Fixed GetReason() not returning results for a failed assertion. #874 v1.10.0 # What's changed since v1.9.0: General improvements: Added JSON support for reading rules and selectors from pipeline. #857 Added HasSchema expression to check the schema of an object. #860 See about_PSRule_Expressions for details. Engineering: Bump Microsoft.SourceLink.GitHub to 1.1.1. #856 Bug fixes: Fixed $Assert.HasJsonSchema accepts empty value. #859 Fixed module configuration is not loaded when case does not match. #864 What's changed since pre-release v1.10.0-B2112002: No additional changes. v1.10.0-B2112002 (pre-release) # What's changed since pre-release v1.10.0-B2111024: Bug fixes: Fixed module configuration is not loaded when case does not match. #864 v1.10.0-B2111024 (pre-release) # What's changed since v1.9.0: General improvements: Added JSON support for reading rules and selectors from pipeline. #857 Added HasSchema expression to check the schema of an object. #860 See about_PSRule_Expressions for details. Engineering: Bump Microsoft.SourceLink.GitHub to 1.1.1. #856 Bug fixes: Fixed $Assert.HasJsonSchema accepts empty value. #859 v1.9.0 # What's changed since v1.8.0: General improvements: Added improvements to YAML output for Get-PSRuleBaseline . #829 Added -Initialize convention block. #826 Use this block to perform any initialization that is required before any rules are run. This block is only run once instead of -Begin which is run once per object. See about_PSRule_Conventions for details. Allow lifetime services to be used. #827 Use $PSRule.AddService and $PSRule.GetService to add a service. Services allows a singleton instance to be used and shared across multiple rules. PSRule will automatically dispose the service when all rules have run. See about_PSRule_Variables for details. Added Export-PSRuleBaseline cmdlet to export baseline. #622 Added JSON output format for Baseline cmdlets. #839 Allow downstream issues to be consumed. #843 Objects can be flagged with issues that have been generated externally. See about_PSRule_Assert for details. Migrated default baseline to module configuration. #809 This enables configuration of the default baseline for a module with a module configuration. This depreciate configuring the default baseline within the module manifest. Modules using manifest configuration will start warning from v1.9.0. See about_PSRule_Options for details. Added JSON support to read baselines from pipeline. #845 Engineering: Bump System.Drawing.Common dependency to v6.0.0. #848 Bug fixes: Fixed convention execution is out of order. #835 What's changed since pre-release v1.9.0-B2111024: Engineering: Bump Microsoft.CodeAnalysis.NetAnalyzers to v6.0.0. #851 v1.9.0-B2111024 (pre-release) # What's changed since pre-release v1.9.0-B2111009: General improvements: Allow downstream issues to be consumed. #843 Objects can be flagged with issues that have been generated externally. See about_PSRule_Assert for details. Migrated default baseline to module configuration. #809 This enables configuration of the default baseline for a module with a module configuration. This depreciate configuring the default baseline within the module manifest. Modules using manifest configuration will start warning from v1.9.0. See about_PSRule_Options for details. Added JSON support to read baselines from pipeline. #845 Engineering: Bump System.Drawing.Common dependency to v6.0.0. #848 v1.9.0-B2111009 (pre-release) # What's changed since pre-release v1.9.0-B2110027: General improvements: Added JSON output format for Baseline cmdlets. #839 Bug fixes: Fixed convention execution is out of order. #835 v1.9.0-B2110027 (pre-release) # What's changed since pre-release v1.9.0-B2110015: General improvements: Added Export-PSRuleBaseline cmdlet to export baseline. #622 v1.9.0-B2110015 (pre-release) # What's changed since v1.8.0: General improvements: Added improvements to YAML output for Get-PSRuleBaseline . #829 Added -Initialize convention block. #826 Use this block to perform any initialization that is required before any rules are run. This block is only run once instead of -Begin which is run once per object. See about_PSRule_Conventions for details. Allow lifetime services to be used. #827 Use $PSRule.AddService and $PSRule.GetService to add a service. Services allows a singleton instance to be used and shared across multiple rules. PSRule will automatically dispose the service when all rules have run. See about_PSRule_Variables for details. v1.8.0 # What's changed since v1.7.2: General improvements: Added YAML output format support for Get-PSRuleBaseline . #326 Added YAML/JSON output format support for Get-PSRule . #128 Added Output.JsonIndent option for JSON output format. #817 Added assertion helpers and expressions for improving intersection checks. #795 Added Count to determine of the field has a specific number of elements. Added SetOf to determine if a collection is another collection. Added Subset to determine if a collection is includes another collection. See about_PSRule_Assert and about_PSRule_Expressions for details. Added support for conditional reason messages with ReasonIf . #804 See about_PSRule_Assert for details. Added support for type and name expression properties. #810 Use type to compare the bound type of the current object. Use name to compare the bound name of the current object. See about_PSRule_Expressions for details. Engineering: Migration of Pester v4 tests to Pester v5. #478 What's changed since pre-release v1.8.0-B2110030: No additional changes. v1.8.0-B2110030 (pre-release) # What's changed since pre-release v1.8.0-B2110020: General improvements: Added Output.JsonIndent option for JSON output format. #817 v1.8.0-B2110020 (pre-release) # What's changed since pre-release v1.8.0-B2110006: General improvements: Added YAML/JSON output format support for Get-PSRule . #128 Engineering: Migration of Pester v4 tests to Pester v5. #478 v1.8.0-B2110006 (pre-release) # What's changed since pre-release v1.8.0-B2109022: General improvements: Added YAML output format support for Get-PSRuleBaseline . #326 v1.8.0-B2109022 (pre-release) # What's changed since pre-release v1.8.0-B2109015: General improvements: Added support for conditional reason messages with ReasonIf . #804 See about_PSRule_Assert for details. Added support for type and name expression properties. #810 Use type to compare the bound type of the current object. Use name to compare the bound name of the current object. See about_PSRule_Expressions for details. v1.8.0-B2109015 (pre-release) # What's changed since v1.7.2: General improvements: Added assertion helpers and expressions for improving intersection checks. #795 Added Count to determine of the field has a specific number of elements. Added SetOf to determine if a collection is another collection. Added Subset to determine if a collection is includes another collection. See about_PSRule_Assert and about_PSRule_Expressions for details. v1.7.2 # What's changed since v1.7.1: Bug fixes: Fixed Get-PSRuleBaseline does not return any results from module. #801 v1.7.1 # What's changed since v1.7.0: Bug fixes: Fixed ResourceTags does not contain a method named ToHashtable. #798 v1.7.0 # What's changed since v1.6.0: Engine features: Added support for generating badges from rule results. #623 Standard or custom badges can be generated using a convention and the badge API. See about_PSRule_Badges for details. General improvements: Rule results now include a run ID or each run. #774 Run ID is returned in Assert-PSRule output at the end of each run by default. By default a unique runId is generated when the rule is run. The Output.Footer option was added to configure the output footer. See about_PSRule_Options for details. Automatically exclude common repository files from input files. #721 Added Input.IgnoreRepositoryCommon option to change default behavior. See about_PSRule_Options for details. Added aggregation assertion methods for AnyOf and AllOf . #776 See about_PSRule_Assert for details. Allow baselines to include local rules. #756 The Rule.IncludeLocal option was automatically include local/ standalone rules not in a module. This option is useful when you want to include local rules not included in a baseline. See about_PSRule_Options for details. Bug fixes: Fixed configuration array deserializes as dictionary from YAML options. #779 What's changed since pre-release v1.7.0-B2109002: No additional changes. v1.7.0-B2109002 (pre-release) # What's changed since pre-release v1.7.0-B2108032: General improvements: Allow baselines to include local rules. #756 The Rule.IncludeLocal option was automatically include local/ standalone rules not in a module. This option is useful when you want to include local rules not included in a baseline. See about_PSRule_Options for details. v1.7.0-B2108032 (pre-release) # What's changed since pre-release v1.7.0-B2108021: Engine features: Added support for generating badges from rule results. #623 Standard or custom badges can be generated using a convention and the badge API. See about_PSRule_Badges for details. General improvements: Rule results now include a run ID or each run. #774 Run ID is returned in Assert-PSRule output at the end of each run by default. By default a unique runId is generated when the rule is run. The Output.Footer option was added to configure the output footer. See about_PSRule_Options for details. v1.7.0-B2108021 (pre-release) # What's changed since pre-release v1.7.0-B2108016: Bug fixes: Fixed configuration array deserializes as dictionary from YAML options. #779 v1.7.0-B2108016 (pre-release) # What's changed since v1.6.0: General improvements: Automatically exclude common repository files from input files. #721 Added Input.IgnoreRepositoryCommon option to change default behavior. See about_PSRule_Options for details. Added aggregation assertion methods for AnyOf and AllOf . #776 See about_PSRule_Assert for details. v1.6.1 # What's changed since v1.6.0: Bug fixes: Fixed configuration array deserializes as dictionary from YAML options. #779 v1.6.0 # What's changed since v1.5.0: Engine features: Added support for YAML rules. #603 YAML rules evaluate an expression tree and return a result for each object. YAML provides an additional option for defining rules in addition to PowerShell script rules. Type and selector pre-conditions are supported. See about_PSRule_Rules for details. General improvements: Added support for object source location in validation. #757 Default rule source location .ps-rule/ is automatically included. #742 Added Include.Path and Include.Module options to automatically include rule sources. See about_PSRule_Options for details. Bug fixes: Fixed target binding across multiple scopes. #762 What's changed since pre-release v1.6.0-B2108009: No additional changes. v1.6.0-B2108009 (pre-release) # What's changed since pre-release v1.6.0-B2108003: Engine features: Added support for YAML rules. #603 YAML rules evaluate an expression tree and return a result for each object. YAML provides an additional option for defining rules in addition to PowerShell script rules. Type and selector pre-conditions are supported. See about_PSRule_Rules for details. v1.6.0-B2108003 (pre-release) # What's changed since pre-release v1.6.0-B2107008: Bug fixes: Fixed target binding across multiple scopes. #762 v1.6.0-B2107008 (pre-release) # What's changed since v1.5.0: General improvements: Added support for object source location in validation. #757 Default rule source location .ps-rule/ is automatically included. #742 Added Include.Path and Include.Module options to automatically include rule sources. See about_PSRule_Options for details. v1.5.0 # What's changed since v1.4.0: General improvements: Added string selector conditions. #747 Use startWith , contains , and endsWith to check for a sub-string. Use isString , isLower , and isUpper to check for string type and casing. See about_PSRule_Selectors for details. Engineering: Bump YamlDotNet dependency to 11.2.1. #740 Bug fixes: Fixed options schema should allow spacing after @pre . #743 Fixed match selector expression passing on missing field. #745 What's changed since pre-release v1.5.0-B2107009: No additional changes. v1.5.0-B2107009 (pre-release) # What's changed since pre-release v1.5.0-B2106006: General improvements: Added string selector conditions. #747 Use startWith , contains , and endsWith to check for a sub-string. Use isString , isLower , and isUpper to check for string type and casing. See about_PSRule_Selectors for details. Engineering: Bump YamlDotNet dependency to 11.2.1. #740 Bug fixes: Fixed options schema should allow spacing after @pre . #743 Fixed match selector expression passing on missing field. #745 v1.5.0-B2106006 (pre-release) # What's changed since v1.4.0: Engineering: Bump YamlDotNet dependency to 11.2.0. #736 v1.4.0 # What's changed since v1.3.0: General improvements: PSRule banner can be configured in output when using Assert-PSRule . #708 Input source location of objects are included in results. Input source location of objects from JSON and YAML input files are read automatically. #624 Input source location of objects from the pipeline are read from properties. #729 Assert output improvements: Added support for Visual Studio Code with VisualStudioCode style. #731 Updated output format provides support for problem matchers in task output. Automatically detect output style from environment variables. #732 Assert-PSRule now defaults to Detect instead of Client . See about_PSRule_Options for details. Improved support for version constraints by: Constraints can include prerelease versions of other matching versions. #714 Constraints support using a @prerelease or @pre to include prerelease versions. #717 Constraint sets allow multiple constraints to be joined together. #715 See about_PSRule_Assert for details. Bug fixes: Fixed prerelease constraint handling for prerelease versions. #712 Fixed null reference in convention for nested exceptions. #725 What's changed since pre-release v1.4.0-B2105041: No additional changes. v1.4.0-B2105041 (pre-release) # What's changed since pre-release v1.4.0-B2105032: General improvements: Source location of objects from the pipeline are read from properties. #729 Assert output improvements: Added support for Visual Studio Code with VisualStudioCode style. #731 Updated output format provides support for problem matchers in task output. Automatically detect output style from environment variables. #732 Assert-PSRule now defaults to Detect instead of Client . See about_PSRule_Options for details. v1.4.0-B2105032 (pre-release) # What's changed since pre-release v1.4.0-B2105019: Bug fixes: Fixed null reference in convention for nested exceptions. #725 v1.4.0-B2105019 (pre-release) # What's changed since pre-release v1.4.0-B2105004: General improvements: Source location of objects are included in results. Source location of objects from JSON and YAML input files are read automatically. #624 Improved support for version constraints by: Constraints can include prerelease versions of other matching versions. #714 Constraints support using a @prerelease or @pre to include prerelease versions. #717 Constraint sets allow multiple constraints to be joined together. #715 See about_PSRule_Assert for details. Bug fixes: Fixed prerelease constraint handling for prerelease versions. #712 v1.4.0-B2105004 (pre-release) # What's changed since v1.3.0: General improvements: PSRule banner can be configured in output when using Assert-PSRule . #708 v1.3.0 # What's changed since v1.2.0: Engine features: Options can be configured with environment variables. #691 See about_PSRule_Options for details. General improvements: Exclude .git sub-directory by default for recursive scans. #697 Added Input.IgnoreGitPath option to configure inclusion of .git path. See about_PSRule_Options for details. Added file path assertion helpers. #679 Added WithinPath to check the file path field is within a specified path. Added NotWithinPath to check the file path field is not within a specified path See about_PSRule_Assert for details. Added DateTime type assertion helper. #680 Added IsDateTime to check of object field is [DateTime] . See about_PSRule_Assert for details. Improved numeric comparison assertion helpers to compare [DateTime] fields. #685 Less , LessOrEqual , Greater , and GreaterOrEqual compare the number of days from the current time. See about_PSRule_Assert for details. Improved handling of field names for objects implementing IList , IEnumerable , and index properties. #692 Engineering: Bump YamlDotNet dependency to 11.1.1. #690 Bug fixes: Fixed expected DocumentEnd got SequenceEnd. #698 What's changed since pre-release v1.3.0-B2105004: No additional changes. v1.3.0-B2105004 (pre-release) # What's changed since pre-release v1.3.0-B2104042: Engine features: Options can be configured with environment variables. #691 See about_PSRule_Options for details. General improvements: Exclude .git sub-directory by default for recursive scans. #697 Added Input.IgnoreGitPath option to configure inclusion of .git path. See about_PSRule_Options for details. v1.3.0-B2104042 (pre-release) # What's changed since pre-release v1.3.0-B2104030: Bug fixes: Fixed expected DocumentEnd got SequenceEnd. #698 v1.3.0-B2104030 (pre-release) # What's changed since pre-release v1.3.0-B2104021: General improvements: Improved handling of field names for objects implementing IList , IEnumerable , and index properties. #692 Engineering: Bump YamlDotNet dependency to 11.1.1. #690 v1.3.0-B2104021 (pre-release) # What's changed since v1.2.0: General improvements: Added file path assertion helpers. #679 Added WithinPath to check the file path field is within a specified path. Added NotWithinPath to check the file path field is not within a specified path See about_PSRule_Assert for details. Added DateTime type assertion helper. #680 Added IsDateTime to check of object field is [DateTime] . See about_PSRule_Assert for details. Improved numeric comparison assertion helpers to compare [DateTime] fields. #685 Less , LessOrEqual , Greater , and GreaterOrEqual compare the number of days from the current time. See about_PSRule_Assert for details. v1.2.0 # What's changed since v1.1.0: Engine features: Added support for extensibility with conventions. #650 Conventions provide an extensibility point within PSRule to execute actions within the pipeline. A convention can expose Begin , Process , and End blocks. In additional to within rules $PSRule.Data can be accessed from Begin and Process blocks. See about_PSRule_Conventions for details. Added support for object expansion with conventions. #661 Use the $PSRule.Import method to import child source objects into the pipeline. See about_PSRule_Variables for details. Added support for complex pre-conditions with selectors. #649 See about_PSRule_Selectors for details. General improvements: Added support for preferring automatic binding over custom binding configurations. #670 Added the Binding.PreferTargetInfo option to prefer target info specified by the object. See about_PSRule_Options for details. Added strong apiVersion to resource types. #647 Resource schemas now support an apiVersion field. The apiVersion field is optional but recommended. Resources without a apiVersion field will not be supported from PSRule v2. Added warning to flag baseline without apiVersion set. Added support for detecting files headers from additional file extensions using FileHeader . #664 Added .bicep , .csx , .jsx , .groovy , .java , .json , .jsonc , .scala , .rb , .bat , .cmd . Added support for Jenkinsfile and Dockerfile without an extension. See about_PSRule_Assert for details. Added support for automatic type binding with files that do not have a file extension. #665 Bug fixes: Fixed dependent rule execution is skipped for consequent input objects. #657 What's changed since pre-release v1.2.0-B2103043: No additional changes. v1.2.0-B2103043 (pre-release) # What's changed since pre-release v1.2.0-B2103031: Engine features: Added support for complex pre-conditions with selectors. #649 General improvements: Added support for preferring automatic binding over custom binding configurations. #670 Added the Binding.PreferTargetInfo option to prefer target info specified by the object. See about_PSRule_Options for details. Added strong apiVersion to resource types. #647 Resource schemas now support an apiVersion field. The apiVersion field is optional but recommended. Resources without a apiVersion field will not be supported from PSRule v2. Added warning to flag baseline without apiVersion set. v1.2.0-B2103031 (pre-release) # What's changed since pre-release v1.2.0-B2103023: General improvements: Added support for detecting files headers from additional file extensions. #664 Added .bicep , .csx , .jsx , .groovy , .java , .json , .jsonc , .scala , .rb , .bat , .cmd . Added support for Jenkinsfile and Dockerfile without an extension. See about_PSRule_Assert for details. Added support for automatic type binding with files that do not have a file extension. #665 v1.2.0-B2103023 (pre-release) # What's changed since pre-release v1.2.0-B2103016: Engine features: Added support for object expansion with conventions. #661 Use the $PSRule.Import method to import child source objects into the pipeline. See about_PSRule_Variables for details. v1.2.0-B2103016 (pre-release) # What's changed since pre-release v1.2.0-B2103008: Bug fixes: Fixed dependent rule execution is skipped for consequent input objects. #657 v1.2.0-B2103008 (pre-release) # What's changed since v1.1.0: Engine features: Added support for extensibility with conventions. #650 Conventions provide an extensibility point within PSRule to execute actions within the pipeline. A convention can expose Begin , Process , and End blocks. In additional to within rules $PSRule.Data can be accessed from Begin and Process blocks. See about_PSRule_Conventions for details. v1.1.0 # What's changed since v1.0.3: Engine features: Added assertion helpers. #640 Added NotHasField to check object does not have any of the specified fields. Added Null to check field value is null. Added NotNull to check field value is not null. See about_PSRule_Assert for details. Added type assertion helpers. #635 Added IsNumeric to check field value is a numeric types. Added IsInteger to check field value is an integer types. Added IsBoolean to check field value is a boolean. Added IsArray to check field value is an array. Added IsString to check field value is a string. Added TypeOf to check field value is a specified type. See about_PSRule_Assert for details. Added content helpers. #637 Added $PSRule.GetContentFirstOrDefault to get content and return the first object. Added $PSRule.GetContentField to get the field from content objects. See about_PSRule_Variables for details. General improvements: Updated HasJsonSchema assertion helper. #636 The URI scheme can optionally be ignored for http:// or https:// URIs. The fragment # is ignored. See about_PSRule_Assert for details. Added support for -Outcome and -As to produce filtered output from Assert-PSRule . #643 Configure Output.As with Summary to produce summarized results per object. Configure Output.Outcome to limit output to Fail or Error . See Assert-PSRule for details. What's changed since pre-release v1.1.0-B2102029: No additional changes. v1.1.0-B2102029 (pre-release) # What's changed since pre-release v1.1.0-B2102024: General improvements: Added support for -Outcome and -As to produce filtered output from Assert-PSRule . #643 Configure Output.As with Summary to produce summarized results per object. Configure Output.Outcome to limit output to Fail or Error . See Assert-PSRule for details. v1.1.0-B2102024 (pre-release) # What's changed since pre-release v1.1.0-B2102019: Engine features: Added assertion helpers. #640 Added NotHasField to check object does not have any of the specified fields. Added Null to check field value is null. Added NotNull to check field value is not null. See about_PSRule_Assert for details. v1.1.0-B2102019 (pre-release) # What's changed since v1.0.3: Engine features: Added type assertion helpers. #635 Added IsNumeric to check field value is a numeric types. Added IsInteger to check field value is an integer types. Added IsBoolean to check field value is a boolean. Added IsArray to check field value is an array. Added IsString to check field value is a string. Added TypeOf to check field value is a specified type. See about_PSRule_Assert for details. Added content helpers. #637 Added $PSRule.GetContentFirstOrDefault to get content and return the first object. Added $PSRule.GetContentField to get the field from content objects. See about_PSRule_Variables for details. General improvements: Updated HasJsonSchema assertion helper. #636 The URI scheme can optionally be ignored for http:// or https:// URIs. The fragment # is ignored. See about_PSRule_Assert for details. v1.0.3 # What's changed since v1.0.2: Bug fixes: Fixed reason reported fields for HasField and HasFields assertion helpers. #632 v1.0.2 # What's changed since v1.0.1: Engineering: Bump Manatee.Json dependency to 13.0.5. #619 Bug fixes: Fixed GetContent processing of InputFileInfo . #625 Fixed null reference of rule reason with wide output. #626 Fixed markdown help handling of inline code blocks with [ . #627 Fixed markdown help inclusion of fenced code blocks in notes and description. #628 v1.0.1 # What's changed since v1.0.0: Bug fixes: Fixed module source key has already been added. #608 v1.0.0 # What's changed since v0.22.0: General improvements: Added rule help link in failed Assert-PSRule output. #595 Engineering: Breaking change : Removed deprecated $Rule properties. #495 Bump Manatee.Json dependency to 13.0.4. #591 What's changed since pre-release v1.0.0-B2011028: No additional changes. v1.0.0-B2011028 (pre-release) # What's changed since v0.22.0: General improvements: Added rule help link in failed Assert-PSRule output. #595 Engineering: Breaking change : Removed deprecated $Rule properties. #495 Bump Manatee.Json dependency to 13.0.4. #591","title":"v1"},{"location":"CHANGELOG-v1/#change-log","text":"See upgrade notes for helpful information when upgrading from previous versions. Important notes : YAML resources will require an apiVersion from PSRule v2. #648 Setting the default module baseline requires a module configuration from PSRule v2. #809 Resource names have naming restrictions introduced from PSRule v2. #1012 Attention PSRule v1 is a prior release. For more information see v2 release notes. Please check out our upgrade notes to get prepared for upgrading to the latest version.","title":"Change log"},{"location":"CHANGELOG-v1/#v1111","text":"What's changed since v1.11.1: Bug fixes: Fixed broken documentation links. #980","title":"v1.11.1"},{"location":"CHANGELOG-v1/#v1110","text":"What's changed since v1.10.0: General improvements: Added version expression to check semantic version constraints. #861 See about_PSRule_Expressions for details. Added hasDefault expression to check field default value. #870 See about_PSRule_Expressions for details. Bug fixes: Fixed GetReason() not returning results for a failed assertion. #874 What's changed since pre-release v1.11.0-B2112016: No additional changes.","title":"v1.11.0"},{"location":"CHANGELOG-v1/#v1110-b2112016-pre-release","text":"What's changed since v1.10.0: General improvements: Added version expression to check semantic version constraints. #861 See about_PSRule_Expressions for details. Added hasDefault expression to check field default value. #870 See about_PSRule_Expressions for details. Bug fixes: Fixed GetReason() not returning results for a failed assertion. #874","title":"v1.11.0-B2112016 (pre-release)"},{"location":"CHANGELOG-v1/#v1100","text":"What's changed since v1.9.0: General improvements: Added JSON support for reading rules and selectors from pipeline. #857 Added HasSchema expression to check the schema of an object. #860 See about_PSRule_Expressions for details. Engineering: Bump Microsoft.SourceLink.GitHub to 1.1.1. #856 Bug fixes: Fixed $Assert.HasJsonSchema accepts empty value. #859 Fixed module configuration is not loaded when case does not match. #864 What's changed since pre-release v1.10.0-B2112002: No additional changes.","title":"v1.10.0"},{"location":"CHANGELOG-v1/#v1100-b2112002-pre-release","text":"What's changed since pre-release v1.10.0-B2111024: Bug fixes: Fixed module configuration is not loaded when case does not match. #864","title":"v1.10.0-B2112002 (pre-release)"},{"location":"CHANGELOG-v1/#v1100-b2111024-pre-release","text":"What's changed since v1.9.0: General improvements: Added JSON support for reading rules and selectors from pipeline. #857 Added HasSchema expression to check the schema of an object. #860 See about_PSRule_Expressions for details. Engineering: Bump Microsoft.SourceLink.GitHub to 1.1.1. #856 Bug fixes: Fixed $Assert.HasJsonSchema accepts empty value. #859","title":"v1.10.0-B2111024 (pre-release)"},{"location":"CHANGELOG-v1/#v190","text":"What's changed since v1.8.0: General improvements: Added improvements to YAML output for Get-PSRuleBaseline . #829 Added -Initialize convention block. #826 Use this block to perform any initialization that is required before any rules are run. This block is only run once instead of -Begin which is run once per object. See about_PSRule_Conventions for details. Allow lifetime services to be used. #827 Use $PSRule.AddService and $PSRule.GetService to add a service. Services allows a singleton instance to be used and shared across multiple rules. PSRule will automatically dispose the service when all rules have run. See about_PSRule_Variables for details. Added Export-PSRuleBaseline cmdlet to export baseline. #622 Added JSON output format for Baseline cmdlets. #839 Allow downstream issues to be consumed. #843 Objects can be flagged with issues that have been generated externally. See about_PSRule_Assert for details. Migrated default baseline to module configuration. #809 This enables configuration of the default baseline for a module with a module configuration. This depreciate configuring the default baseline within the module manifest. Modules using manifest configuration will start warning from v1.9.0. See about_PSRule_Options for details. Added JSON support to read baselines from pipeline. #845 Engineering: Bump System.Drawing.Common dependency to v6.0.0. #848 Bug fixes: Fixed convention execution is out of order. #835 What's changed since pre-release v1.9.0-B2111024: Engineering: Bump Microsoft.CodeAnalysis.NetAnalyzers to v6.0.0. #851","title":"v1.9.0"},{"location":"CHANGELOG-v1/#v190-b2111024-pre-release","text":"What's changed since pre-release v1.9.0-B2111009: General improvements: Allow downstream issues to be consumed. #843 Objects can be flagged with issues that have been generated externally. See about_PSRule_Assert for details. Migrated default baseline to module configuration. #809 This enables configuration of the default baseline for a module with a module configuration. This depreciate configuring the default baseline within the module manifest. Modules using manifest configuration will start warning from v1.9.0. See about_PSRule_Options for details. Added JSON support to read baselines from pipeline. #845 Engineering: Bump System.Drawing.Common dependency to v6.0.0. #848","title":"v1.9.0-B2111024 (pre-release)"},{"location":"CHANGELOG-v1/#v190-b2111009-pre-release","text":"What's changed since pre-release v1.9.0-B2110027: General improvements: Added JSON output format for Baseline cmdlets. #839 Bug fixes: Fixed convention execution is out of order. #835","title":"v1.9.0-B2111009 (pre-release)"},{"location":"CHANGELOG-v1/#v190-b2110027-pre-release","text":"What's changed since pre-release v1.9.0-B2110015: General improvements: Added Export-PSRuleBaseline cmdlet to export baseline. #622","title":"v1.9.0-B2110027 (pre-release)"},{"location":"CHANGELOG-v1/#v190-b2110015-pre-release","text":"What's changed since v1.8.0: General improvements: Added improvements to YAML output for Get-PSRuleBaseline . #829 Added -Initialize convention block. #826 Use this block to perform any initialization that is required before any rules are run. This block is only run once instead of -Begin which is run once per object. See about_PSRule_Conventions for details. Allow lifetime services to be used. #827 Use $PSRule.AddService and $PSRule.GetService to add a service. Services allows a singleton instance to be used and shared across multiple rules. PSRule will automatically dispose the service when all rules have run. See about_PSRule_Variables for details.","title":"v1.9.0-B2110015 (pre-release)"},{"location":"CHANGELOG-v1/#v180","text":"What's changed since v1.7.2: General improvements: Added YAML output format support for Get-PSRuleBaseline . #326 Added YAML/JSON output format support for Get-PSRule . #128 Added Output.JsonIndent option for JSON output format. #817 Added assertion helpers and expressions for improving intersection checks. #795 Added Count to determine of the field has a specific number of elements. Added SetOf to determine if a collection is another collection. Added Subset to determine if a collection is includes another collection. See about_PSRule_Assert and about_PSRule_Expressions for details. Added support for conditional reason messages with ReasonIf . #804 See about_PSRule_Assert for details. Added support for type and name expression properties. #810 Use type to compare the bound type of the current object. Use name to compare the bound name of the current object. See about_PSRule_Expressions for details. Engineering: Migration of Pester v4 tests to Pester v5. #478 What's changed since pre-release v1.8.0-B2110030: No additional changes.","title":"v1.8.0"},{"location":"CHANGELOG-v1/#v180-b2110030-pre-release","text":"What's changed since pre-release v1.8.0-B2110020: General improvements: Added Output.JsonIndent option for JSON output format. #817","title":"v1.8.0-B2110030 (pre-release)"},{"location":"CHANGELOG-v1/#v180-b2110020-pre-release","text":"What's changed since pre-release v1.8.0-B2110006: General improvements: Added YAML/JSON output format support for Get-PSRule . #128 Engineering: Migration of Pester v4 tests to Pester v5. #478","title":"v1.8.0-B2110020 (pre-release)"},{"location":"CHANGELOG-v1/#v180-b2110006-pre-release","text":"What's changed since pre-release v1.8.0-B2109022: General improvements: Added YAML output format support for Get-PSRuleBaseline . #326","title":"v1.8.0-B2110006 (pre-release)"},{"location":"CHANGELOG-v1/#v180-b2109022-pre-release","text":"What's changed since pre-release v1.8.0-B2109015: General improvements: Added support for conditional reason messages with ReasonIf . #804 See about_PSRule_Assert for details. Added support for type and name expression properties. #810 Use type to compare the bound type of the current object. Use name to compare the bound name of the current object. See about_PSRule_Expressions for details.","title":"v1.8.0-B2109022 (pre-release)"},{"location":"CHANGELOG-v1/#v180-b2109015-pre-release","text":"What's changed since v1.7.2: General improvements: Added assertion helpers and expressions for improving intersection checks. #795 Added Count to determine of the field has a specific number of elements. Added SetOf to determine if a collection is another collection. Added Subset to determine if a collection is includes another collection. See about_PSRule_Assert and about_PSRule_Expressions for details.","title":"v1.8.0-B2109015 (pre-release)"},{"location":"CHANGELOG-v1/#v172","text":"What's changed since v1.7.1: Bug fixes: Fixed Get-PSRuleBaseline does not return any results from module. #801","title":"v1.7.2"},{"location":"CHANGELOG-v1/#v171","text":"What's changed since v1.7.0: Bug fixes: Fixed ResourceTags does not contain a method named ToHashtable. #798","title":"v1.7.1"},{"location":"CHANGELOG-v1/#v170","text":"What's changed since v1.6.0: Engine features: Added support for generating badges from rule results. #623 Standard or custom badges can be generated using a convention and the badge API. See about_PSRule_Badges for details. General improvements: Rule results now include a run ID or each run. #774 Run ID is returned in Assert-PSRule output at the end of each run by default. By default a unique runId is generated when the rule is run. The Output.Footer option was added to configure the output footer. See about_PSRule_Options for details. Automatically exclude common repository files from input files. #721 Added Input.IgnoreRepositoryCommon option to change default behavior. See about_PSRule_Options for details. Added aggregation assertion methods for AnyOf and AllOf . #776 See about_PSRule_Assert for details. Allow baselines to include local rules. #756 The Rule.IncludeLocal option was automatically include local/ standalone rules not in a module. This option is useful when you want to include local rules not included in a baseline. See about_PSRule_Options for details. Bug fixes: Fixed configuration array deserializes as dictionary from YAML options. #779 What's changed since pre-release v1.7.0-B2109002: No additional changes.","title":"v1.7.0"},{"location":"CHANGELOG-v1/#v170-b2109002-pre-release","text":"What's changed since pre-release v1.7.0-B2108032: General improvements: Allow baselines to include local rules. #756 The Rule.IncludeLocal option was automatically include local/ standalone rules not in a module. This option is useful when you want to include local rules not included in a baseline. See about_PSRule_Options for details.","title":"v1.7.0-B2109002 (pre-release)"},{"location":"CHANGELOG-v1/#v170-b2108032-pre-release","text":"What's changed since pre-release v1.7.0-B2108021: Engine features: Added support for generating badges from rule results. #623 Standard or custom badges can be generated using a convention and the badge API. See about_PSRule_Badges for details. General improvements: Rule results now include a run ID or each run. #774 Run ID is returned in Assert-PSRule output at the end of each run by default. By default a unique runId is generated when the rule is run. The Output.Footer option was added to configure the output footer. See about_PSRule_Options for details.","title":"v1.7.0-B2108032 (pre-release)"},{"location":"CHANGELOG-v1/#v170-b2108021-pre-release","text":"What's changed since pre-release v1.7.0-B2108016: Bug fixes: Fixed configuration array deserializes as dictionary from YAML options. #779","title":"v1.7.0-B2108021 (pre-release)"},{"location":"CHANGELOG-v1/#v170-b2108016-pre-release","text":"What's changed since v1.6.0: General improvements: Automatically exclude common repository files from input files. #721 Added Input.IgnoreRepositoryCommon option to change default behavior. See about_PSRule_Options for details. Added aggregation assertion methods for AnyOf and AllOf . #776 See about_PSRule_Assert for details.","title":"v1.7.0-B2108016 (pre-release)"},{"location":"CHANGELOG-v1/#v161","text":"What's changed since v1.6.0: Bug fixes: Fixed configuration array deserializes as dictionary from YAML options. #779","title":"v1.6.1"},{"location":"CHANGELOG-v1/#v160","text":"What's changed since v1.5.0: Engine features: Added support for YAML rules. #603 YAML rules evaluate an expression tree and return a result for each object. YAML provides an additional option for defining rules in addition to PowerShell script rules. Type and selector pre-conditions are supported. See about_PSRule_Rules for details. General improvements: Added support for object source location in validation. #757 Default rule source location .ps-rule/ is automatically included. #742 Added Include.Path and Include.Module options to automatically include rule sources. See about_PSRule_Options for details. Bug fixes: Fixed target binding across multiple scopes. #762 What's changed since pre-release v1.6.0-B2108009: No additional changes.","title":"v1.6.0"},{"location":"CHANGELOG-v1/#v160-b2108009-pre-release","text":"What's changed since pre-release v1.6.0-B2108003: Engine features: Added support for YAML rules. #603 YAML rules evaluate an expression tree and return a result for each object. YAML provides an additional option for defining rules in addition to PowerShell script rules. Type and selector pre-conditions are supported. See about_PSRule_Rules for details.","title":"v1.6.0-B2108009 (pre-release)"},{"location":"CHANGELOG-v1/#v160-b2108003-pre-release","text":"What's changed since pre-release v1.6.0-B2107008: Bug fixes: Fixed target binding across multiple scopes. #762","title":"v1.6.0-B2108003 (pre-release)"},{"location":"CHANGELOG-v1/#v160-b2107008-pre-release","text":"What's changed since v1.5.0: General improvements: Added support for object source location in validation. #757 Default rule source location .ps-rule/ is automatically included. #742 Added Include.Path and Include.Module options to automatically include rule sources. See about_PSRule_Options for details.","title":"v1.6.0-B2107008 (pre-release)"},{"location":"CHANGELOG-v1/#v150","text":"What's changed since v1.4.0: General improvements: Added string selector conditions. #747 Use startWith , contains , and endsWith to check for a sub-string. Use isString , isLower , and isUpper to check for string type and casing. See about_PSRule_Selectors for details. Engineering: Bump YamlDotNet dependency to 11.2.1. #740 Bug fixes: Fixed options schema should allow spacing after @pre . #743 Fixed match selector expression passing on missing field. #745 What's changed since pre-release v1.5.0-B2107009: No additional changes.","title":"v1.5.0"},{"location":"CHANGELOG-v1/#v150-b2107009-pre-release","text":"What's changed since pre-release v1.5.0-B2106006: General improvements: Added string selector conditions. #747 Use startWith , contains , and endsWith to check for a sub-string. Use isString , isLower , and isUpper to check for string type and casing. See about_PSRule_Selectors for details. Engineering: Bump YamlDotNet dependency to 11.2.1. #740 Bug fixes: Fixed options schema should allow spacing after @pre . #743 Fixed match selector expression passing on missing field. #745","title":"v1.5.0-B2107009 (pre-release)"},{"location":"CHANGELOG-v1/#v150-b2106006-pre-release","text":"What's changed since v1.4.0: Engineering: Bump YamlDotNet dependency to 11.2.0. #736","title":"v1.5.0-B2106006 (pre-release)"},{"location":"CHANGELOG-v1/#v140","text":"What's changed since v1.3.0: General improvements: PSRule banner can be configured in output when using Assert-PSRule . #708 Input source location of objects are included in results. Input source location of objects from JSON and YAML input files are read automatically. #624 Input source location of objects from the pipeline are read from properties. #729 Assert output improvements: Added support for Visual Studio Code with VisualStudioCode style. #731 Updated output format provides support for problem matchers in task output. Automatically detect output style from environment variables. #732 Assert-PSRule now defaults to Detect instead of Client . See about_PSRule_Options for details. Improved support for version constraints by: Constraints can include prerelease versions of other matching versions. #714 Constraints support using a @prerelease or @pre to include prerelease versions. #717 Constraint sets allow multiple constraints to be joined together. #715 See about_PSRule_Assert for details. Bug fixes: Fixed prerelease constraint handling for prerelease versions. #712 Fixed null reference in convention for nested exceptions. #725 What's changed since pre-release v1.4.0-B2105041: No additional changes.","title":"v1.4.0"},{"location":"CHANGELOG-v1/#v140-b2105041-pre-release","text":"What's changed since pre-release v1.4.0-B2105032: General improvements: Source location of objects from the pipeline are read from properties. #729 Assert output improvements: Added support for Visual Studio Code with VisualStudioCode style. #731 Updated output format provides support for problem matchers in task output. Automatically detect output style from environment variables. #732 Assert-PSRule now defaults to Detect instead of Client . See about_PSRule_Options for details.","title":"v1.4.0-B2105041 (pre-release)"},{"location":"CHANGELOG-v1/#v140-b2105032-pre-release","text":"What's changed since pre-release v1.4.0-B2105019: Bug fixes: Fixed null reference in convention for nested exceptions. #725","title":"v1.4.0-B2105032 (pre-release)"},{"location":"CHANGELOG-v1/#v140-b2105019-pre-release","text":"What's changed since pre-release v1.4.0-B2105004: General improvements: Source location of objects are included in results. Source location of objects from JSON and YAML input files are read automatically. #624 Improved support for version constraints by: Constraints can include prerelease versions of other matching versions. #714 Constraints support using a @prerelease or @pre to include prerelease versions. #717 Constraint sets allow multiple constraints to be joined together. #715 See about_PSRule_Assert for details. Bug fixes: Fixed prerelease constraint handling for prerelease versions. #712","title":"v1.4.0-B2105019 (pre-release)"},{"location":"CHANGELOG-v1/#v140-b2105004-pre-release","text":"What's changed since v1.3.0: General improvements: PSRule banner can be configured in output when using Assert-PSRule . #708","title":"v1.4.0-B2105004 (pre-release)"},{"location":"CHANGELOG-v1/#v130","text":"What's changed since v1.2.0: Engine features: Options can be configured with environment variables. #691 See about_PSRule_Options for details. General improvements: Exclude .git sub-directory by default for recursive scans. #697 Added Input.IgnoreGitPath option to configure inclusion of .git path. See about_PSRule_Options for details. Added file path assertion helpers. #679 Added WithinPath to check the file path field is within a specified path. Added NotWithinPath to check the file path field is not within a specified path See about_PSRule_Assert for details. Added DateTime type assertion helper. #680 Added IsDateTime to check of object field is [DateTime] . See about_PSRule_Assert for details. Improved numeric comparison assertion helpers to compare [DateTime] fields. #685 Less , LessOrEqual , Greater , and GreaterOrEqual compare the number of days from the current time. See about_PSRule_Assert for details. Improved handling of field names for objects implementing IList , IEnumerable , and index properties. #692 Engineering: Bump YamlDotNet dependency to 11.1.1. #690 Bug fixes: Fixed expected DocumentEnd got SequenceEnd. #698 What's changed since pre-release v1.3.0-B2105004: No additional changes.","title":"v1.3.0"},{"location":"CHANGELOG-v1/#v130-b2105004-pre-release","text":"What's changed since pre-release v1.3.0-B2104042: Engine features: Options can be configured with environment variables. #691 See about_PSRule_Options for details. General improvements: Exclude .git sub-directory by default for recursive scans. #697 Added Input.IgnoreGitPath option to configure inclusion of .git path. See about_PSRule_Options for details.","title":"v1.3.0-B2105004 (pre-release)"},{"location":"CHANGELOG-v1/#v130-b2104042-pre-release","text":"What's changed since pre-release v1.3.0-B2104030: Bug fixes: Fixed expected DocumentEnd got SequenceEnd. #698","title":"v1.3.0-B2104042 (pre-release)"},{"location":"CHANGELOG-v1/#v130-b2104030-pre-release","text":"What's changed since pre-release v1.3.0-B2104021: General improvements: Improved handling of field names for objects implementing IList , IEnumerable , and index properties. #692 Engineering: Bump YamlDotNet dependency to 11.1.1. #690","title":"v1.3.0-B2104030 (pre-release)"},{"location":"CHANGELOG-v1/#v130-b2104021-pre-release","text":"What's changed since v1.2.0: General improvements: Added file path assertion helpers. #679 Added WithinPath to check the file path field is within a specified path. Added NotWithinPath to check the file path field is not within a specified path See about_PSRule_Assert for details. Added DateTime type assertion helper. #680 Added IsDateTime to check of object field is [DateTime] . See about_PSRule_Assert for details. Improved numeric comparison assertion helpers to compare [DateTime] fields. #685 Less , LessOrEqual , Greater , and GreaterOrEqual compare the number of days from the current time. See about_PSRule_Assert for details.","title":"v1.3.0-B2104021 (pre-release)"},{"location":"CHANGELOG-v1/#v120","text":"What's changed since v1.1.0: Engine features: Added support for extensibility with conventions. #650 Conventions provide an extensibility point within PSRule to execute actions within the pipeline. A convention can expose Begin , Process , and End blocks. In additional to within rules $PSRule.Data can be accessed from Begin and Process blocks. See about_PSRule_Conventions for details. Added support for object expansion with conventions. #661 Use the $PSRule.Import method to import child source objects into the pipeline. See about_PSRule_Variables for details. Added support for complex pre-conditions with selectors. #649 See about_PSRule_Selectors for details. General improvements: Added support for preferring automatic binding over custom binding configurations. #670 Added the Binding.PreferTargetInfo option to prefer target info specified by the object. See about_PSRule_Options for details. Added strong apiVersion to resource types. #647 Resource schemas now support an apiVersion field. The apiVersion field is optional but recommended. Resources without a apiVersion field will not be supported from PSRule v2. Added warning to flag baseline without apiVersion set. Added support for detecting files headers from additional file extensions using FileHeader . #664 Added .bicep , .csx , .jsx , .groovy , .java , .json , .jsonc , .scala , .rb , .bat , .cmd . Added support for Jenkinsfile and Dockerfile without an extension. See about_PSRule_Assert for details. Added support for automatic type binding with files that do not have a file extension. #665 Bug fixes: Fixed dependent rule execution is skipped for consequent input objects. #657 What's changed since pre-release v1.2.0-B2103043: No additional changes.","title":"v1.2.0"},{"location":"CHANGELOG-v1/#v120-b2103043-pre-release","text":"What's changed since pre-release v1.2.0-B2103031: Engine features: Added support for complex pre-conditions with selectors. #649 General improvements: Added support for preferring automatic binding over custom binding configurations. #670 Added the Binding.PreferTargetInfo option to prefer target info specified by the object. See about_PSRule_Options for details. Added strong apiVersion to resource types. #647 Resource schemas now support an apiVersion field. The apiVersion field is optional but recommended. Resources without a apiVersion field will not be supported from PSRule v2. Added warning to flag baseline without apiVersion set.","title":"v1.2.0-B2103043 (pre-release)"},{"location":"CHANGELOG-v1/#v120-b2103031-pre-release","text":"What's changed since pre-release v1.2.0-B2103023: General improvements: Added support for detecting files headers from additional file extensions. #664 Added .bicep , .csx , .jsx , .groovy , .java , .json , .jsonc , .scala , .rb , .bat , .cmd . Added support for Jenkinsfile and Dockerfile without an extension. See about_PSRule_Assert for details. Added support for automatic type binding with files that do not have a file extension. #665","title":"v1.2.0-B2103031 (pre-release)"},{"location":"CHANGELOG-v1/#v120-b2103023-pre-release","text":"What's changed since pre-release v1.2.0-B2103016: Engine features: Added support for object expansion with conventions. #661 Use the $PSRule.Import method to import child source objects into the pipeline. See about_PSRule_Variables for details.","title":"v1.2.0-B2103023 (pre-release)"},{"location":"CHANGELOG-v1/#v120-b2103016-pre-release","text":"What's changed since pre-release v1.2.0-B2103008: Bug fixes: Fixed dependent rule execution is skipped for consequent input objects. #657","title":"v1.2.0-B2103016 (pre-release)"},{"location":"CHANGELOG-v1/#v120-b2103008-pre-release","text":"What's changed since v1.1.0: Engine features: Added support for extensibility with conventions. #650 Conventions provide an extensibility point within PSRule to execute actions within the pipeline. A convention can expose Begin , Process , and End blocks. In additional to within rules $PSRule.Data can be accessed from Begin and Process blocks. See about_PSRule_Conventions for details.","title":"v1.2.0-B2103008 (pre-release)"},{"location":"CHANGELOG-v1/#v110","text":"What's changed since v1.0.3: Engine features: Added assertion helpers. #640 Added NotHasField to check object does not have any of the specified fields. Added Null to check field value is null. Added NotNull to check field value is not null. See about_PSRule_Assert for details. Added type assertion helpers. #635 Added IsNumeric to check field value is a numeric types. Added IsInteger to check field value is an integer types. Added IsBoolean to check field value is a boolean. Added IsArray to check field value is an array. Added IsString to check field value is a string. Added TypeOf to check field value is a specified type. See about_PSRule_Assert for details. Added content helpers. #637 Added $PSRule.GetContentFirstOrDefault to get content and return the first object. Added $PSRule.GetContentField to get the field from content objects. See about_PSRule_Variables for details. General improvements: Updated HasJsonSchema assertion helper. #636 The URI scheme can optionally be ignored for http:// or https:// URIs. The fragment # is ignored. See about_PSRule_Assert for details. Added support for -Outcome and -As to produce filtered output from Assert-PSRule . #643 Configure Output.As with Summary to produce summarized results per object. Configure Output.Outcome to limit output to Fail or Error . See Assert-PSRule for details. What's changed since pre-release v1.1.0-B2102029: No additional changes.","title":"v1.1.0"},{"location":"CHANGELOG-v1/#v110-b2102029-pre-release","text":"What's changed since pre-release v1.1.0-B2102024: General improvements: Added support for -Outcome and -As to produce filtered output from Assert-PSRule . #643 Configure Output.As with Summary to produce summarized results per object. Configure Output.Outcome to limit output to Fail or Error . See Assert-PSRule for details.","title":"v1.1.0-B2102029 (pre-release)"},{"location":"CHANGELOG-v1/#v110-b2102024-pre-release","text":"What's changed since pre-release v1.1.0-B2102019: Engine features: Added assertion helpers. #640 Added NotHasField to check object does not have any of the specified fields. Added Null to check field value is null. Added NotNull to check field value is not null. See about_PSRule_Assert for details.","title":"v1.1.0-B2102024 (pre-release)"},{"location":"CHANGELOG-v1/#v110-b2102019-pre-release","text":"What's changed since v1.0.3: Engine features: Added type assertion helpers. #635 Added IsNumeric to check field value is a numeric types. Added IsInteger to check field value is an integer types. Added IsBoolean to check field value is a boolean. Added IsArray to check field value is an array. Added IsString to check field value is a string. Added TypeOf to check field value is a specified type. See about_PSRule_Assert for details. Added content helpers. #637 Added $PSRule.GetContentFirstOrDefault to get content and return the first object. Added $PSRule.GetContentField to get the field from content objects. See about_PSRule_Variables for details. General improvements: Updated HasJsonSchema assertion helper. #636 The URI scheme can optionally be ignored for http:// or https:// URIs. The fragment # is ignored. See about_PSRule_Assert for details.","title":"v1.1.0-B2102019 (pre-release)"},{"location":"CHANGELOG-v1/#v103","text":"What's changed since v1.0.2: Bug fixes: Fixed reason reported fields for HasField and HasFields assertion helpers. #632","title":"v1.0.3"},{"location":"CHANGELOG-v1/#v102","text":"What's changed since v1.0.1: Engineering: Bump Manatee.Json dependency to 13.0.5. #619 Bug fixes: Fixed GetContent processing of InputFileInfo . #625 Fixed null reference of rule reason with wide output. #626 Fixed markdown help handling of inline code blocks with [ . #627 Fixed markdown help inclusion of fenced code blocks in notes and description. #628","title":"v1.0.2"},{"location":"CHANGELOG-v1/#v101","text":"What's changed since v1.0.0: Bug fixes: Fixed module source key has already been added. #608","title":"v1.0.1"},{"location":"CHANGELOG-v1/#v100","text":"What's changed since v0.22.0: General improvements: Added rule help link in failed Assert-PSRule output. #595 Engineering: Breaking change : Removed deprecated $Rule properties. #495 Bump Manatee.Json dependency to 13.0.4. #591 What's changed since pre-release v1.0.0-B2011028: No additional changes.","title":"v1.0.0"},{"location":"CHANGELOG-v1/#v100-b2011028-pre-release","text":"What's changed since v0.22.0: General improvements: Added rule help link in failed Assert-PSRule output. #595 Engineering: Breaking change : Removed deprecated $Rule properties. #495 Bump Manatee.Json dependency to 13.0.4. #591","title":"v1.0.0-B2011028 (pre-release)"},{"location":"CHANGELOG-v2/","text":"Change log # See upgrade notes for helpful information when upgrading from previous versions. Important notes : Several properties of rule and language block elements will be removed from v3. See deprecations for details. Experimental features : Functions within YAML and JSON expressions can be used to perform manipulation prior to testing a condition. See functions for more information. Sub-selectors within YAML and JSON expressions can be used to filter rules and list properties. See sub-selectors for more information. Processing of changes files only within a pipeline. See creating your pipeline for more information. Unreleased # v2.7.0-B0006 (pre-release) # What's changed since pre-release v2.7.0-B0001: General improvements: Added support target scope by @BernieWhite. #1350 Bug fixes: Fixed exception with comments in JSON baselines by @BernieWhite. #1336 v2.7.0-B0001 (pre-release) # What's changed since v2.6.0: Bug fixes: Fixed exception calling RuleSource value cannot be null by @BernieWhite. #1343 v2.6.0 # What's changed since v2.5.3: New features: Added support for generating job summaries by @BernieWhite. #1264 Job summaries provide a markdown output for pipelines in addition to other supported output formats. To use, configure the Output.JobSummaryPath option. Added support for time bound suppression groups by @BernieWhite. #1335 Suppression groups can be configured to expire after a specified time by setting the spec.expiresOn property. When a suppression group expires, the suppression group will generate a warning by default. Configure the Execution.SuppressionGroupExpired option to ignore or error on expired suppression groups. Engineering: Bump Microsoft.NET.Test.Sdk to v17.4.0. #1331 Bump PSScriptAnalyzer to v1.21.0. #1318 Class clean up and documentation by @BernieWhite. #1186 What's changed since pre-release v2.6.0-B0034: No additional changes. v2.6.0-B0034 (pre-release) # What's changed since pre-release v2.6.0-B0013: New features: Added support for generating job summaries by @BernieWhite. #1264 Job summaries provide a markdown output for pipelines in addition to other supported output formats. To use, configure the Output.JobSummaryPath option. Added support for time bound suppression groups by @BernieWhite. #1335 Suppression groups can be configured to expire after a specified time by setting the spec.expiresOn property. When a suppression group expires, the suppression group will generate a warning by default. Configure the Execution.SuppressionGroupExpired option to ignore or error on expired suppression groups. Engineering: Bump Microsoft.NET.Test.Sdk to v17.4.0. #1331 v2.6.0-B0013 (pre-release) # What's changed since v2.5.3: Engineering: Bump Microsoft.NET.Test.Sdk to v17.3.2. #1283 Bump PSScriptAnalyzer to v1.21.0. #1318 Class clean up and documentation by @BernieWhite. #1186 v2.5.3 # What's changed since v2.5.2: Bug fixes: Fixed incorrect XML header for encoding by @BernieWhite. #1322 v2.5.2 # What's changed since v2.5.1: Bug fixes: Fixed NUnit output does not escape characters in all result properties by @BernieWhite. #1316 v2.5.1 # What's changed since v2.5.0: Bug fixes: Fixed In with array source object and dot object path by @BernieWhite. #1314 v2.5.0 # What's changed since v2.4.2: New features: Experimental : Added support for only processing changed files by @BernieWhite. #688 To ignore unchanged files, set the Input.IgnoreUnchangedPath option to true . See creating your pipeline for more information. General improvements: Added labels metadata from grouping and filtering rules by @BernieWhite. #1272 Labels are metadata that extends on tags to provide a more structured way to group rules. Rules can be classified by setting the metadata.labels property or -Labels parameter. Provide unblock for command line tools by @BernieWhite. #1261 Engineering: Bump Microsoft.NET.Test.Sdk to v17.3.1. #1248 Bug fixes: Fixed could not load Microsoft.Management.Infrastructure by @BernieWhite. #1249 To use minimal initial session state set Execution.InitialSessionState to Minimal . Fixed unhandled exception with GetRootedPath by @BernieWhite. #1251 Fixed Dockerfile case sensitivity by @BernieWhite. #1269 What's changed since pre-release v2.5.0-B0080: No additional changes. v2.5.0-B0080 (pre-release) # What's changed since pre-release v2.5.0-B0045: Bug fixes: Fixed exception with PathExpressionBuilder.GetAllRecurse by @BernieWhite. #1301 v2.5.0-B0045 (pre-release) # What's changed since pre-release v2.5.0-B0015: New features: Experimental : Added support for only processing changed files by @BernieWhite. #688 To ignore unchanged files, set the Input.IgnoreUnchangedPath option to true . See creating your pipeline for more information. General improvements: Added labels metadata from grouping and filtering rules by @BernieWhite. #1272 Labels are metadata that extends on tags to provide a more structured way to group rules. Rules can be classified by setting the metadata.labels property or -Labels parameter. Bug fixes: Fixed Dockerfile case sensitivity by @BernieWhite. #1269 Fixed markdown parsing of Spanish translated help fails by @BernieWhite @jonathanruiz. #1286 #1285 v2.5.0-B0015 (pre-release) # What's changed since pre-release v2.5.0-B0004: General improvements: Provide unblock for command line tools by @BernieWhite. #1261 v2.5.0-B0004 (pre-release) # What's changed since v2.4.0: Engineering: Bump Microsoft.NET.Test.Sdk to v17.3.1. #1248 Bug fixes: Fixed could not load Microsoft.Management.Infrastructure by @BernieWhite. #1249 To use minimal initial session state set Execution.InitialSessionState to Minimal . Fixed unhandled exception with GetRootedPath by @BernieWhite. #1251 v2.4.2 # What's changed since v2.4.1: Bug fixes: Fixed exception with PathExpressionBuilder.GetAllRecurse by @BernieWhite. #1301 v2.4.1 # What's changed since v2.4.0: Bug fixes: Fixed markdown parsing of Spanish translated help fails by @BernieWhite @jonathanruiz. #1286 #1285 v2.4.0 # What's changed since v2.3.2: New features: Experimental : Added support for functions within YAML and JSON expressions by @BernieWhite. #1227 #1016 Added conversion functions boolean , string , and integer . Added lookup functions configuration , and path . Added string functions concat , substring . See functions for more information. Experimental : Added support for sub-selector YAML and JSON expressions by @BernieWhite. #1024 #1045 Sub-selector pre-conditions add an additional expression to determine if a rule is executed. Sub-selector object filters provide an way to filter items from list properties. See sub-selectors for more information. Engineering: Improvements to PSRule engine API documentation by @BernieWhite. #1186 Updates to PSRule engine API by @BernieWhite. #1152 Added tool support for baselines parameter. Added module path discovery. Added output for verbose and debug messages. Bump support projects to .NET 6 by @BernieWhite. #1209 Bump Microsoft.NET.Test.Sdk to v17.3.0. #1213 Bump BenchmarkDotNet to v0.13.2. #1241 Bump BenchmarkDotNet.Diagnostics.Windows to v0.13.2. #1242 Bug fixes: Fixed reporting of duplicate identifiers which were not generating an error for all cases by @BernieWhite. #1229 Added Execution.DuplicateResourceId option to configure PSRule behaviour. By default, duplicate resource identifiers return an error. Fixed exception on JSON baseline without a synopsis by @BernieWhite. #1230 Fixed repository information not in output by @BernieWhite. #1219 What's changed since pre-release v2.4.0-B0091: No additional changes. v2.4.0-B0091 (pre-release) # What's changed since pre-release v2.4.0-B0063: Engineering: Bump BenchmarkDotNet to v0.13.2. #1241 Bump BenchmarkDotNet.Diagnostics.Windows to v0.13.2. #1242 v2.4.0-B0063 (pre-release) # What's changed since pre-release v2.4.0-B0039: New features: Experimental : Added support for sub-selector YAML and JSON expressions by @BernieWhite. #1024 #1045 Sub-selector pre-conditions add an additional expression to determine if a rule is executed. Sub-selector object filters provide an way to filter items from list properties. See sub-selectors for more information. Engineering: Improvements to PSRule engine API documentation by @BernieWhite. #1186 v2.4.0-B0039 (pre-release) # What's changed since pre-release v2.4.0-B0022: New features: Experimental : Added support for functions within YAML and JSON expressions by @BernieWhite. #1227 #1016 Added conversion functions boolean , string , and integer . Added lookup functions configuration , and path . Added string functions concat , substring . See functions for more information. Bug fixes: Fixed reporting of duplicate identifiers which were not generating an error for all cases by @BernieWhite. #1229 Added Execution.DuplicateResourceId option to configure PSRule behaviour. By default, duplicate resource identifiers return an error. Fixed exception on JSON baseline without a synopsis by @BernieWhite. #1230 v2.4.0-B0022 (pre-release) # What's changed since pre-release v2.4.0-B0009: Engineering: Updates to PSRule engine API by @BernieWhite. #1152 Added tool support for baselines parameter. Added module path discovery. Added output for verbose and debug messages. v2.4.0-B0009 (pre-release) # What's changed since v2.3.2: Engineering: Bump support projects to .NET 6 by @BernieWhite. #1209 Bump Microsoft.NET.Test.Sdk to v17.3.0. #1213 Bug fixes: Fixed repository information not in output by @BernieWhite. #1219 v2.3.2 # What's changed since v2.3.1: Bug fixes: Fixes lost scope for rules by @BernieWhite. #1214 v2.3.1 # What's changed since v2.3.0: Bug fixes: Fixed object path join handling of self path identifier by @BernieWhite. #1204 v2.3.0 # What's changed since v2.2.0: General improvements: Added PathPrefix method to add an object path prefix to assertion reasons by @BernieWhite. #1198 Added support for binding with JSON objects by @BernieWhite. #1182 Added support for full path from JSON objects by @BernieWhite. #1174 Improved reporting of full object path from pre-processed results by @BernieWhite. #1169 Added PSRule for Azure expansion configuration to options schema by @BernieWhite. #1149 Engineering: Bump xunit to v2.4.2. #1200 Expose online link extension method by @BernieWhite. #1195 Added comment documentation to .NET classes and interfaces by @BernieWhite. #1186 Added publishing support for NuGet symbol packages @BernieWhite. #1173 Updated outcome option docs by @BernieWhite. #1166 Bump Sarif.Sdk to v2.4.16. #1177 Refactoring and updates to interfaces to allow use outside of PowerShell by @BernieWhite. #1152 Bug fixes: Fixes JSON parsing of string array for single objects by @BernieWhite. #1193 Fixed handling for JSON objects in rules by @BernieWhite. #1187 Fixed null object reference for object equity comparison by @BernieWhite. #1157 Fixed expression evaluation not logging debug output when using the -Debug switch by @BernieWhite. #1158 Fixed startIndex cannot be larger than length of string by @BernieWhite. #1160 Fixed path within SDK package causes psd1 to compile by @BernieWhite. #1146 What's changed since pre-release v2.3.0-B0163: No additional changes. v2.3.0-B0163 (pre-release) # What's changed since pre-release v2.3.0-B0130: General improvements: Added PathPrefix method to add an object path prefix to assertion reasons by @BernieWhite. #1198 Engineering: Bump xunit to v2.4.2. #1200 v2.3.0-B0130 (pre-release) # What's changed since pre-release v2.3.0-B0100: Engineering: Expose online link extension method by @BernieWhite. #1195 Bug fixes: Fixes JSON parsing of string array for single objects by @BernieWhite. #1193 v2.3.0-B0100 (pre-release) # What's changed since pre-release v2.3.0-B0074: Engineering: Added comment documentation to .NET classes and interfaces by @BernieWhite. #1186 Bug fixes: Fixed handling for JSON objects in rules by @BernieWhite. #1187 v2.3.0-B0074 (pre-release) # What's changed since pre-release v2.3.0-B0051: General improvements: Added support for binding with JSON objects by @BernieWhite. #1182 v2.3.0-B0051 (pre-release) # What's changed since pre-release v2.3.0-B0030: General improvements: Added support for full path from JSON objects by @BernieWhite. #1174 Engineering: Added publishing support for NuGet symbol packages @BernieWhite. #1173 Updated outcome option docs by @BernieWhite. #1166 Bump Sarif.Sdk to v2.4.16. #1177 v2.3.0-B0030 (pre-release) # What's changed since pre-release v2.3.0-B0015: General improvements: Improved reporting of full object path from pre-processed results by @BernieWhite. #1169 v2.3.0-B0015 (pre-release) # What's changed since pre-release v2.3.0-B0006: Bug fixes: Fixed null object reference for object equity comparison by @BernieWhite. #1157 Fixed expression evaluation not logging debug output when using the -Debug switch by @BernieWhite. #1158 Fixed startIndex cannot be larger than length of string by @BernieWhite. #1160 v2.3.0-B0006 (pre-release) # What's changed since pre-release v2.3.0-B0001: General improvements: Added PSRule for Azure expansion configuration to options schema by @BernieWhite. #1149 Engineering: Refactoring and updates to interfaces to allow use outside of PowerShell by @BernieWhite. #1152 v2.3.0-B0001 (pre-release) # What's changed since v2.2.0: Bug fixes: Fixed path within SDK package causes psd1 to compile by @BernieWhite. #1146 v2.2.0 # What's changed since v2.1.0: New features: Added notCount expression and assertion helper by @ArmaanMcleod. #1091 General improvements: Improved reporting of the object path that caused rule failures by @BernieWhite. #1092 Output include a new Detail property with details of the reason and the object path. Custom methods ReasonFrom and ReasonIf accept a path parameter to specify the object path. Added informational message when output has been written to disk by @BernieWhite. #1074 The Output.Footer option now supports OutputFile which reports the output file path. This is enabled by default. Added descendant selector to object path syntax by @BernieWhite. #1133 Use .. to traverse into child objects, for example $..name finds names for all nested objects. Engineering: Bump Newtonsoft.Json to 13.0.1. #1137 Added more object path tests by @ArmaanMcleod. #1110 Bump xunit.runner.visualstudio to 2.4.5. #1084 Bump Pester to 5.3.3. #1079 Bump Microsoft.NET.Test.Sdk to 17.2.0. #1089 Added NuGet packaging publishing by @BernieWhite. #1093 Updated NuGet packaging metadata by @BernieWhite. #1093 Bug fixes: Fixed output of reason with wide format by @BernieWhite. #1117 Fixed piped input does not respect excluded paths by @BernieWhite. #1114 By default, objects are not excluded by source. To exclude piped input based on source configure the Input.IgnoreObjectSource option. Fixed issue building a PSRule project by removing PSRule.psd1 from compile target by @BernieWhite. #1140 Fixed grouping of logical operators in object path by @BernieWhite. #1101 What's changed since pre-release v2.2.0-B0175: No additional changes. v2.2.0-B0175 (pre-release) # What's changed since pre-release v2.2.0-B0131: Bug fixes: Fixed issue building a PSRule project by removing PSRule.psd1 from compile target by @BernieWhite. #1140 v2.2.0-B0131 (pre-release) # What's changed since pre-release v2.2.0-B0089: General improvements: Added descendant selector to object path syntax by @BernieWhite. #1133 Use .. to traverse into child objects, for example $..name finds names for all nested objects. Engineering: Bump Newtonsoft.Json to 13.0.1. #1137 v2.2.0-B0089 (pre-release) # What's changed since pre-release v2.2.0-B0052: General improvements: Improved reporting of the object path that caused rule failures by @BernieWhite. #1092 Output include a new Detail property with details of the reason and the object path. Custom methods ReasonFrom and ReasonIf accept a path parameter to specify the object path. v2.2.0-B0052 (pre-release) # What's changed since pre-release v2.2.0-B0021: General improvements: Added informational message when output has been written to disk by @BernieWhite. #1074 The Output.Footer option now supports OutputFile which reports the output file path. This is enabled by default. Engineering: Added more object path tests by @ArmaanMcleod. #1110 Bug fixes: Fixed output of reason with wide format by @BernieWhite. #1117 Fixed piped input does not respect excluded paths by @BernieWhite. #1114 By default, objects are not excluded by source. To exclude piped input based on source configure the Input.IgnoreObjectSource option. v2.2.0-B0021 (pre-release) # What's changed since v2.1.0: New features: Added notCount expression and assertion helper by @ArmaanMcleod. #1091 Engineering: Bump xunit.runner.visualstudio to 2.4.5. #1084 Bump Pester to 5.3.3. #1079 Bump Microsoft.NET.Test.Sdk to 17.2.0. #1089 Added NuGet packaging publishing by @BernieWhite. #1093 Updated NuGet packaging metadata by @BernieWhite. #1093 Bug fixes: Fixed grouping of logical operators in object path by @BernieWhite. #1101 v2.1.0 # What's changed since v2.0.1: General improvements: Added notStartsWith , notEndsWith , and notContains expressions and assertion helpers. #1047 Added like , notLike expressions and assertion helpers. #1048 Added additional repository paths to ignore by default. #1043 Added custom suppression message during PSRule runs. #1046 When a rule is suppressed using a suppression group the synopsis is shown in the suppression warning. Configure the suppression group synopsis to display a custom message. Suppression groups synopsis can be localized using markdown documentation. Use markdown to set a culture specific synopsis. Custom suppression messages are not supported when suppressing individual rules using ps-rule.yaml . See about_PSRule_SuppressionGroups for details. Added source support for string conditions. #1068 Engineering: Added code signing of module. #1049 Added SBOM manifests to module. #1050 Bump Sarif.Sdk to 2.4.15. #1075 Bump Pester to 5.3.2. #1062 Bug fixes: Important change: Fixed source scope not updated in multi-module runs. #1053 Several properties of rule and language block elements have been renamed to improve consistency. From v3 custom scripts may not work correctly until you update these names. For details on the updated property names see deprecations . What's changed since pre-release v2.1.0-B0069: No additional changes. v2.1.0-B0069 (pre-release) # What's changed since pre-release v2.1.0-B0040: General improvements: Added notStartsWith , notEndsWith , and notContains expressions and assertion helpers. #1047 Added like , notLike expressions and assertion helpers. #1048 Added additional repository paths to ignore by default. #1043 Engineering: Bump Sarif.Sdk to 2.4.15. #1075 v2.1.0-B0040 (pre-release) # What's changed since pre-release v2.1.0-B0015: General improvements: Added custom suppression message during PSRule runs. #1046 When a rule is suppressed using a suppression group the synopsis is shown in the suppression warning. Configure the suppression group synopsis to display a custom message. Suppression groups synopsis can be localized using markdown documentation. Use markdown to set a culture specific synopsis. Custom suppression messages are not supported when suppressing individual rules using ps-rule.yaml . See about_PSRule_SuppressionGroups for details. Added source support for string conditions. #1068 Engineering: Bump Sarif.Sdk to 2.4.14. #1064 Bump Pester to 5.3.2. #1062 Bug fixes: Important change: Fixed source scope not updated in multi-module runs. #1053 Several properties of rule and language block elements have been renamed to improve consistency. From v3 custom scripts may not work correctly until you update these names. For details on the updated property names see deprecations . v2.1.0-B0015 (pre-release) # What's changed since v2.0.1: Engineering: Added code signing of module. #1049 Added SBOM manifests to module. #1050 v2.0.1 # What's changed since v2.0.0: Bug fixes: Fixed read JSON failed with comments. #1051 Fixed null reference on elapsed time when required module check fails. #1054 Fixed failed to read JSON objects with a empty property name. #1052 v2.0.0 # What's changed since v1.11.1: New features: Add support for suppression groups. #793 New SuppressionGroup resource has been included. See about_PSRule_SuppressionGroups for details. Added source expression property. #933 Included the following expressions: source withinPath notWithinPath Added support for rule severity level. #880 Rules can be configured to be Error , Warning , or Information . Failing rules with the Error severity level will cause the pipeline to fail. Rules with the Warning severity level will be reported as warnings. Rules with the Information severity level will be reported as informational messages. By default, the severity level for a rule is Error . Added expression support for type based assertions. #908 Included the following expressions: IsArray IsBoolean IsDateTime IsInteger IsNumeric Added support for formatting results as SARIF. #878 Set Output.Format to Sarif to output results in the SARIF format. See about_PSRule_Options for details. General improvements: Add option to disable invariant culture warning. #899 Added Execution.InvariantCultureWarning option. See about_PSRule_Options for details. Added support for object path expressions. #808 #693 Inspired by JSONPath, object path expressions can be used to access nested objects. Array members can be filtered and enumerated using object path expressions. Object path expressions can be used in YAML, JSON, and PowerShell rules and selectors. See about_PSRule_Assert for details. Improve tracking of suppressed objects. #794 Added Execution.SuppressedRuleWarning option to output warning for suppressed rules. Added support for rule aliases. #792 Aliases allow rules to be references by an alternative name. When renaming rules, add a rule alias to avoid breaking references to the old rule name. To specify an alias use the -Alias parameter or alias metadata property in YAML or JSON. Added support for stable identifiers with rule refs. #881 A rule ref may be optionally be used to reference a rule. Rule refs should be: stable, not changing between releases; opaque, as opposed to being a human-readable string. Stable and opaque refs ease web lookup and to help to avoid language difficulties. To specify a rule ref use the -Ref parameter or ref metadata property in YAML or JSON. Added new properties for module lookup to SARIF results. #951 Capture and output repository info in Assert-PSRule runs. #978 Added Repository.Url option set repository URL reported in output. Repository URL is detected automatically for GitHub Actions and Azure Pipelines. Added RepositoryInfo to Output.Banner option. Repository info is shown by default. Added convert and caseSensitive to string comparison expressions. #1001 The following expressions support type conversion and case-sensitive comparison. startsWith , contains , and endsWith . equals and notEquals . Added convert to numeric comparison expressions. #943 Type conversion is now supported for less , lessOrEquals , greater , and greaterOrEquals . Added Extent property on rules reported by Get-PSRule . #990 Extent provides the line and position of the rule in the source code. Breaking change: Added validation of resource names. #1012 Invalid rules names will now produce a specific error. See upgrade notes for more information. Engineering: Breaking change: Removal of deprecated default baseline from module manifest. #755 Set the default module baseline using module configuration. See upgrade notes for details. Breaking change: Require apiVersion on YAML and JSON to be specified. #648 Resources should use github.com/microsoft/PSRule/v1 as the apiVersion . Resources that do not specify an apiVersion will be ignored. See upgrade notes for details. Breaking change: Prefer module sources over loose files. #610 Module sources are discovered before loose files. Warning is shown for duplicate rule names, and exception is thrown for duplicate rule Ids. See upgrade notes for details. Breaking change: Require rule sources from current working directory to be explicitly included. #760 From v2 onwards, $PWD is not included by default unless -Path . or -Path $PWD is explicitly specified. See upgrade notes for details. Added more tests for JSON resources. #929 Bump Sarif.Sdk to 2.4.13. #1007 Bump PowerShellStandard.Library to 5.1.1. #999 Bug fixes: Fixed object path handling with dash. #902 Fixed empty suppression group rules property applies to no rules. #931 Fixed object reference for suppression group will rule not defined. #932 Fixed rule source loading twice from $PWD and .ps-rule/ . #939 Fixed rule references in SARIF format for extensions need a toolComponent reference. #949 Fixed file objects processed with file input format have no source location. #950 Fixed GitHub code scanning alerts treats pass as problems. #955 By default, SARIF output will only include fail or error outcomes. Added Output.SarifProblemsOnly option to include pass outcomes. Fixed SARIF output includes rule property for default tool component. #956 Fixed Invoke-PSRule hanging if JSON rule file is empty. #969 Fixed SARIF should report base branch. #964 Fixed unclear error message on invalid rule names. #1012 What's changed since pre-release v2.0.0-B2203045: No additional changes. v2.0.0-B2203045 (pre-release) # What's changed since pre-release v2.0.0-B2203033: General improvements: Added convert to numeric comparison expressions. #943 Type conversion is now supported for less , lessOrEquals , greater , and greaterOrEquals . Breaking change: Added validation of resource names. #1012 Invalid rules names will now produce a specific error. See upgrade notes for more information. Bug fixes: Fixed unclear error message on invalid rule names. #1012 v2.0.0-B2203033 (pre-release) # What's changed since pre-release v2.0.0-B2203019: General improvements: Added Extent property on rules reported by Get-PSRule . #990 Extent provides the line and position of the rule in the source code. Engineering: Bump Sarif.Sdk to 2.4.13. #1007 Bump PowerShellStandard.Library to 5.1.1. #999 v2.0.0-B2203019 (pre-release) # What's changed since pre-release v2.0.0-B2202072: General improvements: Added convert and caseSensitive to string comparison expressions. #1001 The following expressions support type conversion and case-sensitive comparison. startsWith , contains , and endsWith . equals and notEquals . v2.0.0-B2202072 (pre-release) # What's changed since pre-release v2.0.0-B2202065: General improvements: Capture and output repository info in Assert-PSRule runs. #978 Added Repository.Url option set repository URL reported in output. Repository URL is detected automatically for GitHub Actions and Azure Pipelines. Added RepositoryInfo to Output.Banner option. Repository info is shown by default. Bug fixes: Fixed SARIF should report base branch. #964 v2.0.0-B2202065 (pre-release) # What's changed since pre-release v2.0.0-B2202056: Bug fixes: Fixed broken documentation links. #980 v2.0.0-B2202056 (pre-release) # What's changed since pre-release v2.0.0-B2202024: Bug fixes: Fixed Invoke-PSRule hanging if JSON rule file is empty. #969 v2.0.0-B2202024 (pre-release) # What's changed since pre-release v2.0.0-B2202017: New features: Added source expression property. #933 Included the following expressions: source withinPath notWithinPath v2.0.0-B2202017 (pre-release) # What's changed since pre-release v2.0.0-B2202006: Bug fixes: Fixed GitHub code scanning alerts treats pass as problems. #955 By default, SARIF output will only include fail or error outcomes. Added Output.SarifProblemsOnly option to include pass outcomes. Fixed SARIF output includes rule property for default tool component. #956 v2.0.0-B2202006 (pre-release) # What's changed since pre-release v2.0.0-B2201161: General improvements: Added new properties for module lookup to SARIF results. #951 Bug fixes: Fixed rule references in SARIF format for extensions need a toolComponent reference. #949 Fixed file objects processed with file input format have no source location. #950 v2.0.0-B2201161 (pre-release) # What's changed since pre-release v2.0.0-B2201146: New features: Added support for rule severity level. #880 Rules can be configured to be Error , Warning , or Information . Failing rules with the Error severity level will cause the pipeline to fail. Rules with the Warning severity level will be reported as warnings. Rules with the Information severity level will be reported as informational messages. By default, the severity level for a rule is Error . Added expression support for type based assertions. #908 Included the following expressions: IsArray IsBoolean IsDateTime IsInteger IsNumeric Added support for formatting results as SARIF. #878 Set Output.Format to Sarif to output results in the SARIF format. See about_PSRule_Options for details. v2.0.0-B2201146 (pre-release) # What's changed since pre-release v2.0.0-B2201135: Engineering: Breaking change: Require rule sources from current working directory to be explicitly included. #760 From v2 onwards, $PWD is not included by default unless -Path . or -Path $PWD is explicitly specified. See upgrade notes for details. Bug fixes: Fixed rule source loading twice from $PWD and .ps-rule/ . #939 v2.0.0-B2201135 (pre-release) # What's changed since pre-release v2.0.0-B2201117: Engineering: Breaking change: Prefer module sources over loose files. #610 Module sources are discovered before loose files. Warning is shown for duplicate rule names, and exception is thrown for duplicate rule Ids. See upgrade notes for details. Added more tests for JSON resources. #929 Bug fixes: Fixed empty suppression group rules property applies to no rules. #931 Fixed object reference for suppression group will rule not defined. #932 v2.0.0-B2201117 (pre-release) # What's changed since pre-release v2.0.0-B2201093: General improvements: Add option to disable invariant culture warning. #899 Added Execution.InvariantCultureWarning option. See about_PSRule_Options for details. v2.0.0-B2201093 (pre-release) # What's changed since pre-release v2.0.0-B2201075: New features: Add support for suppression groups. #793 New SuppressionGroup resource has been included. See about_PSRule_SuppressionGroups for details. v2.0.0-B2201075 (pre-release) # What's changed since pre-release v2.0.0-B2201054: General improvements: Added support for rule aliases. #792 Aliases allow rules to be references by an alternative name. When renaming rules, add a rule alias to avoid breaking references to the old rule name. To specify an alias use the -Alias parameter or alias metadata property in YAML or JSON. Added support for stable identifiers with rule refs. #881 A rule ref may be optionally be used to reference a rule. Rule refs should be: stable, not changing between releases; opaque, as opposed to being a human-readable string. Stable and opaque refs ease web lookup and to help to avoid language difficulties. To specify a rule ref use the -Ref parameter or ref metadata property in YAML or JSON. Bug fixes: Fixed object path handling with dash. #902 v2.0.0-B2201054 (pre-release) # What's changed since v1.11.0: General improvements: Added support for object path expressions. #808 #693 Inspired by JSONPath, object path expressions can be used to access nested objects. Array members can be filtered and enumerated using object path expressions. Object path expressions can be used in YAML, JSON, and PowerShell rules and selectors. See about_PSRule_Assert for details. Improve tracking of suppressed objects. #794 Added Execution.SuppressedRuleWarning option to output warning for suppressed rules. Engineering: Breaking change: Removal of deprecated default baseline from module manifest. #755 Set the default module baseline using module configuration. See upgrade notes for details. Breaking change: Require apiVersion on YAML and JSON to be specified. #648 Resources should use github.com/microsoft/PSRule/v1 as the apiVersion . Resources that do not specify an apiVersion will be ignored. See upgrade notes for details.","title":"v2"},{"location":"CHANGELOG-v2/#change-log","text":"See upgrade notes for helpful information when upgrading from previous versions. Important notes : Several properties of rule and language block elements will be removed from v3. See deprecations for details. Experimental features : Functions within YAML and JSON expressions can be used to perform manipulation prior to testing a condition. See functions for more information. Sub-selectors within YAML and JSON expressions can be used to filter rules and list properties. See sub-selectors for more information. Processing of changes files only within a pipeline. See creating your pipeline for more information.","title":"Change log"},{"location":"CHANGELOG-v2/#unreleased","text":"","title":"Unreleased"},{"location":"CHANGELOG-v2/#v270-b0006-pre-release","text":"What's changed since pre-release v2.7.0-B0001: General improvements: Added support target scope by @BernieWhite. #1350 Bug fixes: Fixed exception with comments in JSON baselines by @BernieWhite. #1336","title":"v2.7.0-B0006 (pre-release)"},{"location":"CHANGELOG-v2/#v270-b0001-pre-release","text":"What's changed since v2.6.0: Bug fixes: Fixed exception calling RuleSource value cannot be null by @BernieWhite. #1343","title":"v2.7.0-B0001 (pre-release)"},{"location":"CHANGELOG-v2/#v260","text":"What's changed since v2.5.3: New features: Added support for generating job summaries by @BernieWhite. #1264 Job summaries provide a markdown output for pipelines in addition to other supported output formats. To use, configure the Output.JobSummaryPath option. Added support for time bound suppression groups by @BernieWhite. #1335 Suppression groups can be configured to expire after a specified time by setting the spec.expiresOn property. When a suppression group expires, the suppression group will generate a warning by default. Configure the Execution.SuppressionGroupExpired option to ignore or error on expired suppression groups. Engineering: Bump Microsoft.NET.Test.Sdk to v17.4.0. #1331 Bump PSScriptAnalyzer to v1.21.0. #1318 Class clean up and documentation by @BernieWhite. #1186 What's changed since pre-release v2.6.0-B0034: No additional changes.","title":"v2.6.0"},{"location":"CHANGELOG-v2/#v260-b0034-pre-release","text":"What's changed since pre-release v2.6.0-B0013: New features: Added support for generating job summaries by @BernieWhite. #1264 Job summaries provide a markdown output for pipelines in addition to other supported output formats. To use, configure the Output.JobSummaryPath option. Added support for time bound suppression groups by @BernieWhite. #1335 Suppression groups can be configured to expire after a specified time by setting the spec.expiresOn property. When a suppression group expires, the suppression group will generate a warning by default. Configure the Execution.SuppressionGroupExpired option to ignore or error on expired suppression groups. Engineering: Bump Microsoft.NET.Test.Sdk to v17.4.0. #1331","title":"v2.6.0-B0034 (pre-release)"},{"location":"CHANGELOG-v2/#v260-b0013-pre-release","text":"What's changed since v2.5.3: Engineering: Bump Microsoft.NET.Test.Sdk to v17.3.2. #1283 Bump PSScriptAnalyzer to v1.21.0. #1318 Class clean up and documentation by @BernieWhite. #1186","title":"v2.6.0-B0013 (pre-release)"},{"location":"CHANGELOG-v2/#v253","text":"What's changed since v2.5.2: Bug fixes: Fixed incorrect XML header for encoding by @BernieWhite. #1322","title":"v2.5.3"},{"location":"CHANGELOG-v2/#v252","text":"What's changed since v2.5.1: Bug fixes: Fixed NUnit output does not escape characters in all result properties by @BernieWhite. #1316","title":"v2.5.2"},{"location":"CHANGELOG-v2/#v251","text":"What's changed since v2.5.0: Bug fixes: Fixed In with array source object and dot object path by @BernieWhite. #1314","title":"v2.5.1"},{"location":"CHANGELOG-v2/#v250","text":"What's changed since v2.4.2: New features: Experimental : Added support for only processing changed files by @BernieWhite. #688 To ignore unchanged files, set the Input.IgnoreUnchangedPath option to true . See creating your pipeline for more information. General improvements: Added labels metadata from grouping and filtering rules by @BernieWhite. #1272 Labels are metadata that extends on tags to provide a more structured way to group rules. Rules can be classified by setting the metadata.labels property or -Labels parameter. Provide unblock for command line tools by @BernieWhite. #1261 Engineering: Bump Microsoft.NET.Test.Sdk to v17.3.1. #1248 Bug fixes: Fixed could not load Microsoft.Management.Infrastructure by @BernieWhite. #1249 To use minimal initial session state set Execution.InitialSessionState to Minimal . Fixed unhandled exception with GetRootedPath by @BernieWhite. #1251 Fixed Dockerfile case sensitivity by @BernieWhite. #1269 What's changed since pre-release v2.5.0-B0080: No additional changes.","title":"v2.5.0"},{"location":"CHANGELOG-v2/#v250-b0080-pre-release","text":"What's changed since pre-release v2.5.0-B0045: Bug fixes: Fixed exception with PathExpressionBuilder.GetAllRecurse by @BernieWhite. #1301","title":"v2.5.0-B0080 (pre-release)"},{"location":"CHANGELOG-v2/#v250-b0045-pre-release","text":"What's changed since pre-release v2.5.0-B0015: New features: Experimental : Added support for only processing changed files by @BernieWhite. #688 To ignore unchanged files, set the Input.IgnoreUnchangedPath option to true . See creating your pipeline for more information. General improvements: Added labels metadata from grouping and filtering rules by @BernieWhite. #1272 Labels are metadata that extends on tags to provide a more structured way to group rules. Rules can be classified by setting the metadata.labels property or -Labels parameter. Bug fixes: Fixed Dockerfile case sensitivity by @BernieWhite. #1269 Fixed markdown parsing of Spanish translated help fails by @BernieWhite @jonathanruiz. #1286 #1285","title":"v2.5.0-B0045 (pre-release)"},{"location":"CHANGELOG-v2/#v250-b0015-pre-release","text":"What's changed since pre-release v2.5.0-B0004: General improvements: Provide unblock for command line tools by @BernieWhite. #1261","title":"v2.5.0-B0015 (pre-release)"},{"location":"CHANGELOG-v2/#v250-b0004-pre-release","text":"What's changed since v2.4.0: Engineering: Bump Microsoft.NET.Test.Sdk to v17.3.1. #1248 Bug fixes: Fixed could not load Microsoft.Management.Infrastructure by @BernieWhite. #1249 To use minimal initial session state set Execution.InitialSessionState to Minimal . Fixed unhandled exception with GetRootedPath by @BernieWhite. #1251","title":"v2.5.0-B0004 (pre-release)"},{"location":"CHANGELOG-v2/#v242","text":"What's changed since v2.4.1: Bug fixes: Fixed exception with PathExpressionBuilder.GetAllRecurse by @BernieWhite. #1301","title":"v2.4.2"},{"location":"CHANGELOG-v2/#v241","text":"What's changed since v2.4.0: Bug fixes: Fixed markdown parsing of Spanish translated help fails by @BernieWhite @jonathanruiz. #1286 #1285","title":"v2.4.1"},{"location":"CHANGELOG-v2/#v240","text":"What's changed since v2.3.2: New features: Experimental : Added support for functions within YAML and JSON expressions by @BernieWhite. #1227 #1016 Added conversion functions boolean , string , and integer . Added lookup functions configuration , and path . Added string functions concat , substring . See functions for more information. Experimental : Added support for sub-selector YAML and JSON expressions by @BernieWhite. #1024 #1045 Sub-selector pre-conditions add an additional expression to determine if a rule is executed. Sub-selector object filters provide an way to filter items from list properties. See sub-selectors for more information. Engineering: Improvements to PSRule engine API documentation by @BernieWhite. #1186 Updates to PSRule engine API by @BernieWhite. #1152 Added tool support for baselines parameter. Added module path discovery. Added output for verbose and debug messages. Bump support projects to .NET 6 by @BernieWhite. #1209 Bump Microsoft.NET.Test.Sdk to v17.3.0. #1213 Bump BenchmarkDotNet to v0.13.2. #1241 Bump BenchmarkDotNet.Diagnostics.Windows to v0.13.2. #1242 Bug fixes: Fixed reporting of duplicate identifiers which were not generating an error for all cases by @BernieWhite. #1229 Added Execution.DuplicateResourceId option to configure PSRule behaviour. By default, duplicate resource identifiers return an error. Fixed exception on JSON baseline without a synopsis by @BernieWhite. #1230 Fixed repository information not in output by @BernieWhite. #1219 What's changed since pre-release v2.4.0-B0091: No additional changes.","title":"v2.4.0"},{"location":"CHANGELOG-v2/#v240-b0091-pre-release","text":"What's changed since pre-release v2.4.0-B0063: Engineering: Bump BenchmarkDotNet to v0.13.2. #1241 Bump BenchmarkDotNet.Diagnostics.Windows to v0.13.2. #1242","title":"v2.4.0-B0091 (pre-release)"},{"location":"CHANGELOG-v2/#v240-b0063-pre-release","text":"What's changed since pre-release v2.4.0-B0039: New features: Experimental : Added support for sub-selector YAML and JSON expressions by @BernieWhite. #1024 #1045 Sub-selector pre-conditions add an additional expression to determine if a rule is executed. Sub-selector object filters provide an way to filter items from list properties. See sub-selectors for more information. Engineering: Improvements to PSRule engine API documentation by @BernieWhite. #1186","title":"v2.4.0-B0063 (pre-release)"},{"location":"CHANGELOG-v2/#v240-b0039-pre-release","text":"What's changed since pre-release v2.4.0-B0022: New features: Experimental : Added support for functions within YAML and JSON expressions by @BernieWhite. #1227 #1016 Added conversion functions boolean , string , and integer . Added lookup functions configuration , and path . Added string functions concat , substring . See functions for more information. Bug fixes: Fixed reporting of duplicate identifiers which were not generating an error for all cases by @BernieWhite. #1229 Added Execution.DuplicateResourceId option to configure PSRule behaviour. By default, duplicate resource identifiers return an error. Fixed exception on JSON baseline without a synopsis by @BernieWhite. #1230","title":"v2.4.0-B0039 (pre-release)"},{"location":"CHANGELOG-v2/#v240-b0022-pre-release","text":"What's changed since pre-release v2.4.0-B0009: Engineering: Updates to PSRule engine API by @BernieWhite. #1152 Added tool support for baselines parameter. Added module path discovery. Added output for verbose and debug messages.","title":"v2.4.0-B0022 (pre-release)"},{"location":"CHANGELOG-v2/#v240-b0009-pre-release","text":"What's changed since v2.3.2: Engineering: Bump support projects to .NET 6 by @BernieWhite. #1209 Bump Microsoft.NET.Test.Sdk to v17.3.0. #1213 Bug fixes: Fixed repository information not in output by @BernieWhite. #1219","title":"v2.4.0-B0009 (pre-release)"},{"location":"CHANGELOG-v2/#v232","text":"What's changed since v2.3.1: Bug fixes: Fixes lost scope for rules by @BernieWhite. #1214","title":"v2.3.2"},{"location":"CHANGELOG-v2/#v231","text":"What's changed since v2.3.0: Bug fixes: Fixed object path join handling of self path identifier by @BernieWhite. #1204","title":"v2.3.1"},{"location":"CHANGELOG-v2/#v230","text":"What's changed since v2.2.0: General improvements: Added PathPrefix method to add an object path prefix to assertion reasons by @BernieWhite. #1198 Added support for binding with JSON objects by @BernieWhite. #1182 Added support for full path from JSON objects by @BernieWhite. #1174 Improved reporting of full object path from pre-processed results by @BernieWhite. #1169 Added PSRule for Azure expansion configuration to options schema by @BernieWhite. #1149 Engineering: Bump xunit to v2.4.2. #1200 Expose online link extension method by @BernieWhite. #1195 Added comment documentation to .NET classes and interfaces by @BernieWhite. #1186 Added publishing support for NuGet symbol packages @BernieWhite. #1173 Updated outcome option docs by @BernieWhite. #1166 Bump Sarif.Sdk to v2.4.16. #1177 Refactoring and updates to interfaces to allow use outside of PowerShell by @BernieWhite. #1152 Bug fixes: Fixes JSON parsing of string array for single objects by @BernieWhite. #1193 Fixed handling for JSON objects in rules by @BernieWhite. #1187 Fixed null object reference for object equity comparison by @BernieWhite. #1157 Fixed expression evaluation not logging debug output when using the -Debug switch by @BernieWhite. #1158 Fixed startIndex cannot be larger than length of string by @BernieWhite. #1160 Fixed path within SDK package causes psd1 to compile by @BernieWhite. #1146 What's changed since pre-release v2.3.0-B0163: No additional changes.","title":"v2.3.0"},{"location":"CHANGELOG-v2/#v230-b0163-pre-release","text":"What's changed since pre-release v2.3.0-B0130: General improvements: Added PathPrefix method to add an object path prefix to assertion reasons by @BernieWhite. #1198 Engineering: Bump xunit to v2.4.2. #1200","title":"v2.3.0-B0163 (pre-release)"},{"location":"CHANGELOG-v2/#v230-b0130-pre-release","text":"What's changed since pre-release v2.3.0-B0100: Engineering: Expose online link extension method by @BernieWhite. #1195 Bug fixes: Fixes JSON parsing of string array for single objects by @BernieWhite. #1193","title":"v2.3.0-B0130 (pre-release)"},{"location":"CHANGELOG-v2/#v230-b0100-pre-release","text":"What's changed since pre-release v2.3.0-B0074: Engineering: Added comment documentation to .NET classes and interfaces by @BernieWhite. #1186 Bug fixes: Fixed handling for JSON objects in rules by @BernieWhite. #1187","title":"v2.3.0-B0100 (pre-release)"},{"location":"CHANGELOG-v2/#v230-b0074-pre-release","text":"What's changed since pre-release v2.3.0-B0051: General improvements: Added support for binding with JSON objects by @BernieWhite. #1182","title":"v2.3.0-B0074 (pre-release)"},{"location":"CHANGELOG-v2/#v230-b0051-pre-release","text":"What's changed since pre-release v2.3.0-B0030: General improvements: Added support for full path from JSON objects by @BernieWhite. #1174 Engineering: Added publishing support for NuGet symbol packages @BernieWhite. #1173 Updated outcome option docs by @BernieWhite. #1166 Bump Sarif.Sdk to v2.4.16. #1177","title":"v2.3.0-B0051 (pre-release)"},{"location":"CHANGELOG-v2/#v230-b0030-pre-release","text":"What's changed since pre-release v2.3.0-B0015: General improvements: Improved reporting of full object path from pre-processed results by @BernieWhite. #1169","title":"v2.3.0-B0030 (pre-release)"},{"location":"CHANGELOG-v2/#v230-b0015-pre-release","text":"What's changed since pre-release v2.3.0-B0006: Bug fixes: Fixed null object reference for object equity comparison by @BernieWhite. #1157 Fixed expression evaluation not logging debug output when using the -Debug switch by @BernieWhite. #1158 Fixed startIndex cannot be larger than length of string by @BernieWhite. #1160","title":"v2.3.0-B0015 (pre-release)"},{"location":"CHANGELOG-v2/#v230-b0006-pre-release","text":"What's changed since pre-release v2.3.0-B0001: General improvements: Added PSRule for Azure expansion configuration to options schema by @BernieWhite. #1149 Engineering: Refactoring and updates to interfaces to allow use outside of PowerShell by @BernieWhite. #1152","title":"v2.3.0-B0006 (pre-release)"},{"location":"CHANGELOG-v2/#v230-b0001-pre-release","text":"What's changed since v2.2.0: Bug fixes: Fixed path within SDK package causes psd1 to compile by @BernieWhite. #1146","title":"v2.3.0-B0001 (pre-release)"},{"location":"CHANGELOG-v2/#v220","text":"What's changed since v2.1.0: New features: Added notCount expression and assertion helper by @ArmaanMcleod. #1091 General improvements: Improved reporting of the object path that caused rule failures by @BernieWhite. #1092 Output include a new Detail property with details of the reason and the object path. Custom methods ReasonFrom and ReasonIf accept a path parameter to specify the object path. Added informational message when output has been written to disk by @BernieWhite. #1074 The Output.Footer option now supports OutputFile which reports the output file path. This is enabled by default. Added descendant selector to object path syntax by @BernieWhite. #1133 Use .. to traverse into child objects, for example $..name finds names for all nested objects. Engineering: Bump Newtonsoft.Json to 13.0.1. #1137 Added more object path tests by @ArmaanMcleod. #1110 Bump xunit.runner.visualstudio to 2.4.5. #1084 Bump Pester to 5.3.3. #1079 Bump Microsoft.NET.Test.Sdk to 17.2.0. #1089 Added NuGet packaging publishing by @BernieWhite. #1093 Updated NuGet packaging metadata by @BernieWhite. #1093 Bug fixes: Fixed output of reason with wide format by @BernieWhite. #1117 Fixed piped input does not respect excluded paths by @BernieWhite. #1114 By default, objects are not excluded by source. To exclude piped input based on source configure the Input.IgnoreObjectSource option. Fixed issue building a PSRule project by removing PSRule.psd1 from compile target by @BernieWhite. #1140 Fixed grouping of logical operators in object path by @BernieWhite. #1101 What's changed since pre-release v2.2.0-B0175: No additional changes.","title":"v2.2.0"},{"location":"CHANGELOG-v2/#v220-b0175-pre-release","text":"What's changed since pre-release v2.2.0-B0131: Bug fixes: Fixed issue building a PSRule project by removing PSRule.psd1 from compile target by @BernieWhite. #1140","title":"v2.2.0-B0175 (pre-release)"},{"location":"CHANGELOG-v2/#v220-b0131-pre-release","text":"What's changed since pre-release v2.2.0-B0089: General improvements: Added descendant selector to object path syntax by @BernieWhite. #1133 Use .. to traverse into child objects, for example $..name finds names for all nested objects. Engineering: Bump Newtonsoft.Json to 13.0.1. #1137","title":"v2.2.0-B0131 (pre-release)"},{"location":"CHANGELOG-v2/#v220-b0089-pre-release","text":"What's changed since pre-release v2.2.0-B0052: General improvements: Improved reporting of the object path that caused rule failures by @BernieWhite. #1092 Output include a new Detail property with details of the reason and the object path. Custom methods ReasonFrom and ReasonIf accept a path parameter to specify the object path.","title":"v2.2.0-B0089 (pre-release)"},{"location":"CHANGELOG-v2/#v220-b0052-pre-release","text":"What's changed since pre-release v2.2.0-B0021: General improvements: Added informational message when output has been written to disk by @BernieWhite. #1074 The Output.Footer option now supports OutputFile which reports the output file path. This is enabled by default. Engineering: Added more object path tests by @ArmaanMcleod. #1110 Bug fixes: Fixed output of reason with wide format by @BernieWhite. #1117 Fixed piped input does not respect excluded paths by @BernieWhite. #1114 By default, objects are not excluded by source. To exclude piped input based on source configure the Input.IgnoreObjectSource option.","title":"v2.2.0-B0052 (pre-release)"},{"location":"CHANGELOG-v2/#v220-b0021-pre-release","text":"What's changed since v2.1.0: New features: Added notCount expression and assertion helper by @ArmaanMcleod. #1091 Engineering: Bump xunit.runner.visualstudio to 2.4.5. #1084 Bump Pester to 5.3.3. #1079 Bump Microsoft.NET.Test.Sdk to 17.2.0. #1089 Added NuGet packaging publishing by @BernieWhite. #1093 Updated NuGet packaging metadata by @BernieWhite. #1093 Bug fixes: Fixed grouping of logical operators in object path by @BernieWhite. #1101","title":"v2.2.0-B0021 (pre-release)"},{"location":"CHANGELOG-v2/#v210","text":"What's changed since v2.0.1: General improvements: Added notStartsWith , notEndsWith , and notContains expressions and assertion helpers. #1047 Added like , notLike expressions and assertion helpers. #1048 Added additional repository paths to ignore by default. #1043 Added custom suppression message during PSRule runs. #1046 When a rule is suppressed using a suppression group the synopsis is shown in the suppression warning. Configure the suppression group synopsis to display a custom message. Suppression groups synopsis can be localized using markdown documentation. Use markdown to set a culture specific synopsis. Custom suppression messages are not supported when suppressing individual rules using ps-rule.yaml . See about_PSRule_SuppressionGroups for details. Added source support for string conditions. #1068 Engineering: Added code signing of module. #1049 Added SBOM manifests to module. #1050 Bump Sarif.Sdk to 2.4.15. #1075 Bump Pester to 5.3.2. #1062 Bug fixes: Important change: Fixed source scope not updated in multi-module runs. #1053 Several properties of rule and language block elements have been renamed to improve consistency. From v3 custom scripts may not work correctly until you update these names. For details on the updated property names see deprecations . What's changed since pre-release v2.1.0-B0069: No additional changes.","title":"v2.1.0"},{"location":"CHANGELOG-v2/#v210-b0069-pre-release","text":"What's changed since pre-release v2.1.0-B0040: General improvements: Added notStartsWith , notEndsWith , and notContains expressions and assertion helpers. #1047 Added like , notLike expressions and assertion helpers. #1048 Added additional repository paths to ignore by default. #1043 Engineering: Bump Sarif.Sdk to 2.4.15. #1075","title":"v2.1.0-B0069 (pre-release)"},{"location":"CHANGELOG-v2/#v210-b0040-pre-release","text":"What's changed since pre-release v2.1.0-B0015: General improvements: Added custom suppression message during PSRule runs. #1046 When a rule is suppressed using a suppression group the synopsis is shown in the suppression warning. Configure the suppression group synopsis to display a custom message. Suppression groups synopsis can be localized using markdown documentation. Use markdown to set a culture specific synopsis. Custom suppression messages are not supported when suppressing individual rules using ps-rule.yaml . See about_PSRule_SuppressionGroups for details. Added source support for string conditions. #1068 Engineering: Bump Sarif.Sdk to 2.4.14. #1064 Bump Pester to 5.3.2. #1062 Bug fixes: Important change: Fixed source scope not updated in multi-module runs. #1053 Several properties of rule and language block elements have been renamed to improve consistency. From v3 custom scripts may not work correctly until you update these names. For details on the updated property names see deprecations .","title":"v2.1.0-B0040 (pre-release)"},{"location":"CHANGELOG-v2/#v210-b0015-pre-release","text":"What's changed since v2.0.1: Engineering: Added code signing of module. #1049 Added SBOM manifests to module. #1050","title":"v2.1.0-B0015 (pre-release)"},{"location":"CHANGELOG-v2/#v201","text":"What's changed since v2.0.0: Bug fixes: Fixed read JSON failed with comments. #1051 Fixed null reference on elapsed time when required module check fails. #1054 Fixed failed to read JSON objects with a empty property name. #1052","title":"v2.0.1"},{"location":"CHANGELOG-v2/#v200","text":"What's changed since v1.11.1: New features: Add support for suppression groups. #793 New SuppressionGroup resource has been included. See about_PSRule_SuppressionGroups for details. Added source expression property. #933 Included the following expressions: source withinPath notWithinPath Added support for rule severity level. #880 Rules can be configured to be Error , Warning , or Information . Failing rules with the Error severity level will cause the pipeline to fail. Rules with the Warning severity level will be reported as warnings. Rules with the Information severity level will be reported as informational messages. By default, the severity level for a rule is Error . Added expression support for type based assertions. #908 Included the following expressions: IsArray IsBoolean IsDateTime IsInteger IsNumeric Added support for formatting results as SARIF. #878 Set Output.Format to Sarif to output results in the SARIF format. See about_PSRule_Options for details. General improvements: Add option to disable invariant culture warning. #899 Added Execution.InvariantCultureWarning option. See about_PSRule_Options for details. Added support for object path expressions. #808 #693 Inspired by JSONPath, object path expressions can be used to access nested objects. Array members can be filtered and enumerated using object path expressions. Object path expressions can be used in YAML, JSON, and PowerShell rules and selectors. See about_PSRule_Assert for details. Improve tracking of suppressed objects. #794 Added Execution.SuppressedRuleWarning option to output warning for suppressed rules. Added support for rule aliases. #792 Aliases allow rules to be references by an alternative name. When renaming rules, add a rule alias to avoid breaking references to the old rule name. To specify an alias use the -Alias parameter or alias metadata property in YAML or JSON. Added support for stable identifiers with rule refs. #881 A rule ref may be optionally be used to reference a rule. Rule refs should be: stable, not changing between releases; opaque, as opposed to being a human-readable string. Stable and opaque refs ease web lookup and to help to avoid language difficulties. To specify a rule ref use the -Ref parameter or ref metadata property in YAML or JSON. Added new properties for module lookup to SARIF results. #951 Capture and output repository info in Assert-PSRule runs. #978 Added Repository.Url option set repository URL reported in output. Repository URL is detected automatically for GitHub Actions and Azure Pipelines. Added RepositoryInfo to Output.Banner option. Repository info is shown by default. Added convert and caseSensitive to string comparison expressions. #1001 The following expressions support type conversion and case-sensitive comparison. startsWith , contains , and endsWith . equals and notEquals . Added convert to numeric comparison expressions. #943 Type conversion is now supported for less , lessOrEquals , greater , and greaterOrEquals . Added Extent property on rules reported by Get-PSRule . #990 Extent provides the line and position of the rule in the source code. Breaking change: Added validation of resource names. #1012 Invalid rules names will now produce a specific error. See upgrade notes for more information. Engineering: Breaking change: Removal of deprecated default baseline from module manifest. #755 Set the default module baseline using module configuration. See upgrade notes for details. Breaking change: Require apiVersion on YAML and JSON to be specified. #648 Resources should use github.com/microsoft/PSRule/v1 as the apiVersion . Resources that do not specify an apiVersion will be ignored. See upgrade notes for details. Breaking change: Prefer module sources over loose files. #610 Module sources are discovered before loose files. Warning is shown for duplicate rule names, and exception is thrown for duplicate rule Ids. See upgrade notes for details. Breaking change: Require rule sources from current working directory to be explicitly included. #760 From v2 onwards, $PWD is not included by default unless -Path . or -Path $PWD is explicitly specified. See upgrade notes for details. Added more tests for JSON resources. #929 Bump Sarif.Sdk to 2.4.13. #1007 Bump PowerShellStandard.Library to 5.1.1. #999 Bug fixes: Fixed object path handling with dash. #902 Fixed empty suppression group rules property applies to no rules. #931 Fixed object reference for suppression group will rule not defined. #932 Fixed rule source loading twice from $PWD and .ps-rule/ . #939 Fixed rule references in SARIF format for extensions need a toolComponent reference. #949 Fixed file objects processed with file input format have no source location. #950 Fixed GitHub code scanning alerts treats pass as problems. #955 By default, SARIF output will only include fail or error outcomes. Added Output.SarifProblemsOnly option to include pass outcomes. Fixed SARIF output includes rule property for default tool component. #956 Fixed Invoke-PSRule hanging if JSON rule file is empty. #969 Fixed SARIF should report base branch. #964 Fixed unclear error message on invalid rule names. #1012 What's changed since pre-release v2.0.0-B2203045: No additional changes.","title":"v2.0.0"},{"location":"CHANGELOG-v2/#v200-b2203045-pre-release","text":"What's changed since pre-release v2.0.0-B2203033: General improvements: Added convert to numeric comparison expressions. #943 Type conversion is now supported for less , lessOrEquals , greater , and greaterOrEquals . Breaking change: Added validation of resource names. #1012 Invalid rules names will now produce a specific error. See upgrade notes for more information. Bug fixes: Fixed unclear error message on invalid rule names. #1012","title":"v2.0.0-B2203045 (pre-release)"},{"location":"CHANGELOG-v2/#v200-b2203033-pre-release","text":"What's changed since pre-release v2.0.0-B2203019: General improvements: Added Extent property on rules reported by Get-PSRule . #990 Extent provides the line and position of the rule in the source code. Engineering: Bump Sarif.Sdk to 2.4.13. #1007 Bump PowerShellStandard.Library to 5.1.1. #999","title":"v2.0.0-B2203033 (pre-release)"},{"location":"CHANGELOG-v2/#v200-b2203019-pre-release","text":"What's changed since pre-release v2.0.0-B2202072: General improvements: Added convert and caseSensitive to string comparison expressions. #1001 The following expressions support type conversion and case-sensitive comparison. startsWith , contains , and endsWith . equals and notEquals .","title":"v2.0.0-B2203019 (pre-release)"},{"location":"CHANGELOG-v2/#v200-b2202072-pre-release","text":"What's changed since pre-release v2.0.0-B2202065: General improvements: Capture and output repository info in Assert-PSRule runs. #978 Added Repository.Url option set repository URL reported in output. Repository URL is detected automatically for GitHub Actions and Azure Pipelines. Added RepositoryInfo to Output.Banner option. Repository info is shown by default. Bug fixes: Fixed SARIF should report base branch. #964","title":"v2.0.0-B2202072 (pre-release)"},{"location":"CHANGELOG-v2/#v200-b2202065-pre-release","text":"What's changed since pre-release v2.0.0-B2202056: Bug fixes: Fixed broken documentation links. #980","title":"v2.0.0-B2202065 (pre-release)"},{"location":"CHANGELOG-v2/#v200-b2202056-pre-release","text":"What's changed since pre-release v2.0.0-B2202024: Bug fixes: Fixed Invoke-PSRule hanging if JSON rule file is empty. #969","title":"v2.0.0-B2202056 (pre-release)"},{"location":"CHANGELOG-v2/#v200-b2202024-pre-release","text":"What's changed since pre-release v2.0.0-B2202017: New features: Added source expression property. #933 Included the following expressions: source withinPath notWithinPath","title":"v2.0.0-B2202024 (pre-release)"},{"location":"CHANGELOG-v2/#v200-b2202017-pre-release","text":"What's changed since pre-release v2.0.0-B2202006: Bug fixes: Fixed GitHub code scanning alerts treats pass as problems. #955 By default, SARIF output will only include fail or error outcomes. Added Output.SarifProblemsOnly option to include pass outcomes. Fixed SARIF output includes rule property for default tool component. #956","title":"v2.0.0-B2202017 (pre-release)"},{"location":"CHANGELOG-v2/#v200-b2202006-pre-release","text":"What's changed since pre-release v2.0.0-B2201161: General improvements: Added new properties for module lookup to SARIF results. #951 Bug fixes: Fixed rule references in SARIF format for extensions need a toolComponent reference. #949 Fixed file objects processed with file input format have no source location. #950","title":"v2.0.0-B2202006 (pre-release)"},{"location":"CHANGELOG-v2/#v200-b2201161-pre-release","text":"What's changed since pre-release v2.0.0-B2201146: New features: Added support for rule severity level. #880 Rules can be configured to be Error , Warning , or Information . Failing rules with the Error severity level will cause the pipeline to fail. Rules with the Warning severity level will be reported as warnings. Rules with the Information severity level will be reported as informational messages. By default, the severity level for a rule is Error . Added expression support for type based assertions. #908 Included the following expressions: IsArray IsBoolean IsDateTime IsInteger IsNumeric Added support for formatting results as SARIF. #878 Set Output.Format to Sarif to output results in the SARIF format. See about_PSRule_Options for details.","title":"v2.0.0-B2201161 (pre-release)"},{"location":"CHANGELOG-v2/#v200-b2201146-pre-release","text":"What's changed since pre-release v2.0.0-B2201135: Engineering: Breaking change: Require rule sources from current working directory to be explicitly included. #760 From v2 onwards, $PWD is not included by default unless -Path . or -Path $PWD is explicitly specified. See upgrade notes for details. Bug fixes: Fixed rule source loading twice from $PWD and .ps-rule/ . #939","title":"v2.0.0-B2201146 (pre-release)"},{"location":"CHANGELOG-v2/#v200-b2201135-pre-release","text":"What's changed since pre-release v2.0.0-B2201117: Engineering: Breaking change: Prefer module sources over loose files. #610 Module sources are discovered before loose files. Warning is shown for duplicate rule names, and exception is thrown for duplicate rule Ids. See upgrade notes for details. Added more tests for JSON resources. #929 Bug fixes: Fixed empty suppression group rules property applies to no rules. #931 Fixed object reference for suppression group will rule not defined. #932","title":"v2.0.0-B2201135 (pre-release)"},{"location":"CHANGELOG-v2/#v200-b2201117-pre-release","text":"What's changed since pre-release v2.0.0-B2201093: General improvements: Add option to disable invariant culture warning. #899 Added Execution.InvariantCultureWarning option. See about_PSRule_Options for details.","title":"v2.0.0-B2201117 (pre-release)"},{"location":"CHANGELOG-v2/#v200-b2201093-pre-release","text":"What's changed since pre-release v2.0.0-B2201075: New features: Add support for suppression groups. #793 New SuppressionGroup resource has been included. See about_PSRule_SuppressionGroups for details.","title":"v2.0.0-B2201093 (pre-release)"},{"location":"CHANGELOG-v2/#v200-b2201075-pre-release","text":"What's changed since pre-release v2.0.0-B2201054: General improvements: Added support for rule aliases. #792 Aliases allow rules to be references by an alternative name. When renaming rules, add a rule alias to avoid breaking references to the old rule name. To specify an alias use the -Alias parameter or alias metadata property in YAML or JSON. Added support for stable identifiers with rule refs. #881 A rule ref may be optionally be used to reference a rule. Rule refs should be: stable, not changing between releases; opaque, as opposed to being a human-readable string. Stable and opaque refs ease web lookup and to help to avoid language difficulties. To specify a rule ref use the -Ref parameter or ref metadata property in YAML or JSON. Bug fixes: Fixed object path handling with dash. #902","title":"v2.0.0-B2201075 (pre-release)"},{"location":"CHANGELOG-v2/#v200-b2201054-pre-release","text":"What's changed since v1.11.0: General improvements: Added support for object path expressions. #808 #693 Inspired by JSONPath, object path expressions can be used to access nested objects. Array members can be filtered and enumerated using object path expressions. Object path expressions can be used in YAML, JSON, and PowerShell rules and selectors. See about_PSRule_Assert for details. Improve tracking of suppressed objects. #794 Added Execution.SuppressedRuleWarning option to output warning for suppressed rules. Engineering: Breaking change: Removal of deprecated default baseline from module manifest. #755 Set the default module baseline using module configuration. See upgrade notes for details. Breaking change: Require apiVersion on YAML and JSON to be specified. #648 Resources should use github.com/microsoft/PSRule/v1 as the apiVersion . Resources that do not specify an apiVersion will be ignored. See upgrade notes for details.","title":"v2.0.0-B2201054 (pre-release)"},{"location":"about/","text":"What is PSRule? # PSRule is a rules engine geared towards testing Infrastructure as Code ( IaC ). Rules you write or import perform static analysis on IaC artifacts such as: templates, manifests, pipelines, and workflows. Why use PSRule? # PSRule aims to provide a rich experience for building and running static analysis tests on IaC . While this has some similarities to traditional testing frameworks it extends on the following: Reuse and share \u2014 existing pre-built rules, configure, or write your own. Incremental adoption \u2014 with baselines allows you to keep moving forward. Handle exceptions \u2014 and keep exceptions auditable in git history. Documentation \u2014 provides recommendations and examples instead of just pass or fail.","title":"About"},{"location":"about/#what-is-psrule","text":"PSRule is a rules engine geared towards testing Infrastructure as Code ( IaC ). Rules you write or import perform static analysis on IaC artifacts such as: templates, manifests, pipelines, and workflows.","title":"What is PSRule?"},{"location":"about/#why-use-psrule","text":"PSRule aims to provide a rich experience for building and running static analysis tests on IaC . While this has some similarities to traditional testing frameworks it extends on the following: Reuse and share \u2014 existing pre-built rules, configure, or write your own. Incremental adoption \u2014 with baselines allows you to keep moving forward. Handle exceptions \u2014 and keep exceptions auditable in git history. Documentation \u2014 provides recommendations and examples instead of just pass or fail.","title":"Why use PSRule?"},{"location":"addon-modules/","text":"Additional modules # Integrations # Azure Monitor # You can send rule results to Azure Monitor using PSRule.Monitor . Pre-built rules # The following modules contain pre-built rules that can be plugged into your pipeline. Module Description Version / downloads PSRule.Rules.Azure A suite of rules to validate Azure resources and infrastructure as code (IaC) using PSRule. PSRule.Rules.Kubernetes A suite of rules to validate Kubernetes resources using PSRule. PSRule.Rules.CAF A suite of rules to validate Azure resources against the Cloud Adoption Framework (CAF) using PSRule. PSRule.Rules.GitHub A suite of rules to validate GitHub repositories using PSRule. PSRule.Rules.MSFT.OSS A suite of rules to validate repositories against Microsoft Open Source Software (OSS) requirements. PSRule.Monitor Log PSRule analysis results to Azure Monitor.","title":"Additional modules"},{"location":"addon-modules/#additional-modules","text":"","title":"Additional modules"},{"location":"addon-modules/#integrations","text":"","title":"Integrations"},{"location":"addon-modules/#azure-monitor","text":"You can send rule results to Azure Monitor using PSRule.Monitor .","title":"Azure Monitor"},{"location":"addon-modules/#pre-built-rules","text":"The following modules contain pre-built rules that can be plugged into your pipeline. Module Description Version / downloads PSRule.Rules.Azure A suite of rules to validate Azure resources and infrastructure as code (IaC) using PSRule. PSRule.Rules.Kubernetes A suite of rules to validate Kubernetes resources using PSRule. PSRule.Rules.CAF A suite of rules to validate Azure resources against the Cloud Adoption Framework (CAF) using PSRule. PSRule.Rules.GitHub A suite of rules to validate GitHub repositories using PSRule. PSRule.Rules.MSFT.OSS A suite of rules to validate repositories against Microsoft Open Source Software (OSS) requirements. PSRule.Monitor Log PSRule analysis results to Azure Monitor.","title":"Pre-built rules"},{"location":"analysis-output/","text":"Analysis output # PSRule supports generating and saving output in a number of different formats. Abstract This topic covers the supported formats and options for presenting output from a PSRule run. Setting the output format # The output format can be configuring by setting the Output.Format option to one the following: Yaml - Output is serialized as YAML. Json - Output is serialized as JSON. Markdown - Output is serialized as Markdown. NUnit3 - Output is serialized as NUnit3 (XML). Csv - Output is serialized as a comma-separated values (CSV). Sarif - Output is serialized as SARIF . Tip To write output to a file, also set the Output.Path option to the file path to save. GitHub Actions Azure Pipelines PowerShell Options file # Analyze and save results - name : Analyze repository uses : microsoft/ps-rule@v2.4.2 with : outputFormat : Sarif outputPath : reports/ps-rule-results.sarif # Analyze and save results - task : ps-rule-assert@2 displayName : Analyze repository inputs : inputType : repository outputFormat : Sarif outputPath : reports/ps-rule-results.sarif Invoke-PSRule Invoke-PSRule -OutputFormat Sarif -OutputPath reports / ps-rule-results . sarif Assert-PSRule Assert-PSRule -OutputFormat Sarif -OutputPath reports / ps-rule-results . sarif ps-rule.yaml output : format : 'Sarif' path : reports/ps-rule-results.sarif Formatting as YAML # When using the YAML output format, results a serialized as YAML. Two spaces are used to indent properties of objects. Example output - data : {} info : displayName : Local.PS.RequireTLS name : Local.PS.RequireTLS synopsis : An example rule to require TLS. level : Error outcome : Fail outcomeReason : Processed reason : - The field 'configure.supportsHttpsTrafficOnly' is set to 'False'. - The field 'configure.minTLSVersion' does not exist. ruleName : Local.PS.RequireTLS runId : 16b0534165ffb5279beeb1672a251fc1ff3124b6 source : - file : C:\\Dev\\Workspace\\PSRule\\docs\\authoring\\writing-rules\\settings.json line : 2 position : 11 type : File targetName : 1fe7c0f476b11301402d5017d87424c36ff085a8 targetType : app1 time : 0 Formatting as JSON # When using the JSON output format, results are serialized as JSON. By default, no indentation is used. Example output [{ \"data\" :{}, \"info\" :{ \"displayName\" : \"Local.PS.RequireTLS\" , \"name\" : \"Local.PS.RequireTLS\" , \"synopsis\" : \"An example rule to require TLS.\" }, \"level\" : 1 , \"outcome\" : \"Fail\" , \"outcomeReason\" : \"Processed\" , \"reason\" :[ \"The field 'configure.supportsHttpsTrafficOnly' is set to 'False'.\" , \"The field 'configure.minTLSVersion' does not exist.\" ], \"ruleName\" : \"Local.PS.RequireTLS\" , \"runId\" : \"df662aad3ae7adee6f35b9733c7aaa53dc4d6b96\" , \"source\" :[{ \"file\" : \"C:\\\\Dev\\\\Workspace\\\\PSRule\\\\docs\\\\authoring\\\\writing-rules\\\\settings.json\" , \"line\" : 2 , \"position\" : 11 , \"type\" : \"File\" }], \"targetName\" : \"1fe7c0f476b11301402d5017d87424c36ff085a8\" , \"targetType\" : \"app1\" , \"time\" : 0 }] Configuring JSON indentation # v1.8.0 The number of spaces used to indent properties and elements is configurable between 0 to 4 spaces. By default, no indentation is used. Example output with 2 spaces [ { \"data\" : {}, \"info\" : { \"displayName\" : \"Local.PS.RequireTLS\" , \"name\" : \"Local.PS.RequireTLS\" , \"synopsis\" : \"An example rule to require TLS.\" }, \"level\" : 1 , \"outcome\" : \"Fail\" , \"outcomeReason\" : \"Processed\" , \"reason\" : [ \"The field 'configure.supportsHttpsTrafficOnly' is set to 'False'.\" , \"The field 'configure.minTLSVersion' does not exist.\" ], \"ruleName\" : \"Local.PS.RequireTLS\" , \"runId\" : \"3afadfed32e57f5283ad71c1aa496da822ff0c84\" , \"source\" : [ { \"file\" : \"C:\\\\Dev\\\\Workspace\\\\PSRule\\\\docs\\\\authoring\\\\writing-rules\\\\settings.json\" , \"line\" : 2 , \"position\" : 11 , \"type\" : \"File\" } ], \"targetName\" : \"1fe7c0f476b11301402d5017d87424c36ff085a8\" , \"targetType\" : \"app1\" , \"time\" : 0 } ] Formatting as CSV # The output from analysis can be formatted as comma-separated values (CSV). Formatting as CSV may be useful when manipulating output results by hand. Output of CSV format varies depending on if detailed or summary output is used. For detailed output, the following columns are added to CSV output for each processed object: Column Description RuleName The name of the rule. TargetName The name of the object that was analyzed. TargetType The type of the object that was analyzed. Outcome The outcome of the analysis, such as Pass or Fail . OutcomeReason An additional reason for the outcome such as Inconclusive . Synopsis A short description of the rule. Recommendation The recommendation of the rule. For summary output, the following columns are used: Column Description RuleName The name of the rule. Pass The number of objects that passed. Fail The number of objects that failed. Outcome The worst case outcome of the analysis, such as Pass or Fail . Synopsis A short description of the rule. Recommendation The recommendation of the rule. Example output RuleName,TargetName,TargetType,Outcome,OutcomeReason,Synopsis,Recommendation \"Local.PS.RequireTLS\",\"1fe7c0f476b11301402d5017d87424c36ff085a8\",\"app1\",\"Fail\",\"Processed\",\"An example rule to require TLS.\", \"Local.YAML.RequireTLS\",\"1fe7c0f476b11301402d5017d87424c36ff085a8\",\"app1\",\"Fail\",\"Processed\",\"An example rule to require TLS.\", \"Local.JSON.RequireTLS\",\"1fe7c0f476b11301402d5017d87424c36ff085a8\",\"app1\",\"Fail\",\"Processed\",\"An example rule to require TLS.\", Formatting as SARIF # v2.0.0 Static Analysis Results Interchange Format ( SARIF ) is a standard output format for static analysis tools. It enables various unrelated tools to consume analysis results from PSRule. You can use SARIF to perform Static Analysis Security Testing (SAST) in DevOps environments at-scale. GitHub code scanning alerts # SARIF results from PSRule can be uploaded to GitHub to create code scanning alerts against a repository. You can see these results in your repository visible under Security > Code scanning alerts . Tip Code scanning is available for all public repositories, and for private repositories owned by organizations where GitHub Advanced Security is enabled. For more information, see About GitHub Advanced Security . To configure GitHub Actions, perform the following steps: Create a GitHub Actions workflow. Add a step using the microsoft/ps-rule action. Configure the outputFormat and outputPath parameters. Add a step using the github/codeql-action/upload-sarif action. Configure the sarif_file parameter to the same file path specified in outputPath . Example .github/workflows/analyze.yaml name : Analyze on : push : branches : [ main ] schedule : - cron : '24 22 * * 0' # At 10:24 PM, on Sunday each week workflow_dispatch : jobs : oss : name : Analyze with PSRule runs-on : ubuntu-latest permissions : contents : read security-events : write steps : - name : Checkout uses : actions/checkout@v3 - name : Run PSRule analysis uses : microsoft/ps-rule@v2.4.2 with : outputFormat : Sarif outputPath : reports/ps-rule-results.sarif - name : Upload results to security tab uses : github/codeql-action/upload-sarif@v2 with : sarif_file : reports/ps-rule-results.sarif Azure DevOps scans tab # SARIF results from PSRule can be uploaded and viewed within Azure DevOps. To add the scans tab to build results the SARIF SAST Scans Tab extension needs to be installed.","title":"Analysis output"},{"location":"analysis-output/#analysis-output","text":"PSRule supports generating and saving output in a number of different formats. Abstract This topic covers the supported formats and options for presenting output from a PSRule run.","title":"Analysis output"},{"location":"analysis-output/#setting-the-output-format","text":"The output format can be configuring by setting the Output.Format option to one the following: Yaml - Output is serialized as YAML. Json - Output is serialized as JSON. Markdown - Output is serialized as Markdown. NUnit3 - Output is serialized as NUnit3 (XML). Csv - Output is serialized as a comma-separated values (CSV). Sarif - Output is serialized as SARIF . Tip To write output to a file, also set the Output.Path option to the file path to save. GitHub Actions Azure Pipelines PowerShell Options file # Analyze and save results - name : Analyze repository uses : microsoft/ps-rule@v2.4.2 with : outputFormat : Sarif outputPath : reports/ps-rule-results.sarif # Analyze and save results - task : ps-rule-assert@2 displayName : Analyze repository inputs : inputType : repository outputFormat : Sarif outputPath : reports/ps-rule-results.sarif Invoke-PSRule Invoke-PSRule -OutputFormat Sarif -OutputPath reports / ps-rule-results . sarif Assert-PSRule Assert-PSRule -OutputFormat Sarif -OutputPath reports / ps-rule-results . sarif ps-rule.yaml output : format : 'Sarif' path : reports/ps-rule-results.sarif","title":"Setting the output format"},{"location":"analysis-output/#formatting-as-yaml","text":"When using the YAML output format, results a serialized as YAML. Two spaces are used to indent properties of objects. Example output - data : {} info : displayName : Local.PS.RequireTLS name : Local.PS.RequireTLS synopsis : An example rule to require TLS. level : Error outcome : Fail outcomeReason : Processed reason : - The field 'configure.supportsHttpsTrafficOnly' is set to 'False'. - The field 'configure.minTLSVersion' does not exist. ruleName : Local.PS.RequireTLS runId : 16b0534165ffb5279beeb1672a251fc1ff3124b6 source : - file : C:\\Dev\\Workspace\\PSRule\\docs\\authoring\\writing-rules\\settings.json line : 2 position : 11 type : File targetName : 1fe7c0f476b11301402d5017d87424c36ff085a8 targetType : app1 time : 0","title":"Formatting as YAML"},{"location":"analysis-output/#formatting-as-json","text":"When using the JSON output format, results are serialized as JSON. By default, no indentation is used. Example output [{ \"data\" :{}, \"info\" :{ \"displayName\" : \"Local.PS.RequireTLS\" , \"name\" : \"Local.PS.RequireTLS\" , \"synopsis\" : \"An example rule to require TLS.\" }, \"level\" : 1 , \"outcome\" : \"Fail\" , \"outcomeReason\" : \"Processed\" , \"reason\" :[ \"The field 'configure.supportsHttpsTrafficOnly' is set to 'False'.\" , \"The field 'configure.minTLSVersion' does not exist.\" ], \"ruleName\" : \"Local.PS.RequireTLS\" , \"runId\" : \"df662aad3ae7adee6f35b9733c7aaa53dc4d6b96\" , \"source\" :[{ \"file\" : \"C:\\\\Dev\\\\Workspace\\\\PSRule\\\\docs\\\\authoring\\\\writing-rules\\\\settings.json\" , \"line\" : 2 , \"position\" : 11 , \"type\" : \"File\" }], \"targetName\" : \"1fe7c0f476b11301402d5017d87424c36ff085a8\" , \"targetType\" : \"app1\" , \"time\" : 0 }]","title":"Formatting as JSON"},{"location":"analysis-output/#configuring-json-indentation","text":"v1.8.0 The number of spaces used to indent properties and elements is configurable between 0 to 4 spaces. By default, no indentation is used. Example output with 2 spaces [ { \"data\" : {}, \"info\" : { \"displayName\" : \"Local.PS.RequireTLS\" , \"name\" : \"Local.PS.RequireTLS\" , \"synopsis\" : \"An example rule to require TLS.\" }, \"level\" : 1 , \"outcome\" : \"Fail\" , \"outcomeReason\" : \"Processed\" , \"reason\" : [ \"The field 'configure.supportsHttpsTrafficOnly' is set to 'False'.\" , \"The field 'configure.minTLSVersion' does not exist.\" ], \"ruleName\" : \"Local.PS.RequireTLS\" , \"runId\" : \"3afadfed32e57f5283ad71c1aa496da822ff0c84\" , \"source\" : [ { \"file\" : \"C:\\\\Dev\\\\Workspace\\\\PSRule\\\\docs\\\\authoring\\\\writing-rules\\\\settings.json\" , \"line\" : 2 , \"position\" : 11 , \"type\" : \"File\" } ], \"targetName\" : \"1fe7c0f476b11301402d5017d87424c36ff085a8\" , \"targetType\" : \"app1\" , \"time\" : 0 } ]","title":"Configuring JSON indentation"},{"location":"analysis-output/#formatting-as-csv","text":"The output from analysis can be formatted as comma-separated values (CSV). Formatting as CSV may be useful when manipulating output results by hand. Output of CSV format varies depending on if detailed or summary output is used. For detailed output, the following columns are added to CSV output for each processed object: Column Description RuleName The name of the rule. TargetName The name of the object that was analyzed. TargetType The type of the object that was analyzed. Outcome The outcome of the analysis, such as Pass or Fail . OutcomeReason An additional reason for the outcome such as Inconclusive . Synopsis A short description of the rule. Recommendation The recommendation of the rule. For summary output, the following columns are used: Column Description RuleName The name of the rule. Pass The number of objects that passed. Fail The number of objects that failed. Outcome The worst case outcome of the analysis, such as Pass or Fail . Synopsis A short description of the rule. Recommendation The recommendation of the rule. Example output RuleName,TargetName,TargetType,Outcome,OutcomeReason,Synopsis,Recommendation \"Local.PS.RequireTLS\",\"1fe7c0f476b11301402d5017d87424c36ff085a8\",\"app1\",\"Fail\",\"Processed\",\"An example rule to require TLS.\", \"Local.YAML.RequireTLS\",\"1fe7c0f476b11301402d5017d87424c36ff085a8\",\"app1\",\"Fail\",\"Processed\",\"An example rule to require TLS.\", \"Local.JSON.RequireTLS\",\"1fe7c0f476b11301402d5017d87424c36ff085a8\",\"app1\",\"Fail\",\"Processed\",\"An example rule to require TLS.\",","title":"Formatting as CSV"},{"location":"analysis-output/#formatting-as-sarif","text":"v2.0.0 Static Analysis Results Interchange Format ( SARIF ) is a standard output format for static analysis tools. It enables various unrelated tools to consume analysis results from PSRule. You can use SARIF to perform Static Analysis Security Testing (SAST) in DevOps environments at-scale.","title":"Formatting as SARIF"},{"location":"analysis-output/#github-code-scanning-alerts","text":"SARIF results from PSRule can be uploaded to GitHub to create code scanning alerts against a repository. You can see these results in your repository visible under Security > Code scanning alerts . Tip Code scanning is available for all public repositories, and for private repositories owned by organizations where GitHub Advanced Security is enabled. For more information, see About GitHub Advanced Security . To configure GitHub Actions, perform the following steps: Create a GitHub Actions workflow. Add a step using the microsoft/ps-rule action. Configure the outputFormat and outputPath parameters. Add a step using the github/codeql-action/upload-sarif action. Configure the sarif_file parameter to the same file path specified in outputPath . Example .github/workflows/analyze.yaml name : Analyze on : push : branches : [ main ] schedule : - cron : '24 22 * * 0' # At 10:24 PM, on Sunday each week workflow_dispatch : jobs : oss : name : Analyze with PSRule runs-on : ubuntu-latest permissions : contents : read security-events : write steps : - name : Checkout uses : actions/checkout@v3 - name : Run PSRule analysis uses : microsoft/ps-rule@v2.4.2 with : outputFormat : Sarif outputPath : reports/ps-rule-results.sarif - name : Upload results to security tab uses : github/codeql-action/upload-sarif@v2 with : sarif_file : reports/ps-rule-results.sarif","title":"GitHub code scanning alerts"},{"location":"analysis-output/#azure-devops-scans-tab","text":"SARIF results from PSRule can be uploaded and viewed within Azure DevOps. To add the scans tab to build results the SARIF SAST Scans Tab extension needs to be installed.","title":"Azure DevOps scans tab"},{"location":"creating-your-pipeline/","text":"Creating your pipeline # You can use PSRule to test Infrastructure as Code (IaC) artifacts throughout their lifecycle. By using validation within a continuous integration (CI) pipeline, any issues provide fast feedback. Within the root directory of your IaC repository: GitHub Actions Azure Pipelines Generic with PowerShell Create a new GitHub Actions workflow by creating .github/workflows/analyze-arm.yaml . name : Analyze templates on : - pull_request jobs : analyze_arm : name : Analyze templates runs-on : ubuntu-latest steps : - name : Checkout uses : actions/checkout@v3 # Analyze Azure resources using PSRule for Azure - name : Analyze Azure template files uses : microsoft/ps-rule@v2.4.2 with : modules : 'PSRule.Rules.Azure' This will automatically install compatible versions of all dependencies. Create a new Azure DevOps YAML pipeline by creating .azure-pipelines/analyze-arm.yaml . steps : # Analyze Azure resources using PSRule for Azure - task : ps-rule-assert@2 displayName : Analyze Azure template files inputs : inputType : repository modules : 'PSRule.Rules.Azure' This will automatically install compatible versions of all dependencies. Create a pipeline in any CI environment by using PowerShell. $modules = @( 'PSRule.Rules.Azure' ) Install-Module -Name $modules -Scope CurrentUser -Force -ErrorAction Stop ; Assert-PSRule -InputPath '.' -Module $modules -Format File -ErrorAction Stop ; Tip This example demonstrates using PSRule for Azure, a populate module for testing Azure IaC. Instead, you can write your own module or use one of our pre-built modules . Configuration # Configuration options for PSRule are set within the ps-rule.yaml file. Ignoring rules # To prevent a rule executing you can either: Exclude rules by name \u2014 The rule is not executed for any object. Suppress rules by name \u2014 The rule is not executed for a specific object by name. Suppress rules by condition \u2014 The rule is not executed for matching objects. Exclude by name Suppression by name Suppression by condition To exclude a rule, set Rule.Exclude option within the ps-rule.yaml file. Docs ps-rule.yaml rule : exclude : # Ignore the following rules for all objects - Azure.VM.UseHybridUseBenefit - Azure.VM.Standalone To suppress an individual rule, set Suppression option within the ps-rule.yaml file. Docs ps-rule.yaml suppression : Azure.AKS.AuthorizedIPs : # Exclude the following externally managed AKS clusters - aks-cluster-prod-eus-001 Azure.Storage.SoftDelete : # Exclude the following non-production storage accounts - storagedeveus6jo36t - storagedeveus1df278 To suppress an rules by condition, create a suppression group. Docs --- # Synopsis: Ignore test objects by name. apiVersion : github.com/microsoft/PSRule/v1 kind : SuppressionGroup metadata : name : SuppressWithTargetName spec : rule : - 'FromFile1' - 'FromFile2' if : name : '.' in : - 'TestObject1' - 'TestObject2' Tip Use comments within ps-rule.yaml to describe the reason why rules are excluded or suppressed. Meaningful comments help during peer review within a Pull Request (PR). Also consider including a date if the exclusions or suppressions are temporary. Processing changed files only # v2.5.0 \u00b7 Docs To only process files that have changed within a pull request, set the Input.IgnoreUnchangedPath option. GitHub Actions Azure Pipelines Generic with PowerShell Update your GitHub Actions workflow by setting the PSRULE_INPUT_IGNOREUNCHANGEDPATH environment variable. .github/workflows/analyze-arm.yaml name : Analyze templates on : - pull_request jobs : analyze_arm : name : Analyze templates runs-on : ubuntu-latest steps : - name : Checkout uses : actions/checkout@v3 # Analyze Azure resources using PSRule for Azure - name : Analyze Azure template files uses : microsoft/ps-rule@v2.4.2 with : modules : 'PSRule.Rules.Azure' env : PSRULE_INPUT_IGNOREUNCHANGEDPATH : true Update your Azure DevOps YAML pipeline by setting the PSRULE_INPUT_IGNOREUNCHANGEDPATH environment variable. .azure-pipelines/analyze-arm.yaml steps : # Analyze Azure resources using PSRule for Azure - task : ps-rule-assert@2 displayName : Analyze Azure template files inputs : inputType : repository modules : 'PSRule.Rules.Azure' env : PSRULE_INPUT_IGNOREUNCHANGEDPATH : true Update your PowerShell command-line to include the Input.IgnoreUnchangedPath option. PowerShell $modules = @( 'PSRule.Rules.Azure' ) $options = @{ 'Input.IgnoreUnchangedPath' = $True } Install-Module -Name $modules -Scope CurrentUser -Force -ErrorAction Stop ; Assert-PSRule -Options $options -InputPath '.' -Module $modules -Format File -ErrorAction Stop ; Tip In some cases it may be nessessary to set Repository.BaseRef to the default branch of your repository. By default, PSRule will detect the default branch of the repository from the build system environment variables.","title":"Creating your pipeline"},{"location":"creating-your-pipeline/#creating-your-pipeline","text":"You can use PSRule to test Infrastructure as Code (IaC) artifacts throughout their lifecycle. By using validation within a continuous integration (CI) pipeline, any issues provide fast feedback. Within the root directory of your IaC repository: GitHub Actions Azure Pipelines Generic with PowerShell Create a new GitHub Actions workflow by creating .github/workflows/analyze-arm.yaml . name : Analyze templates on : - pull_request jobs : analyze_arm : name : Analyze templates runs-on : ubuntu-latest steps : - name : Checkout uses : actions/checkout@v3 # Analyze Azure resources using PSRule for Azure - name : Analyze Azure template files uses : microsoft/ps-rule@v2.4.2 with : modules : 'PSRule.Rules.Azure' This will automatically install compatible versions of all dependencies. Create a new Azure DevOps YAML pipeline by creating .azure-pipelines/analyze-arm.yaml . steps : # Analyze Azure resources using PSRule for Azure - task : ps-rule-assert@2 displayName : Analyze Azure template files inputs : inputType : repository modules : 'PSRule.Rules.Azure' This will automatically install compatible versions of all dependencies. Create a pipeline in any CI environment by using PowerShell. $modules = @( 'PSRule.Rules.Azure' ) Install-Module -Name $modules -Scope CurrentUser -Force -ErrorAction Stop ; Assert-PSRule -InputPath '.' -Module $modules -Format File -ErrorAction Stop ; Tip This example demonstrates using PSRule for Azure, a populate module for testing Azure IaC. Instead, you can write your own module or use one of our pre-built modules .","title":"Creating your pipeline"},{"location":"creating-your-pipeline/#configuration","text":"Configuration options for PSRule are set within the ps-rule.yaml file.","title":"Configuration"},{"location":"creating-your-pipeline/#ignoring-rules","text":"To prevent a rule executing you can either: Exclude rules by name \u2014 The rule is not executed for any object. Suppress rules by name \u2014 The rule is not executed for a specific object by name. Suppress rules by condition \u2014 The rule is not executed for matching objects. Exclude by name Suppression by name Suppression by condition To exclude a rule, set Rule.Exclude option within the ps-rule.yaml file. Docs ps-rule.yaml rule : exclude : # Ignore the following rules for all objects - Azure.VM.UseHybridUseBenefit - Azure.VM.Standalone To suppress an individual rule, set Suppression option within the ps-rule.yaml file. Docs ps-rule.yaml suppression : Azure.AKS.AuthorizedIPs : # Exclude the following externally managed AKS clusters - aks-cluster-prod-eus-001 Azure.Storage.SoftDelete : # Exclude the following non-production storage accounts - storagedeveus6jo36t - storagedeveus1df278 To suppress an rules by condition, create a suppression group. Docs --- # Synopsis: Ignore test objects by name. apiVersion : github.com/microsoft/PSRule/v1 kind : SuppressionGroup metadata : name : SuppressWithTargetName spec : rule : - 'FromFile1' - 'FromFile2' if : name : '.' in : - 'TestObject1' - 'TestObject2' Tip Use comments within ps-rule.yaml to describe the reason why rules are excluded or suppressed. Meaningful comments help during peer review within a Pull Request (PR). Also consider including a date if the exclusions or suppressions are temporary.","title":"Ignoring rules"},{"location":"creating-your-pipeline/#processing-changed-files-only","text":"v2.5.0 \u00b7 Docs To only process files that have changed within a pull request, set the Input.IgnoreUnchangedPath option. GitHub Actions Azure Pipelines Generic with PowerShell Update your GitHub Actions workflow by setting the PSRULE_INPUT_IGNOREUNCHANGEDPATH environment variable. .github/workflows/analyze-arm.yaml name : Analyze templates on : - pull_request jobs : analyze_arm : name : Analyze templates runs-on : ubuntu-latest steps : - name : Checkout uses : actions/checkout@v3 # Analyze Azure resources using PSRule for Azure - name : Analyze Azure template files uses : microsoft/ps-rule@v2.4.2 with : modules : 'PSRule.Rules.Azure' env : PSRULE_INPUT_IGNOREUNCHANGEDPATH : true Update your Azure DevOps YAML pipeline by setting the PSRULE_INPUT_IGNOREUNCHANGEDPATH environment variable. .azure-pipelines/analyze-arm.yaml steps : # Analyze Azure resources using PSRule for Azure - task : ps-rule-assert@2 displayName : Analyze Azure template files inputs : inputType : repository modules : 'PSRule.Rules.Azure' env : PSRULE_INPUT_IGNOREUNCHANGEDPATH : true Update your PowerShell command-line to include the Input.IgnoreUnchangedPath option. PowerShell $modules = @( 'PSRule.Rules.Azure' ) $options = @{ 'Input.IgnoreUnchangedPath' = $True } Install-Module -Name $modules -Scope CurrentUser -Force -ErrorAction Stop ; Assert-PSRule -Options $options -InputPath '.' -Module $modules -Format File -ErrorAction Stop ; Tip In some cases it may be nessessary to set Repository.BaseRef to the default branch of your repository. By default, PSRule will detect the default branch of the repository from the build system environment variables.","title":"Processing changed files only"},{"location":"deprecations/","text":"Deprecations # Deprecations for v3 # Rule output object # Several properties of the rule object have been renamed to improve consistency with other objects. Previously rules returned by Get-PSRule returned a rule object which included the following properties: RuleId RuleName Description ModuleName SourcePath These have been replaced with the following properties: Id instead of RuleId . Name instead of RuleName . Synopsis instead of Description . Source.Module instead of ModuleName . Source.Path instead of SourcePath . The changes apply from v2.1.0 , however the old properties are still available for backwards compatibility. From v3 these properties will be removed. These changes do not affect normal usage of PSRule. Supporting scripts that directly use the old names may not work correctly until you update these names. Language block interface # Several properties of Baselines and Selectors have been renamed to improve consistency. ModuleName SourcePath These have been replaced with the following properties: Source.Module instead of ModuleName . Source.Path instead of SourcePath . The changes apply from v2.1.0 , however the old properties are still available for backwards compatibility. From v3 these properties will be removed. These changes do not affect normal usage of PSRule. Supporting scripts that directly use the old names may not work correctly until you update these names. Deprecations for v2 # Default baseline by module manifest # When packaging baselines in a module, you may want to specify a default baseline. PSRule v1.9.0 added support for setting the default baseline in a module configuration. Previously a default baseline could be set by specifying the baseline in the module manifest. From v1.9.0 this is deprecated and will be removed from v2 . For details on how to migrate to the new default baseline option, continue reading the upgrade notes . Resources without an API version # When creating YAML and JSON resources you define a resource by specifying the apiVersion and kind . To allow new schema versions for resources to be introduced in the future, an apiVersion was introduced. For backwards compatibility, resources without an apiVersion deprecated but supported. From v2 resources without an apiVersion will be ignored. For details on how to add an apiVersion to a resource, continue reading the upgrade notes .","title":"Deprecations"},{"location":"deprecations/#deprecations","text":"","title":"Deprecations"},{"location":"deprecations/#deprecations-for-v3","text":"","title":"Deprecations for v3"},{"location":"deprecations/#rule-output-object","text":"Several properties of the rule object have been renamed to improve consistency with other objects. Previously rules returned by Get-PSRule returned a rule object which included the following properties: RuleId RuleName Description ModuleName SourcePath These have been replaced with the following properties: Id instead of RuleId . Name instead of RuleName . Synopsis instead of Description . Source.Module instead of ModuleName . Source.Path instead of SourcePath . The changes apply from v2.1.0 , however the old properties are still available for backwards compatibility. From v3 these properties will be removed. These changes do not affect normal usage of PSRule. Supporting scripts that directly use the old names may not work correctly until you update these names.","title":"Rule output object"},{"location":"deprecations/#language-block-interface","text":"Several properties of Baselines and Selectors have been renamed to improve consistency. ModuleName SourcePath These have been replaced with the following properties: Source.Module instead of ModuleName . Source.Path instead of SourcePath . The changes apply from v2.1.0 , however the old properties are still available for backwards compatibility. From v3 these properties will be removed. These changes do not affect normal usage of PSRule. Supporting scripts that directly use the old names may not work correctly until you update these names.","title":"Language block interface"},{"location":"deprecations/#deprecations-for-v2","text":"","title":"Deprecations for v2"},{"location":"deprecations/#default-baseline-by-module-manifest","text":"When packaging baselines in a module, you may want to specify a default baseline. PSRule v1.9.0 added support for setting the default baseline in a module configuration. Previously a default baseline could be set by specifying the baseline in the module manifest. From v1.9.0 this is deprecated and will be removed from v2 . For details on how to migrate to the new default baseline option, continue reading the upgrade notes .","title":"Default baseline by module manifest"},{"location":"deprecations/#resources-without-an-api-version","text":"When creating YAML and JSON resources you define a resource by specifying the apiVersion and kind . To allow new schema versions for resources to be introduced in the future, an apiVersion was introduced. For backwards compatibility, resources without an apiVersion deprecated but supported. From v2 resources without an apiVersion will be ignored. For details on how to add an apiVersion to a resource, continue reading the upgrade notes .","title":"Resources without an API version"},{"location":"faq/","text":"Frequently Asked Questions (FAQ) # How is PSRule different to Pester? # PSRule is a framework for testing infrastructure as code ( IaC ) and objects using rules. Rules can be written in PowerShell, YAML, or JSON. Some features include: Objects - PowerShell objects can be validated on the pipeline or imported. Objects can be imported directly from JSON , YAML , or .psd1 . Each object is automatically bound to a target type for use with pre-conditions. Rule results are orientated to validating an object. Built-in assertions , automatically traverse object properties. Pre-conditions - Rules understand which objects they apply to. Objects are bound to a type as they are processed using object properties. Dissimilar objects can be processed quickly. Objects that match no rules are flagged with a warning by default. Packaging - Rules can be reused between projects and optionally packaged into a module. Portable rules, configuration, baselines, and documentation allow greater reuse and distribution. Documentation with detailed guidance or next steps can be included. Standalone or rules from modules can be combined together with -Module and -Path . Configuration - Configuration of rules is handled by PSRule. Rules can be configured at runtime, from YAML configuration, or environment variables. Baselines can be used to pair rules and configuration for a specific scenario. Exceptions - Exceptions to a rule can be ignored for a single object using suppression . Exclusion can be used additionally to ignore a rule entirely. These features make PSRule ideal for validating: Infrastructure as code, including: Kubernetes manifests. Azure Resource Manager (ARM) templates. Configuration files. Pipeline files. Deployments or configurations against a baseline. If you want to test PowerShell code, consider using Pester, we do! What pre-built modules are available for PSRule? # PSRule rules modules can be found on the PowerShell Gallery using the tag PSRule-rules . How do I configure PSRule? # PSRule and rules can be configured by: Parameter - PSRule can be configured at runtime by passing the -Option parameter to cmdlets. Options file - Options stored in YAML are load configuration from file. The default ps-rule.yaml option file is read automatically from the current working path by default. When checking into source control, store this file in the root directory of the repository. Environment variables - Configuration can be specified using environment variables. For example: # With cmdlet $option = New-PSRuleOption -OutputAs Summary -OutputCulture 'en-AU' -NotProcessedWarning $False -Configuration @{ CUSTOM_VALUE = 'example' } $items | Assert-PSRule -Option $option # With hashtable $items | Assert-PSRule -Option @{ 'Output.As' = 'Summary' 'Output.Culture' = 'en-AU' 'Execution.NotProcessedWarning' = $False 'Configuration.CUSTOM_VALUE' = 'Example' } # With YAML output : as : Summary culture : [ 'en-AU' ] execution : notProcessedWarning : false configuration : CUSTOM_VALUE : Example # With environment variable in bash export PSRULE_EXECUTION_NOTPROCESSEDWARNING = false export PSRULE_OUTPUT_AS = Summary export PSRULE_OUTPUT_CULTURE = en-AU export PSRULE_CONFIGURATION_CUSTOM_VALUE = Example For a list of configuration options and usage see about_PSRule_Options . How do I ignore a rule? # To prevent a rule executing you can either: Exclude the rule - The rule is not executed for any object. Suppress the rule - The rule is not executed for a specific object by name. To exclude a rule use the Rule.Exclude option. To do this in YAML, add the following to the ps-rule.yaml options file. # YAML: Using the rule/exclude property rule : exclude : - 'My.FirstRule' # The name of the first rule to exclude. - 'My.SecondRule' # The name of the second rule to exclude. To suppress a rule use the Suppression option. To do this in YAML, add the following to the ps-rule.yaml options file. # YAML: Using the suppression property suppression : My.FirstRule : # The name of the rule being suppressed - TestObject1 # The name of the first object to suppress - TestObject3 # The name of the second object to suppress My.SecondRule : # An additional rule to suppress - TestObject2 The name of the object is reported by PSRule in output results. See about_PSRule_Options for additional usage for both of these options. How do I layer on custom rules on top of an existing module? # PSRule allows rules from modules and standalone (loose) rules to be run together. To run rules from a standalone path use: # Note: .ps-rule/ is a standard path to include standalone rules. # With input from the pipeline $items | Assert-PSRule -Path '.ps-rule/' # With input from file Assert-PSRule -Path '.ps-rule/' -InputPath 'src/' To run rules from an installed module use: # With input from the pipeline $items | Assert-PSRule -Module 'PSRule.Rules.Azure' # With input from file Assert-PSRule -Module 'PSRule.Rules.Azure' -InputPath 'src/' Combining both: Assert-PSRule -Module 'PSRule.Rules.Azure' , 'PSRule.Rules.CAF' -Path '.ps-rule/' -InputPath 'src/' Why should I use PSRule keywords and assertions? # Except for the Rule keyword, using the built-in language features are optional. The built-in keywords and assertions accelerate rule creation. They do this by providing a condition and a set of reasons in a single command. Reasons are also optional; however, they provide additional context as to why the rule failed. Alternatively, you can provide your own reasons to complement standard PowerShell with the Reason keyword.","title":"FAQ"},{"location":"faq/#frequently-asked-questions-faq","text":"","title":"Frequently Asked Questions (FAQ)"},{"location":"faq/#how-is-psrule-different-to-pester","text":"PSRule is a framework for testing infrastructure as code ( IaC ) and objects using rules. Rules can be written in PowerShell, YAML, or JSON. Some features include: Objects - PowerShell objects can be validated on the pipeline or imported. Objects can be imported directly from JSON , YAML , or .psd1 . Each object is automatically bound to a target type for use with pre-conditions. Rule results are orientated to validating an object. Built-in assertions , automatically traverse object properties. Pre-conditions - Rules understand which objects they apply to. Objects are bound to a type as they are processed using object properties. Dissimilar objects can be processed quickly. Objects that match no rules are flagged with a warning by default. Packaging - Rules can be reused between projects and optionally packaged into a module. Portable rules, configuration, baselines, and documentation allow greater reuse and distribution. Documentation with detailed guidance or next steps can be included. Standalone or rules from modules can be combined together with -Module and -Path . Configuration - Configuration of rules is handled by PSRule. Rules can be configured at runtime, from YAML configuration, or environment variables. Baselines can be used to pair rules and configuration for a specific scenario. Exceptions - Exceptions to a rule can be ignored for a single object using suppression . Exclusion can be used additionally to ignore a rule entirely. These features make PSRule ideal for validating: Infrastructure as code, including: Kubernetes manifests. Azure Resource Manager (ARM) templates. Configuration files. Pipeline files. Deployments or configurations against a baseline. If you want to test PowerShell code, consider using Pester, we do!","title":"How is PSRule different to Pester?"},{"location":"faq/#what-pre-built-modules-are-available-for-psrule","text":"PSRule rules modules can be found on the PowerShell Gallery using the tag PSRule-rules .","title":"What pre-built modules are available for PSRule?"},{"location":"faq/#how-do-i-configure-psrule","text":"PSRule and rules can be configured by: Parameter - PSRule can be configured at runtime by passing the -Option parameter to cmdlets. Options file - Options stored in YAML are load configuration from file. The default ps-rule.yaml option file is read automatically from the current working path by default. When checking into source control, store this file in the root directory of the repository. Environment variables - Configuration can be specified using environment variables. For example: # With cmdlet $option = New-PSRuleOption -OutputAs Summary -OutputCulture 'en-AU' -NotProcessedWarning $False -Configuration @{ CUSTOM_VALUE = 'example' } $items | Assert-PSRule -Option $option # With hashtable $items | Assert-PSRule -Option @{ 'Output.As' = 'Summary' 'Output.Culture' = 'en-AU' 'Execution.NotProcessedWarning' = $False 'Configuration.CUSTOM_VALUE' = 'Example' } # With YAML output : as : Summary culture : [ 'en-AU' ] execution : notProcessedWarning : false configuration : CUSTOM_VALUE : Example # With environment variable in bash export PSRULE_EXECUTION_NOTPROCESSEDWARNING = false export PSRULE_OUTPUT_AS = Summary export PSRULE_OUTPUT_CULTURE = en-AU export PSRULE_CONFIGURATION_CUSTOM_VALUE = Example For a list of configuration options and usage see about_PSRule_Options .","title":"How do I configure PSRule?"},{"location":"faq/#how-do-i-ignore-a-rule","text":"To prevent a rule executing you can either: Exclude the rule - The rule is not executed for any object. Suppress the rule - The rule is not executed for a specific object by name. To exclude a rule use the Rule.Exclude option. To do this in YAML, add the following to the ps-rule.yaml options file. # YAML: Using the rule/exclude property rule : exclude : - 'My.FirstRule' # The name of the first rule to exclude. - 'My.SecondRule' # The name of the second rule to exclude. To suppress a rule use the Suppression option. To do this in YAML, add the following to the ps-rule.yaml options file. # YAML: Using the suppression property suppression : My.FirstRule : # The name of the rule being suppressed - TestObject1 # The name of the first object to suppress - TestObject3 # The name of the second object to suppress My.SecondRule : # An additional rule to suppress - TestObject2 The name of the object is reported by PSRule in output results. See about_PSRule_Options for additional usage for both of these options.","title":"How do I ignore a rule?"},{"location":"faq/#how-do-i-layer-on-custom-rules-on-top-of-an-existing-module","text":"PSRule allows rules from modules and standalone (loose) rules to be run together. To run rules from a standalone path use: # Note: .ps-rule/ is a standard path to include standalone rules. # With input from the pipeline $items | Assert-PSRule -Path '.ps-rule/' # With input from file Assert-PSRule -Path '.ps-rule/' -InputPath 'src/' To run rules from an installed module use: # With input from the pipeline $items | Assert-PSRule -Module 'PSRule.Rules.Azure' # With input from file Assert-PSRule -Module 'PSRule.Rules.Azure' -InputPath 'src/' Combining both: Assert-PSRule -Module 'PSRule.Rules.Azure' , 'PSRule.Rules.CAF' -Path '.ps-rule/' -InputPath 'src/'","title":"How do I layer on custom rules on top of an existing module?"},{"location":"faq/#why-should-i-use-psrule-keywords-and-assertions","text":"Except for the Rule keyword, using the built-in language features are optional. The built-in keywords and assertions accelerate rule creation. They do this by providing a condition and a set of reasons in a single command. Reasons are also optional; however, they provide additional context as to why the rule failed. Alternatively, you can provide your own reasons to complement standard PowerShell with the Reason keyword.","title":"Why should I use PSRule keywords and assertions?"},{"location":"features/","text":"Features # DevOps # PSRule allows you to quickly plug-in Infrastructure as Code ( IaC ) controls into your DevOps pipeline. Shift-left \u2014 Identify configuration issues and provide fast feedback in PRs . Quality gates \u2014 Implement quality gates between environments such as dev, test, and prod. Monitor continuously \u2014 Perform ongoing checks for configuration optimization opportunities. Run on MacOS, Linux, and Windows or anywhere PowerShell is supported. Native support for popular continuous integration ( CI ) systems includes: GitHub Actions - Trigger tests for GitHub repositories using workflows. Azure Pipelines - Use tasks to run tests in Azure DevOps YAML or Classic pipelines and releases. Extensible # Import pre-built rules or define your own using YAML, JSON, or PowerShell format. Regardless of the format you choose, any combination of YAML, JSON, or PowerShell rules can be used together. YAML \u2014 Use a popular, easy to read, and learn IaC format. With YAML, you can quickly build out common rules with minimal effort and no scripting experience. JSON \u2014 Is ubiquitous used by many tools. While this format is typically harder to read then YAML it is easy to automate. You may prefer to use this format if you are generating rules with automation. PowerShell \u2014 Is a flexible scripting language. If you or your team already can write a basic PowerShell script, you can already define a rule. PowerShell allows you to tap into a large world-wide community of PowerShell users. Use existing cmdlets to help you build out rules quickly. Rules can be authored using any text editor, but we provide a native extension for Visual Studio Code. Use the extension to quickly author rules or run tests locally before you commit your IaC . Reusable # Typically unit tests in traditional testing frameworks are written for a specific case. This makes it hard invest in tests that are not easily reusable between projects. Several features of PSRule make it easier to reuse and share rules across teams or organizations. The following built-in features improve portability: Modular \u2014 Rules can be packages up into a standard PowerShell module then distributed. Private \u2014 Modules can be published privately on a network share or NuGet feed. Public \u2014 Distribute rules globally using the PowerShell Gallery. Configuration \u2014 PSRule and rules can be configured. Baselines \u2014 An artifact containing rules and configuration for a scenario. Suppression \u2014 Allows you to handle and keep exceptions auditable in git history. Approval \u2014 Use code owners and branch policy concepts to control changes. Documentation \u2014 Provide guidance on how to resolve detected issues. Quick - Use a one liner to quickly add a hint or reference on rules you build. Detailed - Support for markdown allows you to provide detailed detailed guidance to resolve issues.","title":"Features"},{"location":"features/#features","text":"","title":"Features"},{"location":"features/#devops","text":"PSRule allows you to quickly plug-in Infrastructure as Code ( IaC ) controls into your DevOps pipeline. Shift-left \u2014 Identify configuration issues and provide fast feedback in PRs . Quality gates \u2014 Implement quality gates between environments such as dev, test, and prod. Monitor continuously \u2014 Perform ongoing checks for configuration optimization opportunities. Run on MacOS, Linux, and Windows or anywhere PowerShell is supported. Native support for popular continuous integration ( CI ) systems includes: GitHub Actions - Trigger tests for GitHub repositories using workflows. Azure Pipelines - Use tasks to run tests in Azure DevOps YAML or Classic pipelines and releases.","title":"DevOps"},{"location":"features/#extensible","text":"Import pre-built rules or define your own using YAML, JSON, or PowerShell format. Regardless of the format you choose, any combination of YAML, JSON, or PowerShell rules can be used together. YAML \u2014 Use a popular, easy to read, and learn IaC format. With YAML, you can quickly build out common rules with minimal effort and no scripting experience. JSON \u2014 Is ubiquitous used by many tools. While this format is typically harder to read then YAML it is easy to automate. You may prefer to use this format if you are generating rules with automation. PowerShell \u2014 Is a flexible scripting language. If you or your team already can write a basic PowerShell script, you can already define a rule. PowerShell allows you to tap into a large world-wide community of PowerShell users. Use existing cmdlets to help you build out rules quickly. Rules can be authored using any text editor, but we provide a native extension for Visual Studio Code. Use the extension to quickly author rules or run tests locally before you commit your IaC .","title":"Extensible"},{"location":"features/#reusable","text":"Typically unit tests in traditional testing frameworks are written for a specific case. This makes it hard invest in tests that are not easily reusable between projects. Several features of PSRule make it easier to reuse and share rules across teams or organizations. The following built-in features improve portability: Modular \u2014 Rules can be packages up into a standard PowerShell module then distributed. Private \u2014 Modules can be published privately on a network share or NuGet feed. Public \u2014 Distribute rules globally using the PowerShell Gallery. Configuration \u2014 PSRule and rules can be configured. Baselines \u2014 An artifact containing rules and configuration for a scenario. Suppression \u2014 Allows you to handle and keep exceptions auditable in git history. Approval \u2014 Use code owners and branch policy concepts to control changes. Documentation \u2014 Provide guidance on how to resolve detected issues. Quick - Use a one liner to quickly add a hint or reference on rules you build. Detailed - Support for markdown allows you to provide detailed detailed guidance to resolve issues.","title":"Reusable"},{"location":"install-instructions/","text":"Installation # PSRule supports running within continuous integration ( CI ) systems or locally. It is shipped as a PowerShell module which makes it easy to install and distribute updates. Tip PSRule provides native integration to popular CI systems such as GitHub Actions and Azure Pipelines. If you are using a different CI system you can use the local install to run on MacOS, Linux, and Windows worker nodes. With GitHub Actions # GitHub Action Install and use PSRule with GitHub Actions by referencing the microsoft/ps-rule action. - name : Analyze Azure template files uses : microsoft/ps-rule@v2.4.2 This will automatically install compatible versions of all dependencies. With Azure Pipelines # Extension Install and use PSRule with Azure Pipeline by using extension tasks. Install the extension from the marketplace, then use the ps-rule-assert task in pipeline steps. - task : ps-rule-assert@2 displayName : Analyze Azure template files inputs : inputType : repository This will automatically install compatible versions of all dependencies. Installing locally # PSRule can be installed locally from the PowerShell Gallery using PowerShell. You can also use this option to install on CI workers that are not natively supported. The following platforms are supported: Windows PowerShell 5.1 with .NET Framework 4.7.2 or greater. PowerShell 7.2 or greater on MacOS, Linux, and Windows. Installing PowerShell # PowerShell 7.x can be installed on MacOS, Linux, and Windows but is not installed by default. For a list of platforms that PowerShell 7.2 is supported on and install instructions see Get PowerShell . Getting the modules # Module PSRule can be installed or updated from the PowerShell Gallery. Use the following command line examples from a PowerShell terminal to install or update PSRule. For the current user For all users To install PSRule for the current user use: Install-Module -Name 'PSRule' -Repository PSGallery -Scope CurrentUser To update PSRule for the current user use: Update-Module -Name 'PSRule' -Scope CurrentUser Open PowerShell with Run as administrator on Windows or sudo pwsh on Linux. To install PSRule for all users (requires admin/ root permissions) use: Install-Module -Name 'PSRule' -Repository PSGallery -Scope AllUsers To update PSRule for all users (requires admin/ root permissions) use: Update-Module -Name 'PSRule' -Scope AllUsers Pre-release versions # To use a pre-release version of PSRule add the -AllowPrerelease switch when calling Install-Module , Update-Module , or Save-Module cmdlets. Tip To install pre-release module versions, the latest version of PowerShellGet may be required. # Install the latest PowerShellGet version Install-Module -Name PowerShellGet -Repository PSGallery -Scope CurrentUser -Force For the current user For all users To install PSRule for the current user use: Install-Module -Name PowerShellGet -Repository PSGallery -Scope CurrentUser -Force Install-Module -Name 'PSRule' -Repository PSGallery -Scope CurrentUser -AllowPrerelease Open PowerShell with Run as administrator on Windows or sudo pwsh on Linux. To install PSRule for all users (requires admin/ root permissions) use: Install-Module -Name PowerShellGet -Repository PSGallery -Scope CurrentUser -Force Install-Module -Name 'PSRule' -Repository PSGallery -Scope AllUsers -AllowPrerelease Building from source # Source PSRule is provided as open source on GitHub. To build PSRule from source code: Clone the GitHub repository . Run ./build.ps1 from a PowerShell terminal in the cloned path. This build script will compile the module and documentation then output the result into out/modules/PSRule . Development dependencies # The following PowerShell modules will be automatically install if the required versions are not present: PlatyPS Pester PSScriptAnalyzer PowerShellGet PackageManagement InvokeBuild These additional modules are only required for building PSRule. Additionally .NET SDK v6 is required. .NET will not be automatically downloaded and installed. To download and install the latest SDK see Download .NET 6 . Limited access networks # If you are on a network that does not permit Internet access to the PowerShell Gallery, download the required PowerShell modules on an alternative device that has access. PowerShell provides the Save-Module cmdlet that can be run from a PowerShell terminal to do this. The following command lines can be used to download the required modules using a PowerShell terminal. After downloading the modules, copy the module directories to devices with restricted Internet access. Runtime modules Development modules To save PSRule for offline use: Save-Module -Name 'PSRule' -Path '.\\modules' This will save PSRule into the modules sub-directory. To save PSRule development module dependencies for offline use: $modules = @( 'PlatyPS' , 'Pester' , 'PSScriptAnalyzer' , 'PowerShellGet' , 'PackageManagement' , 'InvokeBuild' ) Save-Module -Name $modules -Repository PSGallery -Path '.\\modules' ; This will save required developments dependencies into the modules sub-directory.","title":"Installation"},{"location":"install-instructions/#installation","text":"PSRule supports running within continuous integration ( CI ) systems or locally. It is shipped as a PowerShell module which makes it easy to install and distribute updates. Tip PSRule provides native integration to popular CI systems such as GitHub Actions and Azure Pipelines. If you are using a different CI system you can use the local install to run on MacOS, Linux, and Windows worker nodes.","title":"Installation"},{"location":"install-instructions/#with-github-actions","text":"GitHub Action Install and use PSRule with GitHub Actions by referencing the microsoft/ps-rule action. - name : Analyze Azure template files uses : microsoft/ps-rule@v2.4.2 This will automatically install compatible versions of all dependencies.","title":"With GitHub Actions"},{"location":"install-instructions/#with-azure-pipelines","text":"Extension Install and use PSRule with Azure Pipeline by using extension tasks. Install the extension from the marketplace, then use the ps-rule-assert task in pipeline steps. - task : ps-rule-assert@2 displayName : Analyze Azure template files inputs : inputType : repository This will automatically install compatible versions of all dependencies.","title":"With Azure Pipelines"},{"location":"install-instructions/#installing-locally","text":"PSRule can be installed locally from the PowerShell Gallery using PowerShell. You can also use this option to install on CI workers that are not natively supported. The following platforms are supported: Windows PowerShell 5.1 with .NET Framework 4.7.2 or greater. PowerShell 7.2 or greater on MacOS, Linux, and Windows.","title":"Installing locally"},{"location":"install-instructions/#installing-powershell","text":"PowerShell 7.x can be installed on MacOS, Linux, and Windows but is not installed by default. For a list of platforms that PowerShell 7.2 is supported on and install instructions see Get PowerShell .","title":"Installing PowerShell"},{"location":"install-instructions/#getting-the-modules","text":"Module PSRule can be installed or updated from the PowerShell Gallery. Use the following command line examples from a PowerShell terminal to install or update PSRule. For the current user For all users To install PSRule for the current user use: Install-Module -Name 'PSRule' -Repository PSGallery -Scope CurrentUser To update PSRule for the current user use: Update-Module -Name 'PSRule' -Scope CurrentUser Open PowerShell with Run as administrator on Windows or sudo pwsh on Linux. To install PSRule for all users (requires admin/ root permissions) use: Install-Module -Name 'PSRule' -Repository PSGallery -Scope AllUsers To update PSRule for all users (requires admin/ root permissions) use: Update-Module -Name 'PSRule' -Scope AllUsers","title":"Getting the modules"},{"location":"install-instructions/#pre-release-versions","text":"To use a pre-release version of PSRule add the -AllowPrerelease switch when calling Install-Module , Update-Module , or Save-Module cmdlets. Tip To install pre-release module versions, the latest version of PowerShellGet may be required. # Install the latest PowerShellGet version Install-Module -Name PowerShellGet -Repository PSGallery -Scope CurrentUser -Force For the current user For all users To install PSRule for the current user use: Install-Module -Name PowerShellGet -Repository PSGallery -Scope CurrentUser -Force Install-Module -Name 'PSRule' -Repository PSGallery -Scope CurrentUser -AllowPrerelease Open PowerShell with Run as administrator on Windows or sudo pwsh on Linux. To install PSRule for all users (requires admin/ root permissions) use: Install-Module -Name PowerShellGet -Repository PSGallery -Scope CurrentUser -Force Install-Module -Name 'PSRule' -Repository PSGallery -Scope AllUsers -AllowPrerelease","title":"Pre-release versions"},{"location":"install-instructions/#building-from-source","text":"Source PSRule is provided as open source on GitHub. To build PSRule from source code: Clone the GitHub repository . Run ./build.ps1 from a PowerShell terminal in the cloned path. This build script will compile the module and documentation then output the result into out/modules/PSRule .","title":"Building from source"},{"location":"install-instructions/#development-dependencies","text":"The following PowerShell modules will be automatically install if the required versions are not present: PlatyPS Pester PSScriptAnalyzer PowerShellGet PackageManagement InvokeBuild These additional modules are only required for building PSRule. Additionally .NET SDK v6 is required. .NET will not be automatically downloaded and installed. To download and install the latest SDK see Download .NET 6 .","title":"Development dependencies"},{"location":"install-instructions/#limited-access-networks","text":"If you are on a network that does not permit Internet access to the PowerShell Gallery, download the required PowerShell modules on an alternative device that has access. PowerShell provides the Save-Module cmdlet that can be run from a PowerShell terminal to do this. The following command lines can be used to download the required modules using a PowerShell terminal. After downloading the modules, copy the module directories to devices with restricted Internet access. Runtime modules Development modules To save PSRule for offline use: Save-Module -Name 'PSRule' -Path '.\\modules' This will save PSRule into the modules sub-directory. To save PSRule development module dependencies for offline use: $modules = @( 'PlatyPS' , 'Pester' , 'PSScriptAnalyzer' , 'PowerShellGet' , 'PackageManagement' , 'InvokeBuild' ) Save-Module -Name $modules -Repository PSGallery -Path '.\\modules' ; This will save required developments dependencies into the modules sub-directory.","title":"Limited access networks"},{"location":"license-contributing/","text":"License and contributing # PSRule is licensed with an MIT License , which means it's free to use and modify. But please check out the details. We open source at Microsoft. In addition to our team, we hope you will think about contributing too. Here is how you can get started: Report issues. Upvote existing issues that are important to you. Improve documentation. Contribute code.","title":"License and contributing"},{"location":"license-contributing/#license-and-contributing","text":"PSRule is licensed with an MIT License , which means it's free to use and modify. But please check out the details. We open source at Microsoft. In addition to our team, we hope you will think about contributing too. Here is how you can get started: Report issues. Upvote existing issues that are important to you. Improve documentation. Contribute code.","title":"License and contributing"},{"location":"related-projects/","text":"Related projects # The PSRule project is distributed across multiple repositories. You can find out more by visiting each repository. Name Description ps-rule GitHub continuous integration using GitHub Actions. PSRule-pipelines Azure DevOps continuous integration using Azure Pipelines. PSRule-vscode Support for running and authoring rules within Visual Studio Code. PSRule.Monitor Support for logging PSRule analysis results to Azure Monitor. PSRule.Rules.Azure Rules to validate Azure resources and infrastructure as code (IaC) using PSRule. PSRule.Rules.Azure-quickstart Sample code you can use to quickly start using PSRule for Azure. PSRule.Rules.CAF A suite of rules to validate Azure resources against the Cloud Adoption Framework (CAF) using PSRule. PSRule.Rules.GitHub A suite of rules to validate GitHub repositories using PSRule. PSRule.Rules.Kubernetes A suite of rules to validate Kubernetes resources using PSRule. PSRule.Rules.MSFT.OSS A suite of rules to validate repositories against Microsoft Open Source Software (OSS) requirements.","title":"Related projects"},{"location":"related-projects/#related-projects","text":"The PSRule project is distributed across multiple repositories. You can find out more by visiting each repository. Name Description ps-rule GitHub continuous integration using GitHub Actions. PSRule-pipelines Azure DevOps continuous integration using Azure Pipelines. PSRule-vscode Support for running and authoring rules within Visual Studio Code. PSRule.Monitor Support for logging PSRule analysis results to Azure Monitor. PSRule.Rules.Azure Rules to validate Azure resources and infrastructure as code (IaC) using PSRule. PSRule.Rules.Azure-quickstart Sample code you can use to quickly start using PSRule for Azure. PSRule.Rules.CAF A suite of rules to validate Azure resources against the Cloud Adoption Framework (CAF) using PSRule. PSRule.Rules.GitHub A suite of rules to validate GitHub repositories using PSRule. PSRule.Rules.Kubernetes A suite of rules to validate Kubernetes resources using PSRule. PSRule.Rules.MSFT.OSS A suite of rules to validate repositories against Microsoft Open Source Software (OSS) requirements.","title":"Related projects"},{"location":"support/","text":"Support # This project uses GitHub Issues to track bugs and feature requests. Please search the existing issues before filing new issues to avoid duplicates. For new issues, file your bug or feature request as a new issue . For help, discussion, and support questions about using this project, join or start a discussion . Microsoft Support Policy # Support for this project/ product is limited to the resources listed above.","title":"Support"},{"location":"support/#support","text":"This project uses GitHub Issues to track bugs and feature requests. Please search the existing issues before filing new issues to avoid duplicates. For new issues, file your bug or feature request as a new issue . For help, discussion, and support questions about using this project, join or start a discussion .","title":"Support"},{"location":"support/#microsoft-support-policy","text":"Support for this project/ product is limited to the resources listed above.","title":"Microsoft Support Policy"},{"location":"upgrade-notes/","text":"Upgrade notes # This document contains notes to help upgrade from previous versions of PSRule. Upgrading to v2.0.0 # Resources naming restrictions # When naming resources such as rules or selectors, the following restrictions apply: Use between 3 and 128 characters \u2014 This is the minimum and maximum length of a resource name. Only use allowed characters \u2014 To preserve consistency between file systems, some characters are not permitted. Dots, hyphens, and underscores are not permitted at the start and end of the name. Additionally some characters are restricted for future use. The following characters are not permitted: < (less than) > (greater than) : (colon) / (forward slash) \\ (backslash) | (vertical bar or pipe) ? (question mark) * (asterisk) \" (double quote) ' (single quote) ` (backtick) + (plus) @ (at sign) Integer value zero, sometimes referred to as the ASCII NUL character. Characters whose integer representations are in the range from 1 through 31. Prior to v2.0.0 , there was no specific naming restriction for resources. However functionally PSRule and downstream components could not support all resource names. To avoid confusion, we have decided to restrict resource names to a specific set of characters. From v2.0.0 , resource names that do not meet the naming restrictions will generate an error. Regular expression for valid resource names ^[^<>:/\\\\|?*\"'`+@._\\-\\x00-\\x1F][^<>:/\\\\|?*\"'`+@\\x00-\\x1F]{1,126}[^<>:/\\\\|?*\"'`+@._\\-\\x00-\\x1F]$ Setting default module baseline # When packaging rules in a module, you can set the default baseline. The default baseline from the module will be automatically used unless overridden. Prior to v1.9.0 the default baseline was set by configuring the module manifest .psd1 file. From v1.9.0 the default baseline can be configured by within a module configuration. Using module configuration is the recommended method. Setting the default baseline from module manifest and has been removed from v2.0.0 . A module configuration can be defined in YAML. Example --- # Synopsis: Example module configuration for Enterprise.Rules module. apiVersion : github.com/microsoft/PSRule/v1 kind : ModuleConfig metadata : name : Enterprise.Rules spec : rule : baseline : Enterprise.Default Setting resource API version # When creating YAML and JSON resources you define a resource by specifying the apiVersion and kind . An apiVersion was added as a requirement from v1.2.0 . For compatibility, resources without an apiVersion were supported however deprecated for removal. This has now been removed from v2.0.0 . When defining resource specify an apiVersion . Currently this must be set to github.com/microsoft/PSRule/v1 . YAML JSON --- # Synopsis: An example rule to require TLS. apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'Local.YAML.RequireTLS' spec : condition : field : 'configure.supportsHttpsTrafficOnly' equals : true [ { // Synopsis: An example rule to require TLS. \"apiVersion\" : \"github.com/microsoft/PSRule/v1\" , \"kind\" : \"Rule\" , \"metadata\" : { \"name\" : \"Local.JSON.RequireTLS\" }, \"spec\" : { \"condition\" : { \"field\" : \"configure.supportsHttpsTrafficOnly\" , \"equals\" : true } } } ] Change in source file discovery for Get-PSRuleHelp # Previously in PSRule v1.11.0 and prior versions, rules would show up twice when running Get-PSRuleHelp in the context of a module and in the same working directory of the module. This behavior has now been removed from v2.0.0 . Module files are now preferred over loose files, and rules are only shown once in the output. Any duplicate rule names from loose files are outputted as a warning instead. The old behavior: Name ModuleName Synopsis ---- ---------- -------- M1 . Rule1 This is the default M1 . Rule2 This is the default M1 . Rule1 TestModule Synopsis en-AU . M1 . Rule2 TestModule This is the default The new behavior: WARNING : A rule with the same name 'M1.Rule1' already exists . WARNING : A rule with the same name 'M1.Rule2' already exists . Name ModuleName Synopsis ---- ---------- -------- M1 . Rule1 TestModule Synopsis en-AU . M1 . Rule2 TestModule This is the default Require source discovery from current working directory to be explicitly included # Previously in PSRule v1.11.0 and prior versions, rule sources from the current working directory without the -Path and -Module parameters were automatically included. This behavior has now been removed from v2.0.0 . Rules sources in the current working directory are only included if -Path . or -Path $PWD is specified. The old behavior: Set-Location docs \\ scenarios \\ azure-resources Get-PSRule RuleName ModuleName Synopsis -------- ---------- -------- appServicePlan . MinInstanceCount App Service Plan has multiple instances appServicePlan . MinPlan Use at least a Standard App Service Plan appServiceApp . ARRAffinity Disable client affinity for stateless services appServiceApp . UseHTTPS Use HTTPS only storageAccounts . UseHttps Configure storage accounts to only accept encrypted traffic i . e . HTTPS / SMB storageAccounts . UseEncryption Use at-rest storage encryption The new behavior: Set-Location docs \\ scenarios \\ azure-resources Get-PSRule # No output, need to specify -Path explicitly Get-PSRule -Path $PWD RuleName ModuleName Synopsis -------- ---------- -------- appServicePlan . MinInstanceCount App Service Plan has multiple instances appServicePlan . MinPlan Use at least a Standard App Service Plan appServiceApp . ARRAffinity Disable client affinity for stateless services appServiceApp . UseHTTPS Use HTTPS only storageAccounts . UseHttps Configure storage accounts to only accept encrypted traffic i . e . HTTPS / SMB storageAccounts . UseEncryption Upgrading to v1.4.0 # Follow these notes to upgrade to PSRule v1.4.0 from previous versions. Change in default output styles # Previously in PSRule v1.3.0 and prior the default style when using Assert-PSRule was Client . From v1.4.0 PSRule now defaults to Detect . The Detect output style falls back to Client however may detect one of the following styles instead: AzurePipelines - Output is written for integration Azure Pipelines. GitHubActions - Output is written for integration GitHub Actions. VisualStudioCode - Output is written for integration with Visual Studio Code. Detect uses the following logic: If the TF_BUILD environment variable is set to true , AzurePipelines will be used. If the GITHUB_ACTIONS environment variable is set to true , GitHubActions will be used. If the TERM_PROGRAM environment variable is set to vscode , VisualStudioCode will be used. Use Client . To force usage of the Client output style set the Output.Style option. For example: # YAML: Using the output/style property output : style : Client # Bash: Using environment variable export PSRULE_OUTPUT_STYLE = Client # GitHub Actions: Using environment variable env : PSRULE_OUTPUT_STYLE : Client # Azure Pipelines: Using environment variable variables : - name : PSRULE_OUTPUT_STYLE value : Client Upgrading to v1.0.0 # Follow these notes to upgrade to PSRule v1.0.0 from previous versions. Replaced $Rule target properties # Previously in PSRule v0.22.0 and prior the $Rule automatic variable had the following properties: TargetName TargetType TargetObject For example: Rule 'Rule1' { $Rule . TargetName -eq 'Name1' ; $Rule . TargetType -eq '.json' ; $Rule . TargetObject . someProperty -eq 1 ; } In v1.0.0 these properties have been removed after being deprecated in v0.12.0 . These properties are instead available on the $PSRule variable. Rules referencing the deprecated properties of $Rule must be updated. For example: Rule 'Rule1' { $PSRule . TargetName -eq 'Name1' ; $PSRule . TargetType -eq '.json' ; $PSRule . TargetObject . someProperty -eq 1 ; }","title":"Upgrade notes"},{"location":"upgrade-notes/#upgrade-notes","text":"This document contains notes to help upgrade from previous versions of PSRule.","title":"Upgrade notes"},{"location":"upgrade-notes/#upgrading-to-v200","text":"","title":"Upgrading to v2.0.0"},{"location":"upgrade-notes/#resources-naming-restrictions","text":"When naming resources such as rules or selectors, the following restrictions apply: Use between 3 and 128 characters \u2014 This is the minimum and maximum length of a resource name. Only use allowed characters \u2014 To preserve consistency between file systems, some characters are not permitted. Dots, hyphens, and underscores are not permitted at the start and end of the name. Additionally some characters are restricted for future use. The following characters are not permitted: < (less than) > (greater than) : (colon) / (forward slash) \\ (backslash) | (vertical bar or pipe) ? (question mark) * (asterisk) \" (double quote) ' (single quote) ` (backtick) + (plus) @ (at sign) Integer value zero, sometimes referred to as the ASCII NUL character. Characters whose integer representations are in the range from 1 through 31. Prior to v2.0.0 , there was no specific naming restriction for resources. However functionally PSRule and downstream components could not support all resource names. To avoid confusion, we have decided to restrict resource names to a specific set of characters. From v2.0.0 , resource names that do not meet the naming restrictions will generate an error. Regular expression for valid resource names ^[^<>:/\\\\|?*\"'`+@._\\-\\x00-\\x1F][^<>:/\\\\|?*\"'`+@\\x00-\\x1F]{1,126}[^<>:/\\\\|?*\"'`+@._\\-\\x00-\\x1F]$","title":"Resources naming restrictions"},{"location":"upgrade-notes/#setting-default-module-baseline","text":"When packaging rules in a module, you can set the default baseline. The default baseline from the module will be automatically used unless overridden. Prior to v1.9.0 the default baseline was set by configuring the module manifest .psd1 file. From v1.9.0 the default baseline can be configured by within a module configuration. Using module configuration is the recommended method. Setting the default baseline from module manifest and has been removed from v2.0.0 . A module configuration can be defined in YAML. Example --- # Synopsis: Example module configuration for Enterprise.Rules module. apiVersion : github.com/microsoft/PSRule/v1 kind : ModuleConfig metadata : name : Enterprise.Rules spec : rule : baseline : Enterprise.Default","title":"Setting default module baseline"},{"location":"upgrade-notes/#setting-resource-api-version","text":"When creating YAML and JSON resources you define a resource by specifying the apiVersion and kind . An apiVersion was added as a requirement from v1.2.0 . For compatibility, resources without an apiVersion were supported however deprecated for removal. This has now been removed from v2.0.0 . When defining resource specify an apiVersion . Currently this must be set to github.com/microsoft/PSRule/v1 . YAML JSON --- # Synopsis: An example rule to require TLS. apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'Local.YAML.RequireTLS' spec : condition : field : 'configure.supportsHttpsTrafficOnly' equals : true [ { // Synopsis: An example rule to require TLS. \"apiVersion\" : \"github.com/microsoft/PSRule/v1\" , \"kind\" : \"Rule\" , \"metadata\" : { \"name\" : \"Local.JSON.RequireTLS\" }, \"spec\" : { \"condition\" : { \"field\" : \"configure.supportsHttpsTrafficOnly\" , \"equals\" : true } } } ]","title":"Setting resource API version"},{"location":"upgrade-notes/#change-in-source-file-discovery-for-get-psrulehelp","text":"Previously in PSRule v1.11.0 and prior versions, rules would show up twice when running Get-PSRuleHelp in the context of a module and in the same working directory of the module. This behavior has now been removed from v2.0.0 . Module files are now preferred over loose files, and rules are only shown once in the output. Any duplicate rule names from loose files are outputted as a warning instead. The old behavior: Name ModuleName Synopsis ---- ---------- -------- M1 . Rule1 This is the default M1 . Rule2 This is the default M1 . Rule1 TestModule Synopsis en-AU . M1 . Rule2 TestModule This is the default The new behavior: WARNING : A rule with the same name 'M1.Rule1' already exists . WARNING : A rule with the same name 'M1.Rule2' already exists . Name ModuleName Synopsis ---- ---------- -------- M1 . Rule1 TestModule Synopsis en-AU . M1 . Rule2 TestModule This is the default","title":"Change in source file discovery for Get-PSRuleHelp"},{"location":"upgrade-notes/#require-source-discovery-from-current-working-directory-to-be-explicitly-included","text":"Previously in PSRule v1.11.0 and prior versions, rule sources from the current working directory without the -Path and -Module parameters were automatically included. This behavior has now been removed from v2.0.0 . Rules sources in the current working directory are only included if -Path . or -Path $PWD is specified. The old behavior: Set-Location docs \\ scenarios \\ azure-resources Get-PSRule RuleName ModuleName Synopsis -------- ---------- -------- appServicePlan . MinInstanceCount App Service Plan has multiple instances appServicePlan . MinPlan Use at least a Standard App Service Plan appServiceApp . ARRAffinity Disable client affinity for stateless services appServiceApp . UseHTTPS Use HTTPS only storageAccounts . UseHttps Configure storage accounts to only accept encrypted traffic i . e . HTTPS / SMB storageAccounts . UseEncryption Use at-rest storage encryption The new behavior: Set-Location docs \\ scenarios \\ azure-resources Get-PSRule # No output, need to specify -Path explicitly Get-PSRule -Path $PWD RuleName ModuleName Synopsis -------- ---------- -------- appServicePlan . MinInstanceCount App Service Plan has multiple instances appServicePlan . MinPlan Use at least a Standard App Service Plan appServiceApp . ARRAffinity Disable client affinity for stateless services appServiceApp . UseHTTPS Use HTTPS only storageAccounts . UseHttps Configure storage accounts to only accept encrypted traffic i . e . HTTPS / SMB storageAccounts . UseEncryption","title":"Require source discovery from current working directory to be explicitly included"},{"location":"upgrade-notes/#upgrading-to-v140","text":"Follow these notes to upgrade to PSRule v1.4.0 from previous versions.","title":"Upgrading to v1.4.0"},{"location":"upgrade-notes/#change-in-default-output-styles","text":"Previously in PSRule v1.3.0 and prior the default style when using Assert-PSRule was Client . From v1.4.0 PSRule now defaults to Detect . The Detect output style falls back to Client however may detect one of the following styles instead: AzurePipelines - Output is written for integration Azure Pipelines. GitHubActions - Output is written for integration GitHub Actions. VisualStudioCode - Output is written for integration with Visual Studio Code. Detect uses the following logic: If the TF_BUILD environment variable is set to true , AzurePipelines will be used. If the GITHUB_ACTIONS environment variable is set to true , GitHubActions will be used. If the TERM_PROGRAM environment variable is set to vscode , VisualStudioCode will be used. Use Client . To force usage of the Client output style set the Output.Style option. For example: # YAML: Using the output/style property output : style : Client # Bash: Using environment variable export PSRULE_OUTPUT_STYLE = Client # GitHub Actions: Using environment variable env : PSRULE_OUTPUT_STYLE : Client # Azure Pipelines: Using environment variable variables : - name : PSRULE_OUTPUT_STYLE value : Client","title":"Change in default output styles"},{"location":"upgrade-notes/#upgrading-to-v100","text":"Follow these notes to upgrade to PSRule v1.0.0 from previous versions.","title":"Upgrading to v1.0.0"},{"location":"upgrade-notes/#replaced-rule-target-properties","text":"Previously in PSRule v0.22.0 and prior the $Rule automatic variable had the following properties: TargetName TargetType TargetObject For example: Rule 'Rule1' { $Rule . TargetName -eq 'Name1' ; $Rule . TargetType -eq '.json' ; $Rule . TargetObject . someProperty -eq 1 ; } In v1.0.0 these properties have been removed after being deprecated in v0.12.0 . These properties are instead available on the $PSRule variable. Rules referencing the deprecated properties of $Rule must be updated. For example: Rule 'Rule1' { $PSRule . TargetName -eq 'Name1' ; $PSRule . TargetType -eq '.json' ; $PSRule . TargetObject . someProperty -eq 1 ; }","title":"Replaced $Rule target properties"},{"location":"validating-locally/","text":"Validating locally # PSRule can be installed locally on MacOS, Linux, and Windows for local validation. This allows you to test Infrastructure as Code (IaC) artifacts before pushing changes to a repository. Tip If you haven't already, follow the instructions on installing locally before continuing. With Visual Studio Code # Extension An extension for Visual Studio Code is available for an integrated experience using PSRule. The Visual Studio Code extension includes a built-in task PSRule: Run analysis task. Info To learn about tasks in Visual Studio Code see Integrate with External Tools via Tasks . Customizing the task # The PSRule: Run analysis task will be available automatically after you install the PSRule extension. You can customize the defaults of the task by editing or inserting the task into .vscode/tasks.json within your workspace. JSON { \"type\" : \"PSRule\" , \"problemMatcher\" : [ \"$PSRule\" ], \"label\" : \"PSRule: Run analysis\" , \"modules\" : [ \"PSRule.Rules.Azure\" ], \"presentation\" : { \"clear\" : true , \"panel\" : \"dedicated\" } } Example A complete .vscode/tasks.json might look like the following: .vscode/tasks.json { \"version\" : \"2.0.0\" , \"tasks\" : [ { \"type\" : \"PSRule\" , \"problemMatcher\" : [ \"$PSRule\" ], \"label\" : \"PSRule: Run analysis\" , \"modules\" : [ \"PSRule.Rules.Azure\" ], \"presentation\" : { \"clear\" : true , \"panel\" : \"dedicated\" } } ] }","title":"Validating locally"},{"location":"validating-locally/#validating-locally","text":"PSRule can be installed locally on MacOS, Linux, and Windows for local validation. This allows you to test Infrastructure as Code (IaC) artifacts before pushing changes to a repository. Tip If you haven't already, follow the instructions on installing locally before continuing.","title":"Validating locally"},{"location":"validating-locally/#with-visual-studio-code","text":"Extension An extension for Visual Studio Code is available for an integrated experience using PSRule. The Visual Studio Code extension includes a built-in task PSRule: Run analysis task. Info To learn about tasks in Visual Studio Code see Integrate with External Tools via Tasks .","title":"With Visual Studio Code"},{"location":"validating-locally/#customizing-the-task","text":"The PSRule: Run analysis task will be available automatically after you install the PSRule extension. You can customize the defaults of the task by editing or inserting the task into .vscode/tasks.json within your workspace. JSON { \"type\" : \"PSRule\" , \"problemMatcher\" : [ \"$PSRule\" ], \"label\" : \"PSRule: Run analysis\" , \"modules\" : [ \"PSRule.Rules.Azure\" ], \"presentation\" : { \"clear\" : true , \"panel\" : \"dedicated\" } } Example A complete .vscode/tasks.json might look like the following: .vscode/tasks.json { \"version\" : \"2.0.0\" , \"tasks\" : [ { \"type\" : \"PSRule\" , \"problemMatcher\" : [ \"$PSRule\" ], \"label\" : \"PSRule: Run analysis\" , \"modules\" : [ \"PSRule.Rules.Azure\" ], \"presentation\" : { \"clear\" : true , \"panel\" : \"dedicated\" } } ] }","title":"Customizing the task"},{"location":"versioning/","text":"Changes and versioning # PSRule uses semantic versioning to declare breaking changes. The latest module version can be installed from the PowerShell Gallery. For a list of module changes please see the change log . Pre-releases # Pre-release module versions are created on major commits and can be installed from the PowerShell Gallery. Module versions and change log details for pre-releases will be removed as stable releases are made available. Important Pre-release versions should be considered work in progress. These releases should not be used in production. We may introduce breaking changes between a pre-release as we work towards a stable version release. Experimental features # From time to time we may ship experimential features. These features are generally marked experimential in the change log as these features ship. Experimental features may ship in stable releases, however to use them you may need to: Enabled or explictly reference them. Important Experimental features should be considered work in progress. These features may be incomplete and should not be used in production. We may introduce breaking changes for experimental features as we work towards a general release for the feature. Reporting bugs # If you experience an issue with an pre-release or experimental feature please let us know by logging an issue as a bug .","title":"Changes and versioning"},{"location":"versioning/#changes-and-versioning","text":"PSRule uses semantic versioning to declare breaking changes. The latest module version can be installed from the PowerShell Gallery. For a list of module changes please see the change log .","title":"Changes and versioning"},{"location":"versioning/#pre-releases","text":"Pre-release module versions are created on major commits and can be installed from the PowerShell Gallery. Module versions and change log details for pre-releases will be removed as stable releases are made available. Important Pre-release versions should be considered work in progress. These releases should not be used in production. We may introduce breaking changes between a pre-release as we work towards a stable version release.","title":"Pre-releases"},{"location":"versioning/#experimental-features","text":"From time to time we may ship experimential features. These features are generally marked experimential in the change log as these features ship. Experimental features may ship in stable releases, however to use them you may need to: Enabled or explictly reference them. Important Experimental features should be considered work in progress. These features may be incomplete and should not be used in production. We may introduce breaking changes for experimental features as we work towards a general release for the feature.","title":"Experimental features"},{"location":"versioning/#reporting-bugs","text":"If you experience an issue with an pre-release or experimental feature please let us know by logging an issue as a bug .","title":"Reporting bugs"},{"location":"authoring/packaging-rules/","text":"Packaging rules in a module # PSRule supports distribution of rules within modules. Using a module, rules can be published and installed using standard PowerShell cmdlets. You should consider packaging rules into a module to: Version rules. PowerShell modules support semantic versioning (semver). Reuse rules across projects, pipelines or teams. Publish rules to external consumers via the PowerShell Gallery. This scenario covers the following: Creating a module manifest Including rules and baselines Defining a module configuration Including documentation Creating a module manifest # When creating a PowerShell module, a module manifest is an optional file that stores module metadata. Module manifests use the .psd1 file extension. When packaging rules in a module, a module manifest is required for PSRule discover the module. Creating the manifest file # A module manifest can be created from PowerShell using the New-ModuleManifest cmdlet. Additionally, Visual Studio Code and many other tools also include snippets for creating a module manifest. For example: # Create a directory for the module md ./ Enterprise . Rules ; # Create the manifest New-ModuleManifest -Path ./ Enterprise . Rules / Enterprise . Rules . psd1 -Tags 'PSRule-rules' ; The example above creates a module manifest for a module named Enterprise.Rules tagged with PSRule-rules . The use of the PSRule-rules tag is explained in the following section. Setting module tags # When PSRule cmdlets are used with the -Module parameter, PSRule discovers rule modules. If the module is already imported, that module is used. If the module is not imported, PSRule will import the highest version of the module automatically. For a module to be discovered by PSRule, tag the module with PSRule-rules . To tag modules, find the Tags section the PSData hashtable in the module manifest and add PSRule-rules . An updated module manifest may look like this: # Private data to pass to the module specified in RootModule/ModuleToProcess. This may also contain a PSData hashtable with additional module metadata used by PowerShell. PrivateData = @{ PSData = @{ # Tags applied to this module. These help with module discovery in online galleries. Tags = @( 'PSRule-rules' ) } } Including rules and baselines # Rules and baselines can be included anywhere within the module directory structure. Such as in the root directory of the module or in a nested sub-directory. By convention, consider including rules and baselines within a rules sub-directory within the module. For example: Enterprise.Rules/ rules/ Baseline.Rule.yaml Config.Rule.yaml Standards.Rule.ps1 Enterprise.Rules.psd1 File names # For PSRule to find rules included in a module, rule file names must end with the .Rule.ps1 suffix. We recommend using the exact case .Rule.ps1 . This is because some file systems are case-sensitive. For example, on Linux Standards.rule.ps1 would be ignored by PSRule. Similarly, when including baselines within a module use the .Rule.yaml suffix. Defining a module configuration # A module configuration that sets options defaults and can be optionally packaged with a module. To set a module configuration, define a ModuleConfig resource within an included .Rule.yaml file. A module configuration .Rule.yaml file must be distributed within the module directory structure. PSRule only supports a single ModuleConfig resource. The name of the ModuleConfig must match the name of the module. Additional ModuleConfig resources or with an alternative name are ignored. PSRule does not support module configurations distributed outside of a module. Example --- # Synopsis: Example module configuration for Enterprise.Rules module. apiVersion : github.com/microsoft/PSRule/v1 kind : ModuleConfig metadata : name : Enterprise.Rules spec : binding : targetName : - ResourceName - FullName - name targetType : - ResourceType - type - Extension field : resourceId : [ 'ResourceId' ] subscriptionId : [ 'SubscriptionId' ] resourceGroupName : [ 'ResourceGroupName' ] rule : baseline : Enterprise.Default The following options are allowed within a ModuleConfig : Binding.Field Binding.IgnoreCase Binding.NameSeparator Binding.PreferTargetInfo Binding.TargetName Binding.TargetType Binding.UseQualifiedName Configuration Output.Culture Rule.Baseline Setting a default baseline # Optionally, baselines can be included in rule modules. If a baseline contains configuration or binding options then setting a default baseline is often desirable. When a default baseline is set, PSRule will use the named baseline automatically when processing rules from that module. This feature removes the need for users to specify it manually. To set a default baseline, set the Rule.Baseline property of the ModuleConfig resource. Example --- # Synopsis: Example module configuration for Enterprise.Rules module. apiVersion : github.com/microsoft/PSRule/v1 kind : ModuleConfig metadata : name : Enterprise.Rules spec : binding : targetName : - ResourceName - FullName - name targetType : - ResourceType - type - Extension field : resourceId : [ 'ResourceId' ] subscriptionId : [ 'SubscriptionId' ] resourceGroupName : [ 'ResourceGroupName' ] rule : baseline : Enterprise.Default This examples set the default baseline to Enterprise.Default . The default baseline must be included in file ending with .Rule.yaml within the module directory structure. Including documentation # PSRule supports write and packaging rule modules with markdown documentation. Markdown documentation is automatically interpreted by PSRule and included in output. When including markdown, files are copied into a directory structure based on the target culture. For example, store documentation targeted to the culture en-US in a directory named en-US . Similarly, documentation for cultures such as en-AU , en-GB and fr-FR would be in separate directories. If a directory for the exact culture en-US doesn't exist, PSRule will attempt to find the parent culture. For example, documentation would be read from a directory named en . When naming directories for their culture, use exact case. This is because some file systems are case-sensitive. For example on Linux en-us would not match. For example: Enterprise.Rules/ en/ Org.Az.Storage.UseHttps.md Org.Az.Resource.Tagging.md en-US/ Org.Az.Storage.UseHttps.md fr-FR/ Org.Az.Storage.UseHttps.md rules/ Baseline.Rule.yaml Config.Rule.yaml Standards.Rule.ps1 Enterprise.Rules.psd1 More information # Enterprise.Rules.psd1 - An example module manifest. Baseline.Rule.yaml - An example baseline. Config.Rule.yaml - An example module configuration.","title":"Packaging rules in a module"},{"location":"authoring/packaging-rules/#packaging-rules-in-a-module","text":"PSRule supports distribution of rules within modules. Using a module, rules can be published and installed using standard PowerShell cmdlets. You should consider packaging rules into a module to: Version rules. PowerShell modules support semantic versioning (semver). Reuse rules across projects, pipelines or teams. Publish rules to external consumers via the PowerShell Gallery. This scenario covers the following: Creating a module manifest Including rules and baselines Defining a module configuration Including documentation","title":"Packaging rules in a module"},{"location":"authoring/packaging-rules/#creating-a-module-manifest","text":"When creating a PowerShell module, a module manifest is an optional file that stores module metadata. Module manifests use the .psd1 file extension. When packaging rules in a module, a module manifest is required for PSRule discover the module.","title":"Creating a module manifest"},{"location":"authoring/packaging-rules/#creating-the-manifest-file","text":"A module manifest can be created from PowerShell using the New-ModuleManifest cmdlet. Additionally, Visual Studio Code and many other tools also include snippets for creating a module manifest. For example: # Create a directory for the module md ./ Enterprise . Rules ; # Create the manifest New-ModuleManifest -Path ./ Enterprise . Rules / Enterprise . Rules . psd1 -Tags 'PSRule-rules' ; The example above creates a module manifest for a module named Enterprise.Rules tagged with PSRule-rules . The use of the PSRule-rules tag is explained in the following section.","title":"Creating the manifest file"},{"location":"authoring/packaging-rules/#setting-module-tags","text":"When PSRule cmdlets are used with the -Module parameter, PSRule discovers rule modules. If the module is already imported, that module is used. If the module is not imported, PSRule will import the highest version of the module automatically. For a module to be discovered by PSRule, tag the module with PSRule-rules . To tag modules, find the Tags section the PSData hashtable in the module manifest and add PSRule-rules . An updated module manifest may look like this: # Private data to pass to the module specified in RootModule/ModuleToProcess. This may also contain a PSData hashtable with additional module metadata used by PowerShell. PrivateData = @{ PSData = @{ # Tags applied to this module. These help with module discovery in online galleries. Tags = @( 'PSRule-rules' ) } }","title":"Setting module tags"},{"location":"authoring/packaging-rules/#including-rules-and-baselines","text":"Rules and baselines can be included anywhere within the module directory structure. Such as in the root directory of the module or in a nested sub-directory. By convention, consider including rules and baselines within a rules sub-directory within the module. For example: Enterprise.Rules/ rules/ Baseline.Rule.yaml Config.Rule.yaml Standards.Rule.ps1 Enterprise.Rules.psd1","title":"Including rules and baselines"},{"location":"authoring/packaging-rules/#file-names","text":"For PSRule to find rules included in a module, rule file names must end with the .Rule.ps1 suffix. We recommend using the exact case .Rule.ps1 . This is because some file systems are case-sensitive. For example, on Linux Standards.rule.ps1 would be ignored by PSRule. Similarly, when including baselines within a module use the .Rule.yaml suffix.","title":"File names"},{"location":"authoring/packaging-rules/#defining-a-module-configuration","text":"A module configuration that sets options defaults and can be optionally packaged with a module. To set a module configuration, define a ModuleConfig resource within an included .Rule.yaml file. A module configuration .Rule.yaml file must be distributed within the module directory structure. PSRule only supports a single ModuleConfig resource. The name of the ModuleConfig must match the name of the module. Additional ModuleConfig resources or with an alternative name are ignored. PSRule does not support module configurations distributed outside of a module. Example --- # Synopsis: Example module configuration for Enterprise.Rules module. apiVersion : github.com/microsoft/PSRule/v1 kind : ModuleConfig metadata : name : Enterprise.Rules spec : binding : targetName : - ResourceName - FullName - name targetType : - ResourceType - type - Extension field : resourceId : [ 'ResourceId' ] subscriptionId : [ 'SubscriptionId' ] resourceGroupName : [ 'ResourceGroupName' ] rule : baseline : Enterprise.Default The following options are allowed within a ModuleConfig : Binding.Field Binding.IgnoreCase Binding.NameSeparator Binding.PreferTargetInfo Binding.TargetName Binding.TargetType Binding.UseQualifiedName Configuration Output.Culture Rule.Baseline","title":"Defining a module configuration"},{"location":"authoring/packaging-rules/#setting-a-default-baseline","text":"Optionally, baselines can be included in rule modules. If a baseline contains configuration or binding options then setting a default baseline is often desirable. When a default baseline is set, PSRule will use the named baseline automatically when processing rules from that module. This feature removes the need for users to specify it manually. To set a default baseline, set the Rule.Baseline property of the ModuleConfig resource. Example --- # Synopsis: Example module configuration for Enterprise.Rules module. apiVersion : github.com/microsoft/PSRule/v1 kind : ModuleConfig metadata : name : Enterprise.Rules spec : binding : targetName : - ResourceName - FullName - name targetType : - ResourceType - type - Extension field : resourceId : [ 'ResourceId' ] subscriptionId : [ 'SubscriptionId' ] resourceGroupName : [ 'ResourceGroupName' ] rule : baseline : Enterprise.Default This examples set the default baseline to Enterprise.Default . The default baseline must be included in file ending with .Rule.yaml within the module directory structure.","title":"Setting a default baseline"},{"location":"authoring/packaging-rules/#including-documentation","text":"PSRule supports write and packaging rule modules with markdown documentation. Markdown documentation is automatically interpreted by PSRule and included in output. When including markdown, files are copied into a directory structure based on the target culture. For example, store documentation targeted to the culture en-US in a directory named en-US . Similarly, documentation for cultures such as en-AU , en-GB and fr-FR would be in separate directories. If a directory for the exact culture en-US doesn't exist, PSRule will attempt to find the parent culture. For example, documentation would be read from a directory named en . When naming directories for their culture, use exact case. This is because some file systems are case-sensitive. For example on Linux en-us would not match. For example: Enterprise.Rules/ en/ Org.Az.Storage.UseHttps.md Org.Az.Resource.Tagging.md en-US/ Org.Az.Storage.UseHttps.md fr-FR/ Org.Az.Storage.UseHttps.md rules/ Baseline.Rule.yaml Config.Rule.yaml Standards.Rule.ps1 Enterprise.Rules.psd1","title":"Including documentation"},{"location":"authoring/packaging-rules/#more-information","text":"Enterprise.Rules.psd1 - An example module manifest. Baseline.Rule.yaml - An example baseline. Config.Rule.yaml - An example module configuration.","title":"More information"},{"location":"authoring/storing-rules/","text":"Storing and naming rules # Rules are stored in one or more files and each file can contain one or many rules. Additionally, rules can be grouped into a module and distributed. Abstract This topic covers recommendations for naming and storing rules. Using a standard file path # Rules can be standalone or packaged within a module. Standalone rules are ideal for a single project such as an Infrastructure as Code (IaC) repository. To reuse rules across multiple projects consider packaging these as a module. The instructions for packaging rules in a module can be found here: Packaging rules in a module To store standalone rules we recommend that you: Use .ps-rule/ \u2014 Create a sub-directory called .ps-rule in the root of your repository. Use all lower-case in the sub-directory name. Put any custom rules within this sub-directory. Use files ending with .Rule.* \u2014 PSRule uses a file naming convention to discover rules. Use one of the following depending on the file format you are using: YAML - .Rule.yaml . JSON - .Rule.jsonc or .Rule.json . PowerShell - .Rule.ps1 . Note Build pipelines are often case-sensitive or run on Linux-based systems. Using the casing rule above reduces confusion latter when you configure continuous integration (CI). Naming rules # When running PSRule, rule names must be unique. For example, PSRule for Azure uses the name prefix of Azure. for rules included in the module. Example The following names are examples of rules included within PSRule for Azure: Azure.AKS.Version Azure.AKS.AuthorizedIPs Azure.SQL.MinTLS In addition, names for rules and other resources must meet the following requirements: Use between 3 and 128 characters \u2014 This is the minimum and maximum length of a resource name. Only use allowed characters \u2014 To preserve consistency between file systems, some characters are not permitted. Dots, hyphens, and underscores are not permitted at the start and end of the name. Additionally some characters are restricted for future use. The following characters are not permitted: < (less than) > (greater than) : (colon) / (forward slash) \\ (backslash) | (vertical bar or pipe) ? (question mark) * (asterisk) \" (double quote) ' (single quote) ` (backtick) + (plus) @ (at sign) Integer value zero, sometimes referred to as the ASCII NUL character. Characters whose integer representations are in the range from 1 through 31. Regular expression for valid resource names ^[^<>:/\\\\|?*\"'`+@._\\-\\x00-\\x1F][^<>:/\\\\|?*\"'`+@\\x00-\\x1F]{1,126}[^<>:/\\\\|?*\"'`+@._\\-\\x00-\\x1F]$ When naming rules we recommend that you: Use a standard prefix \u2014 You can use the Local. or Org. prefix for standalone rules. Alternatively choose a short prefix that identifies your organization. Use dotted notation \u2014 Use dots to separate rule name. Use a maximum length of 35 characters \u2014 The default view of Invoke-PSRule truncates longer names. PSRule supports longer rule names however if Invoke-PSRule is called directly consider using Format-List . Avoid using special characters and punctuation \u2014 Although these characters can be used in many cases, they may not be easy to use with all PSRule features.","title":"Storing and naming rules"},{"location":"authoring/storing-rules/#storing-and-naming-rules","text":"Rules are stored in one or more files and each file can contain one or many rules. Additionally, rules can be grouped into a module and distributed. Abstract This topic covers recommendations for naming and storing rules.","title":"Storing and naming rules"},{"location":"authoring/storing-rules/#using-a-standard-file-path","text":"Rules can be standalone or packaged within a module. Standalone rules are ideal for a single project such as an Infrastructure as Code (IaC) repository. To reuse rules across multiple projects consider packaging these as a module. The instructions for packaging rules in a module can be found here: Packaging rules in a module To store standalone rules we recommend that you: Use .ps-rule/ \u2014 Create a sub-directory called .ps-rule in the root of your repository. Use all lower-case in the sub-directory name. Put any custom rules within this sub-directory. Use files ending with .Rule.* \u2014 PSRule uses a file naming convention to discover rules. Use one of the following depending on the file format you are using: YAML - .Rule.yaml . JSON - .Rule.jsonc or .Rule.json . PowerShell - .Rule.ps1 . Note Build pipelines are often case-sensitive or run on Linux-based systems. Using the casing rule above reduces confusion latter when you configure continuous integration (CI).","title":"Using a standard file path"},{"location":"authoring/storing-rules/#naming-rules","text":"When running PSRule, rule names must be unique. For example, PSRule for Azure uses the name prefix of Azure. for rules included in the module. Example The following names are examples of rules included within PSRule for Azure: Azure.AKS.Version Azure.AKS.AuthorizedIPs Azure.SQL.MinTLS In addition, names for rules and other resources must meet the following requirements: Use between 3 and 128 characters \u2014 This is the minimum and maximum length of a resource name. Only use allowed characters \u2014 To preserve consistency between file systems, some characters are not permitted. Dots, hyphens, and underscores are not permitted at the start and end of the name. Additionally some characters are restricted for future use. The following characters are not permitted: < (less than) > (greater than) : (colon) / (forward slash) \\ (backslash) | (vertical bar or pipe) ? (question mark) * (asterisk) \" (double quote) ' (single quote) ` (backtick) + (plus) @ (at sign) Integer value zero, sometimes referred to as the ASCII NUL character. Characters whose integer representations are in the range from 1 through 31. Regular expression for valid resource names ^[^<>:/\\\\|?*\"'`+@._\\-\\x00-\\x1F][^<>:/\\\\|?*\"'`+@\\x00-\\x1F]{1,126}[^<>:/\\\\|?*\"'`+@._\\-\\x00-\\x1F]$ When naming rules we recommend that you: Use a standard prefix \u2014 You can use the Local. or Org. prefix for standalone rules. Alternatively choose a short prefix that identifies your organization. Use dotted notation \u2014 Use dots to separate rule name. Use a maximum length of 35 characters \u2014 The default view of Invoke-PSRule truncates longer names. PSRule supports longer rule names however if Invoke-PSRule is called directly consider using Format-List . Avoid using special characters and punctuation \u2014 Although these characters can be used in many cases, they may not be easy to use with all PSRule features.","title":"Naming rules"},{"location":"authoring/testing-infrastructure/","text":"Testing infrastructure # You can use PSRule to create tests for Infrastructure as Code (IaC). Each test is called a rule . PSRule allows you to write rules using YAML, JSON, or PowerShell. Regardless of the format you choose, any combination of YAML, JSON, or PowerShell rules can be used together. Abstract This topic covers how to create a rule using YAML, JSON, and PowerShell by example. This example, while fictitious is indicative of common testing and validation scenarios for IaC. Sample data # To get started authoring a rule, we will be working with a sample file settings.json . This sample configuration file configures an application. For the purpose of this example, one configuration setting supportsHttpsTrafficOnly is set. This configuration setting can be either true or false . When set to true , Transport Layer Security (TLS) is enforced. When set to false , the application permits insecure communication with HTTP. Contents of settings.json Create a settings.json file in the root of your repository with the following contents. { \"type\" : \"app1\" , \"version\" : 1 , \"configure\" : { \"supportsHttpsTrafficOnly\" : false } } Define a rule # To meet the requirements of our organization we want to write a rule to: Enforce secure traffic by requiring supportsHttpsTrafficOnly to be true . Enforce use of TLS 1.2 as a minimum by requiring minTLSVersion to be 1.2 . In this section the same rule will be authored using YAML, JSON, and PowerShell. Tip To make you editing experience even better, consider installing the Visual Studio Code extension. YAML JSON PowerShell Create a .ps-rule/Local.Rule.yaml file in your repository with the following contents. --- # Synopsis: An example rule to require TLS. apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'Local.YAML.RequireTLS' spec : condition : field : 'configure.supportsHttpsTrafficOnly' equals : true Use a short Synopsis: to describe your rule in a line comment above your rule. For this to be interpreted by PSRule, only a single line is allowed. Name your rule with a unique name. The condition property determines the checks PSRule will use to test settings.json . Specifically, the object path configures.supportsHttpsTrafficOnly must exist and be set to true . Create a .ps-rule/Local.Rule.jsonc file in your repository with the following contents. [ { // Synopsis: An example rule to require TLS. \"apiVersion\" : \"github.com/microsoft/PSRule/v1\" , \"kind\" : \"Rule\" , \"metadata\" : { \"name\" : \"Local.JSON.RequireTLS\" }, \"spec\" : { \"condition\" : { \"field\" : \"configure.supportsHttpsTrafficOnly\" , \"equals\" : true } } } ] Use a short Synopsis: to describe your rule in a line comment above your rule. For this to be interpreted by PSRule, only a single line is allowed. Name your rule with a unique name. The condition property determines the checks PSRule will use to test settings.json . Specifically, the object path configures.supportsHttpsTrafficOnly must exist and be set to true . Create a .ps-rule/Local.Rule.ps1 file in your repository with the following contents. # Synopsis: An example rule to require TLS. Rule 'Local.PS.RequireTLS' { $Assert . HasFieldValue ( $TargetObject , 'configure.supportsHttpsTrafficOnly' , $True ) } Use a short Synopsis: to describe your rule in a line comment above your rule. For this to be interpreted by PSRule, only a single line is allowed. Name your rule with a unique name. The condition contained within the curly braces { } determines the checks PSRule will use to test settings.json . The $Assert.HasFieldValue method checks the object path configures.supportsHttpsTrafficOnly exists and is set to true . Tip To learn more about recommended file and naming conventions for rules, continue reading Storing and naming rules . Using multiple conditions # Each rule must have at least one condition. Additional conditions can be combined to check multiple test cases. In the example a minTLSVersion configuration setting does not exist and is not set. YAML JSON PowerShell Update .ps-rule/Local.Rule.yaml in your repository with the following contents. --- # Synopsis: An example rule to require TLS. apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'Local.YAML.RequireTLS' spec : condition : allOf : - field : 'configure.supportsHttpsTrafficOnly' equals : true - field : 'configure.minTLSVersion' equals : '1.2' Using the allOf expression requires that all conditions be true for the rule to pass. This expression allows an array of one or more conditions to be provided. Using anyOf would pass the rule if any single condition is true. Update .ps-rule/Local.Rule.jsonc in your repository with the following contents. [ { // Synopsis: An example rule to require TLS. \"apiVersion\" : \"github.com/microsoft/PSRule/v1\" , \"kind\" : \"Rule\" , \"metadata\" : { \"name\" : \"Local.JSON.RequireTLS\" }, \"spec\" : { \"condition\" : { \"allOf\" : [ { \"field\" : \"configure.supportsHttpsTrafficOnly\" , \"equals\" : true }, { \"field\" : \"configure.minTLSVersion\" , \"equals\" : \"1.2\" } ] } } } ] Using the allOf expression requires that all conditions be true for the rule to pass. This expression allows an array of one or more conditions to be provided. Using anyOf would pass the rule if any single condition is true. Update .ps-rule/Local.Rule.ps1 in your repository with the following contents. # Synopsis: An example rule to require TLS. Rule 'Local.PS.RequireTLS' { $Assert . HasFieldValue ( $TargetObject , 'configure.supportsHttpsTrafficOnly' , $True ) $Assert . HasFieldValue ( $TargetObject , 'configure.minTLSVersion' , '1.2' ) } An additional, $Assert.HasFieldValue assertion helper method can be called. The rule will pass if all of the conditions return true. Testing # Testing manually # To test the rule manually, run the following command. Assert-PSRule -f ./ settings . json Advanced usage # Severity level # v2.0.0 When defining a rule, you can specify a severity level. The severity level is used if the rule fails. By default, the severity level for a rule is Error . Error - A serious problem that must be addressed before going forward. Warning - A problem that should be addressed. Information - A minor problem or an opportunity to improve the code. In a continuous integration (CI) pipeline, severity level is particularly important. If any rule fails with a severity level of Error the pipeline will fail. This helps prevent serious problems from being introduced into the code base or deployed. The following example shows how to set the severity level to Warning . YAML JSON PowerShell --- # Synopsis: An example rule to require TLS. apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'Local.YAML.RequireTLS' spec : level : Warning condition : allOf : - field : 'configure.supportsHttpsTrafficOnly' equals : true - field : 'configure.minTLSVersion' equals : '1.2' [ { // Synopsis: An example rule to require TLS. \"apiVersion\" : \"github.com/microsoft/PSRule/v1\" , \"kind\" : \"Rule\" , \"metadata\" : { \"name\" : \"Local.JSON.RequireTLS\" }, \"spec\" : { \"level\" : \"Warning\" , \"condition\" : { \"allOf\" : [ { \"field\" : \"configure.supportsHttpsTrafficOnly\" , \"equals\" : true }, { \"field\" : \"configure.minTLSVersion\" , \"equals\" : \"1.2\" } ] } } } ] Update .ps-rule/Local.Rule.ps1 in your repository with the following contents. # Synopsis: An example rule to require TLS. Rule 'Local.PS.RequireTLS' -Level Warning { $Assert . HasFieldValue ( $TargetObject , 'configure.supportsHttpsTrafficOnly' , $True ) $Assert . HasFieldValue ( $TargetObject , 'configure.minTLSVersion' , '1.2' ) }","title":"Testing infrastructure"},{"location":"authoring/testing-infrastructure/#testing-infrastructure","text":"You can use PSRule to create tests for Infrastructure as Code (IaC). Each test is called a rule . PSRule allows you to write rules using YAML, JSON, or PowerShell. Regardless of the format you choose, any combination of YAML, JSON, or PowerShell rules can be used together. Abstract This topic covers how to create a rule using YAML, JSON, and PowerShell by example. This example, while fictitious is indicative of common testing and validation scenarios for IaC.","title":"Testing infrastructure"},{"location":"authoring/testing-infrastructure/#sample-data","text":"To get started authoring a rule, we will be working with a sample file settings.json . This sample configuration file configures an application. For the purpose of this example, one configuration setting supportsHttpsTrafficOnly is set. This configuration setting can be either true or false . When set to true , Transport Layer Security (TLS) is enforced. When set to false , the application permits insecure communication with HTTP. Contents of settings.json Create a settings.json file in the root of your repository with the following contents. { \"type\" : \"app1\" , \"version\" : 1 , \"configure\" : { \"supportsHttpsTrafficOnly\" : false } }","title":"Sample data"},{"location":"authoring/testing-infrastructure/#define-a-rule","text":"To meet the requirements of our organization we want to write a rule to: Enforce secure traffic by requiring supportsHttpsTrafficOnly to be true . Enforce use of TLS 1.2 as a minimum by requiring minTLSVersion to be 1.2 . In this section the same rule will be authored using YAML, JSON, and PowerShell. Tip To make you editing experience even better, consider installing the Visual Studio Code extension. YAML JSON PowerShell Create a .ps-rule/Local.Rule.yaml file in your repository with the following contents. --- # Synopsis: An example rule to require TLS. apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'Local.YAML.RequireTLS' spec : condition : field : 'configure.supportsHttpsTrafficOnly' equals : true Use a short Synopsis: to describe your rule in a line comment above your rule. For this to be interpreted by PSRule, only a single line is allowed. Name your rule with a unique name. The condition property determines the checks PSRule will use to test settings.json . Specifically, the object path configures.supportsHttpsTrafficOnly must exist and be set to true . Create a .ps-rule/Local.Rule.jsonc file in your repository with the following contents. [ { // Synopsis: An example rule to require TLS. \"apiVersion\" : \"github.com/microsoft/PSRule/v1\" , \"kind\" : \"Rule\" , \"metadata\" : { \"name\" : \"Local.JSON.RequireTLS\" }, \"spec\" : { \"condition\" : { \"field\" : \"configure.supportsHttpsTrafficOnly\" , \"equals\" : true } } } ] Use a short Synopsis: to describe your rule in a line comment above your rule. For this to be interpreted by PSRule, only a single line is allowed. Name your rule with a unique name. The condition property determines the checks PSRule will use to test settings.json . Specifically, the object path configures.supportsHttpsTrafficOnly must exist and be set to true . Create a .ps-rule/Local.Rule.ps1 file in your repository with the following contents. # Synopsis: An example rule to require TLS. Rule 'Local.PS.RequireTLS' { $Assert . HasFieldValue ( $TargetObject , 'configure.supportsHttpsTrafficOnly' , $True ) } Use a short Synopsis: to describe your rule in a line comment above your rule. For this to be interpreted by PSRule, only a single line is allowed. Name your rule with a unique name. The condition contained within the curly braces { } determines the checks PSRule will use to test settings.json . The $Assert.HasFieldValue method checks the object path configures.supportsHttpsTrafficOnly exists and is set to true . Tip To learn more about recommended file and naming conventions for rules, continue reading Storing and naming rules .","title":"Define a rule"},{"location":"authoring/testing-infrastructure/#using-multiple-conditions","text":"Each rule must have at least one condition. Additional conditions can be combined to check multiple test cases. In the example a minTLSVersion configuration setting does not exist and is not set. YAML JSON PowerShell Update .ps-rule/Local.Rule.yaml in your repository with the following contents. --- # Synopsis: An example rule to require TLS. apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'Local.YAML.RequireTLS' spec : condition : allOf : - field : 'configure.supportsHttpsTrafficOnly' equals : true - field : 'configure.minTLSVersion' equals : '1.2' Using the allOf expression requires that all conditions be true for the rule to pass. This expression allows an array of one or more conditions to be provided. Using anyOf would pass the rule if any single condition is true. Update .ps-rule/Local.Rule.jsonc in your repository with the following contents. [ { // Synopsis: An example rule to require TLS. \"apiVersion\" : \"github.com/microsoft/PSRule/v1\" , \"kind\" : \"Rule\" , \"metadata\" : { \"name\" : \"Local.JSON.RequireTLS\" }, \"spec\" : { \"condition\" : { \"allOf\" : [ { \"field\" : \"configure.supportsHttpsTrafficOnly\" , \"equals\" : true }, { \"field\" : \"configure.minTLSVersion\" , \"equals\" : \"1.2\" } ] } } } ] Using the allOf expression requires that all conditions be true for the rule to pass. This expression allows an array of one or more conditions to be provided. Using anyOf would pass the rule if any single condition is true. Update .ps-rule/Local.Rule.ps1 in your repository with the following contents. # Synopsis: An example rule to require TLS. Rule 'Local.PS.RequireTLS' { $Assert . HasFieldValue ( $TargetObject , 'configure.supportsHttpsTrafficOnly' , $True ) $Assert . HasFieldValue ( $TargetObject , 'configure.minTLSVersion' , '1.2' ) } An additional, $Assert.HasFieldValue assertion helper method can be called. The rule will pass if all of the conditions return true.","title":"Using multiple conditions"},{"location":"authoring/testing-infrastructure/#testing","text":"","title":"Testing"},{"location":"authoring/testing-infrastructure/#testing-manually","text":"To test the rule manually, run the following command. Assert-PSRule -f ./ settings . json","title":"Testing manually"},{"location":"authoring/testing-infrastructure/#advanced-usage","text":"","title":"Advanced usage"},{"location":"authoring/testing-infrastructure/#severity-level","text":"v2.0.0 When defining a rule, you can specify a severity level. The severity level is used if the rule fails. By default, the severity level for a rule is Error . Error - A serious problem that must be addressed before going forward. Warning - A problem that should be addressed. Information - A minor problem or an opportunity to improve the code. In a continuous integration (CI) pipeline, severity level is particularly important. If any rule fails with a severity level of Error the pipeline will fail. This helps prevent serious problems from being introduced into the code base or deployed. The following example shows how to set the severity level to Warning . YAML JSON PowerShell --- # Synopsis: An example rule to require TLS. apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'Local.YAML.RequireTLS' spec : level : Warning condition : allOf : - field : 'configure.supportsHttpsTrafficOnly' equals : true - field : 'configure.minTLSVersion' equals : '1.2' [ { // Synopsis: An example rule to require TLS. \"apiVersion\" : \"github.com/microsoft/PSRule/v1\" , \"kind\" : \"Rule\" , \"metadata\" : { \"name\" : \"Local.JSON.RequireTLS\" }, \"spec\" : { \"level\" : \"Warning\" , \"condition\" : { \"allOf\" : [ { \"field\" : \"configure.supportsHttpsTrafficOnly\" , \"equals\" : true }, { \"field\" : \"configure.minTLSVersion\" , \"equals\" : \"1.2\" } ] } } } ] Update .ps-rule/Local.Rule.ps1 in your repository with the following contents. # Synopsis: An example rule to require TLS. Rule 'Local.PS.RequireTLS' -Level Warning { $Assert . HasFieldValue ( $TargetObject , 'configure.supportsHttpsTrafficOnly' , $True ) $Assert . HasFieldValue ( $TargetObject , 'configure.minTLSVersion' , '1.2' ) }","title":"Severity level"},{"location":"authoring/using-expressions/","text":"Using expressions # PSRule allows you to write rules using YAML, JSON, or PowerShell. This offers a lot of flexibility to use PSRule for a variety of use cases. Some examples of use cases for each format include: YAML \u2014 Start authoring quickly with minimal knowledge of PowerShell. JSON \u2014 Generate rules automatically using automation tools. PowerShell \u2014 Integrate with other tools using PowerShell cmdlets. Abstract This topic covers the differences and limitations between authoring rules using YAML, JSON, and PowerShell. For an example of authoring rules see Writing rules or Testing infrastructure topics. Language comparison # Expressions and assertion methods can be used to build similar conditions. Expressions \u2014 Schema-based conditions written in YAML or JSON. Expressions can be used in rules and selectors. Assertion methods \u2014 PowerShell-based condition helpers that make rules faster to author. Assertion methods can be used in combination with standard PowerShell code to build rules or conventions. Quick reference # In most cases expressions and assertion method names match. There are some cases where these names do not directly align. This lookup table provides a quick reference for expressions and their assertion method counterpart. Expression Assertion method Contains Contains Count Count Equals 1 n/a EndsWith EndsWith Exists HasField Greater Greater GreaterOrEquals GreaterOrEqual HasDefault HasDefaultValue HasSchema HasJsonSchema HasValue 1 n/a In In IsLower IsLower IsString IsString IsUpper IsUpper Less Less LessOrEquals LessOrEqual Match Match NotEquals n/a NotIn NotIn NotMatch NotMatch SetOf SetOf StartsWith StartsWith Subset Subset Version Version n/a FileHeader n/a FilePath n/a HasFields n/a HasFieldValue 1 IsArray IsArray IsBoolean IsBoolean IsDateTime IsDateTime IsInteger IsInteger IsNumeric IsNumeric n/a JsonSchema Exists NotHasField n/a NotNull NotWithinPath NotWithinPath n/a Null n/a NullOrEmpty n/a TypeOf WithinPath WithinPath The Equals , HasValue expressions and HasFieldValue are similar. \u21a9 \u21a9 \u21a9","title":"Using expressions"},{"location":"authoring/using-expressions/#using-expressions","text":"PSRule allows you to write rules using YAML, JSON, or PowerShell. This offers a lot of flexibility to use PSRule for a variety of use cases. Some examples of use cases for each format include: YAML \u2014 Start authoring quickly with minimal knowledge of PowerShell. JSON \u2014 Generate rules automatically using automation tools. PowerShell \u2014 Integrate with other tools using PowerShell cmdlets. Abstract This topic covers the differences and limitations between authoring rules using YAML, JSON, and PowerShell. For an example of authoring rules see Writing rules or Testing infrastructure topics.","title":"Using expressions"},{"location":"authoring/using-expressions/#language-comparison","text":"Expressions and assertion methods can be used to build similar conditions. Expressions \u2014 Schema-based conditions written in YAML or JSON. Expressions can be used in rules and selectors. Assertion methods \u2014 PowerShell-based condition helpers that make rules faster to author. Assertion methods can be used in combination with standard PowerShell code to build rules or conventions.","title":"Language comparison"},{"location":"authoring/using-expressions/#quick-reference","text":"In most cases expressions and assertion method names match. There are some cases where these names do not directly align. This lookup table provides a quick reference for expressions and their assertion method counterpart. Expression Assertion method Contains Contains Count Count Equals 1 n/a EndsWith EndsWith Exists HasField Greater Greater GreaterOrEquals GreaterOrEqual HasDefault HasDefaultValue HasSchema HasJsonSchema HasValue 1 n/a In In IsLower IsLower IsString IsString IsUpper IsUpper Less Less LessOrEquals LessOrEqual Match Match NotEquals n/a NotIn NotIn NotMatch NotMatch SetOf SetOf StartsWith StartsWith Subset Subset Version Version n/a FileHeader n/a FilePath n/a HasFields n/a HasFieldValue 1 IsArray IsArray IsBoolean IsBoolean IsDateTime IsDateTime IsInteger IsInteger IsNumeric IsNumeric n/a JsonSchema Exists NotHasField n/a NotNull NotWithinPath NotWithinPath n/a Null n/a NullOrEmpty n/a TypeOf WithinPath WithinPath The Equals , HasValue expressions and HasFieldValue are similar. \u21a9 \u21a9 \u21a9","title":"Quick reference"},{"location":"authoring/writing-rule-help/","text":"Writing rule help # PSRule has built-in support for help. Documentation can optionally be added for each rule to provide detailed information or remediation steps. This scenario covers the following: Using inline help Writing markdown documentation Localizing documentation files Using inline help # When authoring rules in PowerShell, PSRule provides the following syntax features: Comment metadata. Recommend keyword. Reason keyword. These features are each describe in detail in the following sections. Comment metadata # Comment metadata can be included directly above a rule block by using the syntax # Synopsis: <text> . This is only supported for populating a rule synopsis. For example: # Synopsis: Must have the app.kubernetes.io/name label Rule 'metadata.Name' -Type 'Deployment' , 'Service' { Exists \"metadata.labels.'app.kubernetes.io/name'\" } This example above would set the synopsis to Must have the app.kubernetes.io/name label . Including comment metadata improves authoring by indicating the rules purpose. Only a single line is supported. A rule synopsis is displayed when using Get-PSRule and Get-PSRuleHelp . The synopsis can not break over multiple lines. The key limitation of only using comment metadata is that it can not be localized for multiple languages. Consider using comment metadata and also using markdown documentation for a multi-language experience. Recommend keyword # The Recommend keyword sets the recommendation for a rule. Use the keyword with a text recommendation at the top of your rule body. Using the Recommend keyword is recommended for rules that are not packaged in a module. When packaging rules in a module consider using markdown help instead. For example: # Synopsis: Must have the app.kubernetes.io/name label Rule 'metadata.Name' -Type 'Deployment' , 'Service' { Recommend 'Consider setting the recommended label ''app.kubernetes.io/name'' on deployment and service resources.' Exists \"metadata.labels.'app.kubernetes.io/name'\" } A rule recommendation is displayed when using Invoke-PSRule or Get-PSRuleHelp . Only use the Recommend keyword once to set the recommendation text and avoid formatting with variables. Recommendations are cached the first time they are used. Supplying a unique recommendation within a rule based on conditions/ logic is not supported. To return a custom unique reason for why the rule failed, use the Reason keyword. Localized recommendations can set by using the $LocalizedData . For example: # Synopsis: Must have the app.kubernetes.io/name label Rule 'metadata.Name' -Type 'Deployment' , 'Service' { Recommend $LocalizedData . RecommendNameLabel Exists \"metadata.labels.'app.kubernetes.io/name'\" } Reason keyword # The Reason keyword sets the reason the rule failed when using Invoke-PSRule and Assert-PSRule . The reason is only included in detailed output if the rule did not pass. If the rule passed, then reason is empty it returned output. Reasons are not included in the default view when using Invoke-PSRule . Use -OutputFormat Wide to display reason messages. To set a reason use the Reason keyword followed by the reason. For example: # Synopsis: Must have the app.kubernetes.io/name label Rule 'metadata.Name' -Type 'Deployment' , 'Service' { Recommend $LocalizedData . RecommendNameLabel Exists \"metadata.labels.'app.kubernetes.io/name'\" Reason 'The standard name label is not set.' } The Reason keyword can be used multiple times within conditional logic to return a list of reasons the rule failed. Additionally the reason messages can be localized by using the $LocalizedData variable. For example: # Synopsis: Must have the app.kubernetes.io/name label Rule 'metadata.Name' -Type 'Deployment' , 'Service' { Recommend $LocalizedData . RecommendNameLabel Exists \"metadata.labels.'app.kubernetes.io/name'\" # $LocalizedData.ReasonLabelMissing is set to 'The standard {0} label is not set.'. Reason ( $LocalizedData . ReasonLabelMissing -f 'name' ) } Writing markdown documentation # In addition to inline help, documentation can be written in markdown to provide online and offline help. Extended documentation is generally easier to author using markdown. Additionally markdown documentation is easily localized. Markdown documentation is authored by creating one or more .md files, one for each rule. PSRule uses a naming convention with a file name the same as the rule to match rule to markdown. For example, metadata.Name.md would be used for a rule named metadata.Name . We recommend matching the rule name case exactly when naming markdown files. This is because some file systems are case-sensitive. For example on Linux Metadata.Name.md would not match. Within each markdown file a number of predefined sections are automatically interpreted by PSRule. While it is possible to have additional sections, they will be ignored by the help system. The basic structure of markdown help is as follows: --- {{ Annotations }} --- # {{ Name of rule }} {{ A brief summary of the rule }} ## Description {{ A detailed description of the rule }} ## Recommendation {{ A detailed explanation of the steps required to pass the rule }} ## Notes {{ Additional information or configuration options }} ## Links {{ Links to external references }} The PSRule Visual Studio Code extension includes snippets for writing markdown documentation. Annotations # The annotation front matter at the top of the markdown document, is a set of key value pairs. Front matter follows YAML conventions and must start on the first line of the markdown document. A --- on a separate line indicates the start and end of the front matter block. Within the front matter block, all key value pairs are treated as annotations by PSRule. Annotations are optional metadata that are associated with the rule. Any annotations associated with a rule are included in output. Some examples of annotations include; severity , category , author . Annotations differ from tags in two key ways: Annotations are localized, and can have a different value for different languages; tags are not. Tags are indexed and can be used to filter rules; annotations have no affect on rule filtering. The following reserved annotation exists: online version - A URL to the online version of the document, used by Get-PSRuleHelp -Online . --- online version: https://github.com/microsoft/PSRule/blob/main/docs/scenarios/rule-docs/rule-docs.md --- The front matter start and end --- are not required and can be removed if no annotations are defined. Display name # The document title, indicated by a level one heading # is the display name of the rule. The rule display name is shown when using Get-PSRuleHelp and is included in output. Specify the display name on a single line. Wrapping the display name across multiple lines is not supported. For example: # Use recommended name label Synopsis section # The synopsis section is indicated by the heading `. Any text following the heading is interpreted by PSRule and included in output. The synopsis is displayed when using Get-PSRule and Get-PSRuleHelp` cmdlets. The synopsis is intended to be a brief description of the rule, over a single line. A good synopsis should convey the purpose of the rule. A more verbose description can be included in the description section. For example: Deployments and services must use the app.kubernetes.io/name label. Description section # The description section is indicated by the heading ## Description . Any text following the heading is interpreted by PSRule and included in output. The description is displayed when using the Get-PSRuleHelp cmdlet. The description is intended to be a verbose description of the rule. If your rule documentation needs to include background information include it here. PSRule supports semantic line breaks, and will automatically run together lines into a single paragraph. Use a blank line to separate paragraphs. For example: ## Description Kubernetes defines a common set of labels that are recommended for tool interoperability. These labels should be used to consistently apply standard metadata. The `app.kubernetes.io/name` label should be used to specify the name of the application. Recommendation section # The recommendation section is indicated by the heading ## Recommendation . Any text following the heading is interpreted by PSRule and included in output. The recommendation is displayed when using the Invoke-PSRule and Get-PSRuleHelp cmdlets. The recommendation is intended to identify corrective actions that can be taken to address any failures. Avoid using URLs within the recommendations. Use the links section to include references to external sources. PSRule supports semantic line breaks, and will automatically run together lines into a single paragraph. Use a blank line to separate paragraphs. For example: ## Recommendation Consider setting the recommended label `app.kubernetes.io/name` on deployment and service resources. Notes section # The notes section is indicated by the heading ## Notes . Any text following the heading is interpreted by PSRule and included in pipeline output. Notes are excluded when formatting output as YAML and JSON. To view any included notes use the Get-PSRuleHelp cmdlet with the -Full switch. Use notes to include additional information such configuration options. PSRule supports semantic line breaks, and will automatically run together lines into a single paragraph. Use a blank line to separate paragraphs. For example: ## Notes The Kubernetes recommended labels include: - `app.kubernetes.io/name` - `app.kubernetes.io/instance` - `app.kubernetes.io/version` - `app.kubernetes.io/component` - `app.kubernetes.io/part-of` - `app.kubernetes.io/managed-by` Links section # The links section is indicated by the heading ## Links . Any markdown links following the heading are interpreted by PSRule and included in pipeline output. Links are excluded when formatting output as YAML and JSON. To view any included links use the Get-PSRuleHelp cmdlet with the -Full switch. Use links to reference external sources with a URL. To specify links, use the markdown syntax [display name](url) . Include each link on a separate line. To improve display in web rendered markdown, use a list of links by prefixing the line with - . Additional text such as See additional information: is useful for web rendered views, but ignored by PSRule. For example: ## Links - [Recommended Labels](https://kubernetes.io/docs/concepts/overview/working-with-objects/common-labels/) Localizing documentation files # When distributing rules, you may need to provide rule help in different languages. PSRule builds on the culture system in PowerShell. Using cultures # A directory structure is used to identify the markdown documentation that should be used for each culture. To get a list of cultures in PowerShell the use cmdlet Get-Culture -ListAvailable . For example, store documentation targeted to the culture en-US in a directory named en-US . Similarly, documentation for cultures such as en-AU , en-GB and fr-FR would be in separate directories. If a directory for the exact culture en-US doesn't exist, PSRule will attempt to find the parent culture. For example, documentation would be read from a directory named en . When naming directories for their culture, use exact case. This is because some file systems are case-sensitive. For example on Linux en-us would not match. Culture directory search path # The path that PSRule looks for a culture directory in varies depending on how the rule is redistributed. Rules can be redistributed individually (loose) or included in a module. The following logic is used to locate the culture directory. If the rules are loose, PSRule will search for the culture directory in the same subdirectory as the .Rule.ps1 file. When rules are included in a module, PSRule will search for the culture directory in the same subdirectory as the module manifest .psd1 file. For example, loose file structure: .ps-rule/ en/ metadata.Name.md en-US/ metadata.Name.md fr-FR/ metadata.Name.md kubernetes.Rule.ps1 Module file structure: Kubernetes.Rules/ en/ metadata.Name.md en-US/ metadata.Name.md fr-FR/ metadata.Name.md rules/ kubernetes.Rule.ps1 Kubernetes.Rules.psd1 More information # kubernetes.Rule.ps1 - An example rule for validating name label. metadata.Name - An example markdown documentation file.","title":"Writing rule help"},{"location":"authoring/writing-rule-help/#writing-rule-help","text":"PSRule has built-in support for help. Documentation can optionally be added for each rule to provide detailed information or remediation steps. This scenario covers the following: Using inline help Writing markdown documentation Localizing documentation files","title":"Writing rule help"},{"location":"authoring/writing-rule-help/#using-inline-help","text":"When authoring rules in PowerShell, PSRule provides the following syntax features: Comment metadata. Recommend keyword. Reason keyword. These features are each describe in detail in the following sections.","title":"Using inline help"},{"location":"authoring/writing-rule-help/#comment-metadata","text":"Comment metadata can be included directly above a rule block by using the syntax # Synopsis: <text> . This is only supported for populating a rule synopsis. For example: # Synopsis: Must have the app.kubernetes.io/name label Rule 'metadata.Name' -Type 'Deployment' , 'Service' { Exists \"metadata.labels.'app.kubernetes.io/name'\" } This example above would set the synopsis to Must have the app.kubernetes.io/name label . Including comment metadata improves authoring by indicating the rules purpose. Only a single line is supported. A rule synopsis is displayed when using Get-PSRule and Get-PSRuleHelp . The synopsis can not break over multiple lines. The key limitation of only using comment metadata is that it can not be localized for multiple languages. Consider using comment metadata and also using markdown documentation for a multi-language experience.","title":"Comment metadata"},{"location":"authoring/writing-rule-help/#recommend-keyword","text":"The Recommend keyword sets the recommendation for a rule. Use the keyword with a text recommendation at the top of your rule body. Using the Recommend keyword is recommended for rules that are not packaged in a module. When packaging rules in a module consider using markdown help instead. For example: # Synopsis: Must have the app.kubernetes.io/name label Rule 'metadata.Name' -Type 'Deployment' , 'Service' { Recommend 'Consider setting the recommended label ''app.kubernetes.io/name'' on deployment and service resources.' Exists \"metadata.labels.'app.kubernetes.io/name'\" } A rule recommendation is displayed when using Invoke-PSRule or Get-PSRuleHelp . Only use the Recommend keyword once to set the recommendation text and avoid formatting with variables. Recommendations are cached the first time they are used. Supplying a unique recommendation within a rule based on conditions/ logic is not supported. To return a custom unique reason for why the rule failed, use the Reason keyword. Localized recommendations can set by using the $LocalizedData . For example: # Synopsis: Must have the app.kubernetes.io/name label Rule 'metadata.Name' -Type 'Deployment' , 'Service' { Recommend $LocalizedData . RecommendNameLabel Exists \"metadata.labels.'app.kubernetes.io/name'\" }","title":"Recommend keyword"},{"location":"authoring/writing-rule-help/#reason-keyword","text":"The Reason keyword sets the reason the rule failed when using Invoke-PSRule and Assert-PSRule . The reason is only included in detailed output if the rule did not pass. If the rule passed, then reason is empty it returned output. Reasons are not included in the default view when using Invoke-PSRule . Use -OutputFormat Wide to display reason messages. To set a reason use the Reason keyword followed by the reason. For example: # Synopsis: Must have the app.kubernetes.io/name label Rule 'metadata.Name' -Type 'Deployment' , 'Service' { Recommend $LocalizedData . RecommendNameLabel Exists \"metadata.labels.'app.kubernetes.io/name'\" Reason 'The standard name label is not set.' } The Reason keyword can be used multiple times within conditional logic to return a list of reasons the rule failed. Additionally the reason messages can be localized by using the $LocalizedData variable. For example: # Synopsis: Must have the app.kubernetes.io/name label Rule 'metadata.Name' -Type 'Deployment' , 'Service' { Recommend $LocalizedData . RecommendNameLabel Exists \"metadata.labels.'app.kubernetes.io/name'\" # $LocalizedData.ReasonLabelMissing is set to 'The standard {0} label is not set.'. Reason ( $LocalizedData . ReasonLabelMissing -f 'name' ) }","title":"Reason keyword"},{"location":"authoring/writing-rule-help/#writing-markdown-documentation","text":"In addition to inline help, documentation can be written in markdown to provide online and offline help. Extended documentation is generally easier to author using markdown. Additionally markdown documentation is easily localized. Markdown documentation is authored by creating one or more .md files, one for each rule. PSRule uses a naming convention with a file name the same as the rule to match rule to markdown. For example, metadata.Name.md would be used for a rule named metadata.Name . We recommend matching the rule name case exactly when naming markdown files. This is because some file systems are case-sensitive. For example on Linux Metadata.Name.md would not match. Within each markdown file a number of predefined sections are automatically interpreted by PSRule. While it is possible to have additional sections, they will be ignored by the help system. The basic structure of markdown help is as follows: --- {{ Annotations }} --- # {{ Name of rule }} {{ A brief summary of the rule }} ## Description {{ A detailed description of the rule }} ## Recommendation {{ A detailed explanation of the steps required to pass the rule }} ## Notes {{ Additional information or configuration options }} ## Links {{ Links to external references }} The PSRule Visual Studio Code extension includes snippets for writing markdown documentation.","title":"Writing markdown documentation"},{"location":"authoring/writing-rule-help/#annotations","text":"The annotation front matter at the top of the markdown document, is a set of key value pairs. Front matter follows YAML conventions and must start on the first line of the markdown document. A --- on a separate line indicates the start and end of the front matter block. Within the front matter block, all key value pairs are treated as annotations by PSRule. Annotations are optional metadata that are associated with the rule. Any annotations associated with a rule are included in output. Some examples of annotations include; severity , category , author . Annotations differ from tags in two key ways: Annotations are localized, and can have a different value for different languages; tags are not. Tags are indexed and can be used to filter rules; annotations have no affect on rule filtering. The following reserved annotation exists: online version - A URL to the online version of the document, used by Get-PSRuleHelp -Online . --- online version: https://github.com/microsoft/PSRule/blob/main/docs/scenarios/rule-docs/rule-docs.md --- The front matter start and end --- are not required and can be removed if no annotations are defined.","title":"Annotations"},{"location":"authoring/writing-rule-help/#display-name","text":"The document title, indicated by a level one heading # is the display name of the rule. The rule display name is shown when using Get-PSRuleHelp and is included in output. Specify the display name on a single line. Wrapping the display name across multiple lines is not supported. For example: # Use recommended name label","title":"Display name"},{"location":"authoring/writing-rule-help/#synopsis-section","text":"The synopsis section is indicated by the heading `. Any text following the heading is interpreted by PSRule and included in output. The synopsis is displayed when using Get-PSRule and Get-PSRuleHelp` cmdlets. The synopsis is intended to be a brief description of the rule, over a single line. A good synopsis should convey the purpose of the rule. A more verbose description can be included in the description section. For example: Deployments and services must use the app.kubernetes.io/name label.","title":"Synopsis section"},{"location":"authoring/writing-rule-help/#description-section","text":"The description section is indicated by the heading ## Description . Any text following the heading is interpreted by PSRule and included in output. The description is displayed when using the Get-PSRuleHelp cmdlet. The description is intended to be a verbose description of the rule. If your rule documentation needs to include background information include it here. PSRule supports semantic line breaks, and will automatically run together lines into a single paragraph. Use a blank line to separate paragraphs. For example: ## Description Kubernetes defines a common set of labels that are recommended for tool interoperability. These labels should be used to consistently apply standard metadata. The `app.kubernetes.io/name` label should be used to specify the name of the application.","title":"Description section"},{"location":"authoring/writing-rule-help/#recommendation-section","text":"The recommendation section is indicated by the heading ## Recommendation . Any text following the heading is interpreted by PSRule and included in output. The recommendation is displayed when using the Invoke-PSRule and Get-PSRuleHelp cmdlets. The recommendation is intended to identify corrective actions that can be taken to address any failures. Avoid using URLs within the recommendations. Use the links section to include references to external sources. PSRule supports semantic line breaks, and will automatically run together lines into a single paragraph. Use a blank line to separate paragraphs. For example: ## Recommendation Consider setting the recommended label `app.kubernetes.io/name` on deployment and service resources.","title":"Recommendation section"},{"location":"authoring/writing-rule-help/#notes-section","text":"The notes section is indicated by the heading ## Notes . Any text following the heading is interpreted by PSRule and included in pipeline output. Notes are excluded when formatting output as YAML and JSON. To view any included notes use the Get-PSRuleHelp cmdlet with the -Full switch. Use notes to include additional information such configuration options. PSRule supports semantic line breaks, and will automatically run together lines into a single paragraph. Use a blank line to separate paragraphs. For example: ## Notes The Kubernetes recommended labels include: - `app.kubernetes.io/name` - `app.kubernetes.io/instance` - `app.kubernetes.io/version` - `app.kubernetes.io/component` - `app.kubernetes.io/part-of` - `app.kubernetes.io/managed-by`","title":"Notes section"},{"location":"authoring/writing-rule-help/#links-section","text":"The links section is indicated by the heading ## Links . Any markdown links following the heading are interpreted by PSRule and included in pipeline output. Links are excluded when formatting output as YAML and JSON. To view any included links use the Get-PSRuleHelp cmdlet with the -Full switch. Use links to reference external sources with a URL. To specify links, use the markdown syntax [display name](url) . Include each link on a separate line. To improve display in web rendered markdown, use a list of links by prefixing the line with - . Additional text such as See additional information: is useful for web rendered views, but ignored by PSRule. For example: ## Links - [Recommended Labels](https://kubernetes.io/docs/concepts/overview/working-with-objects/common-labels/)","title":"Links section"},{"location":"authoring/writing-rule-help/#localizing-documentation-files","text":"When distributing rules, you may need to provide rule help in different languages. PSRule builds on the culture system in PowerShell.","title":"Localizing documentation files"},{"location":"authoring/writing-rule-help/#using-cultures","text":"A directory structure is used to identify the markdown documentation that should be used for each culture. To get a list of cultures in PowerShell the use cmdlet Get-Culture -ListAvailable . For example, store documentation targeted to the culture en-US in a directory named en-US . Similarly, documentation for cultures such as en-AU , en-GB and fr-FR would be in separate directories. If a directory for the exact culture en-US doesn't exist, PSRule will attempt to find the parent culture. For example, documentation would be read from a directory named en . When naming directories for their culture, use exact case. This is because some file systems are case-sensitive. For example on Linux en-us would not match.","title":"Using cultures"},{"location":"authoring/writing-rule-help/#culture-directory-search-path","text":"The path that PSRule looks for a culture directory in varies depending on how the rule is redistributed. Rules can be redistributed individually (loose) or included in a module. The following logic is used to locate the culture directory. If the rules are loose, PSRule will search for the culture directory in the same subdirectory as the .Rule.ps1 file. When rules are included in a module, PSRule will search for the culture directory in the same subdirectory as the module manifest .psd1 file. For example, loose file structure: .ps-rule/ en/ metadata.Name.md en-US/ metadata.Name.md fr-FR/ metadata.Name.md kubernetes.Rule.ps1 Module file structure: Kubernetes.Rules/ en/ metadata.Name.md en-US/ metadata.Name.md fr-FR/ metadata.Name.md rules/ kubernetes.Rule.ps1 Kubernetes.Rules.psd1","title":"Culture directory search path"},{"location":"authoring/writing-rule-help/#more-information","text":"kubernetes.Rule.ps1 - An example rule for validating name label. metadata.Name - An example markdown documentation file.","title":"More information"},{"location":"authoring/packaging-rules/Enterprise.Rules/en/Org.Az.Resource.Tagging/","text":"Use mandatory tags # Each resource must be tagged with mandatory tags. Description # Azure resources can be tagged with additional metadata. Our enterprise standard requires that the following tags are used: Environment BusinessUnit Department CostCode Recommendation # Consider tagging Azure resource with mandatory tags. Links # Use tags to organize your Azure resources and management hierarchy","title":"Use mandatory tags"},{"location":"authoring/packaging-rules/Enterprise.Rules/en/Org.Az.Resource.Tagging/#use-mandatory-tags","text":"Each resource must be tagged with mandatory tags.","title":"Use mandatory tags"},{"location":"authoring/packaging-rules/Enterprise.Rules/en/Org.Az.Resource.Tagging/#description","text":"Azure resources can be tagged with additional metadata. Our enterprise standard requires that the following tags are used: Environment BusinessUnit Department CostCode","title":"Description"},{"location":"authoring/packaging-rules/Enterprise.Rules/en/Org.Az.Resource.Tagging/#recommendation","text":"Consider tagging Azure resource with mandatory tags.","title":"Recommendation"},{"location":"authoring/packaging-rules/Enterprise.Rules/en/Org.Az.Resource.Tagging/#links","text":"Use tags to organize your Azure resources and management hierarchy","title":"Links"},{"location":"authoring/packaging-rules/Enterprise.Rules/en/Org.Az.Storage.UseHttps/","text":"Enforce encrypted Storage connections # Storage accounts should only accept encrypted connections. Description # An Azure Storage Account is configured to allow unencrypted connections. This does not indicate that unencrypted connections are being used. Unencrypted communication to storage accounts could allow disclosure of information to an untrusted party. Storage Accounts can be configured to require encrypted connections, by setting the Secure transfer required option. If secure transfer required is not enabled (the default), unencrypted and encrypted connections are permitted. When secure transfer required is enabled, attempts to connect to storage using HTTP or unencrypted SMB connections are rejected. Recommendation # Storage accounts should only accept secure traffic. Consider setting secure transfer required if there is no requirement to access storage over unencrypted connections. Also consider using Azure Policy to audit or enforce this configuration. Links # Require secure transfer in Azure Storage Sample policy for ensuring https traffic","title":"Enforce encrypted Storage connections"},{"location":"authoring/packaging-rules/Enterprise.Rules/en/Org.Az.Storage.UseHttps/#enforce-encrypted-storage-connections","text":"Storage accounts should only accept encrypted connections.","title":"Enforce encrypted Storage connections"},{"location":"authoring/packaging-rules/Enterprise.Rules/en/Org.Az.Storage.UseHttps/#description","text":"An Azure Storage Account is configured to allow unencrypted connections. This does not indicate that unencrypted connections are being used. Unencrypted communication to storage accounts could allow disclosure of information to an untrusted party. Storage Accounts can be configured to require encrypted connections, by setting the Secure transfer required option. If secure transfer required is not enabled (the default), unencrypted and encrypted connections are permitted. When secure transfer required is enabled, attempts to connect to storage using HTTP or unencrypted SMB connections are rejected.","title":"Description"},{"location":"authoring/packaging-rules/Enterprise.Rules/en/Org.Az.Storage.UseHttps/#recommendation","text":"Storage accounts should only accept secure traffic. Consider setting secure transfer required if there is no requirement to access storage over unencrypted connections. Also consider using Azure Policy to audit or enforce this configuration.","title":"Recommendation"},{"location":"authoring/packaging-rules/Enterprise.Rules/en/Org.Az.Storage.UseHttps/#links","text":"Require secure transfer in Azure Storage Sample policy for ensuring https traffic","title":"Links"},{"location":"authoring/writing-rule-help/en-US/metadata.Name/","text":"Use recommended name label # Deployments and services must use the app.kubernetes.io/name label. Description # Kubernetes defines a common set of labels that are recommended for tool interoperability. These labels should be used to consistently apply standard metadata. The app.kubernetes.io/name label should be used to specify the name of the application. Recommendation # Consider setting the recommended label app.kubernetes.io/name on deployment and service resources. Notes # The Kubernetes recommended labels include: app.kubernetes.io/name app.kubernetes.io/instance app.kubernetes.io/version app.kubernetes.io/component app.kubernetes.io/part-of app.kubernetes.io/managed-by Links # Recommended Labels","title":"Use recommended name label"},{"location":"authoring/writing-rule-help/en-US/metadata.Name/#use-recommended-name-label","text":"Deployments and services must use the app.kubernetes.io/name label.","title":"Use recommended name label"},{"location":"authoring/writing-rule-help/en-US/metadata.Name/#description","text":"Kubernetes defines a common set of labels that are recommended for tool interoperability. These labels should be used to consistently apply standard metadata. The app.kubernetes.io/name label should be used to specify the name of the application.","title":"Description"},{"location":"authoring/writing-rule-help/en-US/metadata.Name/#recommendation","text":"Consider setting the recommended label app.kubernetes.io/name on deployment and service resources.","title":"Recommendation"},{"location":"authoring/writing-rule-help/en-US/metadata.Name/#notes","text":"The Kubernetes recommended labels include: app.kubernetes.io/name app.kubernetes.io/instance app.kubernetes.io/version app.kubernetes.io/component app.kubernetes.io/part-of app.kubernetes.io/managed-by","title":"Notes"},{"location":"authoring/writing-rule-help/en-US/metadata.Name/#links","text":"Recommended Labels","title":"Links"},{"location":"commands/PSRule/en-US/Assert-PSRule/","text":"Assert-PSRule # Evaluate objects against matching rules and assert any failures. SYNTAX # Input (Default) # Assert-PSRule [-Module <String[]>] [-Format <InputFormat>] [-Baseline <BaselineOption>] [-Convention <String[]>] [-Style <OutputStyle>] [-Outcome <RuleOutcome>] [-As <ResultFormat>] [[-Path] <String[]>] [-Name <String[]>] [-Tag <Hashtable>] [-OutputPath <String>] [-OutputFormat <OutputFormat>] [-Option <PSRuleOption>] [-ObjectPath <String>] [-TargetType <String[]>] [-Culture <String[]>] -InputObject <PSObject> [-ResultVariable <String>] [-WhatIf] [-Confirm] [<CommonParameters>] InputPath # Assert-PSRule -InputPath <String[]> [-Module <String[]>] [-Format <InputFormat>] [-Baseline <BaselineOption>] [-Convention <String[]>] [-Style <OutputStyle>] [-Outcome <RuleOutcome>] [-As <ResultFormat>] [[-Path] <String[]>] [-Name <String[]>] [-Tag <Hashtable>] [-OutputPath <String>] [-OutputFormat <OutputFormat>] [-Option <PSRuleOption>] [-ObjectPath <String>] [-TargetType <String[]>] [-Culture <String[]>] [-ResultVariable <String>] [-WhatIf] [-Confirm] [<CommonParameters>] Description # Evaluate objects against matching rules and assert any failures. Objects can be specified directly from the pipeline or provided from file. The commands Invoke-PSRule and Assert-PSRule provide similar functionality, as differ as follows: Invoke-PSRule writes results as structured objects Assert-PSRule writes results as a formatted string. Examples # Example 1 # @{ Name = 'Item 1' } | Assert-PSRule ; Evaluate a simple hashtable on the pipeline against rules loaded from the current working path. Example 2 # # Define objects to validate $items = @(); $items += [PSCustomObject] @{ Name = 'Fridge' }; $items += [PSCustomObject] @{ Name = 'Apple' }; # Validate each item using rules saved in current working path $items | Assert-PSRule -Path .\\ docs \\ scenarios \\ fruit \\ -> Fridge : System.Management.Automation.PSCustomObject [FAIL] isFruit -> Apple : System.Management.Automation.PSCustomObject [PASS] isFruit Assert-PSRule : One or more rules reported failure. At line:1 char:10 + $items | Assert-PSRule -Path .\\docs\\scenarios\\fruit\\ + ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ + CategoryInfo : InvalidData: (:) [Assert-PSRule], FailPipelineException + FullyQualifiedErrorId : PSRule.Fail,Assert-PSRule Evaluate an array of objects on the pipeline against rules loaded a specified relative path. Example 3 # $items | Assert-PSRule -Module PSRule . Rules . Azure -o NUnit3 -OutputPath .\\ reports \\ results . xml Evaluate items from a pre-installed rules module PSRule.Rules.Azure. Additionally save the results as a NUnit report. Example 4 # $items | Assert-PSRule -Path .\\ docs \\ scenarios \\ fruit \\ -ResultVariable resultRecords ; Evaluate items and additionally save the results into a variable resultRecords . PARAMETERS # -InputPath # Instead of processing objects from the pipeline, import objects file the specified file paths. Type : String[] Parameter Sets : InputPath Aliases : f Required : True Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -Format # Configures the input format for when a string is passed in as a target object. When the -InputObject parameter or pipeline input is used, strings are treated as plain text by default. Set this option to either Yaml , Json , Markdown , PowerShellData to have PSRule deserialize the object. When the -InputPath parameter is used with a file path or URL. If the Detect format is used, the file extension will be used to automatically detect the format. When -InputPath is not used, Detect is the same as None . When this option is set to File PSRule scans the path and subdirectories specified by -InputPath . Files are treated as objects instead of being deserialized. Additional, PSRule uses the file extension as the object type. When files have no extension the whole file name is used. See about_PSRule_Options for details. This parameter takes precedence over the Input.Format option if set. Type : InputFormat Parameter Sets : (All) Aliases : Accepted values : None, Yaml, Json, Markdown, PowerShellData, File, Detect Required : False Position : Named Default value : Detect Accept pipeline input : False Accept wildcard characters : False -Baseline # Specifies an explicit baseline by name to use for evaluating rules. Baselines can contain filters and custom configuration that overrides the defaults. Type : BaselineOption Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -Convention # Specifies conventions by name to execute in the pipeline when processing objects. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -Culture # Specifies the culture to use for rule documentation and messages. By default, the culture of PowerShell is used. This option does not affect the culture used for the PSRule engine, which always uses the culture of PowerShell. The PowerShell cmdlet Get-Culture shows the current culture of PowerShell. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -Module # Search for rule definitions within a module. If no sources are specified by -Path , -Module , or options, the current working directory is used. Type : String[] Parameter Sets : (All) Aliases : m Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -Name # The name of a specific rule to evaluate. If this parameter is not specified all rules in search paths will be evaluated. Type : String[] Parameter Sets : (All) Aliases : n Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -ObjectPath # The name of a property to use instead of the pipeline object. If the property specified by ObjectPath is a collection or an array, then each item in evaluated separately. Type : String Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -TargetType # Filters input objects by TargetType. If specified, only objects with the specified TargetType are processed. Objects that do not match TargetType are ignored. If multiple values are specified, only one TargetType must match. This parameter is not case-sensitive. By default, all objects are processed. This parameter if set, overrides the Input.TargetType option. To change the field TargetType is bound to set the Binding.TargetType option. For details see the about_PSRule_Options help topic. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -Option # Additional options that configure execution. A PSRuleOption can be created by using the New-PSRuleOption cmdlet. Alternatively, a hashtable or path to YAML file can be specified with options. For more information on PSRule options see about_PSRule_Options. Type : PSRuleOption Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -OutputPath # Specifies the output file path to write results. Directories along the file path will automatically be created if they do not exist. Type : String Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -OutputFormat # Configures the format that output is written. This parameter has no affect when -OutputPath is not specified. The following format options are available: None - Output is presented as an object using PowerShell defaults. This is the default. Yaml - Output is serialized as YAML. Json - Output is serialized as JSON. Markdown - Output is serialized as Markdown. NUnit3 - Output is serialized as NUnit3 (XML). Csv - Output is serialized as a comma separated values (CSV). Sarif - Output is serialized as SARIF. The Wide format is not applicable to Assert-PSRule . Type : OutputFormat Parameter Sets : (All) Aliases : o Accepted values : None, Yaml, Json, Markdown, NUnit3, Csv, Sarif Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -Style # Configures the style that results will be presented in. The following styles are available: Client - Output is written to the host directly in green/ red to indicate outcome. Plain - Output is written as an unformatted string. This option can be redirected to a file. AzurePipelines - Output is written for integration Azure Pipelines. GitHubActions - Output is written for integration GitHub Actions. VisualStudioCode - Output is written for integration with Visual Studio Code. Detect - Output style will be detected by checking the environment variables. This is the default. Detect uses the following logic: If the TF_BUILD environment variable is set to true , AzurePipelines will be used. If the GITHUB_ACTIONS environment variable is set to true , GitHubActions will be used. If the TERM_PROGRAM environment variable is set to vscode , VisualStudioCode will be used. Use Client . Each of these styles outputs to the host. To capture output as a string redirect the information stream. For example: 6>&1 Type : OutputStyle Parameter Sets : (All) Aliases : Accepted values : Client, Plain, AzurePipelines, GitHubActions, VisualStudioCode, Detect Required : False Position : Named Default value : Client Accept pipeline input : False Accept wildcard characters : False -As # The type of results to produce. Detailed results are generated by default. The following result formats are available: Detail - Returns pass/ fail results for each rule per object. Summary - Failure or errors are shown but passing results are summarized. Type : ResultFormat Parameter Sets : (All) Aliases : Accepted values : Detail, Summary Required : False Position : Named Default value : Detail Accept pipeline input : False Accept wildcard characters : False -Outcome # Filter output to only show rule results with a specific outcome. Type : RuleOutcome Parameter Sets : (All) Aliases : Accepted values : Pass, Fail, Error, None, Processed, All Required : False Position : Named Default value : Pass, Fail, Error Accept pipeline input : False Accept wildcard characters : False -Path # One or more paths to search for rule definitions within. Type : String[] Parameter Sets : (All) Aliases : p Required : False Position : 0 Default value : None Accept pipeline input : False Accept wildcard characters : False -Tag # Only get rules with the specified tags set. If this parameter is not specified all rules in search paths will be returned. When more than one tag is used, all tags must match. Tags are not case sensitive. A tag value of * may be used to filter rules to any rule with the tag set, regardless of tag value. An array of tag values can be used to match a rule with either value. i.e. severity = important, critical matches rules with a category of either important or critical . Type : Hashtable Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -InputObject # The pipeline object to process rules for. Type : PSObject Parameter Sets : Input Aliases : TargetObject Required : True Position : Named Default value : None Accept pipeline input : True (ByValue) Accept wildcard characters : False -ResultVariable # Stores output result objects in the specified variable. Type : String Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -WhatIf # Shows what would happen if the cmdlet runs. The cmdlet is not run. Type : SwitchParameter Parameter Sets : (All) Aliases : wi Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -Confirm # Prompts you for confirmation before running the cmdlet. Type : SwitchParameter Parameter Sets : (All) Aliases : cf Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False CommonParameters # This cmdlet supports the common parameters: -Debug, -ErrorAction, -ErrorVariable, -InformationAction, -InformationVariable, -OutVariable, -OutBuffer, -PipelineVariable, -Verbose, -WarningAction, and -WarningVariable. For more information, see about_CommonParameters . INPUTS # System.Management.Automation.PSObject # You can pipe any object to Assert-PSRule . OUTPUTS # System.String # Notes # RELATED LINKS # Get-PSRule Invoke-PSRule Test-PSRuleTarget","title":"Assert-PSRule"},{"location":"commands/PSRule/en-US/Assert-PSRule/#assert-psrule","text":"Evaluate objects against matching rules and assert any failures.","title":"Assert-PSRule"},{"location":"commands/PSRule/en-US/Assert-PSRule/#syntax","text":"","title":"SYNTAX"},{"location":"commands/PSRule/en-US/Assert-PSRule/#input-default","text":"Assert-PSRule [-Module <String[]>] [-Format <InputFormat>] [-Baseline <BaselineOption>] [-Convention <String[]>] [-Style <OutputStyle>] [-Outcome <RuleOutcome>] [-As <ResultFormat>] [[-Path] <String[]>] [-Name <String[]>] [-Tag <Hashtable>] [-OutputPath <String>] [-OutputFormat <OutputFormat>] [-Option <PSRuleOption>] [-ObjectPath <String>] [-TargetType <String[]>] [-Culture <String[]>] -InputObject <PSObject> [-ResultVariable <String>] [-WhatIf] [-Confirm] [<CommonParameters>]","title":"Input (Default)"},{"location":"commands/PSRule/en-US/Assert-PSRule/#inputpath","text":"Assert-PSRule -InputPath <String[]> [-Module <String[]>] [-Format <InputFormat>] [-Baseline <BaselineOption>] [-Convention <String[]>] [-Style <OutputStyle>] [-Outcome <RuleOutcome>] [-As <ResultFormat>] [[-Path] <String[]>] [-Name <String[]>] [-Tag <Hashtable>] [-OutputPath <String>] [-OutputFormat <OutputFormat>] [-Option <PSRuleOption>] [-ObjectPath <String>] [-TargetType <String[]>] [-Culture <String[]>] [-ResultVariable <String>] [-WhatIf] [-Confirm] [<CommonParameters>]","title":"InputPath"},{"location":"commands/PSRule/en-US/Assert-PSRule/#description","text":"Evaluate objects against matching rules and assert any failures. Objects can be specified directly from the pipeline or provided from file. The commands Invoke-PSRule and Assert-PSRule provide similar functionality, as differ as follows: Invoke-PSRule writes results as structured objects Assert-PSRule writes results as a formatted string.","title":"Description"},{"location":"commands/PSRule/en-US/Assert-PSRule/#examples","text":"","title":"Examples"},{"location":"commands/PSRule/en-US/Assert-PSRule/#example-1","text":"@{ Name = 'Item 1' } | Assert-PSRule ; Evaluate a simple hashtable on the pipeline against rules loaded from the current working path.","title":"Example 1"},{"location":"commands/PSRule/en-US/Assert-PSRule/#example-2","text":"# Define objects to validate $items = @(); $items += [PSCustomObject] @{ Name = 'Fridge' }; $items += [PSCustomObject] @{ Name = 'Apple' }; # Validate each item using rules saved in current working path $items | Assert-PSRule -Path .\\ docs \\ scenarios \\ fruit \\ -> Fridge : System.Management.Automation.PSCustomObject [FAIL] isFruit -> Apple : System.Management.Automation.PSCustomObject [PASS] isFruit Assert-PSRule : One or more rules reported failure. At line:1 char:10 + $items | Assert-PSRule -Path .\\docs\\scenarios\\fruit\\ + ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ + CategoryInfo : InvalidData: (:) [Assert-PSRule], FailPipelineException + FullyQualifiedErrorId : PSRule.Fail,Assert-PSRule Evaluate an array of objects on the pipeline against rules loaded a specified relative path.","title":"Example 2"},{"location":"commands/PSRule/en-US/Assert-PSRule/#example-3","text":"$items | Assert-PSRule -Module PSRule . Rules . Azure -o NUnit3 -OutputPath .\\ reports \\ results . xml Evaluate items from a pre-installed rules module PSRule.Rules.Azure. Additionally save the results as a NUnit report.","title":"Example 3"},{"location":"commands/PSRule/en-US/Assert-PSRule/#example-4","text":"$items | Assert-PSRule -Path .\\ docs \\ scenarios \\ fruit \\ -ResultVariable resultRecords ; Evaluate items and additionally save the results into a variable resultRecords .","title":"Example 4"},{"location":"commands/PSRule/en-US/Assert-PSRule/#parameters","text":"","title":"PARAMETERS"},{"location":"commands/PSRule/en-US/Assert-PSRule/#-inputpath","text":"Instead of processing objects from the pipeline, import objects file the specified file paths. Type : String[] Parameter Sets : InputPath Aliases : f Required : True Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-InputPath"},{"location":"commands/PSRule/en-US/Assert-PSRule/#-format","text":"Configures the input format for when a string is passed in as a target object. When the -InputObject parameter or pipeline input is used, strings are treated as plain text by default. Set this option to either Yaml , Json , Markdown , PowerShellData to have PSRule deserialize the object. When the -InputPath parameter is used with a file path or URL. If the Detect format is used, the file extension will be used to automatically detect the format. When -InputPath is not used, Detect is the same as None . When this option is set to File PSRule scans the path and subdirectories specified by -InputPath . Files are treated as objects instead of being deserialized. Additional, PSRule uses the file extension as the object type. When files have no extension the whole file name is used. See about_PSRule_Options for details. This parameter takes precedence over the Input.Format option if set. Type : InputFormat Parameter Sets : (All) Aliases : Accepted values : None, Yaml, Json, Markdown, PowerShellData, File, Detect Required : False Position : Named Default value : Detect Accept pipeline input : False Accept wildcard characters : False","title":"-Format"},{"location":"commands/PSRule/en-US/Assert-PSRule/#-baseline","text":"Specifies an explicit baseline by name to use for evaluating rules. Baselines can contain filters and custom configuration that overrides the defaults. Type : BaselineOption Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Baseline"},{"location":"commands/PSRule/en-US/Assert-PSRule/#-convention","text":"Specifies conventions by name to execute in the pipeline when processing objects. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Convention"},{"location":"commands/PSRule/en-US/Assert-PSRule/#-culture","text":"Specifies the culture to use for rule documentation and messages. By default, the culture of PowerShell is used. This option does not affect the culture used for the PSRule engine, which always uses the culture of PowerShell. The PowerShell cmdlet Get-Culture shows the current culture of PowerShell. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Culture"},{"location":"commands/PSRule/en-US/Assert-PSRule/#-module","text":"Search for rule definitions within a module. If no sources are specified by -Path , -Module , or options, the current working directory is used. Type : String[] Parameter Sets : (All) Aliases : m Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Module"},{"location":"commands/PSRule/en-US/Assert-PSRule/#-name","text":"The name of a specific rule to evaluate. If this parameter is not specified all rules in search paths will be evaluated. Type : String[] Parameter Sets : (All) Aliases : n Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Name"},{"location":"commands/PSRule/en-US/Assert-PSRule/#-objectpath","text":"The name of a property to use instead of the pipeline object. If the property specified by ObjectPath is a collection or an array, then each item in evaluated separately. Type : String Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-ObjectPath"},{"location":"commands/PSRule/en-US/Assert-PSRule/#-targettype","text":"Filters input objects by TargetType. If specified, only objects with the specified TargetType are processed. Objects that do not match TargetType are ignored. If multiple values are specified, only one TargetType must match. This parameter is not case-sensitive. By default, all objects are processed. This parameter if set, overrides the Input.TargetType option. To change the field TargetType is bound to set the Binding.TargetType option. For details see the about_PSRule_Options help topic. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-TargetType"},{"location":"commands/PSRule/en-US/Assert-PSRule/#-option","text":"Additional options that configure execution. A PSRuleOption can be created by using the New-PSRuleOption cmdlet. Alternatively, a hashtable or path to YAML file can be specified with options. For more information on PSRule options see about_PSRule_Options. Type : PSRuleOption Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Option"},{"location":"commands/PSRule/en-US/Assert-PSRule/#-outputpath","text":"Specifies the output file path to write results. Directories along the file path will automatically be created if they do not exist. Type : String Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-OutputPath"},{"location":"commands/PSRule/en-US/Assert-PSRule/#-outputformat","text":"Configures the format that output is written. This parameter has no affect when -OutputPath is not specified. The following format options are available: None - Output is presented as an object using PowerShell defaults. This is the default. Yaml - Output is serialized as YAML. Json - Output is serialized as JSON. Markdown - Output is serialized as Markdown. NUnit3 - Output is serialized as NUnit3 (XML). Csv - Output is serialized as a comma separated values (CSV). Sarif - Output is serialized as SARIF. The Wide format is not applicable to Assert-PSRule . Type : OutputFormat Parameter Sets : (All) Aliases : o Accepted values : None, Yaml, Json, Markdown, NUnit3, Csv, Sarif Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-OutputFormat"},{"location":"commands/PSRule/en-US/Assert-PSRule/#-style","text":"Configures the style that results will be presented in. The following styles are available: Client - Output is written to the host directly in green/ red to indicate outcome. Plain - Output is written as an unformatted string. This option can be redirected to a file. AzurePipelines - Output is written for integration Azure Pipelines. GitHubActions - Output is written for integration GitHub Actions. VisualStudioCode - Output is written for integration with Visual Studio Code. Detect - Output style will be detected by checking the environment variables. This is the default. Detect uses the following logic: If the TF_BUILD environment variable is set to true , AzurePipelines will be used. If the GITHUB_ACTIONS environment variable is set to true , GitHubActions will be used. If the TERM_PROGRAM environment variable is set to vscode , VisualStudioCode will be used. Use Client . Each of these styles outputs to the host. To capture output as a string redirect the information stream. For example: 6>&1 Type : OutputStyle Parameter Sets : (All) Aliases : Accepted values : Client, Plain, AzurePipelines, GitHubActions, VisualStudioCode, Detect Required : False Position : Named Default value : Client Accept pipeline input : False Accept wildcard characters : False","title":"-Style"},{"location":"commands/PSRule/en-US/Assert-PSRule/#-as","text":"The type of results to produce. Detailed results are generated by default. The following result formats are available: Detail - Returns pass/ fail results for each rule per object. Summary - Failure or errors are shown but passing results are summarized. Type : ResultFormat Parameter Sets : (All) Aliases : Accepted values : Detail, Summary Required : False Position : Named Default value : Detail Accept pipeline input : False Accept wildcard characters : False","title":"-As"},{"location":"commands/PSRule/en-US/Assert-PSRule/#-outcome","text":"Filter output to only show rule results with a specific outcome. Type : RuleOutcome Parameter Sets : (All) Aliases : Accepted values : Pass, Fail, Error, None, Processed, All Required : False Position : Named Default value : Pass, Fail, Error Accept pipeline input : False Accept wildcard characters : False","title":"-Outcome"},{"location":"commands/PSRule/en-US/Assert-PSRule/#-path","text":"One or more paths to search for rule definitions within. Type : String[] Parameter Sets : (All) Aliases : p Required : False Position : 0 Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Path"},{"location":"commands/PSRule/en-US/Assert-PSRule/#-tag","text":"Only get rules with the specified tags set. If this parameter is not specified all rules in search paths will be returned. When more than one tag is used, all tags must match. Tags are not case sensitive. A tag value of * may be used to filter rules to any rule with the tag set, regardless of tag value. An array of tag values can be used to match a rule with either value. i.e. severity = important, critical matches rules with a category of either important or critical . Type : Hashtable Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Tag"},{"location":"commands/PSRule/en-US/Assert-PSRule/#-inputobject","text":"The pipeline object to process rules for. Type : PSObject Parameter Sets : Input Aliases : TargetObject Required : True Position : Named Default value : None Accept pipeline input : True (ByValue) Accept wildcard characters : False","title":"-InputObject"},{"location":"commands/PSRule/en-US/Assert-PSRule/#-resultvariable","text":"Stores output result objects in the specified variable. Type : String Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-ResultVariable"},{"location":"commands/PSRule/en-US/Assert-PSRule/#-whatif","text":"Shows what would happen if the cmdlet runs. The cmdlet is not run. Type : SwitchParameter Parameter Sets : (All) Aliases : wi Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-WhatIf"},{"location":"commands/PSRule/en-US/Assert-PSRule/#-confirm","text":"Prompts you for confirmation before running the cmdlet. Type : SwitchParameter Parameter Sets : (All) Aliases : cf Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Confirm"},{"location":"commands/PSRule/en-US/Assert-PSRule/#commonparameters","text":"This cmdlet supports the common parameters: -Debug, -ErrorAction, -ErrorVariable, -InformationAction, -InformationVariable, -OutVariable, -OutBuffer, -PipelineVariable, -Verbose, -WarningAction, and -WarningVariable. For more information, see about_CommonParameters .","title":"CommonParameters"},{"location":"commands/PSRule/en-US/Assert-PSRule/#inputs","text":"","title":"INPUTS"},{"location":"commands/PSRule/en-US/Assert-PSRule/#systemmanagementautomationpsobject","text":"You can pipe any object to Assert-PSRule .","title":"System.Management.Automation.PSObject"},{"location":"commands/PSRule/en-US/Assert-PSRule/#outputs","text":"","title":"OUTPUTS"},{"location":"commands/PSRule/en-US/Assert-PSRule/#systemstring","text":"","title":"System.String"},{"location":"commands/PSRule/en-US/Assert-PSRule/#notes","text":"","title":"Notes"},{"location":"commands/PSRule/en-US/Assert-PSRule/#related-links","text":"Get-PSRule Invoke-PSRule Test-PSRuleTarget","title":"RELATED LINKS"},{"location":"commands/PSRule/en-US/Export-PSRuleBaseline/","text":"Export-PSRuleBaseline # Exports a list of baselines. SYNTAX # Export-PSRuleBaseline [-Module <String[]>] [[-Path] <String[]>] [-Name <String[]>] [-Option <PSRuleOption>] [-Culture <String>] [-OutputFormat <OutputFormat>] -OutputPath <String> [-OutputEncoding <OutputEncoding>] [-WhatIf] [-Confirm] [<CommonParameters>] Description # Exports a list of baselines to a file. Examples # Example 1 # Export-PSRuleBaseline -Module PSRule . Rules . Azure -OutputFormat Yaml -OutputPath Baseline . Rule . yml Exports list of baselines from PSRule.Rules.Azure module to file Baseline.Rule.yml in YAML output format. PARAMETERS # -Module # Search for baselines definitions within a module. If no sources are specified by -Path , -Module , or options, the current working directory is used. Type : String[] Parameter Sets : (All) Aliases : m Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -Path # One or more paths to search for baselines within. Type : String[] Parameter Sets : (All) Aliases : p Required : False Position : 1 Default value : None Accept pipeline input : False Accept wildcard characters : False -Name # The name of a specific baseline to list. If this parameter is not specified all baselines in search paths will be listed. Type : String[] Parameter Sets : (All) Aliases : n Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : True -Option # Additional options that configure execution. A PSRuleOption can be created by using the New-PSRuleOption cmdlet. Alternatively a hashtable or path to YAML file can be specified with options. For more information on PSRule options see about_PSRule_Options. Type : PSRuleOption Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -Culture # Specifies the culture to use for documentation and messages. By default, the culture of PowerShell is used. This option does not affect the culture used for the PSRule engine, which always uses the culture of PowerShell. The PowerShell cmdlet Get-Culture shows the current culture of PowerShell. Type : String Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -OutputFormat # Configures the format that output is presented in. The following format options are available: Yaml - Output is serialized as YAML. This is the default. Json - Output is serialized as JSON. Type : OutputFormat Parameter Sets : (All) Aliases : o Accepted values : Yaml, Json Required : False Position : Named Default value : Yaml Accept pipeline input : False Accept wildcard characters : False -OutputEncoding # Sets the option Output.Encoding . The Output.Encoding option configured the encoding used to write results to file. Type : OutputEncoding Parameter Sets : (All) Aliases : Accepted values : Default, UTF8, UTF7, Unicode, UTF32, ASCII Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -OutputPath # Sets the option Output.Path . The Output.Path option configures the output path the results are written to. Type : String Parameter Sets : (All) Aliases : Required : True Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -WhatIf # Shows what would happen if the cmdlet runs. The cmdlet is not run. Type : SwitchParameter Parameter Sets : (All) Aliases : wi Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -Confirm # Prompts you for confirmation before running the cmdlet. Type : SwitchParameter Parameter Sets : (All) Aliases : cf Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False CommonParameters # This cmdlet supports the common parameters: -Debug, -ErrorAction, -ErrorVariable, -InformationAction, -InformationVariable, -OutVariable, -OutBuffer, -PipelineVariable, -Verbose, -WarningAction, and -WarningVariable. For more information, see about_CommonParameters . INPUTS # OUTPUTS # Notes # RELATED LINKS # Get-PSRuleBaseline","title":"Export-PSRuleBaseline"},{"location":"commands/PSRule/en-US/Export-PSRuleBaseline/#export-psrulebaseline","text":"Exports a list of baselines.","title":"Export-PSRuleBaseline"},{"location":"commands/PSRule/en-US/Export-PSRuleBaseline/#syntax","text":"Export-PSRuleBaseline [-Module <String[]>] [[-Path] <String[]>] [-Name <String[]>] [-Option <PSRuleOption>] [-Culture <String>] [-OutputFormat <OutputFormat>] -OutputPath <String> [-OutputEncoding <OutputEncoding>] [-WhatIf] [-Confirm] [<CommonParameters>]","title":"SYNTAX"},{"location":"commands/PSRule/en-US/Export-PSRuleBaseline/#description","text":"Exports a list of baselines to a file.","title":"Description"},{"location":"commands/PSRule/en-US/Export-PSRuleBaseline/#examples","text":"","title":"Examples"},{"location":"commands/PSRule/en-US/Export-PSRuleBaseline/#example-1","text":"Export-PSRuleBaseline -Module PSRule . Rules . Azure -OutputFormat Yaml -OutputPath Baseline . Rule . yml Exports list of baselines from PSRule.Rules.Azure module to file Baseline.Rule.yml in YAML output format.","title":"Example 1"},{"location":"commands/PSRule/en-US/Export-PSRuleBaseline/#parameters","text":"","title":"PARAMETERS"},{"location":"commands/PSRule/en-US/Export-PSRuleBaseline/#-module","text":"Search for baselines definitions within a module. If no sources are specified by -Path , -Module , or options, the current working directory is used. Type : String[] Parameter Sets : (All) Aliases : m Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Module"},{"location":"commands/PSRule/en-US/Export-PSRuleBaseline/#-path","text":"One or more paths to search for baselines within. Type : String[] Parameter Sets : (All) Aliases : p Required : False Position : 1 Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Path"},{"location":"commands/PSRule/en-US/Export-PSRuleBaseline/#-name","text":"The name of a specific baseline to list. If this parameter is not specified all baselines in search paths will be listed. Type : String[] Parameter Sets : (All) Aliases : n Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : True","title":"-Name"},{"location":"commands/PSRule/en-US/Export-PSRuleBaseline/#-option","text":"Additional options that configure execution. A PSRuleOption can be created by using the New-PSRuleOption cmdlet. Alternatively a hashtable or path to YAML file can be specified with options. For more information on PSRule options see about_PSRule_Options. Type : PSRuleOption Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Option"},{"location":"commands/PSRule/en-US/Export-PSRuleBaseline/#-culture","text":"Specifies the culture to use for documentation and messages. By default, the culture of PowerShell is used. This option does not affect the culture used for the PSRule engine, which always uses the culture of PowerShell. The PowerShell cmdlet Get-Culture shows the current culture of PowerShell. Type : String Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Culture"},{"location":"commands/PSRule/en-US/Export-PSRuleBaseline/#-outputformat","text":"Configures the format that output is presented in. The following format options are available: Yaml - Output is serialized as YAML. This is the default. Json - Output is serialized as JSON. Type : OutputFormat Parameter Sets : (All) Aliases : o Accepted values : Yaml, Json Required : False Position : Named Default value : Yaml Accept pipeline input : False Accept wildcard characters : False","title":"-OutputFormat"},{"location":"commands/PSRule/en-US/Export-PSRuleBaseline/#-outputencoding","text":"Sets the option Output.Encoding . The Output.Encoding option configured the encoding used to write results to file. Type : OutputEncoding Parameter Sets : (All) Aliases : Accepted values : Default, UTF8, UTF7, Unicode, UTF32, ASCII Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-OutputEncoding"},{"location":"commands/PSRule/en-US/Export-PSRuleBaseline/#-outputpath","text":"Sets the option Output.Path . The Output.Path option configures the output path the results are written to. Type : String Parameter Sets : (All) Aliases : Required : True Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-OutputPath"},{"location":"commands/PSRule/en-US/Export-PSRuleBaseline/#-whatif","text":"Shows what would happen if the cmdlet runs. The cmdlet is not run. Type : SwitchParameter Parameter Sets : (All) Aliases : wi Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-WhatIf"},{"location":"commands/PSRule/en-US/Export-PSRuleBaseline/#-confirm","text":"Prompts you for confirmation before running the cmdlet. Type : SwitchParameter Parameter Sets : (All) Aliases : cf Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Confirm"},{"location":"commands/PSRule/en-US/Export-PSRuleBaseline/#commonparameters","text":"This cmdlet supports the common parameters: -Debug, -ErrorAction, -ErrorVariable, -InformationAction, -InformationVariable, -OutVariable, -OutBuffer, -PipelineVariable, -Verbose, -WarningAction, and -WarningVariable. For more information, see about_CommonParameters .","title":"CommonParameters"},{"location":"commands/PSRule/en-US/Export-PSRuleBaseline/#inputs","text":"","title":"INPUTS"},{"location":"commands/PSRule/en-US/Export-PSRuleBaseline/#outputs","text":"","title":"OUTPUTS"},{"location":"commands/PSRule/en-US/Export-PSRuleBaseline/#notes","text":"","title":"Notes"},{"location":"commands/PSRule/en-US/Export-PSRuleBaseline/#related-links","text":"Get-PSRuleBaseline","title":"RELATED LINKS"},{"location":"commands/PSRule/en-US/Get-PSRule/","text":"Get-PSRule # Get a list of rule definitions. SYNTAX # Get-PSRule [-Module <String[]>] [-ListAvailable] [-OutputFormat <OutputFormat>] [-Baseline <BaselineOption>] [[-Path] <String[]>] [-Name <String[]>] [-Tag <Hashtable>] [-Option <PSRuleOption>] [-Culture <String>] [-IncludeDependencies] [<CommonParameters>] Description # Get a list of matching rule definitions within the search path. Examples # Example 1 # Get-PSRule ; RuleName ModuleName Synopsis -------- ---------- -------- isFruit An example rule Get a list of rule definitions from the current working path. Example 2 # Get-PSRule -Module PSRule . Rules . Azure ; RuleName ModuleName Synopsis -------- ---------- -------- Azure.ACR.AdminUser PSRule.Rules.Azure Use Azure AD accounts instead of using the registry adm\u2026 Azure.ACR.MinSku PSRule.Rules.Azure ACR should use the Premium or Standard SKU for producti\u2026 Azure.AKS.MinNodeCount PSRule.Rules.Azure AKS clusters should have minimum number of nodes for fa\u2026 Azure.AKS.Version PSRule.Rules.Azure AKS clusters should meet the minimum version. Azure.AKS.UseRBAC PSRule.Rules.Azure AKS cluster should use role-based access control (RBAC). Get a list of rule definitions included in the module PSRule.Rules.Azure . Example 3 # Get-PSRule -Module PSRule . Rules . Azure -OutputFormat Wide ; RuleName ModuleName Synopsis Tag -------- ---------- -------- --- Azure.ACR.AdminUser PSRule.Rules.Azure Use Azure AD accounts severity='Critical' instead of using the category='Security registry admin user. configuration' Azure.ACR.MinSku PSRule.Rules.Azure ACR should use the Premium severity='Important' or Standard SKU for category='Performance' production deployments. Azure.AKS.MinNodeCount PSRule.Rules.Azure AKS clusters should have severity='Important' minimum number of nodes for category='Reliability' failover and updates. Azure.AKS.Version PSRule.Rules.Azure AKS clusters should meet severity='Important' the minimum version. category='Operations management' Azure.AKS.UseRBAC PSRule.Rules.Azure AKS cluster should use severity='Important' role-based access control category='Security (RBAC). configuration' Get a list of rule definitions included in the module PSRule.Rules.Azure including tags with line wrapping. PARAMETERS # -Name # The name of a specific rule to list. If this parameter is not specified all rules in search paths will be listed. Type : String[] Parameter Sets : (All) Aliases : n Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -Path # One or more paths to search for rule definitions within. Type : String[] Parameter Sets : (All) Aliases : p Required : False Position : 0 Default value : None Accept pipeline input : False Accept wildcard characters : False -Tag # Only get rules with the specified tags set. If this parameter is not specified all rules in search paths will be returned. When more than one tag is used, all tags must match. Tags are not case sensitive. A tag value of * may be used to filter rules to any rule with the tag set, regardless of tag value. An array of tag values can be used to match a rule with either value. i.e. severity = important, critical matches rules with a category of either important or critical . Type : Hashtable Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -Option # Additional options that configure execution. A PSRuleOption can be created by using the New-PSRuleOption cmdlet. Alternatively a hashtable or path to YAML file can be specified with options. For more information on PSRule options see about_PSRule_Options. Type : PSRuleOption Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -ListAvailable # Look for modules containing rule definitions including modules that are currently not imported. This switch is used with the -Module parameter. Type : SwitchParameter Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -Module # Search for rule definitions within a module. If no sources are specified by -Path , -Module , or options, the current working directory is used. Type : String[] Parameter Sets : (All) Aliases : m Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -Culture # Specifies the culture to use for documentation and messages. By default, the culture of PowerShell is used. This option does not affect the culture used for the PSRule engine, which always uses the culture of PowerShell. The PowerShell cmdlet Get-Culture shows the current culture of PowerShell. Type : String Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -OutputFormat # Configures the format that output is presented in. The following format options are available: None - Output is presented as an object using PowerShell defaults. This is the default. Wide - Output is presented using the wide table format, which includes tags and wraps columns. Yaml - Output is serialized as YAML. Json - Output is serialized as JSON. Type : OutputFormat Parameter Sets : (All) Aliases : o Accepted values : None, Wide, Yaml, Json Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -IncludeDependencies # When this switch is specified, dependencies of the rules that meet the -Name and -Tag filters are included even if they would normally be excluded. This switch has no affect when getting an unfiltered list of rules. Type : SwitchParameter Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -Baseline # When specified, rules are filtered so that only rules that are included in the baselines are returned. Type : BaselineOption Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False CommonParameters # This cmdlet supports the common parameters: -Debug, -ErrorAction, -ErrorVariable, -InformationAction, -InformationVariable, -OutVariable, -OutBuffer, -PipelineVariable, -Verbose, -WarningAction, and -WarningVariable. For more information, see about_CommonParameters . INPUTS # None # OUTPUTS # PSRule.Definitions.Rules.IRuleV1 # Notes # RELATED LINKS # Invoke-PSRule","title":"Get-PSRule"},{"location":"commands/PSRule/en-US/Get-PSRule/#get-psrule","text":"Get a list of rule definitions.","title":"Get-PSRule"},{"location":"commands/PSRule/en-US/Get-PSRule/#syntax","text":"Get-PSRule [-Module <String[]>] [-ListAvailable] [-OutputFormat <OutputFormat>] [-Baseline <BaselineOption>] [[-Path] <String[]>] [-Name <String[]>] [-Tag <Hashtable>] [-Option <PSRuleOption>] [-Culture <String>] [-IncludeDependencies] [<CommonParameters>]","title":"SYNTAX"},{"location":"commands/PSRule/en-US/Get-PSRule/#description","text":"Get a list of matching rule definitions within the search path.","title":"Description"},{"location":"commands/PSRule/en-US/Get-PSRule/#examples","text":"","title":"Examples"},{"location":"commands/PSRule/en-US/Get-PSRule/#example-1","text":"Get-PSRule ; RuleName ModuleName Synopsis -------- ---------- -------- isFruit An example rule Get a list of rule definitions from the current working path.","title":"Example 1"},{"location":"commands/PSRule/en-US/Get-PSRule/#example-2","text":"Get-PSRule -Module PSRule . Rules . Azure ; RuleName ModuleName Synopsis -------- ---------- -------- Azure.ACR.AdminUser PSRule.Rules.Azure Use Azure AD accounts instead of using the registry adm\u2026 Azure.ACR.MinSku PSRule.Rules.Azure ACR should use the Premium or Standard SKU for producti\u2026 Azure.AKS.MinNodeCount PSRule.Rules.Azure AKS clusters should have minimum number of nodes for fa\u2026 Azure.AKS.Version PSRule.Rules.Azure AKS clusters should meet the minimum version. Azure.AKS.UseRBAC PSRule.Rules.Azure AKS cluster should use role-based access control (RBAC). Get a list of rule definitions included in the module PSRule.Rules.Azure .","title":"Example 2"},{"location":"commands/PSRule/en-US/Get-PSRule/#example-3","text":"Get-PSRule -Module PSRule . Rules . Azure -OutputFormat Wide ; RuleName ModuleName Synopsis Tag -------- ---------- -------- --- Azure.ACR.AdminUser PSRule.Rules.Azure Use Azure AD accounts severity='Critical' instead of using the category='Security registry admin user. configuration' Azure.ACR.MinSku PSRule.Rules.Azure ACR should use the Premium severity='Important' or Standard SKU for category='Performance' production deployments. Azure.AKS.MinNodeCount PSRule.Rules.Azure AKS clusters should have severity='Important' minimum number of nodes for category='Reliability' failover and updates. Azure.AKS.Version PSRule.Rules.Azure AKS clusters should meet severity='Important' the minimum version. category='Operations management' Azure.AKS.UseRBAC PSRule.Rules.Azure AKS cluster should use severity='Important' role-based access control category='Security (RBAC). configuration' Get a list of rule definitions included in the module PSRule.Rules.Azure including tags with line wrapping.","title":"Example 3"},{"location":"commands/PSRule/en-US/Get-PSRule/#parameters","text":"","title":"PARAMETERS"},{"location":"commands/PSRule/en-US/Get-PSRule/#-name","text":"The name of a specific rule to list. If this parameter is not specified all rules in search paths will be listed. Type : String[] Parameter Sets : (All) Aliases : n Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Name"},{"location":"commands/PSRule/en-US/Get-PSRule/#-path","text":"One or more paths to search for rule definitions within. Type : String[] Parameter Sets : (All) Aliases : p Required : False Position : 0 Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Path"},{"location":"commands/PSRule/en-US/Get-PSRule/#-tag","text":"Only get rules with the specified tags set. If this parameter is not specified all rules in search paths will be returned. When more than one tag is used, all tags must match. Tags are not case sensitive. A tag value of * may be used to filter rules to any rule with the tag set, regardless of tag value. An array of tag values can be used to match a rule with either value. i.e. severity = important, critical matches rules with a category of either important or critical . Type : Hashtable Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Tag"},{"location":"commands/PSRule/en-US/Get-PSRule/#-option","text":"Additional options that configure execution. A PSRuleOption can be created by using the New-PSRuleOption cmdlet. Alternatively a hashtable or path to YAML file can be specified with options. For more information on PSRule options see about_PSRule_Options. Type : PSRuleOption Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Option"},{"location":"commands/PSRule/en-US/Get-PSRule/#-listavailable","text":"Look for modules containing rule definitions including modules that are currently not imported. This switch is used with the -Module parameter. Type : SwitchParameter Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-ListAvailable"},{"location":"commands/PSRule/en-US/Get-PSRule/#-module","text":"Search for rule definitions within a module. If no sources are specified by -Path , -Module , or options, the current working directory is used. Type : String[] Parameter Sets : (All) Aliases : m Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Module"},{"location":"commands/PSRule/en-US/Get-PSRule/#-culture","text":"Specifies the culture to use for documentation and messages. By default, the culture of PowerShell is used. This option does not affect the culture used for the PSRule engine, which always uses the culture of PowerShell. The PowerShell cmdlet Get-Culture shows the current culture of PowerShell. Type : String Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Culture"},{"location":"commands/PSRule/en-US/Get-PSRule/#-outputformat","text":"Configures the format that output is presented in. The following format options are available: None - Output is presented as an object using PowerShell defaults. This is the default. Wide - Output is presented using the wide table format, which includes tags and wraps columns. Yaml - Output is serialized as YAML. Json - Output is serialized as JSON. Type : OutputFormat Parameter Sets : (All) Aliases : o Accepted values : None, Wide, Yaml, Json Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-OutputFormat"},{"location":"commands/PSRule/en-US/Get-PSRule/#-includedependencies","text":"When this switch is specified, dependencies of the rules that meet the -Name and -Tag filters are included even if they would normally be excluded. This switch has no affect when getting an unfiltered list of rules. Type : SwitchParameter Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-IncludeDependencies"},{"location":"commands/PSRule/en-US/Get-PSRule/#-baseline","text":"When specified, rules are filtered so that only rules that are included in the baselines are returned. Type : BaselineOption Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Baseline"},{"location":"commands/PSRule/en-US/Get-PSRule/#commonparameters","text":"This cmdlet supports the common parameters: -Debug, -ErrorAction, -ErrorVariable, -InformationAction, -InformationVariable, -OutVariable, -OutBuffer, -PipelineVariable, -Verbose, -WarningAction, and -WarningVariable. For more information, see about_CommonParameters .","title":"CommonParameters"},{"location":"commands/PSRule/en-US/Get-PSRule/#inputs","text":"","title":"INPUTS"},{"location":"commands/PSRule/en-US/Get-PSRule/#none","text":"","title":"None"},{"location":"commands/PSRule/en-US/Get-PSRule/#outputs","text":"","title":"OUTPUTS"},{"location":"commands/PSRule/en-US/Get-PSRule/#psruledefinitionsrulesirulev1","text":"","title":"PSRule.Definitions.Rules.IRuleV1"},{"location":"commands/PSRule/en-US/Get-PSRule/#notes","text":"","title":"Notes"},{"location":"commands/PSRule/en-US/Get-PSRule/#related-links","text":"Invoke-PSRule","title":"RELATED LINKS"},{"location":"commands/PSRule/en-US/Get-PSRuleBaseline/","text":"Get-PSRuleBaseline # Get a list of baselines. SYNTAX # Get-PSRuleBaseline [-Module <String[]>] [-ListAvailable] [[-Path] <String[]>] [-Name <String[]>] [-Option <PSRuleOption>] [-Culture <String>] [-OutputFormat <OutputFormat>] [<CommonParameters>] Description # Get a list of matching baselines within the search path. Examples # Example 1 # Get-PSRuleBaseline ; Get a list of baselines from the current working path. PARAMETERS # -Module # Search for baselines definitions within a module. If no sources are specified by -Path , -Module , or options, the current working directory is used. Type : String[] Parameter Sets : (All) Aliases : m Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -ListAvailable # Look for modules containing baselines including modules that are currently not imported. This switch is used with the -Module parameter. Type : SwitchParameter Parameter Sets : (All) Aliases : Required : False Position : Named Default value : False Accept pipeline input : False Accept wildcard characters : False -Path # One or more paths to search for baselines within. Type : String[] Parameter Sets : (All) Aliases : p Required : False Position : 1 Default value : None Accept pipeline input : False Accept wildcard characters : False -Name # The name of a specific baseline to list. If this parameter is not specified all baselines in search paths will be listed. Type : String[] Parameter Sets : (All) Aliases : n Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -Option # Additional options that configure execution. A PSRuleOption can be created by using the New-PSRuleOption cmdlet. Alternatively a hashtable or path to YAML file can be specified with options. For more information on PSRule options see about_PSRule_Options. Type : PSRuleOption Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -Culture # Specifies the culture to use for documentation and messages. By default, the culture of PowerShell is used. This option does not affect the culture used for the PSRule engine, which always uses the culture of PowerShell. The PowerShell cmdlet Get-Culture shows the current culture of PowerShell. Type : String Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -OutputFormat # Configures the format that output is presented in. The following format options are available: None - Output is presented as an object using PowerShell defaults. This is the default. Yaml - Output is serialized as YAML. Json - Output is serialized as JSON. Type : OutputFormat Parameter Sets : (All) Aliases : o Accepted values : None, Yaml, Json Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False CommonParameters # This cmdlet supports the common parameters: -Debug, -ErrorAction, -ErrorVariable, -InformationAction, -InformationVariable, -OutVariable, -OutBuffer, -PipelineVariable, -Verbose, -WarningAction, and -WarningVariable. For more information, see about_CommonParameters . INPUTS # OUTPUTS # PSRule.Definitions.Baseline # This is the default. System.String # When you use -OutputFormat Yaml or -OutputFormat Json . Notes # RELATED LINKS # Get-PSRule","title":"Get-PSRuleBaseline"},{"location":"commands/PSRule/en-US/Get-PSRuleBaseline/#get-psrulebaseline","text":"Get a list of baselines.","title":"Get-PSRuleBaseline"},{"location":"commands/PSRule/en-US/Get-PSRuleBaseline/#syntax","text":"Get-PSRuleBaseline [-Module <String[]>] [-ListAvailable] [[-Path] <String[]>] [-Name <String[]>] [-Option <PSRuleOption>] [-Culture <String>] [-OutputFormat <OutputFormat>] [<CommonParameters>]","title":"SYNTAX"},{"location":"commands/PSRule/en-US/Get-PSRuleBaseline/#description","text":"Get a list of matching baselines within the search path.","title":"Description"},{"location":"commands/PSRule/en-US/Get-PSRuleBaseline/#examples","text":"","title":"Examples"},{"location":"commands/PSRule/en-US/Get-PSRuleBaseline/#example-1","text":"Get-PSRuleBaseline ; Get a list of baselines from the current working path.","title":"Example 1"},{"location":"commands/PSRule/en-US/Get-PSRuleBaseline/#parameters","text":"","title":"PARAMETERS"},{"location":"commands/PSRule/en-US/Get-PSRuleBaseline/#-module","text":"Search for baselines definitions within a module. If no sources are specified by -Path , -Module , or options, the current working directory is used. Type : String[] Parameter Sets : (All) Aliases : m Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Module"},{"location":"commands/PSRule/en-US/Get-PSRuleBaseline/#-listavailable","text":"Look for modules containing baselines including modules that are currently not imported. This switch is used with the -Module parameter. Type : SwitchParameter Parameter Sets : (All) Aliases : Required : False Position : Named Default value : False Accept pipeline input : False Accept wildcard characters : False","title":"-ListAvailable"},{"location":"commands/PSRule/en-US/Get-PSRuleBaseline/#-path","text":"One or more paths to search for baselines within. Type : String[] Parameter Sets : (All) Aliases : p Required : False Position : 1 Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Path"},{"location":"commands/PSRule/en-US/Get-PSRuleBaseline/#-name","text":"The name of a specific baseline to list. If this parameter is not specified all baselines in search paths will be listed. Type : String[] Parameter Sets : (All) Aliases : n Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Name"},{"location":"commands/PSRule/en-US/Get-PSRuleBaseline/#-option","text":"Additional options that configure execution. A PSRuleOption can be created by using the New-PSRuleOption cmdlet. Alternatively a hashtable or path to YAML file can be specified with options. For more information on PSRule options see about_PSRule_Options. Type : PSRuleOption Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Option"},{"location":"commands/PSRule/en-US/Get-PSRuleBaseline/#-culture","text":"Specifies the culture to use for documentation and messages. By default, the culture of PowerShell is used. This option does not affect the culture used for the PSRule engine, which always uses the culture of PowerShell. The PowerShell cmdlet Get-Culture shows the current culture of PowerShell. Type : String Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Culture"},{"location":"commands/PSRule/en-US/Get-PSRuleBaseline/#-outputformat","text":"Configures the format that output is presented in. The following format options are available: None - Output is presented as an object using PowerShell defaults. This is the default. Yaml - Output is serialized as YAML. Json - Output is serialized as JSON. Type : OutputFormat Parameter Sets : (All) Aliases : o Accepted values : None, Yaml, Json Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-OutputFormat"},{"location":"commands/PSRule/en-US/Get-PSRuleBaseline/#commonparameters","text":"This cmdlet supports the common parameters: -Debug, -ErrorAction, -ErrorVariable, -InformationAction, -InformationVariable, -OutVariable, -OutBuffer, -PipelineVariable, -Verbose, -WarningAction, and -WarningVariable. For more information, see about_CommonParameters .","title":"CommonParameters"},{"location":"commands/PSRule/en-US/Get-PSRuleBaseline/#inputs","text":"","title":"INPUTS"},{"location":"commands/PSRule/en-US/Get-PSRuleBaseline/#outputs","text":"","title":"OUTPUTS"},{"location":"commands/PSRule/en-US/Get-PSRuleBaseline/#psruledefinitionsbaseline","text":"This is the default.","title":"PSRule.Definitions.Baseline"},{"location":"commands/PSRule/en-US/Get-PSRuleBaseline/#systemstring","text":"When you use -OutputFormat Yaml or -OutputFormat Json .","title":"System.String"},{"location":"commands/PSRule/en-US/Get-PSRuleBaseline/#notes","text":"","title":"Notes"},{"location":"commands/PSRule/en-US/Get-PSRuleBaseline/#related-links","text":"Get-PSRule","title":"RELATED LINKS"},{"location":"commands/PSRule/en-US/Get-PSRuleHelp/","text":"Get-PSRuleHelp # Displays information about a rule. SYNTAX # Get-PSRuleHelp [-Module <String>] [-Online] [-Full] [[-Name] <String>] [-Path <String>] [-Option <PSRuleOption>] [-Culture <String>] [<CommonParameters>] Description # The Get-PSRuleHelp cmdlet display information about a rule. By default, this cmdlet will look for rules in the current path and loaded modules. To get help for a specific rule or module use the -Name or -Module parameters. If the rule has an online version of the documentation, use the -Online parameter to view it in your default web browser. Examples # Example 1 # Get-PSRuleHelp ; Get a list of rule help within the current path or loaded modules. Example 2 # Get-PSRuleHelp Azure . ACR . AdminUser ; Get rule documentation for the rule Azure.ACR.AdminUser . Example 3 # Get-PSRuleHelp Azure . ACR . AdminUser -Online ; Browse to the online version of documentation for Azure.ACR.AdminUser using the default web browser. PARAMETERS # -Name # The name of the rule to get documentation for. Type : String Parameter Sets : (All) Aliases : n Required : False Position : 1 Default value : None Accept pipeline input : False Accept wildcard characters : True -Path # A path to check documentation for. By default, help from the current working path and loaded modules is listed. Results can be filtered by using -Name , -Path or -Module . Type : String Parameter Sets : (All) Aliases : p Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -Module # Limit returned information to rules in the specified module. By default, help from the current working path and loaded modules is listed. Results can be filtered by using -Name , -Path or -Module . Type : String Parameter Sets : (All) Aliases : m Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -Culture # Specifies the culture to use for rule documentation and messages. By default, the culture of PowerShell is used. This option does not affect the culture used for the PSRule engine, which always uses the culture of PowerShell. The PowerShell cmdlet Get-Culture shows the current culture of PowerShell. Type : String Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -Online # Instead of displaying documentation within PowerShell, browse to the online version using the default web browser. Type : SwitchParameter Parameter Sets : (All) Aliases : Required : False Position : Named Default value : False Accept pipeline input : False Accept wildcard characters : False -Full # Display additional information such as notes and links. Type : SwitchParameter Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -Option # Additional options that configure execution. A PSRuleOption can be created by using the New-PSRuleOption cmdlet. Alternatively a hashtable or path to YAML file can be specified with options. For more information on PSRule options see about_PSRule_Options. Type : PSRuleOption Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False CommonParameters # This cmdlet supports the common parameters: -Debug, -ErrorAction, -ErrorVariable, -InformationAction, -InformationVariable, -OutVariable, -OutBuffer, -PipelineVariable, -Verbose, -WarningAction, and -WarningVariable. For more information, see about_CommonParameters . INPUTS # None # OUTPUTS # PSRule.Rules.RuleHelpInfo # Notes # RELATED LINKS #","title":"Get-PSRuleHelp"},{"location":"commands/PSRule/en-US/Get-PSRuleHelp/#get-psrulehelp","text":"Displays information about a rule.","title":"Get-PSRuleHelp"},{"location":"commands/PSRule/en-US/Get-PSRuleHelp/#syntax","text":"Get-PSRuleHelp [-Module <String>] [-Online] [-Full] [[-Name] <String>] [-Path <String>] [-Option <PSRuleOption>] [-Culture <String>] [<CommonParameters>]","title":"SYNTAX"},{"location":"commands/PSRule/en-US/Get-PSRuleHelp/#description","text":"The Get-PSRuleHelp cmdlet display information about a rule. By default, this cmdlet will look for rules in the current path and loaded modules. To get help for a specific rule or module use the -Name or -Module parameters. If the rule has an online version of the documentation, use the -Online parameter to view it in your default web browser.","title":"Description"},{"location":"commands/PSRule/en-US/Get-PSRuleHelp/#examples","text":"","title":"Examples"},{"location":"commands/PSRule/en-US/Get-PSRuleHelp/#example-1","text":"Get-PSRuleHelp ; Get a list of rule help within the current path or loaded modules.","title":"Example 1"},{"location":"commands/PSRule/en-US/Get-PSRuleHelp/#example-2","text":"Get-PSRuleHelp Azure . ACR . AdminUser ; Get rule documentation for the rule Azure.ACR.AdminUser .","title":"Example 2"},{"location":"commands/PSRule/en-US/Get-PSRuleHelp/#example-3","text":"Get-PSRuleHelp Azure . ACR . AdminUser -Online ; Browse to the online version of documentation for Azure.ACR.AdminUser using the default web browser.","title":"Example 3"},{"location":"commands/PSRule/en-US/Get-PSRuleHelp/#parameters","text":"","title":"PARAMETERS"},{"location":"commands/PSRule/en-US/Get-PSRuleHelp/#-name","text":"The name of the rule to get documentation for. Type : String Parameter Sets : (All) Aliases : n Required : False Position : 1 Default value : None Accept pipeline input : False Accept wildcard characters : True","title":"-Name"},{"location":"commands/PSRule/en-US/Get-PSRuleHelp/#-path","text":"A path to check documentation for. By default, help from the current working path and loaded modules is listed. Results can be filtered by using -Name , -Path or -Module . Type : String Parameter Sets : (All) Aliases : p Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Path"},{"location":"commands/PSRule/en-US/Get-PSRuleHelp/#-module","text":"Limit returned information to rules in the specified module. By default, help from the current working path and loaded modules is listed. Results can be filtered by using -Name , -Path or -Module . Type : String Parameter Sets : (All) Aliases : m Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Module"},{"location":"commands/PSRule/en-US/Get-PSRuleHelp/#-culture","text":"Specifies the culture to use for rule documentation and messages. By default, the culture of PowerShell is used. This option does not affect the culture used for the PSRule engine, which always uses the culture of PowerShell. The PowerShell cmdlet Get-Culture shows the current culture of PowerShell. Type : String Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Culture"},{"location":"commands/PSRule/en-US/Get-PSRuleHelp/#-online","text":"Instead of displaying documentation within PowerShell, browse to the online version using the default web browser. Type : SwitchParameter Parameter Sets : (All) Aliases : Required : False Position : Named Default value : False Accept pipeline input : False Accept wildcard characters : False","title":"-Online"},{"location":"commands/PSRule/en-US/Get-PSRuleHelp/#-full","text":"Display additional information such as notes and links. Type : SwitchParameter Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Full"},{"location":"commands/PSRule/en-US/Get-PSRuleHelp/#-option","text":"Additional options that configure execution. A PSRuleOption can be created by using the New-PSRuleOption cmdlet. Alternatively a hashtable or path to YAML file can be specified with options. For more information on PSRule options see about_PSRule_Options. Type : PSRuleOption Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Option"},{"location":"commands/PSRule/en-US/Get-PSRuleHelp/#commonparameters","text":"This cmdlet supports the common parameters: -Debug, -ErrorAction, -ErrorVariable, -InformationAction, -InformationVariable, -OutVariable, -OutBuffer, -PipelineVariable, -Verbose, -WarningAction, and -WarningVariable. For more information, see about_CommonParameters .","title":"CommonParameters"},{"location":"commands/PSRule/en-US/Get-PSRuleHelp/#inputs","text":"","title":"INPUTS"},{"location":"commands/PSRule/en-US/Get-PSRuleHelp/#none","text":"","title":"None"},{"location":"commands/PSRule/en-US/Get-PSRuleHelp/#outputs","text":"","title":"OUTPUTS"},{"location":"commands/PSRule/en-US/Get-PSRuleHelp/#psrulerulesrulehelpinfo","text":"","title":"PSRule.Rules.RuleHelpInfo"},{"location":"commands/PSRule/en-US/Get-PSRuleHelp/#notes","text":"","title":"Notes"},{"location":"commands/PSRule/en-US/Get-PSRuleHelp/#related-links","text":"","title":"RELATED LINKS"},{"location":"commands/PSRule/en-US/Get-PSRuleTarget/","text":"Get-PSRuleTarget # Get a list of target objects. SYNTAX # Input (Default) # Get-PSRuleTarget [-Format <InputFormat>] [-Option <PSRuleOption>] [-ObjectPath <String>] -InputObject <PSObject> [-WhatIf] [-Confirm] [<CommonParameters>] InputPath # Get-PSRuleTarget -InputPath <String[]> [-Format <InputFormat>] [-Option <PSRuleOption>] [-ObjectPath <String>] [-WhatIf] [-Confirm] [<CommonParameters>] Description # Get a list of target objects from input. Examples # Example 1 # Get-PSRuleTarget -InputPath .\\ resources . json ; Get target objects from resources.json . PARAMETERS # -InputPath # Instead of processing objects from the pipeline, import objects file the specified file paths. Type : String[] Parameter Sets : InputPath Aliases : f Required : True Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -Format # Configures the input format for when a string is passed in as a target object. When the -InputObject parameter or pipeline input is used, strings are treated as plain text by default. Set this option to either Yaml , Json , Markdown , PowerShellData to have PSRule deserialize the object. When the -InputPath parameter is used with a file path or URL. If the Detect format is used, the file extension will be used to automatically detect the format. When -InputPath is not used, Detect is the same as None . See about_PSRule_Options for details. This parameter takes precedence over the Input.Format option if set. Type : InputFormat Parameter Sets : (All) Aliases : Accepted values : None, Yaml, Json, Markdown, PowerShellData, File, Detect Required : False Position : Named Default value : Detect Accept pipeline input : False Accept wildcard characters : False -Option # Additional options that configure execution. A PSRuleOption can be created by using the New-PSRuleOption cmdlet. Alternatively, a hashtable or path to YAML file can be specified with options. For more information on PSRule options see about_PSRule_Options. Type : PSRuleOption Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -ObjectPath # The name of a property to use instead of the pipeline object. If the property specified by ObjectPath is a collection or an array, then each item in evaluated separately. Type : String Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -InputObject # The pipeline object to process rules for. Type : PSObject Parameter Sets : Input Aliases : TargetObject Required : True Position : Named Default value : None Accept pipeline input : True (ByValue) Accept wildcard characters : False -WhatIf # Shows what would happen if the cmdlet runs. The cmdlet is not run. Type : SwitchParameter Parameter Sets : (All) Aliases : wi Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -Confirm # Prompts you for confirmation before running the cmdlet. Type : SwitchParameter Parameter Sets : (All) Aliases : cf Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False CommonParameters # This cmdlet supports the common parameters: -Debug, -ErrorAction, -ErrorVariable, -InformationAction, -InformationVariable, -OutVariable, -OutBuffer, -PipelineVariable, -Verbose, -WarningAction, and -WarningVariable. For more information, see about_CommonParameters . INPUTS # OUTPUTS # System.Management.Automation.PSObject # Notes # RELATED LINKS #","title":"Get-PSRuleTarget"},{"location":"commands/PSRule/en-US/Get-PSRuleTarget/#get-psruletarget","text":"Get a list of target objects.","title":"Get-PSRuleTarget"},{"location":"commands/PSRule/en-US/Get-PSRuleTarget/#syntax","text":"","title":"SYNTAX"},{"location":"commands/PSRule/en-US/Get-PSRuleTarget/#input-default","text":"Get-PSRuleTarget [-Format <InputFormat>] [-Option <PSRuleOption>] [-ObjectPath <String>] -InputObject <PSObject> [-WhatIf] [-Confirm] [<CommonParameters>]","title":"Input (Default)"},{"location":"commands/PSRule/en-US/Get-PSRuleTarget/#inputpath","text":"Get-PSRuleTarget -InputPath <String[]> [-Format <InputFormat>] [-Option <PSRuleOption>] [-ObjectPath <String>] [-WhatIf] [-Confirm] [<CommonParameters>]","title":"InputPath"},{"location":"commands/PSRule/en-US/Get-PSRuleTarget/#description","text":"Get a list of target objects from input.","title":"Description"},{"location":"commands/PSRule/en-US/Get-PSRuleTarget/#examples","text":"","title":"Examples"},{"location":"commands/PSRule/en-US/Get-PSRuleTarget/#example-1","text":"Get-PSRuleTarget -InputPath .\\ resources . json ; Get target objects from resources.json .","title":"Example 1"},{"location":"commands/PSRule/en-US/Get-PSRuleTarget/#parameters","text":"","title":"PARAMETERS"},{"location":"commands/PSRule/en-US/Get-PSRuleTarget/#-inputpath","text":"Instead of processing objects from the pipeline, import objects file the specified file paths. Type : String[] Parameter Sets : InputPath Aliases : f Required : True Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-InputPath"},{"location":"commands/PSRule/en-US/Get-PSRuleTarget/#-format","text":"Configures the input format for when a string is passed in as a target object. When the -InputObject parameter or pipeline input is used, strings are treated as plain text by default. Set this option to either Yaml , Json , Markdown , PowerShellData to have PSRule deserialize the object. When the -InputPath parameter is used with a file path or URL. If the Detect format is used, the file extension will be used to automatically detect the format. When -InputPath is not used, Detect is the same as None . See about_PSRule_Options for details. This parameter takes precedence over the Input.Format option if set. Type : InputFormat Parameter Sets : (All) Aliases : Accepted values : None, Yaml, Json, Markdown, PowerShellData, File, Detect Required : False Position : Named Default value : Detect Accept pipeline input : False Accept wildcard characters : False","title":"-Format"},{"location":"commands/PSRule/en-US/Get-PSRuleTarget/#-option","text":"Additional options that configure execution. A PSRuleOption can be created by using the New-PSRuleOption cmdlet. Alternatively, a hashtable or path to YAML file can be specified with options. For more information on PSRule options see about_PSRule_Options. Type : PSRuleOption Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Option"},{"location":"commands/PSRule/en-US/Get-PSRuleTarget/#-objectpath","text":"The name of a property to use instead of the pipeline object. If the property specified by ObjectPath is a collection or an array, then each item in evaluated separately. Type : String Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-ObjectPath"},{"location":"commands/PSRule/en-US/Get-PSRuleTarget/#-inputobject","text":"The pipeline object to process rules for. Type : PSObject Parameter Sets : Input Aliases : TargetObject Required : True Position : Named Default value : None Accept pipeline input : True (ByValue) Accept wildcard characters : False","title":"-InputObject"},{"location":"commands/PSRule/en-US/Get-PSRuleTarget/#-whatif","text":"Shows what would happen if the cmdlet runs. The cmdlet is not run. Type : SwitchParameter Parameter Sets : (All) Aliases : wi Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-WhatIf"},{"location":"commands/PSRule/en-US/Get-PSRuleTarget/#-confirm","text":"Prompts you for confirmation before running the cmdlet. Type : SwitchParameter Parameter Sets : (All) Aliases : cf Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Confirm"},{"location":"commands/PSRule/en-US/Get-PSRuleTarget/#commonparameters","text":"This cmdlet supports the common parameters: -Debug, -ErrorAction, -ErrorVariable, -InformationAction, -InformationVariable, -OutVariable, -OutBuffer, -PipelineVariable, -Verbose, -WarningAction, and -WarningVariable. For more information, see about_CommonParameters .","title":"CommonParameters"},{"location":"commands/PSRule/en-US/Get-PSRuleTarget/#inputs","text":"","title":"INPUTS"},{"location":"commands/PSRule/en-US/Get-PSRuleTarget/#outputs","text":"","title":"OUTPUTS"},{"location":"commands/PSRule/en-US/Get-PSRuleTarget/#systemmanagementautomationpsobject","text":"","title":"System.Management.Automation.PSObject"},{"location":"commands/PSRule/en-US/Get-PSRuleTarget/#notes","text":"","title":"Notes"},{"location":"commands/PSRule/en-US/Get-PSRuleTarget/#related-links","text":"","title":"RELATED LINKS"},{"location":"commands/PSRule/en-US/Invoke-PSRule/","text":"Invoke-PSRule # Evaluate objects against matching rules and output the results. SYNTAX # Input (Default) # Invoke-PSRule [-Module <String[]>] [-Outcome <RuleOutcome>] [-As <ResultFormat>] [-Format <InputFormat>] [-OutputPath <String>] [-OutputFormat <OutputFormat>] [-Baseline <BaselineOption>] [-Convention <String[]>] [[-Path] <String[]>] [-Name <String[]>] [-Tag <Hashtable>] [-Option <PSRuleOption>] [-ObjectPath <String>] [-TargetType <String[]>] [-Culture <String[]>] -InputObject <PSObject> [-WhatIf] [-Confirm] [<CommonParameters>] InputPath # Invoke-PSRule -InputPath <String[]> [-Module <String[]>] [-Outcome <RuleOutcome>] [-As <ResultFormat>] [-Format <InputFormat>] [-OutputPath <String>] [-OutputFormat <OutputFormat>] [-Baseline <BaselineOption>] [-Convention <String[]>] [[-Path] <String[]>] [-Name <String[]>] [-Tag <Hashtable>] [-Option <PSRuleOption>] [-ObjectPath <String>] [-TargetType <String[]>] [-Culture <String[]>] [-WhatIf] [-Confirm] [<CommonParameters>] Description # Evaluate objects against matching rules and output the results. Objects can be specified directly from the pipeline or provided from file. The commands Invoke-PSRule and Assert-PSRule provide similar functionality, as differ as follows: Invoke-PSRule writes results as structured objects Assert-PSRule writes results as a formatted string. Examples # Example 1 # @{ Name = 'Item 1' } | Invoke-PSRule ; Evaluate a simple hashtable on the pipeline against rules loaded from the current working path. Example 2 # # Define objects to validate $items = @(); $items += [PSCustomObject] @{ Name = 'Fridge' }; $items += [PSCustomObject] @{ Name = 'Apple' }; # Validate each item using rules saved in current working path $items | Invoke-PSRule ; TargetName: Fridge RuleName Outcome Recommendation -------- ------- -------------- isFruit Fail Fruit is only Apple, Orange and Pear TargetName: Apple RuleName Outcome Recommendation -------- ------- -------------- isFruit Pass Fruit is only Apple, Orange and Pear Evaluate an array of objects on the pipeline against rules loaded from the current working path. Example 3 # # Define objects to validate $items = @(); $items += [PSCustomObject] @{ Name = 'Fridge' }; $items += [PSCustomObject] @{ Name = 'Apple' }; # Validate each item and only return failing results $items | Invoke-PSRule -Outcome Fail ; TargetName: Fridge RuleName Outcome Recommendation -------- ------- -------------- isFruit Fail Fruit is only Apple, Orange and Pear Evaluate an array of objects, only failing object results are returned. Example 4 # # Define objects to validate $items = @(); $items += [PSCustomObject] @{ Name = 'Fridge' }; $items += [PSCustomObject] @{ Name = 'Apple' }; # Validate each item and show rule summary $items | Invoke-PSRule -As Summary ; RuleName Pass Fail Outcome -------- ---- ---- ------- isFruit 1 1 Fail Evaluate an array of objects. The results for each rule is returned as a summary. Outcome is represented as the worst outcome. PARAMETERS # -Name # The name of a specific rule to evaluate. If this parameter is not specified all rules in search paths will be evaluated. Type : String[] Parameter Sets : (All) Aliases : n Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -Path # One or more paths to search for rule definitions within. Type : String[] Parameter Sets : (All) Aliases : p Required : False Position : 0 Default value : None Accept pipeline input : False Accept wildcard characters : False -Outcome # Filter output to only show rule results with a specific outcome. Type : RuleOutcome Parameter Sets : (All) Aliases : Accepted values : Pass, Fail, Error, None, Processed, All Required : False Position : Named Default value : Pass, Fail, Error Accept pipeline input : False Accept wildcard characters : False -Tag # Only get rules with the specified tags set. If this parameter is not specified all rules in search paths will be returned. When more than one tag is used, all tags must match. Tags are not case sensitive. A tag value of * may be used to filter rules to any rule with the tag set, regardless of tag value. An array of tag values can be used to match a rule with either value. i.e. severity = important, critical matches rules with a category of either important or critical . Type : Hashtable Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -InputObject # The pipeline object to process rules for. Type : PSObject Parameter Sets : Input Aliases : TargetObject Required : True Position : Named Default value : None Accept pipeline input : True (ByValue) Accept wildcard characters : False -Option # Additional options that configure execution. A PSRuleOption can be created by using the New-PSRuleOption cmdlet. Alternatively, a hashtable or path to YAML file can be specified with options. For more information on PSRule options see about_PSRule_Options. Type : PSRuleOption Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -As # The type of results to produce. Detailed results are generated by default. The following result formats are available: Detail - Returns pass/ fail results for each rule per object. Summary - Returns summarized results for the rule and the worst outcome. Type : ResultFormat Parameter Sets : (All) Aliases : Accepted values : Detail, Summary Required : False Position : Named Default value : Detail Accept pipeline input : False Accept wildcard characters : False -Format # Configures the input format for when a string is passed in as a target object. When the -InputObject parameter or pipeline input is used, strings are treated as plain text by default. Set this option to either Yaml , Json , Markdown , PowerShellData to have PSRule deserialize the object. When the -InputPath parameter is used with a file path or URL. If the Detect format is used, the file extension will be used to automatically detect the format. When -InputPath is not used, Detect is the same as None . When this option is set to File PSRule scans the path and subdirectories specified by -InputPath . Files are treated as objects instead of being deserialized. Additional, PSRule uses the file extension as the object type. When files have no extension the whole file name is used. See about_PSRule_Options for details. This parameter takes precedence over the Input.Format option if set. Type : InputFormat Parameter Sets : (All) Aliases : Accepted values : None, Yaml, Json, Markdown, PowerShellData, File, Detect Required : False Position : Named Default value : Detect Accept pipeline input : False Accept wildcard characters : False -Baseline # Specifies an explicit baseline by name to use for evaluating rules. Baselines can contain filters and custom configuration that overrides the defaults. Type : BaselineOption Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -Convention # Specifies conventions by name to execute in the pipeline when processing objects. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -Culture # Specifies the culture to use for rule documentation and messages. By default, the culture of PowerShell is used. This option does not affect the culture used for the PSRule engine, which always uses the culture of PowerShell. The PowerShell cmdlet Get-Culture shows the current culture of PowerShell. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -ObjectPath # The name of a property to use instead of the pipeline object. If the property specified by ObjectPath is a collection or an array, then each item in evaluated separately. Type : String Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -TargetType # Filters input objects by TargetType. If specified, only objects with the specified TargetType are processed. Objects that do not match TargetType are ignored. If multiple values are specified, only one TargetType must match. This parameter is not case-sensitive. By default, all objects are processed. This parameter if set, overrides the Input.TargetType option. To change the field TargetType is bound to set the Binding.TargetType option. For details see the about_PSRule_Options help topic. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -Module # Search for rule definitions within a module. If no sources are specified by -Path , -Module , or options, the current working directory is used. Type : String[] Parameter Sets : (All) Aliases : m Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -InputPath # Instead of processing objects from the pipeline, import objects file the specified file paths. Type : String[] Parameter Sets : InputPath Aliases : f Required : True Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -OutputPath # Specifies the output file path to write results. Directories along the file path will automatically be created if they do not exist. Type : String Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -OutputFormat # Configures the format that output is presented in. The following format options are available: None - Output is presented as an object using PowerShell defaults. This is the default. Yaml - Output is serialized as YAML. Json - Output is serialized as JSON. Markdown - Output is serialized as Markdown. NUnit3 - Output is serialized as NUnit3 (XML). Csv - Output is serialized as a comma separated values (CSV). Wide - Output is presented using the wide table format, which includes reason and wraps columns. Sarif - Output is serialized as SARIF. Type : OutputFormat Parameter Sets : (All) Aliases : o Accepted values : None, Yaml, Json, Markdown, NUnit3, Csv, Wide, Sarif Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -Confirm # Prompts you for confirmation before running the cmdlet. Type : SwitchParameter Parameter Sets : (All) Aliases : cf Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -WhatIf # Shows what would happen if the cmdlet runs. The cmdlet is not run. Type : SwitchParameter Parameter Sets : (All) Aliases : wi Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False CommonParameters # This cmdlet supports the common parameters: -Debug, -ErrorAction, -ErrorVariable, -InformationAction, -InformationVariable, -OutVariable, -OutBuffer, -PipelineVariable, -Verbose, -WarningAction, and -WarningVariable. For more information, see about_CommonParameters . INPUTS # System.Management.Automation.PSObject # You can pipe any object to Invoke-PSRule . OUTPUTS # PSRule.Rules.RuleRecord # This is the default. PSRule.Rules.RuleSummaryRecord # When you use the -As Summary . Otherwise, it returns a RuleRecord object. Notes # RELATED LINKS # Get-PSRule Assert-PSRule Test-PSRuleTarget","title":"Invoke-PSRule"},{"location":"commands/PSRule/en-US/Invoke-PSRule/#invoke-psrule","text":"Evaluate objects against matching rules and output the results.","title":"Invoke-PSRule"},{"location":"commands/PSRule/en-US/Invoke-PSRule/#syntax","text":"","title":"SYNTAX"},{"location":"commands/PSRule/en-US/Invoke-PSRule/#input-default","text":"Invoke-PSRule [-Module <String[]>] [-Outcome <RuleOutcome>] [-As <ResultFormat>] [-Format <InputFormat>] [-OutputPath <String>] [-OutputFormat <OutputFormat>] [-Baseline <BaselineOption>] [-Convention <String[]>] [[-Path] <String[]>] [-Name <String[]>] [-Tag <Hashtable>] [-Option <PSRuleOption>] [-ObjectPath <String>] [-TargetType <String[]>] [-Culture <String[]>] -InputObject <PSObject> [-WhatIf] [-Confirm] [<CommonParameters>]","title":"Input (Default)"},{"location":"commands/PSRule/en-US/Invoke-PSRule/#inputpath","text":"Invoke-PSRule -InputPath <String[]> [-Module <String[]>] [-Outcome <RuleOutcome>] [-As <ResultFormat>] [-Format <InputFormat>] [-OutputPath <String>] [-OutputFormat <OutputFormat>] [-Baseline <BaselineOption>] [-Convention <String[]>] [[-Path] <String[]>] [-Name <String[]>] [-Tag <Hashtable>] [-Option <PSRuleOption>] [-ObjectPath <String>] [-TargetType <String[]>] [-Culture <String[]>] [-WhatIf] [-Confirm] [<CommonParameters>]","title":"InputPath"},{"location":"commands/PSRule/en-US/Invoke-PSRule/#description","text":"Evaluate objects against matching rules and output the results. Objects can be specified directly from the pipeline or provided from file. The commands Invoke-PSRule and Assert-PSRule provide similar functionality, as differ as follows: Invoke-PSRule writes results as structured objects Assert-PSRule writes results as a formatted string.","title":"Description"},{"location":"commands/PSRule/en-US/Invoke-PSRule/#examples","text":"","title":"Examples"},{"location":"commands/PSRule/en-US/Invoke-PSRule/#example-1","text":"@{ Name = 'Item 1' } | Invoke-PSRule ; Evaluate a simple hashtable on the pipeline against rules loaded from the current working path.","title":"Example 1"},{"location":"commands/PSRule/en-US/Invoke-PSRule/#example-2","text":"# Define objects to validate $items = @(); $items += [PSCustomObject] @{ Name = 'Fridge' }; $items += [PSCustomObject] @{ Name = 'Apple' }; # Validate each item using rules saved in current working path $items | Invoke-PSRule ; TargetName: Fridge RuleName Outcome Recommendation -------- ------- -------------- isFruit Fail Fruit is only Apple, Orange and Pear TargetName: Apple RuleName Outcome Recommendation -------- ------- -------------- isFruit Pass Fruit is only Apple, Orange and Pear Evaluate an array of objects on the pipeline against rules loaded from the current working path.","title":"Example 2"},{"location":"commands/PSRule/en-US/Invoke-PSRule/#example-3","text":"# Define objects to validate $items = @(); $items += [PSCustomObject] @{ Name = 'Fridge' }; $items += [PSCustomObject] @{ Name = 'Apple' }; # Validate each item and only return failing results $items | Invoke-PSRule -Outcome Fail ; TargetName: Fridge RuleName Outcome Recommendation -------- ------- -------------- isFruit Fail Fruit is only Apple, Orange and Pear Evaluate an array of objects, only failing object results are returned.","title":"Example 3"},{"location":"commands/PSRule/en-US/Invoke-PSRule/#example-4","text":"# Define objects to validate $items = @(); $items += [PSCustomObject] @{ Name = 'Fridge' }; $items += [PSCustomObject] @{ Name = 'Apple' }; # Validate each item and show rule summary $items | Invoke-PSRule -As Summary ; RuleName Pass Fail Outcome -------- ---- ---- ------- isFruit 1 1 Fail Evaluate an array of objects. The results for each rule is returned as a summary. Outcome is represented as the worst outcome.","title":"Example 4"},{"location":"commands/PSRule/en-US/Invoke-PSRule/#parameters","text":"","title":"PARAMETERS"},{"location":"commands/PSRule/en-US/Invoke-PSRule/#-name","text":"The name of a specific rule to evaluate. If this parameter is not specified all rules in search paths will be evaluated. Type : String[] Parameter Sets : (All) Aliases : n Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Name"},{"location":"commands/PSRule/en-US/Invoke-PSRule/#-path","text":"One or more paths to search for rule definitions within. Type : String[] Parameter Sets : (All) Aliases : p Required : False Position : 0 Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Path"},{"location":"commands/PSRule/en-US/Invoke-PSRule/#-outcome","text":"Filter output to only show rule results with a specific outcome. Type : RuleOutcome Parameter Sets : (All) Aliases : Accepted values : Pass, Fail, Error, None, Processed, All Required : False Position : Named Default value : Pass, Fail, Error Accept pipeline input : False Accept wildcard characters : False","title":"-Outcome"},{"location":"commands/PSRule/en-US/Invoke-PSRule/#-tag","text":"Only get rules with the specified tags set. If this parameter is not specified all rules in search paths will be returned. When more than one tag is used, all tags must match. Tags are not case sensitive. A tag value of * may be used to filter rules to any rule with the tag set, regardless of tag value. An array of tag values can be used to match a rule with either value. i.e. severity = important, critical matches rules with a category of either important or critical . Type : Hashtable Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Tag"},{"location":"commands/PSRule/en-US/Invoke-PSRule/#-inputobject","text":"The pipeline object to process rules for. Type : PSObject Parameter Sets : Input Aliases : TargetObject Required : True Position : Named Default value : None Accept pipeline input : True (ByValue) Accept wildcard characters : False","title":"-InputObject"},{"location":"commands/PSRule/en-US/Invoke-PSRule/#-option","text":"Additional options that configure execution. A PSRuleOption can be created by using the New-PSRuleOption cmdlet. Alternatively, a hashtable or path to YAML file can be specified with options. For more information on PSRule options see about_PSRule_Options. Type : PSRuleOption Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Option"},{"location":"commands/PSRule/en-US/Invoke-PSRule/#-as","text":"The type of results to produce. Detailed results are generated by default. The following result formats are available: Detail - Returns pass/ fail results for each rule per object. Summary - Returns summarized results for the rule and the worst outcome. Type : ResultFormat Parameter Sets : (All) Aliases : Accepted values : Detail, Summary Required : False Position : Named Default value : Detail Accept pipeline input : False Accept wildcard characters : False","title":"-As"},{"location":"commands/PSRule/en-US/Invoke-PSRule/#-format","text":"Configures the input format for when a string is passed in as a target object. When the -InputObject parameter or pipeline input is used, strings are treated as plain text by default. Set this option to either Yaml , Json , Markdown , PowerShellData to have PSRule deserialize the object. When the -InputPath parameter is used with a file path or URL. If the Detect format is used, the file extension will be used to automatically detect the format. When -InputPath is not used, Detect is the same as None . When this option is set to File PSRule scans the path and subdirectories specified by -InputPath . Files are treated as objects instead of being deserialized. Additional, PSRule uses the file extension as the object type. When files have no extension the whole file name is used. See about_PSRule_Options for details. This parameter takes precedence over the Input.Format option if set. Type : InputFormat Parameter Sets : (All) Aliases : Accepted values : None, Yaml, Json, Markdown, PowerShellData, File, Detect Required : False Position : Named Default value : Detect Accept pipeline input : False Accept wildcard characters : False","title":"-Format"},{"location":"commands/PSRule/en-US/Invoke-PSRule/#-baseline","text":"Specifies an explicit baseline by name to use for evaluating rules. Baselines can contain filters and custom configuration that overrides the defaults. Type : BaselineOption Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Baseline"},{"location":"commands/PSRule/en-US/Invoke-PSRule/#-convention","text":"Specifies conventions by name to execute in the pipeline when processing objects. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Convention"},{"location":"commands/PSRule/en-US/Invoke-PSRule/#-culture","text":"Specifies the culture to use for rule documentation and messages. By default, the culture of PowerShell is used. This option does not affect the culture used for the PSRule engine, which always uses the culture of PowerShell. The PowerShell cmdlet Get-Culture shows the current culture of PowerShell. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Culture"},{"location":"commands/PSRule/en-US/Invoke-PSRule/#-objectpath","text":"The name of a property to use instead of the pipeline object. If the property specified by ObjectPath is a collection or an array, then each item in evaluated separately. Type : String Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-ObjectPath"},{"location":"commands/PSRule/en-US/Invoke-PSRule/#-targettype","text":"Filters input objects by TargetType. If specified, only objects with the specified TargetType are processed. Objects that do not match TargetType are ignored. If multiple values are specified, only one TargetType must match. This parameter is not case-sensitive. By default, all objects are processed. This parameter if set, overrides the Input.TargetType option. To change the field TargetType is bound to set the Binding.TargetType option. For details see the about_PSRule_Options help topic. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-TargetType"},{"location":"commands/PSRule/en-US/Invoke-PSRule/#-module","text":"Search for rule definitions within a module. If no sources are specified by -Path , -Module , or options, the current working directory is used. Type : String[] Parameter Sets : (All) Aliases : m Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Module"},{"location":"commands/PSRule/en-US/Invoke-PSRule/#-inputpath","text":"Instead of processing objects from the pipeline, import objects file the specified file paths. Type : String[] Parameter Sets : InputPath Aliases : f Required : True Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-InputPath"},{"location":"commands/PSRule/en-US/Invoke-PSRule/#-outputpath","text":"Specifies the output file path to write results. Directories along the file path will automatically be created if they do not exist. Type : String Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-OutputPath"},{"location":"commands/PSRule/en-US/Invoke-PSRule/#-outputformat","text":"Configures the format that output is presented in. The following format options are available: None - Output is presented as an object using PowerShell defaults. This is the default. Yaml - Output is serialized as YAML. Json - Output is serialized as JSON. Markdown - Output is serialized as Markdown. NUnit3 - Output is serialized as NUnit3 (XML). Csv - Output is serialized as a comma separated values (CSV). Wide - Output is presented using the wide table format, which includes reason and wraps columns. Sarif - Output is serialized as SARIF. Type : OutputFormat Parameter Sets : (All) Aliases : o Accepted values : None, Yaml, Json, Markdown, NUnit3, Csv, Wide, Sarif Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-OutputFormat"},{"location":"commands/PSRule/en-US/Invoke-PSRule/#-confirm","text":"Prompts you for confirmation before running the cmdlet. Type : SwitchParameter Parameter Sets : (All) Aliases : cf Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Confirm"},{"location":"commands/PSRule/en-US/Invoke-PSRule/#-whatif","text":"Shows what would happen if the cmdlet runs. The cmdlet is not run. Type : SwitchParameter Parameter Sets : (All) Aliases : wi Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-WhatIf"},{"location":"commands/PSRule/en-US/Invoke-PSRule/#commonparameters","text":"This cmdlet supports the common parameters: -Debug, -ErrorAction, -ErrorVariable, -InformationAction, -InformationVariable, -OutVariable, -OutBuffer, -PipelineVariable, -Verbose, -WarningAction, and -WarningVariable. For more information, see about_CommonParameters .","title":"CommonParameters"},{"location":"commands/PSRule/en-US/Invoke-PSRule/#inputs","text":"","title":"INPUTS"},{"location":"commands/PSRule/en-US/Invoke-PSRule/#systemmanagementautomationpsobject","text":"You can pipe any object to Invoke-PSRule .","title":"System.Management.Automation.PSObject"},{"location":"commands/PSRule/en-US/Invoke-PSRule/#outputs","text":"","title":"OUTPUTS"},{"location":"commands/PSRule/en-US/Invoke-PSRule/#psrulerulesrulerecord","text":"This is the default.","title":"PSRule.Rules.RuleRecord"},{"location":"commands/PSRule/en-US/Invoke-PSRule/#psrulerulesrulesummaryrecord","text":"When you use the -As Summary . Otherwise, it returns a RuleRecord object.","title":"PSRule.Rules.RuleSummaryRecord"},{"location":"commands/PSRule/en-US/Invoke-PSRule/#notes","text":"","title":"Notes"},{"location":"commands/PSRule/en-US/Invoke-PSRule/#related-links","text":"Get-PSRule Assert-PSRule Test-PSRuleTarget","title":"RELATED LINKS"},{"location":"commands/PSRule/en-US/New-PSRuleOption/","text":"New-PSRuleOption # Create options to configure PSRule execution. SYNTAX # FromPath (Default) # New-PSRuleOption [[-Path] <String>] [-Configuration <ConfigurationOption>] [-SuppressTargetName <SuppressionOption>] [-BindTargetName <BindTargetName[]>] [-BindTargetType <BindTargetName[]>] [-BindingIgnoreCase <Boolean>] [-BindingField <Hashtable>] [-BindingNameSeparator <String>] [-BindingPreferTargetInfo <Boolean>] [-TargetName <String[]>] [-TargetType <String[]>] [-BindingUseQualifiedName <Boolean>] [-Convention <String[]>] [-AliasReferenceWarning <Boolean>] [-DuplicateResourceId <ExecutionActionPreference>] [-InconclusiveWarning <Boolean>] [-NotProcessedWarning <Boolean>] [-SuppressedRuleWarning <Boolean>] [-InvariantCultureWarning <Boolean>] [-InitialSessionState <SessionState>] [-IncludeModule <String[]>] [-IncludePath <String[]>] [-Format <InputFormat>] [-InputIgnoreGitPath <Boolean>] [-InputIgnoreRepositoryCommon <Boolean>] [-InputIgnoreObjectSource <Boolean>] [-InputIgnoreUnchangedPath <Boolean>] [-ObjectPath <String>] [-InputTargetType <String[]>] [-InputPathIgnore <String[]>] [-LoggingLimitDebug <String[]>] [-LoggingLimitVerbose <String[]>] [-LoggingRuleFail <OutcomeLogStream>] [-LoggingRulePass <OutcomeLogStream>] [-OutputAs <ResultFormat>] [-OutputBanner <BannerFormat>] [-OutputCulture <String[]>] [-OutputEncoding <OutputEncoding>] [-OutputFooter <FooterFormat>] [-OutputFormat <OutputFormat>] [-OutputJobSummaryPath <String>] [-OutputJsonIndent <Int32>] [-OutputOutcome <RuleOutcome>] [-OutputPath <String>] [-OutputSarifProblemsOnly <Boolean>] [-OutputStyle <OutputStyle>] [-RepositoryBaseRef <String>] [-RepositoryUrl <String>] [-RuleIncludeLocal <Boolean>] [<CommonParameters>] FromOption # New-PSRuleOption [-Option] <PSRuleOption> [-Configuration <ConfigurationOption>] [-SuppressTargetName <SuppressionOption>] [-BindTargetName <BindTargetName[]>] [-BindTargetType <BindTargetName[]>] [-BindingIgnoreCase <Boolean>] [-BindingField <Hashtable>] [-BindingNameSeparator <String>] [-BindingPreferTargetInfo <Boolean>] [-TargetName <String[]>] [-TargetType <String[]>] [-BindingUseQualifiedName <Boolean>] [-Convention <String[]>] [-AliasReferenceWarning <Boolean>] [-DuplicateResourceId <ExecutionActionPreference>] [-InconclusiveWarning <Boolean>] [-NotProcessedWarning <Boolean>] [-SuppressedRuleWarning <Boolean>] [-InvariantCultureWarning <Boolean>] [-InitialSessionState <SessionState>] [-IncludeModule <String[]>] [-IncludePath <String[]>] [-Format <InputFormat>] [-InputIgnoreGitPath <Boolean>] [-InputIgnoreRepositoryCommon <Boolean>] [-InputIgnoreObjectSource <Boolean>] [-InputIgnoreUnchangedPath <Boolean>] [-ObjectPath <String>] [-InputTargetType <String[]>] [-InputPathIgnore <String[]>] [-LoggingLimitDebug <String[]>] [-LoggingLimitVerbose <String[]>] [-LoggingRuleFail <OutcomeLogStream>] [-LoggingRulePass <OutcomeLogStream>] [-OutputAs <ResultFormat>] [-OutputBanner <BannerFormat>] [-OutputCulture <String[]>] [-OutputEncoding <OutputEncoding>] [-OutputFooter <FooterFormat>] [-OutputFormat <OutputFormat>] [-OutputJobSummaryPath <String>] [-OutputJsonIndent <Int32>] [-OutputOutcome <RuleOutcome>] [-OutputPath <String>] [-OutputSarifProblemsOnly <Boolean>] [-OutputStyle <OutputStyle>] [-RepositoryBaseRef <String>] [-RepositoryUrl <String>] [-RuleIncludeLocal <Boolean>] [<CommonParameters>] FromDefault # New-PSRuleOption [-Default] [-Configuration <ConfigurationOption>] [-SuppressTargetName <SuppressionOption>] [-BindTargetName <BindTargetName[]>] [-BindTargetType <BindTargetName[]>] [-BindingIgnoreCase <Boolean>] [-BindingField <Hashtable>] [-BindingNameSeparator <String>] [-BindingPreferTargetInfo <Boolean>] [-TargetName <String[]>] [-TargetType <String[]>] [-BindingUseQualifiedName <Boolean>] [-Convention <String[]>] [-AliasReferenceWarning <Boolean>] [-DuplicateResourceId <ExecutionActionPreference>] [-InconclusiveWarning <Boolean>] [-NotProcessedWarning <Boolean>] [-SuppressedRuleWarning <Boolean>] [-InvariantCultureWarning <Boolean>] [-InitialSessionState <SessionState>] [-IncludeModule <String[]>] [-IncludePath <String[]>] [-Format <InputFormat>] [-InputIgnoreGitPath <Boolean>] [-InputIgnoreRepositoryCommon <Boolean>] [-InputIgnoreObjectSource <Boolean>] [-InputIgnoreUnchangedPath <Boolean>] [-ObjectPath <String>] [-InputTargetType <String[]>] [-InputPathIgnore <String[]>] [-LoggingLimitDebug <String[]>] [-LoggingLimitVerbose <String[]>] [-LoggingRuleFail <OutcomeLogStream>] [-LoggingRulePass <OutcomeLogStream>] [-OutputAs <ResultFormat>] [-OutputBanner <BannerFormat>] [-OutputCulture <String[]>] [-OutputEncoding <OutputEncoding>] [-OutputFooter <FooterFormat>] [-OutputFormat <OutputFormat>] [-OutputJobSummaryPath <String>] [-OutputJsonIndent <Int32>] [-OutputOutcome <RuleOutcome>] [-OutputPath <String>] [-OutputSarifProblemsOnly <Boolean>] [-OutputStyle <OutputStyle>] [-RepositoryBaseRef <String>] [-RepositoryUrl <String>] [-RuleIncludeLocal <Boolean>] [<CommonParameters>] Description # The New-PSRuleOption cmdlet creates an options object that can be passed to PSRule cmdlets to configure execution. Examples # Example 1 # $option = New-PSRuleOption -Option @{ 'execution.mode' = 'ConstrainedLanguage' } @{ Name = 'Item 1' } | Invoke-PSRule -Option $option Create an options object and run rules in constrained mode. Example 2 # $option = New-PSRuleOption -SuppressTargetName @{ 'storageAccounts.UseHttps' = 'TestObject1' , 'TestObject3' }; Create an options object that suppresses TestObject1 and TestObject3 for a rule named storageAccounts.UseHttps . Example 3 # # Create a custom function that returns a TargetName string $bindFn = { param ( $TargetObject ) $otherName = $TargetObject . PSObject . Properties [ 'OtherName' ]; if ( $otherName -eq $Null ) { return $Null } return $otherName . Value ; } # Specify the binding function script block code to execute $option = New-PSRuleOption -BindTargetName $bindFn ; Creates an options object that uses a custom function to bind the TargetName of an object. Example 4 # $option = New-PSRuleOption -Configuration @{ 'appServiceMinInstanceCount' = 2 }; Create an options object that sets the appServiceMinInstanceCount baseline configuration option to 2 . PARAMETERS # -Option # Additional options that configure execution. Option also accepts a hashtable to configure options. See about_PSRule_Options for more information. Type : PSRuleOption Parameter Sets : FromOption Aliases : Required : True Position : 0 Default value : None Accept pipeline input : False Accept wildcard characters : False -Path # The path to a YAML file containing options. Either a directory or file path can be specified. When a directory is used, ps-rule.yaml will be used as the file name. If the -Path parameter is specified and the file does not exist, an exception will be generated. Type : String Parameter Sets : FromPath Aliases : Required : False Position : 1 Default value : None Accept pipeline input : False Accept wildcard characters : False -Default # When specified, defaults are used for any options not overridden. Type : SwitchParameter Parameter Sets : FromDefault Aliases : Required : True Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -SuppressTargetName # Configures suppression for a list of objects by TargetName. SuppressTargetName also accepts a hashtable to configure rule suppression. See about_PSRule_Options for more information. Type : SuppressionOption Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -BindTargetName # Configures a custom function to use to bind TargetName of an object. See about_PSRule_Options for more information. Type : BindTargetName[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -Configuration # Configures a set of baseline configuration values that can be used in rule definitions instead of using hard coded values. Configuration also accepts a hashtable of configuration values as key/ value pairs. See about_PSRule_Options for more information. Type : ConfigurationOption Parameter Sets : (All) Aliases : BaselineConfiguration Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -BindTargetType # Configures a custom function to use to bind TargetType of an object. See about_PSRule_Options for more information. Type : BindTargetName[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -BindingIgnoreCase # Sets the option Binding.IgnoreCase . The option Binding.IgnoreCase determines if binding operations are case-sensitive or not. See about_PSRule_Options for more information. Type : Boolean Parameter Sets : (All) Aliases : Required : False Position : Named Default value : True Accept pipeline input : False Accept wildcard characters : False -BindingField # Sets the option Binding.Field . The option specified one or more custom field bindings. See about_PSRule_Options for more information. Type : Hashtable Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -BindingNameSeparator # Sets the option Binding.NameSeparator . This option specifies the separator to use for qualified names. See about_PSRule_Options for more information. Type : String Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -BindingPreferTargetInfo # Sets the option Binding.PreferTargetInfo . This option specifies if automatic binding is preferred over configured binding options. See about_PSRule_Options for more information. Type : Boolean Parameter Sets : (All) Aliases : Required : False Position : Named Default value : False Accept pipeline input : False Accept wildcard characters : False -Convention # Sets the Option.ConventionInclude option. This option specifies the name of conventions to execute in the pipeline when processing objects. See about_PSRule_Options for more information. Type : String[] Parameter Sets : (All) Aliases : ConventionInclude Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -TargetName # Sets the option Binding.TargetName . This option specifies one or more properties of TargetObject to use to bind TargetName to. See about_PSRule_Options for more information. Type : String[] Parameter Sets : (All) Aliases : BindingTargetName Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -TargetType # Sets the option Binding.TargetType . This option specifies one or more properties of TargetObject to use to bind TargetType to. See about_PSRule_Options for more information. Type : String[] Parameter Sets : (All) Aliases : BindingTargetType Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -BindingUseQualifiedName # Sets the option Binding.UseQualifiedName . This option specifies is qualified target names are used. See about_PSRule_Options for more information. Type : Boolean Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -InconclusiveWarning # Sets the option Execution.InconclusiveWarning . The Execution.InconclusiveWarning option determines if a warning is generated when the outcome of a rule is inconclusive. See about_PSRule_Options for more information. Type : Boolean Parameter Sets : (All) Aliases : ExecutionInconclusiveWarning Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -NotProcessedWarning # Sets the option Execution.NotProcessedWarning . The Execution.NotProcessedWarning option determines if a warning is generated when an object is not processed by any rule. See about_PSRule_Options for more information. Type : Boolean Parameter Sets : (All) Aliases : ExecutionNotProcessedWarning Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -SuppressedRuleWarning # Sets the Execution.SuppressedRuleWarning option. The Execution.SuppressedRuleWarning option determines if a warning is generated when a rule is suppressed. See about_PSRule_Options for more information. Type : Boolean Parameter Sets : (All) Aliases : ExecutionSuppressedRuleWarning Required : False Position : Named Default value : True Accept pipeline input : False Accept wildcard characters : False -IncludeModule # Sets the Include.Module option to include additional module sources. See about_PSRule_Options for more information. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -IncludePath # Sets the Include.Path option to include additional standalone sources. See about_PSRule_Options for more information. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -Format # Sets the Input.Format option to configure the input format for when a string is passed in as a target object. See about_PSRule_Options for more information. Type : InputFormat Parameter Sets : (All) Aliases : InputFormat Accepted values : None, Yaml, Json, Markdown, PowerShellData, File, Detect Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -InputIgnoreGitPath # Sets the Input.IgnoreGitPath option to determine if files within the .git path are ignored. See about_PSRule_Options for more information. Type : Boolean Parameter Sets : (All) Aliases : Required : False Position : Named Default value : True Accept pipeline input : False Accept wildcard characters : False -InputIgnoreRepositoryCommon # Sets the Input.IgnoreRepositoryCommon option to determine if files common repository files are ignored. See about_PSRule_Options for more information. Type : Boolean Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -InputIgnoreUnchangedPath # Sets the option Input.IgnoreUnchangedPath . The Input.IgnoreUnchangedPath option determine if unchanged files are ignored. Type : Boolean Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -ObjectPath # Sets the Input.ObjectPath option to use an object path to use instead of the pipeline object. See about_PSRule_Options for more information. Type : String Parameter Sets : (All) Aliases : InputObjectPath Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -InputPathIgnore # Sets the Input.PathIgnore option. If specified, files that match the path spec will not be processed. See about_PSRule_Options for more information. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -InputTargetType # Sets the Input.TargetType option to only process objects with the specified TargetType. See about_PSRule_Options for more information. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -InputIgnoreObjectSource # Sets the option Input.IgnoreObjectSource . The Input.IgnoreObjectSource option determines if objects will be skipped if the source path has been ignored. Type : Boolean Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -LoggingLimitDebug # Sets the Logging.LimitDebug option to limit debug messages to a list of named debug scopes. See about_PSRule_Options for more information. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -LoggingLimitVerbose # Sets the Logging.LimitVerbose option to limit verbose messages to a list of named verbose scopes. See about_PSRule_Options for more information. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -LoggingRuleFail # Sets the Logging.RuleFail option to generate an informational message for each rule fail. See about_PSRule_Options for more information. Type : OutcomeLogStream Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -LoggingRulePass # Sets the Logging.RulePass option to generate an informational message for each rule pass. See about_PSRule_Options for more information. Type : OutcomeLogStream Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -OutputAs # Sets the option Output.As . The Output.As option configures the type of results to produce, either detail or summary. Type : ResultFormat Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -OutputBanner # Sets the option Output.Banner . The Output.Banner option configure information displayed with PSRule banner. This option is only applicable when using Assert-PSRule cmdlet. Type : BannerFormat Parameter Sets : (All) Aliases : Required : False Position : Named Default value : Default Accept pipeline input : False Accept wildcard characters : False -OutputCulture # Sets the option Output.Culture . The Output.Culture option configures the culture used to generated output. When multiple cultures are specified, the first matching culture will be used. See about_PSRule_Options for more information. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -OutputEncoding # Sets the option Output.Encoding . The Output.Encoding option configured the encoding used to write results to file. Type : OutputEncoding Parameter Sets : (All) Aliases : Accepted values : Default, UTF8, UTF7, Unicode, UTF32, ASCII Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -OutputFooter # Sets the option Output.Footer . The Output.Footer option configures the information displayed for PSRule footer. See about_PSRule_Options for more information. Type : FooterFormat Parameter Sets : (All) Aliases : Required : False Position : Named Default value : Default Accept pipeline input : False Accept wildcard characters : False -OutputFormat # Sets the option Output.Format . The Output.Format option configures the format that results will be presented in. See about_PSRule_Options for more information. Type : OutputFormat Parameter Sets : (All) Aliases : Accepted values : None, Yaml, Json, Markdown, NUnit3, Csv, Wide, Sarif Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -OutputJobSummaryPath # Set the option Output.JobSummaryPath . The Output.JobSummaryPath option configures the path to a job summary output file. Type : String Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -OutputJsonIndent # Sets the option Output.JsonIndent . The Output.JsonIndent option configures indentation for JSON output. This option only applies to Get-PSRule , Invoke-PSRule and Assert-PSRule cmdlets. Type : Int32 Parameter Sets : (All) Aliases : JsonIndent Accepted values : 0, 1, 2, 3, 4 Required : False Position : Named Default value : 0 Accept pipeline input : False Accept wildcard characters : False -OutputOutcome # Sets the Output.Outcome option. This option can be set to include or exclude output results. See about_PSRule_Options for more information. Type : RuleOutcome Parameter Sets : (All) Aliases : Outcome Required : False Position : Named Default value : Processed Accept pipeline input : False Accept wildcard characters : False -OutputPath # Sets the option Output.Path . The Output.Path option configures an output file path to write results. Type : String Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -OutputSarifProblemsOnly # Sets the option Option.SarifProblemsOnly . The Output.SarifProblemsOnly option determines if SARIF output only includes fail and error outcomes. Type : Boolean Parameter Sets : (All) Aliases : Required : False Position : Named Default value : True Accept pipeline input : False Accept wildcard characters : False -OutputStyle # Sets the option Option.Style . The Output.Style option configures the style that results will be presented in. This option only applies to Assert-PSRule . Type : OutputStyle Parameter Sets : (All) Aliases : Accepted values : Client, Plain, AzurePipelines, GitHubActions Required : False Position : Named Default value : Client Accept pipeline input : False Accept wildcard characters : False -RepositoryBaseRef # Sets the option Repository.BaseRef . The Repository.BaseRef option sets the repository base ref used for comparisons of changed files. Type : String Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -RepositoryUrl # Sets the option Repository.Url . The Repository.Url option sets the repository URL reported in output. Type : String Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -RuleIncludeLocal # Sets the option Rule.IncludeLocal . The Rule.IncludeLocal option configures if local rules are automatically included. See about_PSRule_Options for more information. Type : Boolean Parameter Sets : (All) Aliases : Required : False Position : Named Default value : False Accept pipeline input : False Accept wildcard characters : False -AliasReferenceWarning # Sets the option Execution.AliasReferenceWarning . The Execution.AliasReferenceWarning option determines if a warning is logged when alises are referenced. Type : Boolean Parameter Sets : (All) Aliases : ExecutionAliasReferenceWarning Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -InvariantCultureWarning # Sets the option Execution.InvariantCultureWarning . The Execution.InvariantCultureWarning option sets if a warning is logged when invarient culture is detected. Type : Boolean Parameter Sets : (All) Aliases : ExecutionInvariantCultureWarning Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -DuplicateResourceId # Sets the option Execution.DuplicateResourceId . The Execution.DuplicateResourceId option determines how to handle duplicate resources identifiers during execution. Type : ExecutionActionPreference Parameter Sets : (All) Aliases : ExecutionDuplicateResourceId Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -InitialSessionState # Sets the option Execution.InitialSessionState . The Execution.InitialSessionState option determines how the initial session state for executing PowerShell code is created. Type : SessionState Parameter Sets : (All) Aliases : ExecutionInitialSessionState Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False CommonParameters # This cmdlet supports the common parameters: -Debug, -ErrorAction, -ErrorVariable, -InformationAction, -InformationVariable, -OutVariable, -OutBuffer, -PipelineVariable, -Verbose, -WarningAction, and -WarningVariable. For more information, see about_CommonParameters . INPUTS # None # OUTPUTS # PSRule.Configuration.PSRuleOption # Notes # RELATED LINKS # Invoke-PSRule Set-PSRuleOption","title":"New-PSRuleOption"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#new-psruleoption","text":"Create options to configure PSRule execution.","title":"New-PSRuleOption"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#syntax","text":"","title":"SYNTAX"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#frompath-default","text":"New-PSRuleOption [[-Path] <String>] [-Configuration <ConfigurationOption>] [-SuppressTargetName <SuppressionOption>] [-BindTargetName <BindTargetName[]>] [-BindTargetType <BindTargetName[]>] [-BindingIgnoreCase <Boolean>] [-BindingField <Hashtable>] [-BindingNameSeparator <String>] [-BindingPreferTargetInfo <Boolean>] [-TargetName <String[]>] [-TargetType <String[]>] [-BindingUseQualifiedName <Boolean>] [-Convention <String[]>] [-AliasReferenceWarning <Boolean>] [-DuplicateResourceId <ExecutionActionPreference>] [-InconclusiveWarning <Boolean>] [-NotProcessedWarning <Boolean>] [-SuppressedRuleWarning <Boolean>] [-InvariantCultureWarning <Boolean>] [-InitialSessionState <SessionState>] [-IncludeModule <String[]>] [-IncludePath <String[]>] [-Format <InputFormat>] [-InputIgnoreGitPath <Boolean>] [-InputIgnoreRepositoryCommon <Boolean>] [-InputIgnoreObjectSource <Boolean>] [-InputIgnoreUnchangedPath <Boolean>] [-ObjectPath <String>] [-InputTargetType <String[]>] [-InputPathIgnore <String[]>] [-LoggingLimitDebug <String[]>] [-LoggingLimitVerbose <String[]>] [-LoggingRuleFail <OutcomeLogStream>] [-LoggingRulePass <OutcomeLogStream>] [-OutputAs <ResultFormat>] [-OutputBanner <BannerFormat>] [-OutputCulture <String[]>] [-OutputEncoding <OutputEncoding>] [-OutputFooter <FooterFormat>] [-OutputFormat <OutputFormat>] [-OutputJobSummaryPath <String>] [-OutputJsonIndent <Int32>] [-OutputOutcome <RuleOutcome>] [-OutputPath <String>] [-OutputSarifProblemsOnly <Boolean>] [-OutputStyle <OutputStyle>] [-RepositoryBaseRef <String>] [-RepositoryUrl <String>] [-RuleIncludeLocal <Boolean>] [<CommonParameters>]","title":"FromPath (Default)"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#fromoption","text":"New-PSRuleOption [-Option] <PSRuleOption> [-Configuration <ConfigurationOption>] [-SuppressTargetName <SuppressionOption>] [-BindTargetName <BindTargetName[]>] [-BindTargetType <BindTargetName[]>] [-BindingIgnoreCase <Boolean>] [-BindingField <Hashtable>] [-BindingNameSeparator <String>] [-BindingPreferTargetInfo <Boolean>] [-TargetName <String[]>] [-TargetType <String[]>] [-BindingUseQualifiedName <Boolean>] [-Convention <String[]>] [-AliasReferenceWarning <Boolean>] [-DuplicateResourceId <ExecutionActionPreference>] [-InconclusiveWarning <Boolean>] [-NotProcessedWarning <Boolean>] [-SuppressedRuleWarning <Boolean>] [-InvariantCultureWarning <Boolean>] [-InitialSessionState <SessionState>] [-IncludeModule <String[]>] [-IncludePath <String[]>] [-Format <InputFormat>] [-InputIgnoreGitPath <Boolean>] [-InputIgnoreRepositoryCommon <Boolean>] [-InputIgnoreObjectSource <Boolean>] [-InputIgnoreUnchangedPath <Boolean>] [-ObjectPath <String>] [-InputTargetType <String[]>] [-InputPathIgnore <String[]>] [-LoggingLimitDebug <String[]>] [-LoggingLimitVerbose <String[]>] [-LoggingRuleFail <OutcomeLogStream>] [-LoggingRulePass <OutcomeLogStream>] [-OutputAs <ResultFormat>] [-OutputBanner <BannerFormat>] [-OutputCulture <String[]>] [-OutputEncoding <OutputEncoding>] [-OutputFooter <FooterFormat>] [-OutputFormat <OutputFormat>] [-OutputJobSummaryPath <String>] [-OutputJsonIndent <Int32>] [-OutputOutcome <RuleOutcome>] [-OutputPath <String>] [-OutputSarifProblemsOnly <Boolean>] [-OutputStyle <OutputStyle>] [-RepositoryBaseRef <String>] [-RepositoryUrl <String>] [-RuleIncludeLocal <Boolean>] [<CommonParameters>]","title":"FromOption"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#fromdefault","text":"New-PSRuleOption [-Default] [-Configuration <ConfigurationOption>] [-SuppressTargetName <SuppressionOption>] [-BindTargetName <BindTargetName[]>] [-BindTargetType <BindTargetName[]>] [-BindingIgnoreCase <Boolean>] [-BindingField <Hashtable>] [-BindingNameSeparator <String>] [-BindingPreferTargetInfo <Boolean>] [-TargetName <String[]>] [-TargetType <String[]>] [-BindingUseQualifiedName <Boolean>] [-Convention <String[]>] [-AliasReferenceWarning <Boolean>] [-DuplicateResourceId <ExecutionActionPreference>] [-InconclusiveWarning <Boolean>] [-NotProcessedWarning <Boolean>] [-SuppressedRuleWarning <Boolean>] [-InvariantCultureWarning <Boolean>] [-InitialSessionState <SessionState>] [-IncludeModule <String[]>] [-IncludePath <String[]>] [-Format <InputFormat>] [-InputIgnoreGitPath <Boolean>] [-InputIgnoreRepositoryCommon <Boolean>] [-InputIgnoreObjectSource <Boolean>] [-InputIgnoreUnchangedPath <Boolean>] [-ObjectPath <String>] [-InputTargetType <String[]>] [-InputPathIgnore <String[]>] [-LoggingLimitDebug <String[]>] [-LoggingLimitVerbose <String[]>] [-LoggingRuleFail <OutcomeLogStream>] [-LoggingRulePass <OutcomeLogStream>] [-OutputAs <ResultFormat>] [-OutputBanner <BannerFormat>] [-OutputCulture <String[]>] [-OutputEncoding <OutputEncoding>] [-OutputFooter <FooterFormat>] [-OutputFormat <OutputFormat>] [-OutputJobSummaryPath <String>] [-OutputJsonIndent <Int32>] [-OutputOutcome <RuleOutcome>] [-OutputPath <String>] [-OutputSarifProblemsOnly <Boolean>] [-OutputStyle <OutputStyle>] [-RepositoryBaseRef <String>] [-RepositoryUrl <String>] [-RuleIncludeLocal <Boolean>] [<CommonParameters>]","title":"FromDefault"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#description","text":"The New-PSRuleOption cmdlet creates an options object that can be passed to PSRule cmdlets to configure execution.","title":"Description"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#examples","text":"","title":"Examples"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#example-1","text":"$option = New-PSRuleOption -Option @{ 'execution.mode' = 'ConstrainedLanguage' } @{ Name = 'Item 1' } | Invoke-PSRule -Option $option Create an options object and run rules in constrained mode.","title":"Example 1"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#example-2","text":"$option = New-PSRuleOption -SuppressTargetName @{ 'storageAccounts.UseHttps' = 'TestObject1' , 'TestObject3' }; Create an options object that suppresses TestObject1 and TestObject3 for a rule named storageAccounts.UseHttps .","title":"Example 2"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#example-3","text":"# Create a custom function that returns a TargetName string $bindFn = { param ( $TargetObject ) $otherName = $TargetObject . PSObject . Properties [ 'OtherName' ]; if ( $otherName -eq $Null ) { return $Null } return $otherName . Value ; } # Specify the binding function script block code to execute $option = New-PSRuleOption -BindTargetName $bindFn ; Creates an options object that uses a custom function to bind the TargetName of an object.","title":"Example 3"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#example-4","text":"$option = New-PSRuleOption -Configuration @{ 'appServiceMinInstanceCount' = 2 }; Create an options object that sets the appServiceMinInstanceCount baseline configuration option to 2 .","title":"Example 4"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#parameters","text":"","title":"PARAMETERS"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-option","text":"Additional options that configure execution. Option also accepts a hashtable to configure options. See about_PSRule_Options for more information. Type : PSRuleOption Parameter Sets : FromOption Aliases : Required : True Position : 0 Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Option"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-path","text":"The path to a YAML file containing options. Either a directory or file path can be specified. When a directory is used, ps-rule.yaml will be used as the file name. If the -Path parameter is specified and the file does not exist, an exception will be generated. Type : String Parameter Sets : FromPath Aliases : Required : False Position : 1 Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Path"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-default","text":"When specified, defaults are used for any options not overridden. Type : SwitchParameter Parameter Sets : FromDefault Aliases : Required : True Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Default"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-suppresstargetname","text":"Configures suppression for a list of objects by TargetName. SuppressTargetName also accepts a hashtable to configure rule suppression. See about_PSRule_Options for more information. Type : SuppressionOption Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-SuppressTargetName"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-bindtargetname","text":"Configures a custom function to use to bind TargetName of an object. See about_PSRule_Options for more information. Type : BindTargetName[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-BindTargetName"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-configuration","text":"Configures a set of baseline configuration values that can be used in rule definitions instead of using hard coded values. Configuration also accepts a hashtable of configuration values as key/ value pairs. See about_PSRule_Options for more information. Type : ConfigurationOption Parameter Sets : (All) Aliases : BaselineConfiguration Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Configuration"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-bindtargettype","text":"Configures a custom function to use to bind TargetType of an object. See about_PSRule_Options for more information. Type : BindTargetName[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-BindTargetType"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-bindingignorecase","text":"Sets the option Binding.IgnoreCase . The option Binding.IgnoreCase determines if binding operations are case-sensitive or not. See about_PSRule_Options for more information. Type : Boolean Parameter Sets : (All) Aliases : Required : False Position : Named Default value : True Accept pipeline input : False Accept wildcard characters : False","title":"-BindingIgnoreCase"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-bindingfield","text":"Sets the option Binding.Field . The option specified one or more custom field bindings. See about_PSRule_Options for more information. Type : Hashtable Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-BindingField"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-bindingnameseparator","text":"Sets the option Binding.NameSeparator . This option specifies the separator to use for qualified names. See about_PSRule_Options for more information. Type : String Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-BindingNameSeparator"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-bindingprefertargetinfo","text":"Sets the option Binding.PreferTargetInfo . This option specifies if automatic binding is preferred over configured binding options. See about_PSRule_Options for more information. Type : Boolean Parameter Sets : (All) Aliases : Required : False Position : Named Default value : False Accept pipeline input : False Accept wildcard characters : False","title":"-BindingPreferTargetInfo"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-convention","text":"Sets the Option.ConventionInclude option. This option specifies the name of conventions to execute in the pipeline when processing objects. See about_PSRule_Options for more information. Type : String[] Parameter Sets : (All) Aliases : ConventionInclude Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Convention"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-targetname","text":"Sets the option Binding.TargetName . This option specifies one or more properties of TargetObject to use to bind TargetName to. See about_PSRule_Options for more information. Type : String[] Parameter Sets : (All) Aliases : BindingTargetName Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-TargetName"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-targettype","text":"Sets the option Binding.TargetType . This option specifies one or more properties of TargetObject to use to bind TargetType to. See about_PSRule_Options for more information. Type : String[] Parameter Sets : (All) Aliases : BindingTargetType Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-TargetType"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-bindingusequalifiedname","text":"Sets the option Binding.UseQualifiedName . This option specifies is qualified target names are used. See about_PSRule_Options for more information. Type : Boolean Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-BindingUseQualifiedName"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-inconclusivewarning","text":"Sets the option Execution.InconclusiveWarning . The Execution.InconclusiveWarning option determines if a warning is generated when the outcome of a rule is inconclusive. See about_PSRule_Options for more information. Type : Boolean Parameter Sets : (All) Aliases : ExecutionInconclusiveWarning Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-InconclusiveWarning"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-notprocessedwarning","text":"Sets the option Execution.NotProcessedWarning . The Execution.NotProcessedWarning option determines if a warning is generated when an object is not processed by any rule. See about_PSRule_Options for more information. Type : Boolean Parameter Sets : (All) Aliases : ExecutionNotProcessedWarning Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-NotProcessedWarning"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-suppressedrulewarning","text":"Sets the Execution.SuppressedRuleWarning option. The Execution.SuppressedRuleWarning option determines if a warning is generated when a rule is suppressed. See about_PSRule_Options for more information. Type : Boolean Parameter Sets : (All) Aliases : ExecutionSuppressedRuleWarning Required : False Position : Named Default value : True Accept pipeline input : False Accept wildcard characters : False","title":"-SuppressedRuleWarning"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-includemodule","text":"Sets the Include.Module option to include additional module sources. See about_PSRule_Options for more information. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-IncludeModule"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-includepath","text":"Sets the Include.Path option to include additional standalone sources. See about_PSRule_Options for more information. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-IncludePath"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-format","text":"Sets the Input.Format option to configure the input format for when a string is passed in as a target object. See about_PSRule_Options for more information. Type : InputFormat Parameter Sets : (All) Aliases : InputFormat Accepted values : None, Yaml, Json, Markdown, PowerShellData, File, Detect Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Format"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-inputignoregitpath","text":"Sets the Input.IgnoreGitPath option to determine if files within the .git path are ignored. See about_PSRule_Options for more information. Type : Boolean Parameter Sets : (All) Aliases : Required : False Position : Named Default value : True Accept pipeline input : False Accept wildcard characters : False","title":"-InputIgnoreGitPath"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-inputignorerepositorycommon","text":"Sets the Input.IgnoreRepositoryCommon option to determine if files common repository files are ignored. See about_PSRule_Options for more information. Type : Boolean Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-InputIgnoreRepositoryCommon"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-inputignoreunchangedpath","text":"Sets the option Input.IgnoreUnchangedPath . The Input.IgnoreUnchangedPath option determine if unchanged files are ignored. Type : Boolean Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-InputIgnoreUnchangedPath"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-objectpath","text":"Sets the Input.ObjectPath option to use an object path to use instead of the pipeline object. See about_PSRule_Options for more information. Type : String Parameter Sets : (All) Aliases : InputObjectPath Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-ObjectPath"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-inputpathignore","text":"Sets the Input.PathIgnore option. If specified, files that match the path spec will not be processed. See about_PSRule_Options for more information. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-InputPathIgnore"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-inputtargettype","text":"Sets the Input.TargetType option to only process objects with the specified TargetType. See about_PSRule_Options for more information. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-InputTargetType"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-inputignoreobjectsource","text":"Sets the option Input.IgnoreObjectSource . The Input.IgnoreObjectSource option determines if objects will be skipped if the source path has been ignored. Type : Boolean Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-InputIgnoreObjectSource"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-logginglimitdebug","text":"Sets the Logging.LimitDebug option to limit debug messages to a list of named debug scopes. See about_PSRule_Options for more information. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-LoggingLimitDebug"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-logginglimitverbose","text":"Sets the Logging.LimitVerbose option to limit verbose messages to a list of named verbose scopes. See about_PSRule_Options for more information. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-LoggingLimitVerbose"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-loggingrulefail","text":"Sets the Logging.RuleFail option to generate an informational message for each rule fail. See about_PSRule_Options for more information. Type : OutcomeLogStream Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-LoggingRuleFail"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-loggingrulepass","text":"Sets the Logging.RulePass option to generate an informational message for each rule pass. See about_PSRule_Options for more information. Type : OutcomeLogStream Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-LoggingRulePass"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-outputas","text":"Sets the option Output.As . The Output.As option configures the type of results to produce, either detail or summary. Type : ResultFormat Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-OutputAs"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-outputbanner","text":"Sets the option Output.Banner . The Output.Banner option configure information displayed with PSRule banner. This option is only applicable when using Assert-PSRule cmdlet. Type : BannerFormat Parameter Sets : (All) Aliases : Required : False Position : Named Default value : Default Accept pipeline input : False Accept wildcard characters : False","title":"-OutputBanner"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-outputculture","text":"Sets the option Output.Culture . The Output.Culture option configures the culture used to generated output. When multiple cultures are specified, the first matching culture will be used. See about_PSRule_Options for more information. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-OutputCulture"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-outputencoding","text":"Sets the option Output.Encoding . The Output.Encoding option configured the encoding used to write results to file. Type : OutputEncoding Parameter Sets : (All) Aliases : Accepted values : Default, UTF8, UTF7, Unicode, UTF32, ASCII Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-OutputEncoding"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-outputfooter","text":"Sets the option Output.Footer . The Output.Footer option configures the information displayed for PSRule footer. See about_PSRule_Options for more information. Type : FooterFormat Parameter Sets : (All) Aliases : Required : False Position : Named Default value : Default Accept pipeline input : False Accept wildcard characters : False","title":"-OutputFooter"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-outputformat","text":"Sets the option Output.Format . The Output.Format option configures the format that results will be presented in. See about_PSRule_Options for more information. Type : OutputFormat Parameter Sets : (All) Aliases : Accepted values : None, Yaml, Json, Markdown, NUnit3, Csv, Wide, Sarif Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-OutputFormat"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-outputjobsummarypath","text":"Set the option Output.JobSummaryPath . The Output.JobSummaryPath option configures the path to a job summary output file. Type : String Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-OutputJobSummaryPath"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-outputjsonindent","text":"Sets the option Output.JsonIndent . The Output.JsonIndent option configures indentation for JSON output. This option only applies to Get-PSRule , Invoke-PSRule and Assert-PSRule cmdlets. Type : Int32 Parameter Sets : (All) Aliases : JsonIndent Accepted values : 0, 1, 2, 3, 4 Required : False Position : Named Default value : 0 Accept pipeline input : False Accept wildcard characters : False","title":"-OutputJsonIndent"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-outputoutcome","text":"Sets the Output.Outcome option. This option can be set to include or exclude output results. See about_PSRule_Options for more information. Type : RuleOutcome Parameter Sets : (All) Aliases : Outcome Required : False Position : Named Default value : Processed Accept pipeline input : False Accept wildcard characters : False","title":"-OutputOutcome"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-outputpath","text":"Sets the option Output.Path . The Output.Path option configures an output file path to write results. Type : String Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-OutputPath"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-outputsarifproblemsonly","text":"Sets the option Option.SarifProblemsOnly . The Output.SarifProblemsOnly option determines if SARIF output only includes fail and error outcomes. Type : Boolean Parameter Sets : (All) Aliases : Required : False Position : Named Default value : True Accept pipeline input : False Accept wildcard characters : False","title":"-OutputSarifProblemsOnly"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-outputstyle","text":"Sets the option Option.Style . The Output.Style option configures the style that results will be presented in. This option only applies to Assert-PSRule . Type : OutputStyle Parameter Sets : (All) Aliases : Accepted values : Client, Plain, AzurePipelines, GitHubActions Required : False Position : Named Default value : Client Accept pipeline input : False Accept wildcard characters : False","title":"-OutputStyle"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-repositorybaseref","text":"Sets the option Repository.BaseRef . The Repository.BaseRef option sets the repository base ref used for comparisons of changed files. Type : String Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-RepositoryBaseRef"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-repositoryurl","text":"Sets the option Repository.Url . The Repository.Url option sets the repository URL reported in output. Type : String Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-RepositoryUrl"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-ruleincludelocal","text":"Sets the option Rule.IncludeLocal . The Rule.IncludeLocal option configures if local rules are automatically included. See about_PSRule_Options for more information. Type : Boolean Parameter Sets : (All) Aliases : Required : False Position : Named Default value : False Accept pipeline input : False Accept wildcard characters : False","title":"-RuleIncludeLocal"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-aliasreferencewarning","text":"Sets the option Execution.AliasReferenceWarning . The Execution.AliasReferenceWarning option determines if a warning is logged when alises are referenced. Type : Boolean Parameter Sets : (All) Aliases : ExecutionAliasReferenceWarning Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-AliasReferenceWarning"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-invariantculturewarning","text":"Sets the option Execution.InvariantCultureWarning . The Execution.InvariantCultureWarning option sets if a warning is logged when invarient culture is detected. Type : Boolean Parameter Sets : (All) Aliases : ExecutionInvariantCultureWarning Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-InvariantCultureWarning"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-duplicateresourceid","text":"Sets the option Execution.DuplicateResourceId . The Execution.DuplicateResourceId option determines how to handle duplicate resources identifiers during execution. Type : ExecutionActionPreference Parameter Sets : (All) Aliases : ExecutionDuplicateResourceId Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-DuplicateResourceId"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-initialsessionstate","text":"Sets the option Execution.InitialSessionState . The Execution.InitialSessionState option determines how the initial session state for executing PowerShell code is created. Type : SessionState Parameter Sets : (All) Aliases : ExecutionInitialSessionState Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-InitialSessionState"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#commonparameters","text":"This cmdlet supports the common parameters: -Debug, -ErrorAction, -ErrorVariable, -InformationAction, -InformationVariable, -OutVariable, -OutBuffer, -PipelineVariable, -Verbose, -WarningAction, and -WarningVariable. For more information, see about_CommonParameters .","title":"CommonParameters"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#inputs","text":"","title":"INPUTS"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#none","text":"","title":"None"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#outputs","text":"","title":"OUTPUTS"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#psruleconfigurationpsruleoption","text":"","title":"PSRule.Configuration.PSRuleOption"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#notes","text":"","title":"Notes"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#related-links","text":"Invoke-PSRule Set-PSRuleOption","title":"RELATED LINKS"},{"location":"commands/PSRule/en-US/PSRule/","text":"PSRule Module # Description # A PowerShell rules engine. PSRule Cmdlets # Assert-PSRule # Evaluate objects against matching rules and assert any failures. Export-PSRuleBaseline # Exports a list of baselines to a file. Get-PSRule # Get a list of matching rule definitions within the search path. Get-PSRuleBaseline # Get a list of matching baselines within the search path. Get-PSRuleHelp # Get documentation for a rule. Get-PSRuleTarget # Get a list of target object. Invoke-PSRule # Evaluate objects against matching rules and output the results. New-PSRuleOption # Create options to configure PSRule execution. Set-PSRuleOption # Set options to configure PSRule execution. Test-PSRuleTarget # Evaluate pipeline objects against matching rules.","title":"PSRule Module"},{"location":"commands/PSRule/en-US/PSRule/#psrule-module","text":"","title":"PSRule Module"},{"location":"commands/PSRule/en-US/PSRule/#description","text":"A PowerShell rules engine.","title":"Description"},{"location":"commands/PSRule/en-US/PSRule/#psrule-cmdlets","text":"","title":"PSRule Cmdlets"},{"location":"commands/PSRule/en-US/PSRule/#assert-psrule","text":"Evaluate objects against matching rules and assert any failures.","title":"Assert-PSRule"},{"location":"commands/PSRule/en-US/PSRule/#export-psrulebaseline","text":"Exports a list of baselines to a file.","title":"Export-PSRuleBaseline"},{"location":"commands/PSRule/en-US/PSRule/#get-psrule","text":"Get a list of matching rule definitions within the search path.","title":"Get-PSRule"},{"location":"commands/PSRule/en-US/PSRule/#get-psrulebaseline","text":"Get a list of matching baselines within the search path.","title":"Get-PSRuleBaseline"},{"location":"commands/PSRule/en-US/PSRule/#get-psrulehelp","text":"Get documentation for a rule.","title":"Get-PSRuleHelp"},{"location":"commands/PSRule/en-US/PSRule/#get-psruletarget","text":"Get a list of target object.","title":"Get-PSRuleTarget"},{"location":"commands/PSRule/en-US/PSRule/#invoke-psrule","text":"Evaluate objects against matching rules and output the results.","title":"Invoke-PSRule"},{"location":"commands/PSRule/en-US/PSRule/#new-psruleoption","text":"Create options to configure PSRule execution.","title":"New-PSRuleOption"},{"location":"commands/PSRule/en-US/PSRule/#set-psruleoption","text":"Set options to configure PSRule execution.","title":"Set-PSRuleOption"},{"location":"commands/PSRule/en-US/PSRule/#test-psruletarget","text":"Evaluate pipeline objects against matching rules.","title":"Test-PSRuleTarget"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/","text":"Set-PSRuleOption # Sets options that configure PSRule execution. SYNTAX # Set-PSRuleOption [[-Path] <String>] [-Option <PSRuleOption>] [-PassThru] [-Force] [-AllowClobber] [-BindingIgnoreCase <Boolean>] [-BindingField <Hashtable>] [-BindingNameSeparator <String>] [-BindingPreferTargetInfo <Boolean>] [-TargetName <String[]>] [-TargetType <String[]>] [-BindingUseQualifiedName <Boolean>] [-Convention <String[]>] [-AliasReferenceWarning <Boolean>] [-DuplicateResourceId <ExecutionActionPreference>] [-InconclusiveWarning <Boolean>] [-NotProcessedWarning <Boolean>] [-SuppressedRuleWarning <Boolean>] [-InvariantCultureWarning <Boolean>] [-InitialSessionState <SessionState>] [-IncludeModule <String[]>] [-IncludePath <String[]>] [-Format <InputFormat>] [-InputIgnoreGitPath <Boolean>] [-InputIgnoreObjectSource <Boolean>] [-InputIgnoreRepositoryCommon <Boolean>] [-InputIgnoreUnchangedPath <Boolean>] [-ObjectPath <String>] [-InputPathIgnore <String[]>] [-InputTargetType <String[]>] [-LoggingLimitDebug <String[]>] [-LoggingLimitVerbose <String[]>] [-LoggingRuleFail <OutcomeLogStream>] [-LoggingRulePass <OutcomeLogStream>] [-OutputAs <ResultFormat>] [-OutputBanner <BannerFormat>] [-OutputCulture <String[]>] [-OutputEncoding <OutputEncoding>] [-OutputFooter <FooterFormat>] [-OutputFormat <OutputFormat>] [-OutputJobSummaryPath <String>] [-OutputJsonIndent <Int32>] [-OutputOutcome <RuleOutcome>] [-OutputPath <String>] [-OutputSarifProblemsOnly <Boolean>] [-OutputStyle <OutputStyle>] [-RepositoryBaseRef <String>] [-RepositoryUrl <String>] [-RuleIncludeLocal <Boolean>] [-WhatIf] [-Confirm] [<CommonParameters>] Description # Sets options that configure PSRule execution. Examples # Example 1 # PS C :\\> Set-PSRuleOption -OutputFormat Yaml ; Sets the Output.Format to Yaml for ps-rule.yaml in the current working path. If the ps-rule.yaml file exists, it is merged with the existing file and overwritten. If the file does not exist, a new file is created. Example 2 # PS C :\\> Set-PSRuleOption -OutputFormat Yaml -Path .\\ project-options . yaml ; Sets the Output.Format to Yaml for project-options.yaml in the current working path. If the project-options.yaml file exists, it is merged with the existing file and overwritten. If the file does not exist, a new file is created. PARAMETERS # -Path # The path to a YAML file where options will be set. Either a directory or file path can be specified. When a directory is used, ps-rule.yaml will be used as the file name. The file will be created if it does not exist. If the file already exists it will be merged with the existing options and overwritten . If the directory does not exist an error will be generated. To force the creation of the directory path use the -Force switch. Type : String Parameter Sets : (All) Aliases : Required : False Position : 1 Default value : None Accept pipeline input : False Accept wildcard characters : False -Option # An options object to use. Type : PSRuleOption Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : True (ByValue) Accept wildcard characters : False -PassThru # Use this option to return the options object to the pipeline instead of saving to disk. Type : SwitchParameter Parameter Sets : (All) Aliases : Required : False Position : Named Default value : False Accept pipeline input : False Accept wildcard characters : False -Force # Force creation of directory path for Path parameter, when the directory does not already exist. Type : SwitchParameter Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -AllowClobber # Overwrite YAML files that contain comments. Type : SwitchParameter Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -BindingIgnoreCase # Sets the option Binding.IgnoreCase . The option Binding.IgnoreCase determines if binding operations are case-sensitive or not. See about_PSRule_Options for more information. Type : Boolean Parameter Sets : (All) Aliases : Required : False Position : Named Default value : True Accept pipeline input : False Accept wildcard characters : False -BindingField # Sets the option Binding.Field . The option specified one or more custom field bindings. See about_PSRule_Options for more information. Type : Hashtable Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -BindingNameSeparator # Sets the option Binding.NameSeparator . This option specifies the separator to use for qualified names. See about_PSRule_Options for more information. Type : String Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -BindingPreferTargetInfo # Sets the option Binding.PreferTargetInfo . This option specifies if automatic binding is preferred over configured binding options. See about_PSRule_Options for more information. Type : Boolean Parameter Sets : (All) Aliases : Required : False Position : Named Default value : False Accept pipeline input : False Accept wildcard characters : False -Convention # Sets the Option.ConventionInclude option. This option specifies the name of conventions to execute in the pipeline when processing objects. See about_PSRule_Options for more information. Type : String[] Parameter Sets : (All) Aliases : ConventionInclude Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -TargetName # Sets the option Binding.TargetName . This option specifies one or more properties of TargetObject to use to bind TargetName to. See about_PSRule_Options for more information. Type : String[] Parameter Sets : (All) Aliases : BindingTargetName Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -TargetType # Sets the option Binding.TargetType . This option specifies one or more properties of TargetObject to use to bind TargetType to. See about_PSRule_Options for more information. Type : String[] Parameter Sets : (All) Aliases : BindingTargetType Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -BindingUseQualifiedName # Sets the option Binding.UseQualifiedName . This option specifies is qualified target names are used. See about_PSRule_Options for more information. Type : Boolean Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -InconclusiveWarning # Sets the option Execution.InconclusiveWarning . The Execution.InconclusiveWarning option determines if a warning is generated when the outcome of a rule is inconclusive. See about_PSRule_Options for more information. Type : Boolean Parameter Sets : (All) Aliases : ExecutionInconclusiveWarning Required : False Position : Named Default value : True Accept pipeline input : False Accept wildcard characters : False -NotProcessedWarning # Sets the Execution.NotProcessedWarning option. The Execution.NotProcessedWarning option determines if a warning is generated when an object is not processed by any rule. See about_PSRule_Options for more information. Type : Boolean Parameter Sets : (All) Aliases : ExecutionNotProcessedWarning Required : False Position : Named Default value : True Accept pipeline input : False Accept wildcard characters : False -SuppressedRuleWarning # Sets the Execution.SuppressedRuleWarning option. The Execution.SuppressedRuleWarning option determines if a warning is generated when a rule is suppressed. See about_PSRule_Options for more information. Type : Boolean Parameter Sets : (All) Aliases : ExecutionSuppressedRuleWarning Required : False Position : Named Default value : True Accept pipeline input : False Accept wildcard characters : False -IncludeModule # Sets the Include.Module option to include additional module sources. See about_PSRule_Options for more information. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -IncludePath # Sets the Include.Path option to include additional standalone sources. See about_PSRule_Options for more information. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -Format # Sets the Input.Format option to configure the input format for when a string is passed in as a target object. See about_PSRule_Options for more information. Type : InputFormat Parameter Sets : (All) Aliases : InputFormat Accepted values : None, Yaml, Json, Markdown, PowerShellData, File, Detect Required : False Position : Named Default value : Detect Accept pipeline input : False Accept wildcard characters : False -InputIgnoreGitPath # Sets the Input.IgnoreGitPath option to determine if files within the .git path are ignored. See about_PSRule_Options for more information. Type : Boolean Parameter Sets : (All) Aliases : Required : False Position : Named Default value : True Accept pipeline input : False Accept wildcard characters : False -InputIgnoreRepositoryCommon # Sets the Input.IgnoreRepositoryCommon option to determine if files common repository files are ignored. See about_PSRule_Options for more information. Type : Boolean Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -InputIgnoreUnchangedPath # Sets the option Input.IgnoreUnchangedPath . The Input.IgnoreUnchangedPath option determine if unchanged files are ignored. Type : Boolean Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -ObjectPath # Sets the Input.ObjectPath option to use an object path to use instead of the pipeline object. See about_PSRule_Options for more information. Type : String Parameter Sets : (All) Aliases : InputObjectPath Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -InputPathIgnore # Sets the Input.PathIgnore option. If specified, files that match the path spec will not be processed. See about_PSRule_Options for more information. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -InputTargetType # Sets the Input.TargetType option to only process objects with the specified TargetType. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -InputIgnoreObjectSource # Sets the option Input.IgnoreObjectSource . The Input.IgnoreObjectSource option determines if objects will be skipped if the source path has been ignored. Type : Boolean Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -LoggingLimitDebug # Sets the Logging.LimitDebug option to limit debug messages to a list of named debug scopes. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -LoggingLimitVerbose # Sets the Logging.LimitVerbose option to limit verbose messages to a list of named verbose scopes. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -LoggingRuleFail # Sets the Logging.RuleFail option to generate an informational message for each rule fail. Type : OutcomeLogStream Parameter Sets : (All) Aliases : Accepted values : None, Error, Warning, Information Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -LoggingRulePass # Sets the Logging.RulePass option to generate an informational message for each rule pass. Type : OutcomeLogStream Parameter Sets : (All) Aliases : Accepted values : None, Error, Warning, Information Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -OutputAs # Sets the option Output.As . The Output.As option configures the type of results to produce, either detail or summary. Type : ResultFormat Parameter Sets : (All) Aliases : Accepted values : Detail, Summary Required : False Position : Named Default value : Detail Accept pipeline input : False Accept wildcard characters : False -OutputBanner # Sets the option Output.Banner . The Output.Banner option configure information displayed with PSRule banner. This option is only applicable when using Assert-PSRule cmdlet. Type : BannerFormat Parameter Sets : (All) Aliases : Required : False Position : Named Default value : Default Accept pipeline input : False Accept wildcard characters : False -OutputCulture # Sets the option Output.Culture . The Output.Culture option configures the culture used to generated output. When multiple cultures are specified, the first matching culture will be used. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -OutputEncoding # Sets the option Output.Encoding . The Output.Encoding option configured the encoding used to write results to file. Type : OutputEncoding Parameter Sets : (All) Aliases : Accepted values : Default, UTF8, UTF7, Unicode, UTF32, ASCII Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -OutputFooter # Sets the option Output.Footer . The Output.Footer option configures the information displayed for PSRule footer. See about_PSRule_Options for more information. Type : FooterFormat Parameter Sets : (All) Aliases : Required : False Position : Named Default value : Default Accept pipeline input : False Accept wildcard characters : False -OutputFormat # Sets the option Output.Format . The Output.Format option configures the format that results will be presented in. Type : OutputFormat Parameter Sets : (All) Aliases : Accepted values : None, Yaml, Json, Markdown, NUnit3, Csv, Wide, Sarif Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -OutputJobSummaryPath # Set the option Output.JobSummaryPath . The Output.JobSummaryPath option configures the path to a job summary output file. Type : String Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -OutputJsonIndent # Sets the option Output.JsonIndent . The Output.JsonIndent option configures indentation for JSON output. This option only applies to Get-PSRule , Invoke-PSRule and Assert-PSRule cmdlets. Type : Int32 Parameter Sets : (All) Aliases : JsonIndent Accepted values : 0, 1, 2, 3, 4 Required : False Position : Named Default value : 0 Accept pipeline input : False Accept wildcard characters : False -OutputOutcome # Sets the Output.Outcome option. This option can be set to include or exclude output results. See about_PSRule_Options for more information. Type : RuleOutcome Parameter Sets : (All) Aliases : Outcome Required : False Position : Named Default value : Processed Accept pipeline input : False Accept wildcard characters : False -OutputPath # Sets the option Output.Path . The Output.Path option configures an output file path to write results. Type : String Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -OutputSarifProblemsOnly # Sets the option Option.SarifProblemsOnly . The Output.SarifProblemsOnly option determines if SARIF output only includes fail and error outcomes. Type : Boolean Parameter Sets : (All) Aliases : Required : False Position : Named Default value : True Accept pipeline input : False Accept wildcard characters : False -OutputStyle # Sets the option Option.Style . The Output.Style option configures the style that results will be presented in. This option only applies to Assert-PSRule . Type : OutputStyle Parameter Sets : (All) Aliases : Accepted values : Client, Plain, AzurePipelines, GitHubActions Required : False Position : Named Default value : Client Accept pipeline input : False Accept wildcard characters : False -WhatIf # Shows what would happen if the cmdlet runs. The cmdlet is not run. Type : SwitchParameter Parameter Sets : (All) Aliases : wi Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -Confirm # Prompts you for confirmation before running the cmdlet. Type : SwitchParameter Parameter Sets : (All) Aliases : cf Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -RepositoryBaseRef # Sets the option Repository.BaseRef . The Repository.BaseRef option sets the repository base ref used for comparisons of changed files. Type : String Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -RepositoryUrl # Sets the option Repository.Url . The Repository.Url option sets the repository URL reported in output. Type : String Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -RuleIncludeLocal # Sets the option Rule.IncludeLocal . The Rule.IncludeLocal option configures if local rules are automatically included. See about_PSRule_Options for more information. Type : Boolean Parameter Sets : (All) Aliases : Required : False Position : Named Default value : False Accept pipeline input : False Accept wildcard characters : False -AliasReferenceWarning # Sets the option Execution.AliasReferenceWarning . The Execution.AliasReferenceWarning option determines if a warning is logged when alises are referenced. Type : Boolean Parameter Sets : (All) Aliases : ExecutionAliasReferenceWarning Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -InvariantCultureWarning # Sets the option Execution.InvariantCultureWarning . The Execution.InvariantCultureWarning option set if a warning is logged when invarient culture is detected. Type : Boolean Parameter Sets : (All) Aliases : ExecutionInvariantCultureWarning Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -DuplicateResourceId # Sets the option Execution.DuplicateResourceId . The Execution.DuplicateResourceId option determines how to handle duplicate resources identifiers during execution. Type : ExecutionActionPreference Parameter Sets : (All) Aliases : ExecutionDuplicateResourceId Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -InitialSessionState # Sets the option Execution.InitialSessionState . The Execution.InitialSessionState option determines how the initial session state for executing PowerShell code is created. Type : SessionState Parameter Sets : (All) Aliases : ExecutionInitialSessionState Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False CommonParameters # This cmdlet supports the common parameters: -Debug, -ErrorAction, -ErrorVariable, -InformationAction, -InformationVariable, -OutVariable, -OutBuffer, -PipelineVariable, -Verbose, -WarningAction, and -WarningVariable. For more information, see about_CommonParameters . INPUTS # OUTPUTS # PSRule.Configuration.PSRuleOption # When you use the -PassThru switch, an options object is returned to the pipeline. Notes # RELATED LINKS # New-PSRuleOption","title":"Set-PSRuleOption"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#set-psruleoption","text":"Sets options that configure PSRule execution.","title":"Set-PSRuleOption"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#syntax","text":"Set-PSRuleOption [[-Path] <String>] [-Option <PSRuleOption>] [-PassThru] [-Force] [-AllowClobber] [-BindingIgnoreCase <Boolean>] [-BindingField <Hashtable>] [-BindingNameSeparator <String>] [-BindingPreferTargetInfo <Boolean>] [-TargetName <String[]>] [-TargetType <String[]>] [-BindingUseQualifiedName <Boolean>] [-Convention <String[]>] [-AliasReferenceWarning <Boolean>] [-DuplicateResourceId <ExecutionActionPreference>] [-InconclusiveWarning <Boolean>] [-NotProcessedWarning <Boolean>] [-SuppressedRuleWarning <Boolean>] [-InvariantCultureWarning <Boolean>] [-InitialSessionState <SessionState>] [-IncludeModule <String[]>] [-IncludePath <String[]>] [-Format <InputFormat>] [-InputIgnoreGitPath <Boolean>] [-InputIgnoreObjectSource <Boolean>] [-InputIgnoreRepositoryCommon <Boolean>] [-InputIgnoreUnchangedPath <Boolean>] [-ObjectPath <String>] [-InputPathIgnore <String[]>] [-InputTargetType <String[]>] [-LoggingLimitDebug <String[]>] [-LoggingLimitVerbose <String[]>] [-LoggingRuleFail <OutcomeLogStream>] [-LoggingRulePass <OutcomeLogStream>] [-OutputAs <ResultFormat>] [-OutputBanner <BannerFormat>] [-OutputCulture <String[]>] [-OutputEncoding <OutputEncoding>] [-OutputFooter <FooterFormat>] [-OutputFormat <OutputFormat>] [-OutputJobSummaryPath <String>] [-OutputJsonIndent <Int32>] [-OutputOutcome <RuleOutcome>] [-OutputPath <String>] [-OutputSarifProblemsOnly <Boolean>] [-OutputStyle <OutputStyle>] [-RepositoryBaseRef <String>] [-RepositoryUrl <String>] [-RuleIncludeLocal <Boolean>] [-WhatIf] [-Confirm] [<CommonParameters>]","title":"SYNTAX"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#description","text":"Sets options that configure PSRule execution.","title":"Description"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#examples","text":"","title":"Examples"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#example-1","text":"PS C :\\> Set-PSRuleOption -OutputFormat Yaml ; Sets the Output.Format to Yaml for ps-rule.yaml in the current working path. If the ps-rule.yaml file exists, it is merged with the existing file and overwritten. If the file does not exist, a new file is created.","title":"Example 1"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#example-2","text":"PS C :\\> Set-PSRuleOption -OutputFormat Yaml -Path .\\ project-options . yaml ; Sets the Output.Format to Yaml for project-options.yaml in the current working path. If the project-options.yaml file exists, it is merged with the existing file and overwritten. If the file does not exist, a new file is created.","title":"Example 2"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#parameters","text":"","title":"PARAMETERS"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-path","text":"The path to a YAML file where options will be set. Either a directory or file path can be specified. When a directory is used, ps-rule.yaml will be used as the file name. The file will be created if it does not exist. If the file already exists it will be merged with the existing options and overwritten . If the directory does not exist an error will be generated. To force the creation of the directory path use the -Force switch. Type : String Parameter Sets : (All) Aliases : Required : False Position : 1 Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Path"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-option","text":"An options object to use. Type : PSRuleOption Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : True (ByValue) Accept wildcard characters : False","title":"-Option"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-passthru","text":"Use this option to return the options object to the pipeline instead of saving to disk. Type : SwitchParameter Parameter Sets : (All) Aliases : Required : False Position : Named Default value : False Accept pipeline input : False Accept wildcard characters : False","title":"-PassThru"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-force","text":"Force creation of directory path for Path parameter, when the directory does not already exist. Type : SwitchParameter Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Force"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-allowclobber","text":"Overwrite YAML files that contain comments. Type : SwitchParameter Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-AllowClobber"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-bindingignorecase","text":"Sets the option Binding.IgnoreCase . The option Binding.IgnoreCase determines if binding operations are case-sensitive or not. See about_PSRule_Options for more information. Type : Boolean Parameter Sets : (All) Aliases : Required : False Position : Named Default value : True Accept pipeline input : False Accept wildcard characters : False","title":"-BindingIgnoreCase"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-bindingfield","text":"Sets the option Binding.Field . The option specified one or more custom field bindings. See about_PSRule_Options for more information. Type : Hashtable Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-BindingField"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-bindingnameseparator","text":"Sets the option Binding.NameSeparator . This option specifies the separator to use for qualified names. See about_PSRule_Options for more information. Type : String Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-BindingNameSeparator"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-bindingprefertargetinfo","text":"Sets the option Binding.PreferTargetInfo . This option specifies if automatic binding is preferred over configured binding options. See about_PSRule_Options for more information. Type : Boolean Parameter Sets : (All) Aliases : Required : False Position : Named Default value : False Accept pipeline input : False Accept wildcard characters : False","title":"-BindingPreferTargetInfo"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-convention","text":"Sets the Option.ConventionInclude option. This option specifies the name of conventions to execute in the pipeline when processing objects. See about_PSRule_Options for more information. Type : String[] Parameter Sets : (All) Aliases : ConventionInclude Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Convention"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-targetname","text":"Sets the option Binding.TargetName . This option specifies one or more properties of TargetObject to use to bind TargetName to. See about_PSRule_Options for more information. Type : String[] Parameter Sets : (All) Aliases : BindingTargetName Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-TargetName"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-targettype","text":"Sets the option Binding.TargetType . This option specifies one or more properties of TargetObject to use to bind TargetType to. See about_PSRule_Options for more information. Type : String[] Parameter Sets : (All) Aliases : BindingTargetType Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-TargetType"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-bindingusequalifiedname","text":"Sets the option Binding.UseQualifiedName . This option specifies is qualified target names are used. See about_PSRule_Options for more information. Type : Boolean Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-BindingUseQualifiedName"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-inconclusivewarning","text":"Sets the option Execution.InconclusiveWarning . The Execution.InconclusiveWarning option determines if a warning is generated when the outcome of a rule is inconclusive. See about_PSRule_Options for more information. Type : Boolean Parameter Sets : (All) Aliases : ExecutionInconclusiveWarning Required : False Position : Named Default value : True Accept pipeline input : False Accept wildcard characters : False","title":"-InconclusiveWarning"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-notprocessedwarning","text":"Sets the Execution.NotProcessedWarning option. The Execution.NotProcessedWarning option determines if a warning is generated when an object is not processed by any rule. See about_PSRule_Options for more information. Type : Boolean Parameter Sets : (All) Aliases : ExecutionNotProcessedWarning Required : False Position : Named Default value : True Accept pipeline input : False Accept wildcard characters : False","title":"-NotProcessedWarning"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-suppressedrulewarning","text":"Sets the Execution.SuppressedRuleWarning option. The Execution.SuppressedRuleWarning option determines if a warning is generated when a rule is suppressed. See about_PSRule_Options for more information. Type : Boolean Parameter Sets : (All) Aliases : ExecutionSuppressedRuleWarning Required : False Position : Named Default value : True Accept pipeline input : False Accept wildcard characters : False","title":"-SuppressedRuleWarning"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-includemodule","text":"Sets the Include.Module option to include additional module sources. See about_PSRule_Options for more information. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-IncludeModule"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-includepath","text":"Sets the Include.Path option to include additional standalone sources. See about_PSRule_Options for more information. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-IncludePath"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-format","text":"Sets the Input.Format option to configure the input format for when a string is passed in as a target object. See about_PSRule_Options for more information. Type : InputFormat Parameter Sets : (All) Aliases : InputFormat Accepted values : None, Yaml, Json, Markdown, PowerShellData, File, Detect Required : False Position : Named Default value : Detect Accept pipeline input : False Accept wildcard characters : False","title":"-Format"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-inputignoregitpath","text":"Sets the Input.IgnoreGitPath option to determine if files within the .git path are ignored. See about_PSRule_Options for more information. Type : Boolean Parameter Sets : (All) Aliases : Required : False Position : Named Default value : True Accept pipeline input : False Accept wildcard characters : False","title":"-InputIgnoreGitPath"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-inputignorerepositorycommon","text":"Sets the Input.IgnoreRepositoryCommon option to determine if files common repository files are ignored. See about_PSRule_Options for more information. Type : Boolean Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-InputIgnoreRepositoryCommon"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-inputignoreunchangedpath","text":"Sets the option Input.IgnoreUnchangedPath . The Input.IgnoreUnchangedPath option determine if unchanged files are ignored. Type : Boolean Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-InputIgnoreUnchangedPath"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-objectpath","text":"Sets the Input.ObjectPath option to use an object path to use instead of the pipeline object. See about_PSRule_Options for more information. Type : String Parameter Sets : (All) Aliases : InputObjectPath Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-ObjectPath"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-inputpathignore","text":"Sets the Input.PathIgnore option. If specified, files that match the path spec will not be processed. See about_PSRule_Options for more information. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-InputPathIgnore"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-inputtargettype","text":"Sets the Input.TargetType option to only process objects with the specified TargetType. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-InputTargetType"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-inputignoreobjectsource","text":"Sets the option Input.IgnoreObjectSource . The Input.IgnoreObjectSource option determines if objects will be skipped if the source path has been ignored. Type : Boolean Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-InputIgnoreObjectSource"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-logginglimitdebug","text":"Sets the Logging.LimitDebug option to limit debug messages to a list of named debug scopes. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-LoggingLimitDebug"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-logginglimitverbose","text":"Sets the Logging.LimitVerbose option to limit verbose messages to a list of named verbose scopes. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-LoggingLimitVerbose"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-loggingrulefail","text":"Sets the Logging.RuleFail option to generate an informational message for each rule fail. Type : OutcomeLogStream Parameter Sets : (All) Aliases : Accepted values : None, Error, Warning, Information Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-LoggingRuleFail"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-loggingrulepass","text":"Sets the Logging.RulePass option to generate an informational message for each rule pass. Type : OutcomeLogStream Parameter Sets : (All) Aliases : Accepted values : None, Error, Warning, Information Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-LoggingRulePass"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-outputas","text":"Sets the option Output.As . The Output.As option configures the type of results to produce, either detail or summary. Type : ResultFormat Parameter Sets : (All) Aliases : Accepted values : Detail, Summary Required : False Position : Named Default value : Detail Accept pipeline input : False Accept wildcard characters : False","title":"-OutputAs"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-outputbanner","text":"Sets the option Output.Banner . The Output.Banner option configure information displayed with PSRule banner. This option is only applicable when using Assert-PSRule cmdlet. Type : BannerFormat Parameter Sets : (All) Aliases : Required : False Position : Named Default value : Default Accept pipeline input : False Accept wildcard characters : False","title":"-OutputBanner"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-outputculture","text":"Sets the option Output.Culture . The Output.Culture option configures the culture used to generated output. When multiple cultures are specified, the first matching culture will be used. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-OutputCulture"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-outputencoding","text":"Sets the option Output.Encoding . The Output.Encoding option configured the encoding used to write results to file. Type : OutputEncoding Parameter Sets : (All) Aliases : Accepted values : Default, UTF8, UTF7, Unicode, UTF32, ASCII Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-OutputEncoding"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-outputfooter","text":"Sets the option Output.Footer . The Output.Footer option configures the information displayed for PSRule footer. See about_PSRule_Options for more information. Type : FooterFormat Parameter Sets : (All) Aliases : Required : False Position : Named Default value : Default Accept pipeline input : False Accept wildcard characters : False","title":"-OutputFooter"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-outputformat","text":"Sets the option Output.Format . The Output.Format option configures the format that results will be presented in. Type : OutputFormat Parameter Sets : (All) Aliases : Accepted values : None, Yaml, Json, Markdown, NUnit3, Csv, Wide, Sarif Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-OutputFormat"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-outputjobsummarypath","text":"Set the option Output.JobSummaryPath . The Output.JobSummaryPath option configures the path to a job summary output file. Type : String Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-OutputJobSummaryPath"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-outputjsonindent","text":"Sets the option Output.JsonIndent . The Output.JsonIndent option configures indentation for JSON output. This option only applies to Get-PSRule , Invoke-PSRule and Assert-PSRule cmdlets. Type : Int32 Parameter Sets : (All) Aliases : JsonIndent Accepted values : 0, 1, 2, 3, 4 Required : False Position : Named Default value : 0 Accept pipeline input : False Accept wildcard characters : False","title":"-OutputJsonIndent"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-outputoutcome","text":"Sets the Output.Outcome option. This option can be set to include or exclude output results. See about_PSRule_Options for more information. Type : RuleOutcome Parameter Sets : (All) Aliases : Outcome Required : False Position : Named Default value : Processed Accept pipeline input : False Accept wildcard characters : False","title":"-OutputOutcome"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-outputpath","text":"Sets the option Output.Path . The Output.Path option configures an output file path to write results. Type : String Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-OutputPath"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-outputsarifproblemsonly","text":"Sets the option Option.SarifProblemsOnly . The Output.SarifProblemsOnly option determines if SARIF output only includes fail and error outcomes. Type : Boolean Parameter Sets : (All) Aliases : Required : False Position : Named Default value : True Accept pipeline input : False Accept wildcard characters : False","title":"-OutputSarifProblemsOnly"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-outputstyle","text":"Sets the option Option.Style . The Output.Style option configures the style that results will be presented in. This option only applies to Assert-PSRule . Type : OutputStyle Parameter Sets : (All) Aliases : Accepted values : Client, Plain, AzurePipelines, GitHubActions Required : False Position : Named Default value : Client Accept pipeline input : False Accept wildcard characters : False","title":"-OutputStyle"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-whatif","text":"Shows what would happen if the cmdlet runs. The cmdlet is not run. Type : SwitchParameter Parameter Sets : (All) Aliases : wi Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-WhatIf"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-confirm","text":"Prompts you for confirmation before running the cmdlet. Type : SwitchParameter Parameter Sets : (All) Aliases : cf Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Confirm"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-repositorybaseref","text":"Sets the option Repository.BaseRef . The Repository.BaseRef option sets the repository base ref used for comparisons of changed files. Type : String Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-RepositoryBaseRef"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-repositoryurl","text":"Sets the option Repository.Url . The Repository.Url option sets the repository URL reported in output. Type : String Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-RepositoryUrl"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-ruleincludelocal","text":"Sets the option Rule.IncludeLocal . The Rule.IncludeLocal option configures if local rules are automatically included. See about_PSRule_Options for more information. Type : Boolean Parameter Sets : (All) Aliases : Required : False Position : Named Default value : False Accept pipeline input : False Accept wildcard characters : False","title":"-RuleIncludeLocal"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-aliasreferencewarning","text":"Sets the option Execution.AliasReferenceWarning . The Execution.AliasReferenceWarning option determines if a warning is logged when alises are referenced. Type : Boolean Parameter Sets : (All) Aliases : ExecutionAliasReferenceWarning Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-AliasReferenceWarning"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-invariantculturewarning","text":"Sets the option Execution.InvariantCultureWarning . The Execution.InvariantCultureWarning option set if a warning is logged when invarient culture is detected. Type : Boolean Parameter Sets : (All) Aliases : ExecutionInvariantCultureWarning Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-InvariantCultureWarning"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-duplicateresourceid","text":"Sets the option Execution.DuplicateResourceId . The Execution.DuplicateResourceId option determines how to handle duplicate resources identifiers during execution. Type : ExecutionActionPreference Parameter Sets : (All) Aliases : ExecutionDuplicateResourceId Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-DuplicateResourceId"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-initialsessionstate","text":"Sets the option Execution.InitialSessionState . The Execution.InitialSessionState option determines how the initial session state for executing PowerShell code is created. Type : SessionState Parameter Sets : (All) Aliases : ExecutionInitialSessionState Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-InitialSessionState"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#commonparameters","text":"This cmdlet supports the common parameters: -Debug, -ErrorAction, -ErrorVariable, -InformationAction, -InformationVariable, -OutVariable, -OutBuffer, -PipelineVariable, -Verbose, -WarningAction, and -WarningVariable. For more information, see about_CommonParameters .","title":"CommonParameters"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#inputs","text":"","title":"INPUTS"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#outputs","text":"","title":"OUTPUTS"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#psruleconfigurationpsruleoption","text":"When you use the -PassThru switch, an options object is returned to the pipeline.","title":"PSRule.Configuration.PSRuleOption"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#notes","text":"","title":"Notes"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#related-links","text":"New-PSRuleOption","title":"RELATED LINKS"},{"location":"commands/PSRule/en-US/Test-PSRuleTarget/","text":"Test-PSRuleTarget # Pass or fail objects against matching rules. SYNTAX # Input (Default) # Test-PSRuleTarget [-Module <String[]>] [-Outcome <RuleOutcome>] [-Format <InputFormat>] [-Convention <String[]>] [[-Path] <String[]>] [-Name <String[]>] [-Tag <Hashtable>] -InputObject <PSObject> [-Option <PSRuleOption>] [-ObjectPath <String>] [-TargetType <String[]>] [-Culture <String>] [<CommonParameters>] InputPath # Test-PSRuleTarget -InputPath <String[]> [-Module <String[]>] [-Outcome <RuleOutcome>] [-Format <InputFormat>] [-Convention <String[]>] [[-Path] <String[]>] [-Name <String[]>] [-Tag <Hashtable>] [-Option <PSRuleOption>] [-ObjectPath <String>] [-TargetType <String[]>] [-Culture <String>] [<CommonParameters>] Description # Evaluate objects against matching rules and return an overall pass or fail for the object as $True (pass) or $False (fail). PSRule uses the following logic to determine overall pass or fail for an object: The object fails if: Any rules fail or error. Any rules are inconclusive. The object passes if: No matching rules were found. All rules pass. By default, objects that do match any rules are not returned in results. To return $True for these objects, use -Outcome All . Examples # Example 1 # @{ Name = 'Item 1' } | Test-PSRuleTarget ; Evaluate a simple hashtable on the pipeline against rules loaded from the current working path. PARAMETERS # -Path # One or more paths to search for rule definitions within. If the -Module parameter is used, rule definitions from the currently working path will not be included by default. Type : String[] Parameter Sets : (All) Aliases : p Required : False Position : 1 Default value : None Accept pipeline input : False Accept wildcard characters : False -Name # The name of a specific rule to evaluate. If this parameter is not specified all rules in search paths will be evaluated. Type : String[] Parameter Sets : (All) Aliases : n Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -Outcome # Filter output to only show pipeline objects with a specific outcome. Type : RuleOutcome Parameter Sets : (All) Aliases : Accepted values : Pass, Fail, Error, None, Processed, All Required : False Position : Named Default value : Pass, Fail, Error Accept pipeline input : False Accept wildcard characters : False -Tag # Only get rules with the specified tags set. If this parameter is not specified all rules in search paths will be returned. When more than one tag is used, all tags must match. Tags are not case sensitive. A tag value of * may be used to filter rules to any rule with the tag set, regardless of tag value. An array of tag values can be used to match a rule with either value. i.e. severity = important, critical matches rules with a category of either important or critical . Type : Hashtable Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -InputObject # The pipeline object to process rules for. Type : PSObject Parameter Sets : Input Aliases : TargetObject Required : True Position : Named Default value : None Accept pipeline input : True (ByValue) Accept wildcard characters : False -Option # Additional options that configure execution. A PSRuleOption can be created by using the New-PSRuleOption cmdlet. Alternatively, a hashtable or path to YAML file can be specified with options. For more information on PSRule options see about_PSRule_Options. Type : PSRuleOption Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -Format # Configures the input format for when a string is passed in as a target object. When the -InputObject parameter or pipeline input is used, strings are treated as plain text by default. Set this option to either Yaml , Json , Markdown , PowerShellData to have PSRule deserialize the object. When the -InputPath parameter is used with a file path or URL. If the Detect format is used, the file extension will be used to automatically detect the format. When -InputPath is not used, Detect is the same as None . When this option is set to File PSRule scans the path and subdirectories specified by -InputPath . Files are treated as objects instead of being deserialized. Additional, PSRule uses the file extension as the object type. When files have no extension the whole file name is used. See about_PSRule_Options for details. This parameter takes precedence over the Input.Format option if set. Type : InputFormat Parameter Sets : (All) Aliases : Accepted values : None, Yaml, Json, Markdown, PowerShellData, Repository, Detect Required : False Position : Named Default value : Detect Accept pipeline input : False Accept wildcard characters : False -Convention # Specifies conventions by name to execute in the pipeline when processing objects. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -Culture # Specifies the culture to use for rule documentation and messages. By default, the culture of PowerShell is used. This option does not affect the culture used for the PSRule engine, which always uses the culture of PowerShell. The PowerShell cmdlet Get-Culture shows the current culture of PowerShell. Type : String Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -ObjectPath # The name of a property to use instead of the pipeline object. If the property specified by ObjectPath is a collection or an array, then each item in evaluated separately. Type : String Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -TargetType # Filters input objects by TargetType. If specified, only objects with the specified TargetType are processed. Objects that do not match TargetType are ignored. If multiple values are specified, only one TargetType must match. This parameter is not case-sensitive. By default, all objects are processed. This parameter if set, overrides the Input.TargetType option. To change the field TargetType is bound to set the Binding.TargetType option. For details see the about_PSRule_Options help topic. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -Module # Search for rule definitions within a module. When specified without the -Path parameter, only rule definitions in the module will be discovered. When both -Path and -Module are specified, rule definitions from both are discovered. Type : String[] Parameter Sets : (All) Aliases : m Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -InputPath # Instead of processing objects from the pipeline, import objects file the specified file paths. Type : String[] Parameter Sets : InputPath Aliases : f Required : True Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False CommonParameters # This cmdlet supports the common parameters: -Debug, -ErrorAction, -ErrorVariable, -InformationAction, -InformationVariable, -OutVariable, -OutBuffer, -PipelineVariable, -Verbose, -WarningAction, and -WarningVariable. For more information, see about_CommonParameters . INPUTS # System.Management.Automation.PSObject # You can pipe any object to Test-PSRuleTarget . OUTPUTS # System.Boolean # Returns $True when the object passes and $False when the object fails. Notes # RELATED LINKS # Invoke-PSRule Assert-PSRule Get-PSRule","title":"Test-PSRuleTarget"},{"location":"commands/PSRule/en-US/Test-PSRuleTarget/#test-psruletarget","text":"Pass or fail objects against matching rules.","title":"Test-PSRuleTarget"},{"location":"commands/PSRule/en-US/Test-PSRuleTarget/#syntax","text":"","title":"SYNTAX"},{"location":"commands/PSRule/en-US/Test-PSRuleTarget/#input-default","text":"Test-PSRuleTarget [-Module <String[]>] [-Outcome <RuleOutcome>] [-Format <InputFormat>] [-Convention <String[]>] [[-Path] <String[]>] [-Name <String[]>] [-Tag <Hashtable>] -InputObject <PSObject> [-Option <PSRuleOption>] [-ObjectPath <String>] [-TargetType <String[]>] [-Culture <String>] [<CommonParameters>]","title":"Input (Default)"},{"location":"commands/PSRule/en-US/Test-PSRuleTarget/#inputpath","text":"Test-PSRuleTarget -InputPath <String[]> [-Module <String[]>] [-Outcome <RuleOutcome>] [-Format <InputFormat>] [-Convention <String[]>] [[-Path] <String[]>] [-Name <String[]>] [-Tag <Hashtable>] [-Option <PSRuleOption>] [-ObjectPath <String>] [-TargetType <String[]>] [-Culture <String>] [<CommonParameters>]","title":"InputPath"},{"location":"commands/PSRule/en-US/Test-PSRuleTarget/#description","text":"Evaluate objects against matching rules and return an overall pass or fail for the object as $True (pass) or $False (fail). PSRule uses the following logic to determine overall pass or fail for an object: The object fails if: Any rules fail or error. Any rules are inconclusive. The object passes if: No matching rules were found. All rules pass. By default, objects that do match any rules are not returned in results. To return $True for these objects, use -Outcome All .","title":"Description"},{"location":"commands/PSRule/en-US/Test-PSRuleTarget/#examples","text":"","title":"Examples"},{"location":"commands/PSRule/en-US/Test-PSRuleTarget/#example-1","text":"@{ Name = 'Item 1' } | Test-PSRuleTarget ; Evaluate a simple hashtable on the pipeline against rules loaded from the current working path.","title":"Example 1"},{"location":"commands/PSRule/en-US/Test-PSRuleTarget/#parameters","text":"","title":"PARAMETERS"},{"location":"commands/PSRule/en-US/Test-PSRuleTarget/#-path","text":"One or more paths to search for rule definitions within. If the -Module parameter is used, rule definitions from the currently working path will not be included by default. Type : String[] Parameter Sets : (All) Aliases : p Required : False Position : 1 Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Path"},{"location":"commands/PSRule/en-US/Test-PSRuleTarget/#-name","text":"The name of a specific rule to evaluate. If this parameter is not specified all rules in search paths will be evaluated. Type : String[] Parameter Sets : (All) Aliases : n Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Name"},{"location":"commands/PSRule/en-US/Test-PSRuleTarget/#-outcome","text":"Filter output to only show pipeline objects with a specific outcome. Type : RuleOutcome Parameter Sets : (All) Aliases : Accepted values : Pass, Fail, Error, None, Processed, All Required : False Position : Named Default value : Pass, Fail, Error Accept pipeline input : False Accept wildcard characters : False","title":"-Outcome"},{"location":"commands/PSRule/en-US/Test-PSRuleTarget/#-tag","text":"Only get rules with the specified tags set. If this parameter is not specified all rules in search paths will be returned. When more than one tag is used, all tags must match. Tags are not case sensitive. A tag value of * may be used to filter rules to any rule with the tag set, regardless of tag value. An array of tag values can be used to match a rule with either value. i.e. severity = important, critical matches rules with a category of either important or critical . Type : Hashtable Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Tag"},{"location":"commands/PSRule/en-US/Test-PSRuleTarget/#-inputobject","text":"The pipeline object to process rules for. Type : PSObject Parameter Sets : Input Aliases : TargetObject Required : True Position : Named Default value : None Accept pipeline input : True (ByValue) Accept wildcard characters : False","title":"-InputObject"},{"location":"commands/PSRule/en-US/Test-PSRuleTarget/#-option","text":"Additional options that configure execution. A PSRuleOption can be created by using the New-PSRuleOption cmdlet. Alternatively, a hashtable or path to YAML file can be specified with options. For more information on PSRule options see about_PSRule_Options. Type : PSRuleOption Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Option"},{"location":"commands/PSRule/en-US/Test-PSRuleTarget/#-format","text":"Configures the input format for when a string is passed in as a target object. When the -InputObject parameter or pipeline input is used, strings are treated as plain text by default. Set this option to either Yaml , Json , Markdown , PowerShellData to have PSRule deserialize the object. When the -InputPath parameter is used with a file path or URL. If the Detect format is used, the file extension will be used to automatically detect the format. When -InputPath is not used, Detect is the same as None . When this option is set to File PSRule scans the path and subdirectories specified by -InputPath . Files are treated as objects instead of being deserialized. Additional, PSRule uses the file extension as the object type. When files have no extension the whole file name is used. See about_PSRule_Options for details. This parameter takes precedence over the Input.Format option if set. Type : InputFormat Parameter Sets : (All) Aliases : Accepted values : None, Yaml, Json, Markdown, PowerShellData, Repository, Detect Required : False Position : Named Default value : Detect Accept pipeline input : False Accept wildcard characters : False","title":"-Format"},{"location":"commands/PSRule/en-US/Test-PSRuleTarget/#-convention","text":"Specifies conventions by name to execute in the pipeline when processing objects. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Convention"},{"location":"commands/PSRule/en-US/Test-PSRuleTarget/#-culture","text":"Specifies the culture to use for rule documentation and messages. By default, the culture of PowerShell is used. This option does not affect the culture used for the PSRule engine, which always uses the culture of PowerShell. The PowerShell cmdlet Get-Culture shows the current culture of PowerShell. Type : String Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Culture"},{"location":"commands/PSRule/en-US/Test-PSRuleTarget/#-objectpath","text":"The name of a property to use instead of the pipeline object. If the property specified by ObjectPath is a collection or an array, then each item in evaluated separately. Type : String Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-ObjectPath"},{"location":"commands/PSRule/en-US/Test-PSRuleTarget/#-targettype","text":"Filters input objects by TargetType. If specified, only objects with the specified TargetType are processed. Objects that do not match TargetType are ignored. If multiple values are specified, only one TargetType must match. This parameter is not case-sensitive. By default, all objects are processed. This parameter if set, overrides the Input.TargetType option. To change the field TargetType is bound to set the Binding.TargetType option. For details see the about_PSRule_Options help topic. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-TargetType"},{"location":"commands/PSRule/en-US/Test-PSRuleTarget/#-module","text":"Search for rule definitions within a module. When specified without the -Path parameter, only rule definitions in the module will be discovered. When both -Path and -Module are specified, rule definitions from both are discovered. Type : String[] Parameter Sets : (All) Aliases : m Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Module"},{"location":"commands/PSRule/en-US/Test-PSRuleTarget/#-inputpath","text":"Instead of processing objects from the pipeline, import objects file the specified file paths. Type : String[] Parameter Sets : InputPath Aliases : f Required : True Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-InputPath"},{"location":"commands/PSRule/en-US/Test-PSRuleTarget/#commonparameters","text":"This cmdlet supports the common parameters: -Debug, -ErrorAction, -ErrorVariable, -InformationAction, -InformationVariable, -OutVariable, -OutBuffer, -PipelineVariable, -Verbose, -WarningAction, and -WarningVariable. For more information, see about_CommonParameters .","title":"CommonParameters"},{"location":"commands/PSRule/en-US/Test-PSRuleTarget/#inputs","text":"","title":"INPUTS"},{"location":"commands/PSRule/en-US/Test-PSRuleTarget/#systemmanagementautomationpsobject","text":"You can pipe any object to Test-PSRuleTarget .","title":"System.Management.Automation.PSObject"},{"location":"commands/PSRule/en-US/Test-PSRuleTarget/#outputs","text":"","title":"OUTPUTS"},{"location":"commands/PSRule/en-US/Test-PSRuleTarget/#systemboolean","text":"Returns $True when the object passes and $False when the object fails.","title":"System.Boolean"},{"location":"commands/PSRule/en-US/Test-PSRuleTarget/#notes","text":"","title":"Notes"},{"location":"commands/PSRule/en-US/Test-PSRuleTarget/#related-links","text":"Invoke-PSRule Assert-PSRule Get-PSRule","title":"RELATED LINKS"},{"location":"concepts/grouping-rules/","text":"Grouping rules # Abstract Labels are additional metadata that can be used to classify rules. Together with tags they can be used to group or filter rules. Using labels # When defining a rule you can specify labels to classify or link rules using a framework or standard. A single rule can be can linked to multiple labels. For example: The Azure Well-Architected Framework (WAF) defines pillars such as Security and Reliability . The CIS Benchmarks define a number of control IDs such as 3.12 and 13.4 . YAML JSON PowerShell To specify labels in YAML, use the labels property: --- # Synopsis: A rule with labels defined. apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : WithLabels labels : Azure.WAF/pillar : Security Azure.ASB.v3/control : [ 'ID-1' , 'ID-2' ] spec : { } To specify labels in JSON, use the labels property: { // Synopsis: A rule with labels defined. \"apiVersion\" : \"github.com/microsoft/PSRule/v1\" , \"kind\" : \"Rule\" , \"metadata\" : { \"name\" : \"WithLabels\" , \"labels\" : { \"Azure.WAF/pillar\" : \"Security\" , \"Azure.ASB.v3/control\" : [ \"ID-1\" , \"ID-2\" ] } }, \"spec\" : { } } To specify labels in PowerShell, use the -Labels parameter: # Synopsis: A rule with labels defined. Rule 'WithLabels' -Labels @{ 'Azure.WAF/pillar' = 'Security' ; 'Azure.ASB.v3/control' = @( 'ID-1' , 'ID-2' ) } { # Define conditions here } Filtering with labels # A reason for assigning labels to rules is to perform filtering of rules to a specific subset. This can be accomplished using baselines and the spec.rule.labels property. For example: --- # Synopsis: A baseline which returns only security rules. apiVersion : github.com/microsoft/PSRule/v1 kind : Baseline metadata : name : TestBaseline6 spec : rule : labels : Azure.WAF/pillar : [ 'Security' ] --- # Synopsis: A baseline which returns any rules that are classified to Azure.WAF/pillar. apiVersion : github.com/microsoft/PSRule/v1 kind : Baseline metadata : name : TestBaseline6 spec : rule : labels : Azure.WAF/pillar : '*'","title":"Grouping rules"},{"location":"concepts/grouping-rules/#grouping-rules","text":"Abstract Labels are additional metadata that can be used to classify rules. Together with tags they can be used to group or filter rules.","title":"Grouping rules"},{"location":"concepts/grouping-rules/#using-labels","text":"When defining a rule you can specify labels to classify or link rules using a framework or standard. A single rule can be can linked to multiple labels. For example: The Azure Well-Architected Framework (WAF) defines pillars such as Security and Reliability . The CIS Benchmarks define a number of control IDs such as 3.12 and 13.4 . YAML JSON PowerShell To specify labels in YAML, use the labels property: --- # Synopsis: A rule with labels defined. apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : WithLabels labels : Azure.WAF/pillar : Security Azure.ASB.v3/control : [ 'ID-1' , 'ID-2' ] spec : { } To specify labels in JSON, use the labels property: { // Synopsis: A rule with labels defined. \"apiVersion\" : \"github.com/microsoft/PSRule/v1\" , \"kind\" : \"Rule\" , \"metadata\" : { \"name\" : \"WithLabels\" , \"labels\" : { \"Azure.WAF/pillar\" : \"Security\" , \"Azure.ASB.v3/control\" : [ \"ID-1\" , \"ID-2\" ] } }, \"spec\" : { } } To specify labels in PowerShell, use the -Labels parameter: # Synopsis: A rule with labels defined. Rule 'WithLabels' -Labels @{ 'Azure.WAF/pillar' = 'Security' ; 'Azure.ASB.v3/control' = @( 'ID-1' , 'ID-2' ) } { # Define conditions here }","title":"Using labels"},{"location":"concepts/grouping-rules/#filtering-with-labels","text":"A reason for assigning labels to rules is to perform filtering of rules to a specific subset. This can be accomplished using baselines and the spec.rule.labels property. For example: --- # Synopsis: A baseline which returns only security rules. apiVersion : github.com/microsoft/PSRule/v1 kind : Baseline metadata : name : TestBaseline6 spec : rule : labels : Azure.WAF/pillar : [ 'Security' ] --- # Synopsis: A baseline which returns any rules that are classified to Azure.WAF/pillar. apiVersion : github.com/microsoft/PSRule/v1 kind : Baseline metadata : name : TestBaseline6 spec : rule : labels : Azure.WAF/pillar : '*'","title":"Filtering with labels"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/","tags":["language"],"text":"Assertion methods # Describes the assertion helper that can be used within PSRule rule definitions. Description # PSRule includes an assertion helper exposed as a built-in variable $Assert . The $Assert object provides a consistent set of methods to evaluate objects. Each $Assert method returns an AssertResult object that contains the result of the assertion. The following built-in assertion methods are provided: Contains - The field value must contain at least one of the strings. Count - The field value must contain the specified number of items. EndsWith - The field value must match at least one suffix. FileHeader - The file must contain a comment header. FilePath - The file path must exist. Greater - The field value must be greater. GreaterOrEqual - The field value must be greater or equal to. HasDefaultValue - The object should not have the field or the field value is set to the default value. HasField - The object must have any of the specified fields. HasFields - The object must have all of the specified fields. HasFieldValue - The object must have the specified field and that field is not empty. HasJsonSchema - The object must reference a JSON schema with the $schema field. In - The field value must be included in the set. IsArray - The field value must be an array. IsBoolean - The field value must be a boolean. IsDateTime - The field value must be a DateTime. IsInteger - The field value must be an integer. IsLower - The field value must include only lowercase characters. IsNumeric - The field value must be a numeric type. IsString - The field value must be a string. IsUpper - The field value must include only uppercase characters. JsonSchema - The object must validate successfully against a JSON schema. Less - The field value must be less. LessOrEqual - The field value must be less or equal to. Like - The value must match any of the specified wildcard values. Match - The field value matches a regular expression pattern. NotContains - The value must not contain any of the specified strings. NotCount - The field value must not contain the specified number of items. NotEndsWith - The value must not end with any of the specified strings. NotHasField - The object must not have any of the specified fields. NotIn - The field value must not be included in the set. NotLike - The value must not match any of the specified wildcard values. NotMatch - The field value does not match a regular expression pattern. NotNull - The field value must not be null. NotStartsWith - The value must not start with any of the specified strings. NotWithinPath - The field must not be within the specified path. Null - The field value must not exist or be null. NullOrEmpty - The object must not have the specified field or it must be empty. TypeOf - The field value must be of the specified type. SetOf - The field value must match a set of specified values. StartsWith - The field value must match at least one prefix. Subset - The field value must include a set of specified values. Version - The field value must be a semantic version string. WithinPath - The field value must be within the specified path. The $Assert variable can only be used within a rule definition block or script pre-conditions. Using assertion methods # An assertion method can be used like other methods in PowerShell. i.e. $Assert.methodName(parameters) . Assertion methods use the following standard pattern: The first parameter is always the input object of type PSObject , additional parameters can be included based on the functionality required by the method. In many cases the input object will be $TargetObject , however assertion methods must not assume that $TargetObject will be used. Assertion methods must accept a $Null input object. Assertion methods return the AssertResult object that is interpreted by the rule pipeline. Some assertion methods may overlap or provide similar functionality to built-in keywords. Where you have the choice, use built-in keywords. Use assertion methods for advanced cases or increased flexibility. In the following example, Assert.HasFieldValue asserts that $TargetObject should have a field named Type with a non-empty value. Rule 'Assert.HasTypeField' { $Assert . HasFieldValue ( $TargetObject , 'Type' ) } To find perform multiple assertions use. Rule 'Assert.HasRequiredFields' { $Assert . HasFieldValue ( $TargetObject , 'Name' ) $Assert . HasFieldValue ( $TargetObject , 'Type' ) $Assert . HasFieldValue ( $TargetObject , 'Value' ) } Field names # Many of the built-in assertion methods accept an object path or field name. An object path is an expression that traverses object properties, keys or indexes of the input object . The syntax for an object path is inspired by JSONPath which is current an IETF Internet-Draft. The object path expression can contain: Property names for PSObjects or .NET objects. Keys for hash table or dictionaries. Indexes for arrays or collections. Queries that filter items from array or collection properties. For example: . , or $ refers to input object itself. Name , .Name , or $.Name refers to the name member of the input object . Properties.enabled refers to the enabled member under the Properties member. Alternatively this can also be written as Properties['enabled'] . Tags.env refers to the env member under a hash table property of the input object . Tags+env refers to the env member using a case-sensitive match. Properties.securityRules[0].name references to the name member of the first security rule. Properties.securityRules[-1].name references to the name member of the last security rule. Properties.securityRules[?@direction == 'Inbound'].name returns the name of any inbound rules. This will return an array of security rule names. Notable differences between object paths and JSONPath are: Member names (properties and keys) are case-insensitive by default. To perform a case-sensitive match of a member name use a plus selector + in front of the member name. Some assertions such as HasField provide an option to match case when matching member names. When this is used, the plus selector perform an case-insensitive match. Quoted member names with single or double quotes are supported with dot selector. i.e. Properties.'spaced name' is valid. Member names with a dash - are supported without being quoted. However member names can not start or end with a dash. i.e. Properties.dashed-name and Properties.'-dashed-name' are valid. Contains # The Contains assertion method checks the field value contains the specified string. Optionally a case-sensitive compare can be used, however case is ignored by default. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. text - A string or an array of strings to compare the field value with. Only one string must match. When an empty array of strings is specified or text is an empty string, Contains always passes. caseSensitive (optional) - Use a case sensitive compare of the field value. Case is ignored by default. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The parameter 'text' is null. The field '{0}' does not exist. The field value '{0}' is not a string. The field '{0}' does not contain '{1}'. Examples: Rule 'Contains' { $Assert . Contains ( $TargetObject , 'ResourceGroupName' , 'prod' ) $Assert . Contains ( $TargetObject , 'Name' , @( 'prod' , 'test' ), $True ) } Count # The Count assertion method checks the field value contains the specified number of items. The field value must be an array or collection. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. count - The number of items that the field value must contain. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' does not exist. The field '{0}' is not enumerable. The field '{0}' has '{1}' items instead of '{2}'. Examples: Rule 'Count' { $Assert . Count ( $TargetObject , 'items' , 2 ) } EndsWith # The EndsWith assertion method checks the field value ends with the specified suffix. Optionally a case-sensitive compare can be used, however case is ignored by default. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. suffix - A suffix or an array of suffixes to compare the field value with. Only one suffix must match. When an empty array of suffixes is specified or suffix is an empty string, EndsWith always passes. caseSensitive (optional) - Use a case sensitive compare of the field value. Case is ignored by default. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The parameter 'suffix' is null. The field '{0}' does not exist. The field value '{0}' is not a string. The field '{0}' does not end with '{1}'. Examples: Rule 'EndsWith' { $Assert . EndsWith ( $TargetObject , 'ResourceGroupName' , 'eus' ) $Assert . EndsWith ( $TargetObject , 'Name' , @( 'db' , 'web' ), $True ) } FileHeader # The FileHeader assertion method checks a file for a comment header. When comparing the file header, the format of line comments are automatically detected by file extension. Single line comments are supported. Multi-line comments are not supported. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field containing a valid file path. header - One or more lines of a header to compare with file contents. prefix (optional) - An optional comment prefix for each line. By default a comment prefix will automatically detected based on file extension. When set, detection by file extension is skipped. Prefix detection for line comments is supported with the following file extensions: .bicep , .cs , .csx .ts , .js , .jsx , .fs , .go , .groovy , .php , .cpp , .h , .java , .json , .jsonc , .scala , Jenkinsfile - Use a prefix of ( // ). .ps1 , .psd1 , .psm1 , .yaml , .yml , .r , .py , .sh , .tf , .tfvars , .gitignore , .pl , .rb , Dockerfile - Use a prefix of ( # ). .sql , .lau - Use a prefix of ( -- ). .bat , .cmd - Use a prefix of ( :: ). Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' does not exist. The field value '{0}' is not a string. The file '{0}' does not exist. The header was not set. Examples: Rule 'FileHeader' { $Assert . FileHeader ( $TargetObject , 'FullName' , @( 'Copyright (c) Microsoft Corporation.' 'Licensed under the MIT License.' )); } FilePath # The FilePath assertion method checks the file exists. Checks use file system case-sensitivity rules. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field containing a file path. suffix (optional) - Additional file path suffixes to append. When specified each suffix is combined with the file path. Only one full file path must be a valid file for the assertion method to pass. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' does not exist. The field value '{0}' is not a string. The file '{0}' does not exist. Examples: Rule 'FilePath' { $Assert . FilePath ( $TargetObject , 'FullName' , @( 'CHANGELOG.md' )); $Assert . FilePath ( $TargetObject , 'FullName' , @( 'LICENSE' , 'LICENSE.txt' )); $Assert . FilePath ( $TargetObject , 'FullName' , @( 'CODE_OF_CONDUCT.md' )); $Assert . FilePath ( $TargetObject , 'FullName' , @( 'CONTRIBUTING.md' )); $Assert . FilePath ( $TargetObject , 'FullName' , @( 'SECURITY.md' )); $Assert . FilePath ( $TargetObject , 'FullName' , @( 'README.md' )); $Assert . FilePath ( $TargetObject , 'FullName' , @( '.github/CODEOWNERS' )); $Assert . FilePath ( $TargetObject , 'FullName' , @( '.github/PULL_REQUEST_TEMPLATE.md' )); } Greater # The Greater assertion method checks the field value is greater than the specified value. The field value can either be an integer, float, array, or string. When the field value is: An integer or float, a numerical comparison is used. An array, the number of elements is compared. A string, the length of the string is compared. A DateTime, the number of days from the current time is compared. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. value - A integer to compare the field value against. convert (optional) - Convert numerical strings and use a numerical comparison instead of using string length. By default the string length is compared. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' does not exist. The value '{0}' was not > '{1}'. The field value '{0}' can not be compared with '{1}'. Examples: Rule 'Greater' { $Assert . Greater ( $TargetObject , 'value' , 3 ) } GreaterOrEqual # The GreaterOrEqual assertion method checks the field value is greater or equal to the specified value. The field value can either be an integer, float, array, or string. When the field value is: An integer or float, a numerical comparison is used. An array, the number of elements is compared. A string, the length of the string is compared. A DateTime, the number of days from the current time is compared. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. value - A integer to compare the field value against. convert (optional) - Convert numerical strings and use a numerical comparison instead of using string length. By default the string length is compared. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' does not exist. The value '{0}' was not >= '{1}'. The field value '{0}' can not be compared with '{1}'. Examples: Rule 'GreaterOrEqual' { $Assert . GreaterOrEqual ( $TargetObject , 'value' , 3 ) } HasDefaultValue # The HasDefaultValue assertion method check that the field does not exist or the field value is set to the default value. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. defaultValue - The expected value if the field exists. This assertion will pass if: The field does not exist. The field value is set to defaultValue . This assertion will fail if: The field value is set to a value different from defaultValue . Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' is set to '{1}'. Examples: Rule 'HasDefaultValue' { $Assert . HasDefaultValue ( $TargetObject , 'Properties.osProfile.linuxConfiguration.provisionVMAgent' , $True ) } HasField # The HasField assertion method checks the object has any of the specified fields. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of one or more fields to check. By default, a case insensitive compare is used. If more than one field is specified, only one must exist. caseSensitive (optional) - Use a case sensitive compare of the field name. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. Does not exist. Examples: Rule 'HasField' { $Assert . HasField ( $TargetObject , 'Name' ) $Assert . HasField ( $TargetObject , 'tag.Environment' , $True ) $Assert . HasField ( $TargetObject , @( 'tag.Environment' , 'tag.Env' ), $True ) } HasFields # The HasFields assertion method checks the object has all of the specified fields. The following parameters are accepted: inputObject - The object being checked for the specified fields. field - The name of one or more fields to check. By default, a case insensitive compare is used. If more than one field is specified, all fields must exist. caseSensitive (optional) - Use a case sensitive compare of the field name. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' does not exist. Examples: Rule 'HasFields' { $Assert . HasFields ( $TargetObject , 'Name' ) $Assert . HasFields ( $TargetObject , 'tag.Environment' , $True ) $Assert . HasFields ( $TargetObject , @( 'tag.Environment' , 'tag.Env' ), $True ) } HasFieldValue # The HasFieldValue assertion method checks the field value of the object is not empty. A field value is empty if any of the following are true: The field does not exist. The field value is $Null . The field value is an empty array or collection. The field value is an empty string '' . The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. expectedValue (optional) - Check that the field value is set to a specific value. To check $Null use NullOrEmpty instead. If expectedValue is $Null the field value will not be compared. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. Does not exist. Is null or empty. Is set to '{0}'. Examples: Rule 'HasFieldValue' { $Assert . HasFieldValue ( $TargetObject , 'Name' ) $Assert . HasFieldValue ( $TargetObject , 'tag.Environment' , 'production' ) } HasJsonSchema # The HasJsonSchema assertion method determines if the input object has a $schema property defined. If the $schema property is defined, it must not be empty and match one of the supplied schemas. If a trailing # is specified it is ignored from the $schema property and uri parameter below. The following parameters are accepted: inputObject - The object being compared. uri - Optional. When specified, the object being compared must have a $schema property set to one of the specified schemas. ignoreScheme - Optional. By default, ignoreScheme is $False . When $True , the schema will match if http or https is specified. Reasons include: The parameter 'inputObject' is null. The field '$schema' does not exist. The field value '$schema' is not a string. The value of '$schema' is null or empty. None of the specified schemas match '{0}'. Examples: Rule 'HasFieldValue' { $Assert . HasJsonSchema ( $TargetObject ) $Assert . HasJsonSchema ( $TargetObject , \"http://json-schema.org/draft-07/schema`#\" ) $Assert . HasJsonSchema ( $TargetObject , \"https://json-schema.org/draft-07/schema\" , $True ) } JsonSchema # The JsonSchema assertion method compares the input object against a defined JSON schema. The following parameters are accepted: inputObject - The object being compared against the JSON schema. uri - A URL or file path to a JSON schema file formatted as UTF-8. Either a file path or URL can be used to specify the location of the schema file. Reasons include: The parameter 'inputObject' is null. The parameter 'uri' is null or empty. The JSON schema '{0}' could not be found. Failed schema validation on {0}. {1} Examples: Rule 'JsonSchema' { $Assert . JsonSchema ( $TargetObject , 'tests/PSRule.Tests/FromFile.Json.schema.json' ) } In # The In assertion method checks the field value is included in a set of values. The field value can either be an integer, float, array, or string. When the field value is an array, only one item must be included in the set. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. values - An array of values that the field value is compared against. When an empty array is specified, In will always fail. caseSensitive (optional) - Use a case sensitive compare of the field value. Case is ignored by default. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The parameter 'values' is null. The field '{0}' does not exist. The field value '{0}' was not included in the set. Examples: Rule 'In' { $Assert . In ( $TargetObject , 'Sku.tier' , @( 'PremiumV2' , 'Premium' , 'Standard' )) $Assert . In ( $TargetObject , 'Sku.tier' , @( 'PremiumV2' , 'Premium' , 'Standard' ), $True ) } IsArray # The IsArray assertion method checks the field value is an array type. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' does not exist. The field value '{0}' is null. The field value '{1}' of type {0} is not [array]. Examples: Rule 'IsArray' { # Require Value1 to be an array $Assert . IsArray ( $TargetObject , 'Value1' ) } IsBoolean # The IsBoolean assertion method checks the field value is a boolean type. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. convert (optional) - Try to convert strings. By default strings are not converted. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' does not exist. The field value '{0}' is null. The value '{0}' is not a boolean. Examples: Rule 'IsBoolean' { # Require Value1 to be a boolean $Assert . IsBoolean ( $TargetObject , 'Value1' ) # Require Value1 to be a boolean or a boolean string $Assert . IsBoolean ( $TargetObject , 'Value1' , $True ) } IsDateTime # The IsDateTime assertion method checks the field value is a DateTime type. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. convert (optional) - Try to convert strings. By default strings are not converted. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' does not exist. The field value '{0}' is null. The value '{0}' is not a date. Examples: Rule 'IsDateTime' { # Require Value1 to be a DateTime $Assert . IsDateTime ( $TargetObject , 'Value1' ) # Require Value1 to be a DateTime or a DateTime string $Assert . IsDateTime ( $TargetObject , 'Value1' , $True ) } IsInteger # The IsInteger assertion method checks the field value is a integer type. The following types are considered integer types int , long , byte . The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. convert (optional) - Try to convert strings. By default strings are not converted. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' does not exist. The field value '{0}' is null. The value '{0}' is not an integer. Examples: Rule 'IsInteger' { # Require Value1 to be an integer $Assert . IsInteger ( $TargetObject , 'Value1' ) # Require Value1 to be an integer or a integer string $Assert . IsInteger ( $TargetObject , 'Value1' , $True ) } IsLower # The IsLower assertion method checks the field value uses only lowercase characters. Non-letter characters are ignored by default and will pass. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. requireLetters (optional) - Require each character to be lowercase letters only. Non-letter characters are ignored by default. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' does not exist. The field value '{0}' is not a string. The value '{0}' does not contain only lowercase characters. The value '{0}' does not contain only letters. Examples: Rule 'IsLower' { # Require Name to be lowercase $Assert . IsLower ( $TargetObject , 'Name' ) # Require Name to only contain lowercase letters $Assert . IsLower ( $TargetObject , 'Name' , $True ) } IsNumeric # The IsNumeric assertion method checks the field value is a numeric type. The following types are considered numeric types int , long , float , byte , double . The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. convert (optional) - Try to convert numerical strings. By default strings are not converted. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' does not exist. The field value '{0}' is null. The value '{0}' is not numeric. Examples: Rule 'IsNumeric' { # Require Value1 to be numeric $Assert . IsNumeric ( $TargetObject , 'Value1' ) # Require Value1 to be numeric or a numerical string $Assert . IsNumeric ( $TargetObject , 'Value1' , $True ) } IsString # The IsString assertion method checks the field value is a string type. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' does not exist. The field value '{0}' is null. The value '{0}' is not a string. Examples: Rule 'IsString' { # Require Value1 to be a string $Assert . IsString ( $TargetObject , 'Value1' ) } IsUpper # The IsUpper assertion method checks the field value uses only uppercase characters. Non-letter characters are ignored by default and will pass. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. requireLetters (optional) - Require each character to be uppercase letters only. Non-letter characters are ignored by default. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' does not exist. The field value '{0}' is not a string. The value '{0}' does not contain only uppercase characters. The value '{0}' does not contain only letters. Examples: Rule 'IsUpper' { # Require Name to be uppercase $Assert . IsUpper ( $TargetObject , 'Name' ) # Require Name to only contain uppercase letters $Assert . IsUpper ( $TargetObject , 'Name' , $True ) } Less # The Less assertion method checks the field value is less than the specified value. The field value can either be an integer, float, array, or string. When the field value is: An integer or float, a numerical comparison is used. An array, the number of elements is compared. A string, the length of the string is compared. A DateTime, the number of days from the current time is compared. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. value - A integer to compare the field value against. convert (optional) - Convert numerical strings and use a numerical comparison instead of using string length. By default the string length is compared. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' does not exist. The value '{0}' was not < '{1}'. The field value '{0}' can not be compared with '{1}'. Examples: Rule 'Less' { $Assert . Less ( $TargetObject , 'value' , 3 ) } LessOrEqual # The LessOrEqual assertion method checks the field value is less or equal to the specified value. The field value can either be an integer, float, array, or string. When the field value is: An integer or float, a numerical comparison is used. An array, the number of elements is compared. A string, the length of the string is compared. A DateTime, the number of days from the current time is compared. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. value - A integer to compare the field value against. convert (optional) - Convert numerical strings and use a numerical comparison instead of using string length. By default the string length is compared. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' does not exist. The value '{0}' was not <= '{1}'. The field value '{0}' can not be compared with '{1}'. Examples: Rule 'LessOrEqual' { $Assert . LessOrEqual ( $TargetObject , 'value' , 3 ) } Like # The Like assertion method checks the field value matches a specified pattern. Optionally a case-sensitive compare can be used, however case is ignored by default. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. pattern - A pattern or an array of patterns to compare the field value with. Only one pattern must match. When an empty array of patterns is specified, Like always passes. caseSensitive (optional) - Use a case sensitive compare of the field value. Case is ignored by default. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The parameter 'prefix' is null. The field '{0}' does not exist. The field value '{0}' is not a string. The value '{0}' is not like '{1}'. Examples: Rule 'Like' { $Assert . Like ( $TargetObject , 'ResourceGroupName' , 'rg-*' ) $Assert . Like ( $TargetObject , 'Name' , @( 'st*' , 'diag*' ), $True ) } Match # The Match assertion method checks the field value matches a regular expression pattern. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. pattern - A regular expression pattern to match. caseSensitive (optional) - Use a case sensitive compare of the field value. Case is ignored by default. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' does not exist. The field value '{0}' is not a string. The field value '{0}' does not match the pattern '{1}'. Examples: Rule 'Match' { $Assert . Match ( $TargetObject , 'value' , '^[a-z]*$' ) $Assert . Match ( $TargetObject , 'value' , '^[a-z]*$' , $True ) } NotContains # The NotContains assertion method checks the field value contains the specified string. This condition fails when any of the specified sub-strings are found. Optionally a case-sensitive compare can be used, however case is ignored by default. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. text - A string or an array of strings to compare the field value with. When an empty array of strings is specified or text is an empty string, NotContains always passes. caseSensitive (optional) - Use a case sensitive compare of the field value. Case is ignored by default. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The parameter 'text' is null. The field '{0}' does not exist. The value '{0}' contains '{1}'. Examples: Rule 'NotContains' { $Assert . NotContains ( $TargetObject , 'ResourceGroupName' , 'prod' ) $Assert . NotContains ( $TargetObject , 'Name' , @( 'prod' , 'test' ), $True ) } NotCount # The NotCount assertion method checks the field value does not contain the specified number of items. The field value must be an array or collection. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. count - The number of items that the field value must contain. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' does not exist. The field '{0}' is not enumerable. The field '{0}' has '{1}' items instead of '{2}'. Examples: Rule 'NotCount' { $Assert . NotCount ( $TargetObject , 'items' , 2 ) } NotEndsWith # The NotEndsWith assertion method checks the field value ends with the specified suffix. This condition fails when any of the specified sub-strings are found at the end of the operand. Optionally a case-sensitive compare can be used, however case is ignored by default. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. suffix - A suffix or an array of suffixes to compare the field value with. When an empty array of suffixes is specified or suffix is an empty string, NotEndsWith always passes. caseSensitive (optional) - Use a case sensitive compare of the field value. Case is ignored by default. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The parameter 'suffix' is null. The field '{0}' does not exist. The value '{0}' ends with '{1}'. Examples: Rule 'NotEndsWith' { $Assert . NotEndsWith ( $TargetObject , 'ResourceGroupName' , 'eus' ) $Assert . NotEndsWith ( $TargetObject , 'Name' , @( 'db' , 'web' ), $True ) } NotHasField # The NotHasField assertion method checks the object does not have any of the specified fields. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of one or more fields to check. By default, a case insensitive compare is used. If more than one field is specified, all must not exist. caseSensitive (optional) - Use a case sensitive compare of the field name. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' exists. Examples: Rule 'NotHasField' { $Assert . NotHasField ( $TargetObject , 'Name' ) $Assert . NotHasField ( $TargetObject , 'tag.Environment' , $True ) $Assert . NotHasField ( $TargetObject , @( 'tag.Environment' , 'tag.Env' ), $True ) } NotIn # The NotIn assertion method checks the field value is not in a set of values. The field value can either be an integer, array, float, or string. When the field value is an array, none of the items must be included in the set. If the field does not exist at all, it is not in the set and passes. To check the field exists combine this assertion method with HasFieldValue . The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. values - An array values that the field value is compared against. When an empty array is specified, NotIn will always pass. caseSensitive (optional) - Use a case sensitive compare of the field value. Case is ignored by default. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The parameter 'values' is null. The field value '{0}' was in the set. Examples: Rule 'In' { $Assert . NotIn ( $TargetObject , 'Sku.tier' , @( 'Free' , 'Shared' , 'Basic' )) $Assert . NotIn ( $TargetObject , 'Sku.tier' , @( 'Free' , 'Shared' , 'Basic' ), $True ) } NotLike # The NotLike assertion method checks the field value matches a specified pattern. This condition fails when any of the specified patterns match the field value. Optionally a case-sensitive compare can be used, however case is ignored by default. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. pattern - A pattern or an array of patterns to compare the field value with. When an empty array of pattens is specified, NotLike always passes. caseSensitive (optional) - Use a case sensitive compare of the field value. Case is ignored by default. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The parameter 'prefix' is null. The field '{0}' does not exist. The value '{0}' is like '{1}' Examples: Rule 'NotLike' { $Assert . NotLike ( $TargetObject , 'ResourceGroupName' , 'rg-*' ) $Assert . NotLike ( $TargetObject , 'Name' , @( 'st*' , 'diag*' ), $True ) } NotMatch # The NotMatch assertion method checks the field value does not match a regular expression pattern. If the field does not exist at all, it does not match and passes. To check the field exists combine this assertion method with HasFieldValue . The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. pattern - A regular expression pattern to match. caseSensitive (optional) - Use a case sensitive compare of the field value. Case is ignored by default. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field value '{0}' is not a string. The field value '{0}' matches the pattern '{1}'. Examples: Rule 'NotMatch' { $Assert . NotMatch ( $TargetObject , 'value' , '^[a-z]*$' ) $Assert . NotMatch ( $TargetObject , 'value' , '^[a-z]*$' , $True ) } NotNull # The NotNull assertion method checks the field value of the object is not null. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' does not exist. The field value '{0}' is null. Examples: Rule 'NotNull' { $Assert . NotNull ( $TargetObject , 'Name' ) $Assert . NotNull ( $TargetObject , 'tag.Environment' ) } NotStartsWith # The NotStartsWith assertion method checks the field value starts with the specified prefix. This condition fails when any of the specified sub-strings are found at the start of the operand. Optionally a case-sensitive compare can be used, however case is ignored by default. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. prefix - A prefix or an array of prefixes to compare the field value with. When an empty array of prefixes is specified or prefix is an empty string, NotStartsWith always passes. caseSensitive (optional) - Use a case sensitive compare of the field value. Case is ignored by default. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The parameter 'prefix' is null. The field '{0}' does not exist. The value '{0}' starts with '{1}'. Examples: Rule 'NotStartsWith' { $Assert . NotStartsWith ( $TargetObject , 'ResourceGroupName' , 'rg-' ) $Assert . NotStartsWith ( $TargetObject , 'Name' , @( 'st' , 'diag' ), $True ) } NotWithinPath # The NotWithinPath assertion method checks the file is not within a specified path. Checks use file system case-sensitivity rules by default. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field containing a file path. When the field is InputFileInfo or FileInfo , PSRule will automatically resolve the file path. path - An array of one or more directory paths to check. Only one path must match. caseSensitive (optional) - Determines if case-sensitive path matching is used. This can be set to $True or $False . When not set or $Null , the case-sensitivity rules of the working path file system will be used. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The parameter 'path' is null or empty. The field '{0}' does not exist. The file '{0}' is within the path '{1}'. Examples: Rule 'NotWithinPath' { # The file must not be within either policy/ or security/ sub-directories. $Assert . NotWithinPath ( $TargetObject , 'FullName' , @( 'policy/' , 'security/' )); } Null # The Null assertion method checks the field value of the object is null. A field value is null if any of the following are true: The field does not exist. The field value is $Null . The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field value '{0}' is not null. Examples: Rule 'Null' { $Assert . Null ( $TargetObject , 'NotField' ) $Assert . Null ( $TargetObject , 'tag.NullField' ) } NullOrEmpty # The NullOrEmpty assertion method checks the field value of the object is null or empty. A field value is null or empty if any of the following are true: The field does not exist. The field value is $Null . The field value is an empty array or collection. The field value is an empty string '' . The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' is not empty. Examples: Rule 'NullOrEmpty' { $Assert . NullOrEmpty ( $TargetObject , 'Name' ) $Assert . NullOrEmpty ( $TargetObject , 'tag.Environment' ) } TypeOf # The TypeOf assertion method checks the field value is a specified type. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. type - One or more specified types to check. The field value only has to match a single type of more than one type is specified. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The parameter 'type' is null or empty. The field '{0}' does not exist. The field value '{0}' is null. The field value '{2}' of type {1} is not {0}. Examples: Rule 'TypeOf' { # Require Value1 to be [int] $Assert . TypeOf ( $TargetObject , 'Value1' , [int] ) # Require Value1 to be [int] or [long] $Assert . TypeOf ( $TargetObject , 'Value1' , @( [int], [long] )) } SetOf # The SetOf assertion method checks the field value only includes all of the specified values. The field value must be an array or collection. Specified values can be included in the field value in any order. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. values - An array of values that the field value is compared against. caseSensitive (optional) - Use a case sensitive compare of the field value. Case is ignored by default. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The parameter 'values' is null. The field '{0}' does not exist. The field '{0}' is not enumerable. The field '{0}' did not contain '{1}'. The field '{0}' has '{1}' items instead of '{2}'. Examples: Rule 'Subset' { $Assert . SetOf ( $TargetObject , 'zones' , @( '1' , '2' , '3' )) } StartsWith # The StartsWith assertion method checks the field value starts with the specified prefix. Optionally a case-sensitive compare can be used, however case is ignored by default. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. prefix - A prefix or an array of prefixes to compare the field value with. Only one prefix must match. When an empty array of prefixes is specified or prefix is an empty string, StartsWith always passes. caseSensitive (optional) - Use a case sensitive compare of the field value. Case is ignored by default. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The parameter 'prefix' is null. The field '{0}' does not exist. The field value '{0}' is not a string. The field '{0}' does not start with '{1}'. Examples: Rule 'StartsWith' { $Assert . StartsWith ( $TargetObject , 'ResourceGroupName' , 'rg-' ) $Assert . StartsWith ( $TargetObject , 'Name' , @( 'st' , 'diag' ), $True ) } Subset # The Subset assertion method checks the field value includes all of the specified values. The field value may also contain additional values that are not specified in the values parameter. The field value must be an array or collection. Specified values can be included in the field value in any order. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. values - An array of values that the field value is compared against. When an empty array is specified, Subset will always pass. caseSensitive (optional) - Use a case sensitive compare of the field value. Case is ignored by default. unique (optional) - A boolean value that indicates if the items must be unique. When true the field value must not contain duplicate items. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The parameter 'values' is null. The field '{0}' does not exist. The field '{0}' is not enumerable. The field '{0}' did not contain '{1}'. The field '{0}' included multiple instances of '{1}'. Examples: Rule 'Subset' { $Assert . Subset ( $TargetObject , 'logs' , @( 'cluster-autoscaler' , 'kube-apiserver' , 'kube-scheduler' ), $True , $True ) } Version # The Version assertion method checks the field value is a valid semantic version. A constraint can optionally be provided to require the semantic version to be within a range. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. constraint (optional) - A version constraint, see below for details of version constrain format. includePrerelease (optional) - Determines if prerelease versions are included. Unless specified this defaults to $False . The following are supported constraints: version - Must match version exactly. This also accepts the following prefixes; = , v , V . e.g. 1.2.3 , =1.2.3 >version - Must be greater than version. e.g. >1.2.3 >=version - Must be greater than or equal to version. e.g. >=1.2.3 <version - Must be less than version. e.g. <1.2.3 <=version - Must be less than or equal to version. e.g. <=1.2.3 ^version - Compatible with version. e.g. ^1.2.3 - >=1.2.3 , <2.0.0 ~version - Approximately equivalent to version e.g. ~1.2.3 - >=1.2.3 , <1.3.0 An empty, null or * constraint matches all valid semantic versions. Multiple constraints can be joined together: Use a space to separate multiple constraints, each must be true ( logical AND ). Separates constraint sets with the double pipe || . Only one constraint set must be true ( logical OR ). By example: 1.2.3 || >=3.4.5 <5.0.0 results in: Pass: 1.2.3 , 3.4.5 , 3.5.0 , 4.9.9 . Fail: 3.0.0 , 5.0.0 . Handling for prerelease versions: Constraints and versions containing prerelease identifiers are supported. i.e. >=1.2.3-build.1 or 1.2.3-build.1 . A version containing a prerelease identifer follows semantic versioning rules. i.e. 1.2.3-alpha < 1.2.3-alpha.1 < 1.2.3-alpha.beta < 1.2.3-beta < 1.2.3-beta.2 < 1.2.3-beta.11 < 1.2.3-rc.1 < 1.2.3 . A constraint without a prerelease identifer will only match a stable version by default. Set includePrerelease to $True to include prerelease versions. Constraints with a prerelease identifer will only match: Matching prerelease versions of the same major.minor.patch version by default. Set includePrerelease to $True to include prerelease versions of all matching versions. Alternatively use the @pre or @prerelease flag in a constraint. Matching stable versions. By example: >=1.2.3 results in: Pass: 1.2.3 , 9.9.9 . Fail: 1.2.3-build.1 , 9.9.9-build.1 . >=1.2.3-0 results in: Pass: 1.2.3 , 1.2.3-build.1 , 9.9.9 . Fail: 9.9.9-build.1 . <1.2.3 results in: Pass: 1.2.2 , 1.0.0 . Fail: 1.0.0-build.1 , 1.2.3-build.1 . <1.2.3-0 results in: Pass: 1.2.2 , 1.0.0 . Fail: 1.0.0-build.1 , 1.2.3-build.1 . @pre >=1.2.3 results in: Pass: 1.2.3 , 9.9.9 , 9.9.9-build.1 Fail: 1.2.3-build.1 . @pre >=1.2.3-0 results in: Pass: 1.2.3 , 1.2.3-build.1 , 9.9.9 , 9.9.9-build.1 . Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' does not exist. The field value '{0}' is not a version string. The version '{0}' does not match the constraint '{1}'. Examples: Rule 'ValidVersion' { $Assert . Version ( $TargetObject , 'version' ) } Rule 'MinimumVersion' { $Assert . Version ( $TargetObject , 'version' , '>=1.2.3' ) } Rule 'MinimumVersionWithPrerelease' { $Assert . Version ( $TargetObject , 'version' , '>=1.2.3-0' , $True ) } Rule 'MinimumVersionWithFlag' { $Assert . Version ( $TargetObject , 'version' , '@pre >=1.2.3-0' ) } WithinPath # The WithinPath assertion method checks if the file path is within a required path. Checks use file system case-sensitivity rules by default. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field containing a file path. When the field is InputFileInfo or FileInfo , PSRule will automatically resolve the file path. path - An array of one or more directory paths to check. Only one path must match. caseSensitive (optional) - Determines if case-sensitive path matching is used. This can be set to $True or $False . When not set or $Null , the case-sensitivity rules of the working path file system will be used. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The parameter 'path' is null or empty. The field '{0}' does not exist. The file '{0}' is not within the path '{1}'. Examples: Rule 'WithinPath' { # Require the file to be within either policy/ or security/ sub-directories. $Assert . WithinPath ( $TargetObject , 'FullName' , @( 'policy/' , 'security/' )); } Advanced usage # The AssertResult object returned from assertion methods: Handles pass/ fail conditions and collection of reason information. Allows rules to implement their own handling or forward it up the stack to affect the rule outcome. The following properties are available: Result - Either $True (Pass) or $False (Fail). The following methods are available: AddReason(<string> text) - Can be used to append additional reasons to the result. A reason can only be set if the assertion failed. Reason text should be localized before calling this method. Localization can be done using the $LocalizedData automatic variable. WithReason(<string> text, <bool> replace) - Can be used to append or replace reasons on the result. In addition, WithReason can be chained. Reason(<string> text, params <object[]> args) - Replaces the reason on the results with a formatted string. This method can be chained. For usage see examples below. ReasonFrom(<string> path, <string> text, params <object[]> args) - Replaces the reason on the results with a formatted string. Path specifies the object path that affected the reason. This method can be chained. For usage see examples below. ReasonIf(<bool> condition, <string> text, params <object[]> args) - Replaces the reason if the condition is true. This method can be chained, similar to Reason . ReasonIf(<string> path, <bool> condition, <string> text, params <object[]> args) - Replaces the reason if the condition is true. This method can be chained, similar to ReasonFrom . PathPrefix(<string> path) - Adds a path prefix to any reasons. This method can be chained. For usage see examples below. GetReason() - Gets any reasons currently associated with the failed result. Complete() - Returns $True (Pass) or $False (Fail) to the rule record. If the assertion failed, any reasons are automatically added to the rule record. To read the result without adding reason to the rule record use the Result property. Ignore() - Ignores the result. Nothing future is returned and any reasons are cleared. Use this method when implementing custom handling. Use of Complete is optional, uncompleted results are automatically completed after the rule has executed. Uncompleted results may return reasons out of sequence. Using these advanced methods is not supported in rule script pre-conditions. In this example, Complete is used to find the first field with an empty value. Rule 'Assert.HasFieldValue' { $Assert . HasFieldValue ( $TargetObject , 'Name' ). Complete () -and $Assert . HasFieldValue ( $TargetObject , 'Type' ). Complete () -and $Assert . HasFieldValue ( $TargetObject , 'Value' ). Complete () } In this example, the built-in reason is replaced with a custom reason, and immediately returned. The reason text is automatically formatted with any parameters provided. Rule 'Assert.HasCustomValue' { $Assert . HasDefaultValue ( $TargetObject , 'value' , 'test' ). Reason ( 'The field {0} is using a non-default value: {1}' , 'value' , $TargetObject . value ) # With localized string $Assert . HasDefaultValue ( $TargetObject , 'value' , 'test' ). Reason ( $LocalizedData . NonDefaultValue , 'value' , $TargetObject . value ) } In this example, the built-in reason has a path prefix added to any reasons. Rule 'Assert.ChildHasFieldValue' { $items = @( $TargetObject . items ) for ( $i = 0 ; $i -lt $items . Length ; $i ++) { $Assert . HasFieldValue ( $items [ $i ], 'Name' ). PathPrefix ( \"items[$i]\" ) } } Downstream issues # Before PSRule performs analysis external tools or rules modules may have already performed analysis. Issues identified by downstream tools can be consumed by PSRule using the _PSRule.issue property. If a _PSRule property exists with issue sub-property PSRule will consume issue as an array of issues. Each issue has the following properties: type - The issue type. Issues are filtered by type. name - The name of a specific issue. message - The reason message for the issue. To get issues for an object use the Get or Any methods. # Get an array of all issues for the current object. $PSRule . Issue . Get (); # Get an array of issues of a specific type. $PSRule . Issue . Get ( 'CustomIssue' ); # Return true of any issues exist. $PSRule . Issue . Any (); # Return true of any issues of a specific type exist. $PSRule . Issue . Any ( 'CustomIssue' ); For example: # Synopsis: Fail if the object has any 'PSRule.Rules.Azure.Parameter.Insecure' issues. Rule 'IssueReportTest' { $Assert . Create ( $PSRule . Issue . Get ( 'PSRule.Rules.Azure.Parameter.Insecure' )); } Authoring assertion methods # The following built-in helper methods are provided for working with $Assert when authoring new assertion methods: Create(<bool> condition, <string> reason, params <object[]> args) - Returns a result either pass or fail assertion result. Additional arguments can be provided to format the custom reason string. Create(<TargetIssueInfo[]>) - Returns a result based on reported downstream issues. Pass() - Returns a pass assertion result. Fail() - Results a fail assertion result. Fail(<string> reason, params <object[]> args) - Results a fail assertion result with a custom reason. Additional arguments can be provided to format the custom reason string. Aggregating assertion methods # The following built-in helper methods are provided for aggregating assertion results: AnyOf(<AssertResult[]> results) - Results from assertion methods are aggregated into a single result. If any result is a pass, the result is a pass. If all results are fails, the result is a fail and any reasons are added to the result. If no results are provided, the result is a fail. AllOf(<AssertResult[]> results) - Results from assertion methods are aggregated into a single result. If all results are passes, the result is a pass. If any result is a fail, the result is a fail and any reasons are added to the result. If no results are provided, the result is a fail. For example: Rule 'Assert.HasFieldValue' { $Assert . AllOf ( $Assert . HasFieldValue ( $TargetObject , 'Name' ), $Assert . HasFieldValue ( $TargetObject , 'Type' ), $Assert . HasFieldValue ( $TargetObject , 'Value' ) ) } Links # about_PSRule_Variables","title":"Assertion methods"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#assertion-methods","text":"Describes the assertion helper that can be used within PSRule rule definitions.","title":"Assertion methods"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#description","text":"PSRule includes an assertion helper exposed as a built-in variable $Assert . The $Assert object provides a consistent set of methods to evaluate objects. Each $Assert method returns an AssertResult object that contains the result of the assertion. The following built-in assertion methods are provided: Contains - The field value must contain at least one of the strings. Count - The field value must contain the specified number of items. EndsWith - The field value must match at least one suffix. FileHeader - The file must contain a comment header. FilePath - The file path must exist. Greater - The field value must be greater. GreaterOrEqual - The field value must be greater or equal to. HasDefaultValue - The object should not have the field or the field value is set to the default value. HasField - The object must have any of the specified fields. HasFields - The object must have all of the specified fields. HasFieldValue - The object must have the specified field and that field is not empty. HasJsonSchema - The object must reference a JSON schema with the $schema field. In - The field value must be included in the set. IsArray - The field value must be an array. IsBoolean - The field value must be a boolean. IsDateTime - The field value must be a DateTime. IsInteger - The field value must be an integer. IsLower - The field value must include only lowercase characters. IsNumeric - The field value must be a numeric type. IsString - The field value must be a string. IsUpper - The field value must include only uppercase characters. JsonSchema - The object must validate successfully against a JSON schema. Less - The field value must be less. LessOrEqual - The field value must be less or equal to. Like - The value must match any of the specified wildcard values. Match - The field value matches a regular expression pattern. NotContains - The value must not contain any of the specified strings. NotCount - The field value must not contain the specified number of items. NotEndsWith - The value must not end with any of the specified strings. NotHasField - The object must not have any of the specified fields. NotIn - The field value must not be included in the set. NotLike - The value must not match any of the specified wildcard values. NotMatch - The field value does not match a regular expression pattern. NotNull - The field value must not be null. NotStartsWith - The value must not start with any of the specified strings. NotWithinPath - The field must not be within the specified path. Null - The field value must not exist or be null. NullOrEmpty - The object must not have the specified field or it must be empty. TypeOf - The field value must be of the specified type. SetOf - The field value must match a set of specified values. StartsWith - The field value must match at least one prefix. Subset - The field value must include a set of specified values. Version - The field value must be a semantic version string. WithinPath - The field value must be within the specified path. The $Assert variable can only be used within a rule definition block or script pre-conditions.","title":"Description"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#using-assertion-methods","text":"An assertion method can be used like other methods in PowerShell. i.e. $Assert.methodName(parameters) . Assertion methods use the following standard pattern: The first parameter is always the input object of type PSObject , additional parameters can be included based on the functionality required by the method. In many cases the input object will be $TargetObject , however assertion methods must not assume that $TargetObject will be used. Assertion methods must accept a $Null input object. Assertion methods return the AssertResult object that is interpreted by the rule pipeline. Some assertion methods may overlap or provide similar functionality to built-in keywords. Where you have the choice, use built-in keywords. Use assertion methods for advanced cases or increased flexibility. In the following example, Assert.HasFieldValue asserts that $TargetObject should have a field named Type with a non-empty value. Rule 'Assert.HasTypeField' { $Assert . HasFieldValue ( $TargetObject , 'Type' ) } To find perform multiple assertions use. Rule 'Assert.HasRequiredFields' { $Assert . HasFieldValue ( $TargetObject , 'Name' ) $Assert . HasFieldValue ( $TargetObject , 'Type' ) $Assert . HasFieldValue ( $TargetObject , 'Value' ) }","title":"Using assertion methods"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#field-names","text":"Many of the built-in assertion methods accept an object path or field name. An object path is an expression that traverses object properties, keys or indexes of the input object . The syntax for an object path is inspired by JSONPath which is current an IETF Internet-Draft. The object path expression can contain: Property names for PSObjects or .NET objects. Keys for hash table or dictionaries. Indexes for arrays or collections. Queries that filter items from array or collection properties. For example: . , or $ refers to input object itself. Name , .Name , or $.Name refers to the name member of the input object . Properties.enabled refers to the enabled member under the Properties member. Alternatively this can also be written as Properties['enabled'] . Tags.env refers to the env member under a hash table property of the input object . Tags+env refers to the env member using a case-sensitive match. Properties.securityRules[0].name references to the name member of the first security rule. Properties.securityRules[-1].name references to the name member of the last security rule. Properties.securityRules[?@direction == 'Inbound'].name returns the name of any inbound rules. This will return an array of security rule names. Notable differences between object paths and JSONPath are: Member names (properties and keys) are case-insensitive by default. To perform a case-sensitive match of a member name use a plus selector + in front of the member name. Some assertions such as HasField provide an option to match case when matching member names. When this is used, the plus selector perform an case-insensitive match. Quoted member names with single or double quotes are supported with dot selector. i.e. Properties.'spaced name' is valid. Member names with a dash - are supported without being quoted. However member names can not start or end with a dash. i.e. Properties.dashed-name and Properties.'-dashed-name' are valid.","title":"Field names"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#contains","text":"The Contains assertion method checks the field value contains the specified string. Optionally a case-sensitive compare can be used, however case is ignored by default. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. text - A string or an array of strings to compare the field value with. Only one string must match. When an empty array of strings is specified or text is an empty string, Contains always passes. caseSensitive (optional) - Use a case sensitive compare of the field value. Case is ignored by default. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The parameter 'text' is null. The field '{0}' does not exist. The field value '{0}' is not a string. The field '{0}' does not contain '{1}'. Examples: Rule 'Contains' { $Assert . Contains ( $TargetObject , 'ResourceGroupName' , 'prod' ) $Assert . Contains ( $TargetObject , 'Name' , @( 'prod' , 'test' ), $True ) }","title":"Contains"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#count","text":"The Count assertion method checks the field value contains the specified number of items. The field value must be an array or collection. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. count - The number of items that the field value must contain. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' does not exist. The field '{0}' is not enumerable. The field '{0}' has '{1}' items instead of '{2}'. Examples: Rule 'Count' { $Assert . Count ( $TargetObject , 'items' , 2 ) }","title":"Count"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#endswith","text":"The EndsWith assertion method checks the field value ends with the specified suffix. Optionally a case-sensitive compare can be used, however case is ignored by default. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. suffix - A suffix or an array of suffixes to compare the field value with. Only one suffix must match. When an empty array of suffixes is specified or suffix is an empty string, EndsWith always passes. caseSensitive (optional) - Use a case sensitive compare of the field value. Case is ignored by default. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The parameter 'suffix' is null. The field '{0}' does not exist. The field value '{0}' is not a string. The field '{0}' does not end with '{1}'. Examples: Rule 'EndsWith' { $Assert . EndsWith ( $TargetObject , 'ResourceGroupName' , 'eus' ) $Assert . EndsWith ( $TargetObject , 'Name' , @( 'db' , 'web' ), $True ) }","title":"EndsWith"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#fileheader","text":"The FileHeader assertion method checks a file for a comment header. When comparing the file header, the format of line comments are automatically detected by file extension. Single line comments are supported. Multi-line comments are not supported. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field containing a valid file path. header - One or more lines of a header to compare with file contents. prefix (optional) - An optional comment prefix for each line. By default a comment prefix will automatically detected based on file extension. When set, detection by file extension is skipped. Prefix detection for line comments is supported with the following file extensions: .bicep , .cs , .csx .ts , .js , .jsx , .fs , .go , .groovy , .php , .cpp , .h , .java , .json , .jsonc , .scala , Jenkinsfile - Use a prefix of ( // ). .ps1 , .psd1 , .psm1 , .yaml , .yml , .r , .py , .sh , .tf , .tfvars , .gitignore , .pl , .rb , Dockerfile - Use a prefix of ( # ). .sql , .lau - Use a prefix of ( -- ). .bat , .cmd - Use a prefix of ( :: ). Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' does not exist. The field value '{0}' is not a string. The file '{0}' does not exist. The header was not set. Examples: Rule 'FileHeader' { $Assert . FileHeader ( $TargetObject , 'FullName' , @( 'Copyright (c) Microsoft Corporation.' 'Licensed under the MIT License.' )); }","title":"FileHeader"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#filepath","text":"The FilePath assertion method checks the file exists. Checks use file system case-sensitivity rules. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field containing a file path. suffix (optional) - Additional file path suffixes to append. When specified each suffix is combined with the file path. Only one full file path must be a valid file for the assertion method to pass. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' does not exist. The field value '{0}' is not a string. The file '{0}' does not exist. Examples: Rule 'FilePath' { $Assert . FilePath ( $TargetObject , 'FullName' , @( 'CHANGELOG.md' )); $Assert . FilePath ( $TargetObject , 'FullName' , @( 'LICENSE' , 'LICENSE.txt' )); $Assert . FilePath ( $TargetObject , 'FullName' , @( 'CODE_OF_CONDUCT.md' )); $Assert . FilePath ( $TargetObject , 'FullName' , @( 'CONTRIBUTING.md' )); $Assert . FilePath ( $TargetObject , 'FullName' , @( 'SECURITY.md' )); $Assert . FilePath ( $TargetObject , 'FullName' , @( 'README.md' )); $Assert . FilePath ( $TargetObject , 'FullName' , @( '.github/CODEOWNERS' )); $Assert . FilePath ( $TargetObject , 'FullName' , @( '.github/PULL_REQUEST_TEMPLATE.md' )); }","title":"FilePath"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#greater","text":"The Greater assertion method checks the field value is greater than the specified value. The field value can either be an integer, float, array, or string. When the field value is: An integer or float, a numerical comparison is used. An array, the number of elements is compared. A string, the length of the string is compared. A DateTime, the number of days from the current time is compared. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. value - A integer to compare the field value against. convert (optional) - Convert numerical strings and use a numerical comparison instead of using string length. By default the string length is compared. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' does not exist. The value '{0}' was not > '{1}'. The field value '{0}' can not be compared with '{1}'. Examples: Rule 'Greater' { $Assert . Greater ( $TargetObject , 'value' , 3 ) }","title":"Greater"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#greaterorequal","text":"The GreaterOrEqual assertion method checks the field value is greater or equal to the specified value. The field value can either be an integer, float, array, or string. When the field value is: An integer or float, a numerical comparison is used. An array, the number of elements is compared. A string, the length of the string is compared. A DateTime, the number of days from the current time is compared. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. value - A integer to compare the field value against. convert (optional) - Convert numerical strings and use a numerical comparison instead of using string length. By default the string length is compared. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' does not exist. The value '{0}' was not >= '{1}'. The field value '{0}' can not be compared with '{1}'. Examples: Rule 'GreaterOrEqual' { $Assert . GreaterOrEqual ( $TargetObject , 'value' , 3 ) }","title":"GreaterOrEqual"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#hasdefaultvalue","text":"The HasDefaultValue assertion method check that the field does not exist or the field value is set to the default value. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. defaultValue - The expected value if the field exists. This assertion will pass if: The field does not exist. The field value is set to defaultValue . This assertion will fail if: The field value is set to a value different from defaultValue . Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' is set to '{1}'. Examples: Rule 'HasDefaultValue' { $Assert . HasDefaultValue ( $TargetObject , 'Properties.osProfile.linuxConfiguration.provisionVMAgent' , $True ) }","title":"HasDefaultValue"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#hasfield","text":"The HasField assertion method checks the object has any of the specified fields. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of one or more fields to check. By default, a case insensitive compare is used. If more than one field is specified, only one must exist. caseSensitive (optional) - Use a case sensitive compare of the field name. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. Does not exist. Examples: Rule 'HasField' { $Assert . HasField ( $TargetObject , 'Name' ) $Assert . HasField ( $TargetObject , 'tag.Environment' , $True ) $Assert . HasField ( $TargetObject , @( 'tag.Environment' , 'tag.Env' ), $True ) }","title":"HasField"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#hasfields","text":"The HasFields assertion method checks the object has all of the specified fields. The following parameters are accepted: inputObject - The object being checked for the specified fields. field - The name of one or more fields to check. By default, a case insensitive compare is used. If more than one field is specified, all fields must exist. caseSensitive (optional) - Use a case sensitive compare of the field name. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' does not exist. Examples: Rule 'HasFields' { $Assert . HasFields ( $TargetObject , 'Name' ) $Assert . HasFields ( $TargetObject , 'tag.Environment' , $True ) $Assert . HasFields ( $TargetObject , @( 'tag.Environment' , 'tag.Env' ), $True ) }","title":"HasFields"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#hasfieldvalue","text":"The HasFieldValue assertion method checks the field value of the object is not empty. A field value is empty if any of the following are true: The field does not exist. The field value is $Null . The field value is an empty array or collection. The field value is an empty string '' . The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. expectedValue (optional) - Check that the field value is set to a specific value. To check $Null use NullOrEmpty instead. If expectedValue is $Null the field value will not be compared. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. Does not exist. Is null or empty. Is set to '{0}'. Examples: Rule 'HasFieldValue' { $Assert . HasFieldValue ( $TargetObject , 'Name' ) $Assert . HasFieldValue ( $TargetObject , 'tag.Environment' , 'production' ) }","title":"HasFieldValue"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#hasjsonschema","text":"The HasJsonSchema assertion method determines if the input object has a $schema property defined. If the $schema property is defined, it must not be empty and match one of the supplied schemas. If a trailing # is specified it is ignored from the $schema property and uri parameter below. The following parameters are accepted: inputObject - The object being compared. uri - Optional. When specified, the object being compared must have a $schema property set to one of the specified schemas. ignoreScheme - Optional. By default, ignoreScheme is $False . When $True , the schema will match if http or https is specified. Reasons include: The parameter 'inputObject' is null. The field '$schema' does not exist. The field value '$schema' is not a string. The value of '$schema' is null or empty. None of the specified schemas match '{0}'. Examples: Rule 'HasFieldValue' { $Assert . HasJsonSchema ( $TargetObject ) $Assert . HasJsonSchema ( $TargetObject , \"http://json-schema.org/draft-07/schema`#\" ) $Assert . HasJsonSchema ( $TargetObject , \"https://json-schema.org/draft-07/schema\" , $True ) }","title":"HasJsonSchema"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#jsonschema","text":"The JsonSchema assertion method compares the input object against a defined JSON schema. The following parameters are accepted: inputObject - The object being compared against the JSON schema. uri - A URL or file path to a JSON schema file formatted as UTF-8. Either a file path or URL can be used to specify the location of the schema file. Reasons include: The parameter 'inputObject' is null. The parameter 'uri' is null or empty. The JSON schema '{0}' could not be found. Failed schema validation on {0}. {1} Examples: Rule 'JsonSchema' { $Assert . JsonSchema ( $TargetObject , 'tests/PSRule.Tests/FromFile.Json.schema.json' ) }","title":"JsonSchema"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#in","text":"The In assertion method checks the field value is included in a set of values. The field value can either be an integer, float, array, or string. When the field value is an array, only one item must be included in the set. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. values - An array of values that the field value is compared against. When an empty array is specified, In will always fail. caseSensitive (optional) - Use a case sensitive compare of the field value. Case is ignored by default. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The parameter 'values' is null. The field '{0}' does not exist. The field value '{0}' was not included in the set. Examples: Rule 'In' { $Assert . In ( $TargetObject , 'Sku.tier' , @( 'PremiumV2' , 'Premium' , 'Standard' )) $Assert . In ( $TargetObject , 'Sku.tier' , @( 'PremiumV2' , 'Premium' , 'Standard' ), $True ) }","title":"In"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#isarray","text":"The IsArray assertion method checks the field value is an array type. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' does not exist. The field value '{0}' is null. The field value '{1}' of type {0} is not [array]. Examples: Rule 'IsArray' { # Require Value1 to be an array $Assert . IsArray ( $TargetObject , 'Value1' ) }","title":"IsArray"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#isboolean","text":"The IsBoolean assertion method checks the field value is a boolean type. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. convert (optional) - Try to convert strings. By default strings are not converted. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' does not exist. The field value '{0}' is null. The value '{0}' is not a boolean. Examples: Rule 'IsBoolean' { # Require Value1 to be a boolean $Assert . IsBoolean ( $TargetObject , 'Value1' ) # Require Value1 to be a boolean or a boolean string $Assert . IsBoolean ( $TargetObject , 'Value1' , $True ) }","title":"IsBoolean"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#isdatetime","text":"The IsDateTime assertion method checks the field value is a DateTime type. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. convert (optional) - Try to convert strings. By default strings are not converted. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' does not exist. The field value '{0}' is null. The value '{0}' is not a date. Examples: Rule 'IsDateTime' { # Require Value1 to be a DateTime $Assert . IsDateTime ( $TargetObject , 'Value1' ) # Require Value1 to be a DateTime or a DateTime string $Assert . IsDateTime ( $TargetObject , 'Value1' , $True ) }","title":"IsDateTime"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#isinteger","text":"The IsInteger assertion method checks the field value is a integer type. The following types are considered integer types int , long , byte . The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. convert (optional) - Try to convert strings. By default strings are not converted. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' does not exist. The field value '{0}' is null. The value '{0}' is not an integer. Examples: Rule 'IsInteger' { # Require Value1 to be an integer $Assert . IsInteger ( $TargetObject , 'Value1' ) # Require Value1 to be an integer or a integer string $Assert . IsInteger ( $TargetObject , 'Value1' , $True ) }","title":"IsInteger"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#islower","text":"The IsLower assertion method checks the field value uses only lowercase characters. Non-letter characters are ignored by default and will pass. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. requireLetters (optional) - Require each character to be lowercase letters only. Non-letter characters are ignored by default. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' does not exist. The field value '{0}' is not a string. The value '{0}' does not contain only lowercase characters. The value '{0}' does not contain only letters. Examples: Rule 'IsLower' { # Require Name to be lowercase $Assert . IsLower ( $TargetObject , 'Name' ) # Require Name to only contain lowercase letters $Assert . IsLower ( $TargetObject , 'Name' , $True ) }","title":"IsLower"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#isnumeric","text":"The IsNumeric assertion method checks the field value is a numeric type. The following types are considered numeric types int , long , float , byte , double . The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. convert (optional) - Try to convert numerical strings. By default strings are not converted. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' does not exist. The field value '{0}' is null. The value '{0}' is not numeric. Examples: Rule 'IsNumeric' { # Require Value1 to be numeric $Assert . IsNumeric ( $TargetObject , 'Value1' ) # Require Value1 to be numeric or a numerical string $Assert . IsNumeric ( $TargetObject , 'Value1' , $True ) }","title":"IsNumeric"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#isstring","text":"The IsString assertion method checks the field value is a string type. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' does not exist. The field value '{0}' is null. The value '{0}' is not a string. Examples: Rule 'IsString' { # Require Value1 to be a string $Assert . IsString ( $TargetObject , 'Value1' ) }","title":"IsString"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#isupper","text":"The IsUpper assertion method checks the field value uses only uppercase characters. Non-letter characters are ignored by default and will pass. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. requireLetters (optional) - Require each character to be uppercase letters only. Non-letter characters are ignored by default. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' does not exist. The field value '{0}' is not a string. The value '{0}' does not contain only uppercase characters. The value '{0}' does not contain only letters. Examples: Rule 'IsUpper' { # Require Name to be uppercase $Assert . IsUpper ( $TargetObject , 'Name' ) # Require Name to only contain uppercase letters $Assert . IsUpper ( $TargetObject , 'Name' , $True ) }","title":"IsUpper"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#less","text":"The Less assertion method checks the field value is less than the specified value. The field value can either be an integer, float, array, or string. When the field value is: An integer or float, a numerical comparison is used. An array, the number of elements is compared. A string, the length of the string is compared. A DateTime, the number of days from the current time is compared. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. value - A integer to compare the field value against. convert (optional) - Convert numerical strings and use a numerical comparison instead of using string length. By default the string length is compared. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' does not exist. The value '{0}' was not < '{1}'. The field value '{0}' can not be compared with '{1}'. Examples: Rule 'Less' { $Assert . Less ( $TargetObject , 'value' , 3 ) }","title":"Less"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#lessorequal","text":"The LessOrEqual assertion method checks the field value is less or equal to the specified value. The field value can either be an integer, float, array, or string. When the field value is: An integer or float, a numerical comparison is used. An array, the number of elements is compared. A string, the length of the string is compared. A DateTime, the number of days from the current time is compared. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. value - A integer to compare the field value against. convert (optional) - Convert numerical strings and use a numerical comparison instead of using string length. By default the string length is compared. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' does not exist. The value '{0}' was not <= '{1}'. The field value '{0}' can not be compared with '{1}'. Examples: Rule 'LessOrEqual' { $Assert . LessOrEqual ( $TargetObject , 'value' , 3 ) }","title":"LessOrEqual"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#like","text":"The Like assertion method checks the field value matches a specified pattern. Optionally a case-sensitive compare can be used, however case is ignored by default. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. pattern - A pattern or an array of patterns to compare the field value with. Only one pattern must match. When an empty array of patterns is specified, Like always passes. caseSensitive (optional) - Use a case sensitive compare of the field value. Case is ignored by default. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The parameter 'prefix' is null. The field '{0}' does not exist. The field value '{0}' is not a string. The value '{0}' is not like '{1}'. Examples: Rule 'Like' { $Assert . Like ( $TargetObject , 'ResourceGroupName' , 'rg-*' ) $Assert . Like ( $TargetObject , 'Name' , @( 'st*' , 'diag*' ), $True ) }","title":"Like"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#match","text":"The Match assertion method checks the field value matches a regular expression pattern. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. pattern - A regular expression pattern to match. caseSensitive (optional) - Use a case sensitive compare of the field value. Case is ignored by default. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' does not exist. The field value '{0}' is not a string. The field value '{0}' does not match the pattern '{1}'. Examples: Rule 'Match' { $Assert . Match ( $TargetObject , 'value' , '^[a-z]*$' ) $Assert . Match ( $TargetObject , 'value' , '^[a-z]*$' , $True ) }","title":"Match"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#notcontains","text":"The NotContains assertion method checks the field value contains the specified string. This condition fails when any of the specified sub-strings are found. Optionally a case-sensitive compare can be used, however case is ignored by default. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. text - A string or an array of strings to compare the field value with. When an empty array of strings is specified or text is an empty string, NotContains always passes. caseSensitive (optional) - Use a case sensitive compare of the field value. Case is ignored by default. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The parameter 'text' is null. The field '{0}' does not exist. The value '{0}' contains '{1}'. Examples: Rule 'NotContains' { $Assert . NotContains ( $TargetObject , 'ResourceGroupName' , 'prod' ) $Assert . NotContains ( $TargetObject , 'Name' , @( 'prod' , 'test' ), $True ) }","title":"NotContains"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#notcount","text":"The NotCount assertion method checks the field value does not contain the specified number of items. The field value must be an array or collection. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. count - The number of items that the field value must contain. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' does not exist. The field '{0}' is not enumerable. The field '{0}' has '{1}' items instead of '{2}'. Examples: Rule 'NotCount' { $Assert . NotCount ( $TargetObject , 'items' , 2 ) }","title":"NotCount"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#notendswith","text":"The NotEndsWith assertion method checks the field value ends with the specified suffix. This condition fails when any of the specified sub-strings are found at the end of the operand. Optionally a case-sensitive compare can be used, however case is ignored by default. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. suffix - A suffix or an array of suffixes to compare the field value with. When an empty array of suffixes is specified or suffix is an empty string, NotEndsWith always passes. caseSensitive (optional) - Use a case sensitive compare of the field value. Case is ignored by default. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The parameter 'suffix' is null. The field '{0}' does not exist. The value '{0}' ends with '{1}'. Examples: Rule 'NotEndsWith' { $Assert . NotEndsWith ( $TargetObject , 'ResourceGroupName' , 'eus' ) $Assert . NotEndsWith ( $TargetObject , 'Name' , @( 'db' , 'web' ), $True ) }","title":"NotEndsWith"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#nothasfield","text":"The NotHasField assertion method checks the object does not have any of the specified fields. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of one or more fields to check. By default, a case insensitive compare is used. If more than one field is specified, all must not exist. caseSensitive (optional) - Use a case sensitive compare of the field name. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' exists. Examples: Rule 'NotHasField' { $Assert . NotHasField ( $TargetObject , 'Name' ) $Assert . NotHasField ( $TargetObject , 'tag.Environment' , $True ) $Assert . NotHasField ( $TargetObject , @( 'tag.Environment' , 'tag.Env' ), $True ) }","title":"NotHasField"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#notin","text":"The NotIn assertion method checks the field value is not in a set of values. The field value can either be an integer, array, float, or string. When the field value is an array, none of the items must be included in the set. If the field does not exist at all, it is not in the set and passes. To check the field exists combine this assertion method with HasFieldValue . The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. values - An array values that the field value is compared against. When an empty array is specified, NotIn will always pass. caseSensitive (optional) - Use a case sensitive compare of the field value. Case is ignored by default. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The parameter 'values' is null. The field value '{0}' was in the set. Examples: Rule 'In' { $Assert . NotIn ( $TargetObject , 'Sku.tier' , @( 'Free' , 'Shared' , 'Basic' )) $Assert . NotIn ( $TargetObject , 'Sku.tier' , @( 'Free' , 'Shared' , 'Basic' ), $True ) }","title":"NotIn"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#notlike","text":"The NotLike assertion method checks the field value matches a specified pattern. This condition fails when any of the specified patterns match the field value. Optionally a case-sensitive compare can be used, however case is ignored by default. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. pattern - A pattern or an array of patterns to compare the field value with. When an empty array of pattens is specified, NotLike always passes. caseSensitive (optional) - Use a case sensitive compare of the field value. Case is ignored by default. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The parameter 'prefix' is null. The field '{0}' does not exist. The value '{0}' is like '{1}' Examples: Rule 'NotLike' { $Assert . NotLike ( $TargetObject , 'ResourceGroupName' , 'rg-*' ) $Assert . NotLike ( $TargetObject , 'Name' , @( 'st*' , 'diag*' ), $True ) }","title":"NotLike"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#notmatch","text":"The NotMatch assertion method checks the field value does not match a regular expression pattern. If the field does not exist at all, it does not match and passes. To check the field exists combine this assertion method with HasFieldValue . The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. pattern - A regular expression pattern to match. caseSensitive (optional) - Use a case sensitive compare of the field value. Case is ignored by default. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field value '{0}' is not a string. The field value '{0}' matches the pattern '{1}'. Examples: Rule 'NotMatch' { $Assert . NotMatch ( $TargetObject , 'value' , '^[a-z]*$' ) $Assert . NotMatch ( $TargetObject , 'value' , '^[a-z]*$' , $True ) }","title":"NotMatch"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#notnull","text":"The NotNull assertion method checks the field value of the object is not null. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' does not exist. The field value '{0}' is null. Examples: Rule 'NotNull' { $Assert . NotNull ( $TargetObject , 'Name' ) $Assert . NotNull ( $TargetObject , 'tag.Environment' ) }","title":"NotNull"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#notstartswith","text":"The NotStartsWith assertion method checks the field value starts with the specified prefix. This condition fails when any of the specified sub-strings are found at the start of the operand. Optionally a case-sensitive compare can be used, however case is ignored by default. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. prefix - A prefix or an array of prefixes to compare the field value with. When an empty array of prefixes is specified or prefix is an empty string, NotStartsWith always passes. caseSensitive (optional) - Use a case sensitive compare of the field value. Case is ignored by default. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The parameter 'prefix' is null. The field '{0}' does not exist. The value '{0}' starts with '{1}'. Examples: Rule 'NotStartsWith' { $Assert . NotStartsWith ( $TargetObject , 'ResourceGroupName' , 'rg-' ) $Assert . NotStartsWith ( $TargetObject , 'Name' , @( 'st' , 'diag' ), $True ) }","title":"NotStartsWith"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#notwithinpath","text":"The NotWithinPath assertion method checks the file is not within a specified path. Checks use file system case-sensitivity rules by default. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field containing a file path. When the field is InputFileInfo or FileInfo , PSRule will automatically resolve the file path. path - An array of one or more directory paths to check. Only one path must match. caseSensitive (optional) - Determines if case-sensitive path matching is used. This can be set to $True or $False . When not set or $Null , the case-sensitivity rules of the working path file system will be used. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The parameter 'path' is null or empty. The field '{0}' does not exist. The file '{0}' is within the path '{1}'. Examples: Rule 'NotWithinPath' { # The file must not be within either policy/ or security/ sub-directories. $Assert . NotWithinPath ( $TargetObject , 'FullName' , @( 'policy/' , 'security/' )); }","title":"NotWithinPath"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#null","text":"The Null assertion method checks the field value of the object is null. A field value is null if any of the following are true: The field does not exist. The field value is $Null . The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field value '{0}' is not null. Examples: Rule 'Null' { $Assert . Null ( $TargetObject , 'NotField' ) $Assert . Null ( $TargetObject , 'tag.NullField' ) }","title":"Null"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#nullorempty","text":"The NullOrEmpty assertion method checks the field value of the object is null or empty. A field value is null or empty if any of the following are true: The field does not exist. The field value is $Null . The field value is an empty array or collection. The field value is an empty string '' . The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' is not empty. Examples: Rule 'NullOrEmpty' { $Assert . NullOrEmpty ( $TargetObject , 'Name' ) $Assert . NullOrEmpty ( $TargetObject , 'tag.Environment' ) }","title":"NullOrEmpty"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#typeof","text":"The TypeOf assertion method checks the field value is a specified type. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. type - One or more specified types to check. The field value only has to match a single type of more than one type is specified. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The parameter 'type' is null or empty. The field '{0}' does not exist. The field value '{0}' is null. The field value '{2}' of type {1} is not {0}. Examples: Rule 'TypeOf' { # Require Value1 to be [int] $Assert . TypeOf ( $TargetObject , 'Value1' , [int] ) # Require Value1 to be [int] or [long] $Assert . TypeOf ( $TargetObject , 'Value1' , @( [int], [long] )) }","title":"TypeOf"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#setof","text":"The SetOf assertion method checks the field value only includes all of the specified values. The field value must be an array or collection. Specified values can be included in the field value in any order. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. values - An array of values that the field value is compared against. caseSensitive (optional) - Use a case sensitive compare of the field value. Case is ignored by default. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The parameter 'values' is null. The field '{0}' does not exist. The field '{0}' is not enumerable. The field '{0}' did not contain '{1}'. The field '{0}' has '{1}' items instead of '{2}'. Examples: Rule 'Subset' { $Assert . SetOf ( $TargetObject , 'zones' , @( '1' , '2' , '3' )) }","title":"SetOf"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#startswith","text":"The StartsWith assertion method checks the field value starts with the specified prefix. Optionally a case-sensitive compare can be used, however case is ignored by default. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. prefix - A prefix or an array of prefixes to compare the field value with. Only one prefix must match. When an empty array of prefixes is specified or prefix is an empty string, StartsWith always passes. caseSensitive (optional) - Use a case sensitive compare of the field value. Case is ignored by default. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The parameter 'prefix' is null. The field '{0}' does not exist. The field value '{0}' is not a string. The field '{0}' does not start with '{1}'. Examples: Rule 'StartsWith' { $Assert . StartsWith ( $TargetObject , 'ResourceGroupName' , 'rg-' ) $Assert . StartsWith ( $TargetObject , 'Name' , @( 'st' , 'diag' ), $True ) }","title":"StartsWith"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#subset","text":"The Subset assertion method checks the field value includes all of the specified values. The field value may also contain additional values that are not specified in the values parameter. The field value must be an array or collection. Specified values can be included in the field value in any order. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. values - An array of values that the field value is compared against. When an empty array is specified, Subset will always pass. caseSensitive (optional) - Use a case sensitive compare of the field value. Case is ignored by default. unique (optional) - A boolean value that indicates if the items must be unique. When true the field value must not contain duplicate items. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The parameter 'values' is null. The field '{0}' does not exist. The field '{0}' is not enumerable. The field '{0}' did not contain '{1}'. The field '{0}' included multiple instances of '{1}'. Examples: Rule 'Subset' { $Assert . Subset ( $TargetObject , 'logs' , @( 'cluster-autoscaler' , 'kube-apiserver' , 'kube-scheduler' ), $True , $True ) }","title":"Subset"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#version","text":"The Version assertion method checks the field value is a valid semantic version. A constraint can optionally be provided to require the semantic version to be within a range. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. constraint (optional) - A version constraint, see below for details of version constrain format. includePrerelease (optional) - Determines if prerelease versions are included. Unless specified this defaults to $False . The following are supported constraints: version - Must match version exactly. This also accepts the following prefixes; = , v , V . e.g. 1.2.3 , =1.2.3 >version - Must be greater than version. e.g. >1.2.3 >=version - Must be greater than or equal to version. e.g. >=1.2.3 <version - Must be less than version. e.g. <1.2.3 <=version - Must be less than or equal to version. e.g. <=1.2.3 ^version - Compatible with version. e.g. ^1.2.3 - >=1.2.3 , <2.0.0 ~version - Approximately equivalent to version e.g. ~1.2.3 - >=1.2.3 , <1.3.0 An empty, null or * constraint matches all valid semantic versions. Multiple constraints can be joined together: Use a space to separate multiple constraints, each must be true ( logical AND ). Separates constraint sets with the double pipe || . Only one constraint set must be true ( logical OR ). By example: 1.2.3 || >=3.4.5 <5.0.0 results in: Pass: 1.2.3 , 3.4.5 , 3.5.0 , 4.9.9 . Fail: 3.0.0 , 5.0.0 . Handling for prerelease versions: Constraints and versions containing prerelease identifiers are supported. i.e. >=1.2.3-build.1 or 1.2.3-build.1 . A version containing a prerelease identifer follows semantic versioning rules. i.e. 1.2.3-alpha < 1.2.3-alpha.1 < 1.2.3-alpha.beta < 1.2.3-beta < 1.2.3-beta.2 < 1.2.3-beta.11 < 1.2.3-rc.1 < 1.2.3 . A constraint without a prerelease identifer will only match a stable version by default. Set includePrerelease to $True to include prerelease versions. Constraints with a prerelease identifer will only match: Matching prerelease versions of the same major.minor.patch version by default. Set includePrerelease to $True to include prerelease versions of all matching versions. Alternatively use the @pre or @prerelease flag in a constraint. Matching stable versions. By example: >=1.2.3 results in: Pass: 1.2.3 , 9.9.9 . Fail: 1.2.3-build.1 , 9.9.9-build.1 . >=1.2.3-0 results in: Pass: 1.2.3 , 1.2.3-build.1 , 9.9.9 . Fail: 9.9.9-build.1 . <1.2.3 results in: Pass: 1.2.2 , 1.0.0 . Fail: 1.0.0-build.1 , 1.2.3-build.1 . <1.2.3-0 results in: Pass: 1.2.2 , 1.0.0 . Fail: 1.0.0-build.1 , 1.2.3-build.1 . @pre >=1.2.3 results in: Pass: 1.2.3 , 9.9.9 , 9.9.9-build.1 Fail: 1.2.3-build.1 . @pre >=1.2.3-0 results in: Pass: 1.2.3 , 1.2.3-build.1 , 9.9.9 , 9.9.9-build.1 . Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' does not exist. The field value '{0}' is not a version string. The version '{0}' does not match the constraint '{1}'. Examples: Rule 'ValidVersion' { $Assert . Version ( $TargetObject , 'version' ) } Rule 'MinimumVersion' { $Assert . Version ( $TargetObject , 'version' , '>=1.2.3' ) } Rule 'MinimumVersionWithPrerelease' { $Assert . Version ( $TargetObject , 'version' , '>=1.2.3-0' , $True ) } Rule 'MinimumVersionWithFlag' { $Assert . Version ( $TargetObject , 'version' , '@pre >=1.2.3-0' ) }","title":"Version"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#withinpath","text":"The WithinPath assertion method checks if the file path is within a required path. Checks use file system case-sensitivity rules by default. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field containing a file path. When the field is InputFileInfo or FileInfo , PSRule will automatically resolve the file path. path - An array of one or more directory paths to check. Only one path must match. caseSensitive (optional) - Determines if case-sensitive path matching is used. This can be set to $True or $False . When not set or $Null , the case-sensitivity rules of the working path file system will be used. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The parameter 'path' is null or empty. The field '{0}' does not exist. The file '{0}' is not within the path '{1}'. Examples: Rule 'WithinPath' { # Require the file to be within either policy/ or security/ sub-directories. $Assert . WithinPath ( $TargetObject , 'FullName' , @( 'policy/' , 'security/' )); }","title":"WithinPath"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#advanced-usage","text":"The AssertResult object returned from assertion methods: Handles pass/ fail conditions and collection of reason information. Allows rules to implement their own handling or forward it up the stack to affect the rule outcome. The following properties are available: Result - Either $True (Pass) or $False (Fail). The following methods are available: AddReason(<string> text) - Can be used to append additional reasons to the result. A reason can only be set if the assertion failed. Reason text should be localized before calling this method. Localization can be done using the $LocalizedData automatic variable. WithReason(<string> text, <bool> replace) - Can be used to append or replace reasons on the result. In addition, WithReason can be chained. Reason(<string> text, params <object[]> args) - Replaces the reason on the results with a formatted string. This method can be chained. For usage see examples below. ReasonFrom(<string> path, <string> text, params <object[]> args) - Replaces the reason on the results with a formatted string. Path specifies the object path that affected the reason. This method can be chained. For usage see examples below. ReasonIf(<bool> condition, <string> text, params <object[]> args) - Replaces the reason if the condition is true. This method can be chained, similar to Reason . ReasonIf(<string> path, <bool> condition, <string> text, params <object[]> args) - Replaces the reason if the condition is true. This method can be chained, similar to ReasonFrom . PathPrefix(<string> path) - Adds a path prefix to any reasons. This method can be chained. For usage see examples below. GetReason() - Gets any reasons currently associated with the failed result. Complete() - Returns $True (Pass) or $False (Fail) to the rule record. If the assertion failed, any reasons are automatically added to the rule record. To read the result without adding reason to the rule record use the Result property. Ignore() - Ignores the result. Nothing future is returned and any reasons are cleared. Use this method when implementing custom handling. Use of Complete is optional, uncompleted results are automatically completed after the rule has executed. Uncompleted results may return reasons out of sequence. Using these advanced methods is not supported in rule script pre-conditions. In this example, Complete is used to find the first field with an empty value. Rule 'Assert.HasFieldValue' { $Assert . HasFieldValue ( $TargetObject , 'Name' ). Complete () -and $Assert . HasFieldValue ( $TargetObject , 'Type' ). Complete () -and $Assert . HasFieldValue ( $TargetObject , 'Value' ). Complete () } In this example, the built-in reason is replaced with a custom reason, and immediately returned. The reason text is automatically formatted with any parameters provided. Rule 'Assert.HasCustomValue' { $Assert . HasDefaultValue ( $TargetObject , 'value' , 'test' ). Reason ( 'The field {0} is using a non-default value: {1}' , 'value' , $TargetObject . value ) # With localized string $Assert . HasDefaultValue ( $TargetObject , 'value' , 'test' ). Reason ( $LocalizedData . NonDefaultValue , 'value' , $TargetObject . value ) } In this example, the built-in reason has a path prefix added to any reasons. Rule 'Assert.ChildHasFieldValue' { $items = @( $TargetObject . items ) for ( $i = 0 ; $i -lt $items . Length ; $i ++) { $Assert . HasFieldValue ( $items [ $i ], 'Name' ). PathPrefix ( \"items[$i]\" ) } }","title":"Advanced usage"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#downstream-issues","text":"Before PSRule performs analysis external tools or rules modules may have already performed analysis. Issues identified by downstream tools can be consumed by PSRule using the _PSRule.issue property. If a _PSRule property exists with issue sub-property PSRule will consume issue as an array of issues. Each issue has the following properties: type - The issue type. Issues are filtered by type. name - The name of a specific issue. message - The reason message for the issue. To get issues for an object use the Get or Any methods. # Get an array of all issues for the current object. $PSRule . Issue . Get (); # Get an array of issues of a specific type. $PSRule . Issue . Get ( 'CustomIssue' ); # Return true of any issues exist. $PSRule . Issue . Any (); # Return true of any issues of a specific type exist. $PSRule . Issue . Any ( 'CustomIssue' ); For example: # Synopsis: Fail if the object has any 'PSRule.Rules.Azure.Parameter.Insecure' issues. Rule 'IssueReportTest' { $Assert . Create ( $PSRule . Issue . Get ( 'PSRule.Rules.Azure.Parameter.Insecure' )); }","title":"Downstream issues"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#authoring-assertion-methods","text":"The following built-in helper methods are provided for working with $Assert when authoring new assertion methods: Create(<bool> condition, <string> reason, params <object[]> args) - Returns a result either pass or fail assertion result. Additional arguments can be provided to format the custom reason string. Create(<TargetIssueInfo[]>) - Returns a result based on reported downstream issues. Pass() - Returns a pass assertion result. Fail() - Results a fail assertion result. Fail(<string> reason, params <object[]> args) - Results a fail assertion result with a custom reason. Additional arguments can be provided to format the custom reason string.","title":"Authoring assertion methods"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#aggregating-assertion-methods","text":"The following built-in helper methods are provided for aggregating assertion results: AnyOf(<AssertResult[]> results) - Results from assertion methods are aggregated into a single result. If any result is a pass, the result is a pass. If all results are fails, the result is a fail and any reasons are added to the result. If no results are provided, the result is a fail. AllOf(<AssertResult[]> results) - Results from assertion methods are aggregated into a single result. If all results are passes, the result is a pass. If any result is a fail, the result is a fail and any reasons are added to the result. If no results are provided, the result is a fail. For example: Rule 'Assert.HasFieldValue' { $Assert . AllOf ( $Assert . HasFieldValue ( $TargetObject , 'Name' ), $Assert . HasFieldValue ( $TargetObject , 'Type' ), $Assert . HasFieldValue ( $TargetObject , 'Value' ) ) }","title":"Aggregating assertion methods"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#links","text":"about_PSRule_Variables","title":"Links"},{"location":"concepts/PSRule/en-US/about_PSRule_Badges/","text":"Badges # Describes using the badge API with PSRule. Description # PSRule executes rules to validate an object from input. When processing input it may be necessary to perform custom actions before or after rules execute. Conventions provide an extensibility point that can be shipped with or external to standard rules. The badge API can be used to create badges within a convention. Using the API # PSRule provides the $PSRule built-in variable that exposes the badge API. By using the $PSRule.Badges.Create method you can create a standard or custom badge. The create method provides the following overloads: // Create a badge for the worst case of an analyzed object. IBadge Create ( InvokeResult result ); // Create a badge for the worst case of all analyzed objects. IBadge Create ( IEnumerable < InvokeResult > result ); // Create a custom badge. IBadge Create ( string title , BadgeType type , string label ); A badge once created can be read as a string or written to disk with the following methods: // Get the badge as SVG text content. string ToSvg (); // Write the SVG badge content directly to disk. void ToFile ( string path ); Defining conventions # To define a convention, add a Export-PSRuleConvention block within a .Rule.ps1 file. The .Rule.ps1 must be in an included path or module with -Path or -Module . The Export-PSRuleConvention block works similar to the Rule block. Each convention must have a unique name. Currently the badge API support creating badges in the -End block. For example: # Synopsis: A convention that generates a badge for an aggregate result. Export-PSRuleConvention 'Local.Aggregate' -End { $PSRule . Badges . Create ( $PSRule . Output ). ToFile ( 'out/badges/aggregate.svg' ); } # Synopsis: A convention that generates a custom badge. Export-PSRuleConvention 'Local.CustomBadge' -End { $PSRule . Badges . Create ( 'PSRule' , [PSRule.Badges.BadgeType] :: Success , 'OK' ). ToFile ( 'out/badges/custom.svg' ); } Using conventions # A convention can be included by using the -Convention parameter when executing a PSRule cmdlet. Alternatively, conventions can be included with options. To use a convention specify the name of the convention by name. For example: Invoke-PSRule -Convention 'Local.Aggregate' ; Links # Invoke-PSRule","title":"Badges"},{"location":"concepts/PSRule/en-US/about_PSRule_Badges/#badges","text":"Describes using the badge API with PSRule.","title":"Badges"},{"location":"concepts/PSRule/en-US/about_PSRule_Badges/#description","text":"PSRule executes rules to validate an object from input. When processing input it may be necessary to perform custom actions before or after rules execute. Conventions provide an extensibility point that can be shipped with or external to standard rules. The badge API can be used to create badges within a convention.","title":"Description"},{"location":"concepts/PSRule/en-US/about_PSRule_Badges/#using-the-api","text":"PSRule provides the $PSRule built-in variable that exposes the badge API. By using the $PSRule.Badges.Create method you can create a standard or custom badge. The create method provides the following overloads: // Create a badge for the worst case of an analyzed object. IBadge Create ( InvokeResult result ); // Create a badge for the worst case of all analyzed objects. IBadge Create ( IEnumerable < InvokeResult > result ); // Create a custom badge. IBadge Create ( string title , BadgeType type , string label ); A badge once created can be read as a string or written to disk with the following methods: // Get the badge as SVG text content. string ToSvg (); // Write the SVG badge content directly to disk. void ToFile ( string path );","title":"Using the API"},{"location":"concepts/PSRule/en-US/about_PSRule_Badges/#defining-conventions","text":"To define a convention, add a Export-PSRuleConvention block within a .Rule.ps1 file. The .Rule.ps1 must be in an included path or module with -Path or -Module . The Export-PSRuleConvention block works similar to the Rule block. Each convention must have a unique name. Currently the badge API support creating badges in the -End block. For example: # Synopsis: A convention that generates a badge for an aggregate result. Export-PSRuleConvention 'Local.Aggregate' -End { $PSRule . Badges . Create ( $PSRule . Output ). ToFile ( 'out/badges/aggregate.svg' ); } # Synopsis: A convention that generates a custom badge. Export-PSRuleConvention 'Local.CustomBadge' -End { $PSRule . Badges . Create ( 'PSRule' , [PSRule.Badges.BadgeType] :: Success , 'OK' ). ToFile ( 'out/badges/custom.svg' ); }","title":"Defining conventions"},{"location":"concepts/PSRule/en-US/about_PSRule_Badges/#using-conventions","text":"A convention can be included by using the -Convention parameter when executing a PSRule cmdlet. Alternatively, conventions can be included with options. To use a convention specify the name of the convention by name. For example: Invoke-PSRule -Convention 'Local.Aggregate' ;","title":"Using conventions"},{"location":"concepts/PSRule/en-US/about_PSRule_Badges/#links","text":"Invoke-PSRule","title":"Links"},{"location":"concepts/PSRule/en-US/about_PSRule_Baseline/","text":"Baselines # Describes usage of baselines within PSRule. Description # PSRule lets you define a baseline. A baseline includes a set of rule and configuration options that are used for evaluating objects. The following baseline options can be configured: Binding.Field Binding.IgnoreCase Binding.NameSeparator Binding.PreferTargetInfo Binding.TargetName Binding.TargetType Binding.UseQualifiedName Configuration Rule.Include Rule.IncludeLocal Rule.Exclude Rule.Tag Baseline options can be: Included as a baseline spec within a YAML or JSON file. When using this method, multiple baseline specs can be defined within the same YAML/JSON file. Each YAML baseline spec is separated using --- . Each JSON baseline spec is separated by JSON objects in a JSON array. Set within a workspace options file like ps-rule.yaml or ps-rule.json . Only a single baseline can be specified. See about_PSRule_Options for details on using this method. Baseline specs # YAML baseline specs are saved within a YAML file with a .Rule.yaml or .Rule.yml extension, for example Baseline.Rule.yaml . JSON baseline specs are saved within a file with a .Rule.json or .Rule.jsonc extension, for example Baseline.Rule.json . Use .jsonc to view JSON with Comments in Visual Studio Code. To define a YAML baseline spec use the following structure: --- # Synopsis: <synopsis> apiVersion : github.com/microsoft/PSRule/v1 kind : Baseline metadata : name : <name> annotations : { } spec : # One or more baseline options binding : { } rule : { } configuration : { } For example: --- # Synopsis: This is an example baseline apiVersion : github.com/microsoft/PSRule/v1 kind : Baseline metadata : name : Baseline1 spec : binding : field : id : - ResourceId targetName : - Name - ResourceName - ResourceGroupName targetType : - ResourceType rule : include : - Rule1 - Rule2 configuration : allowedLocations : - 'Australia East' - 'Australia South East' --- # Synopsis: This is an example baseline apiVersion : github.com/microsoft/PSRule/v1 kind : Baseline metadata : name : Baseline2 spec : binding : targetName : - Name - ResourceName - ResourceGroupName targetType : - ResourceType rule : include : - Rule1 - Rule3 configuration : allowedLocations : - 'Australia East' To define a JSON baseline spec use the following structure: [ { // Synopsis: <synopsis> \"apiVersion\" : \"github.com/microsoft/PSRule/v1\" , \"kind\" : \"Baseline\" , \"metadata\" : { \"name\" : \"<name>\" , \"annotations\" : {} }, \"spec\" : { \"binding\" : {}, \"rule\" : {}, \"configuration\" : {} } } ] For example: [ { // Synopsis: This is an example baseline \"apiVersion\" : \"github.com/microsoft/PSRule/v1\" , \"kind\" : \"Baseline\" , \"metadata\" : { \"name\" : \"Baseline1\" }, \"spec\" : { \"binding\" : { \"field\" : { \"id\" : [ \"ResourceId\" ] }, \"targetName\" : [ \"Name\" , \"ResourceName\" , \"ResourceGroupName\" ], \"targetType\" : [ \"ResourceType\" ] }, \"rule\" : { \"include\" : [ \"Rule1\" , \"Rule2\" ] }, \"configuration\" : { \"allowedLocations\" : [ \"Australia East\" , \"Australia South East\" ] } } }, { // Synopsis: This is an example baseline \"apiVersion\" : \"github.com/microsoft/PSRule/v1\" , \"kind\" : \"Baseline\" , \"metadata\" : { \"name\" : \"Baseline2\" }, \"spec\" : { \"binding\" : { \"targetName\" : [ \"Name\" , \"ResourceName\" , \"ResourceGroupName\" ], \"targetType\" : [ \"ResourceType\" ] }, \"rule\" : { \"include\" : [ \"Rule1\" , \"Rule3\" ] }, \"configuration\" : { \"allowedLocations\" : [ \"Australia East\" ] } } } ] Baseline scopes # When baseline options are set, PSRule uses the following order to determine precedence. Parameter - -Name and -Tag . Explicit - A named baseline specified with -Baseline . Workspace - Included in ps-rule.yaml or specified on the command line with -Option . Module - A baseline object included in a .Rule.yaml or .Rule.json file. After precedence is determined, baselines are merged and null values are ignored, such that: Annotations # Additional baseline annotations can be provided as key/ value pairs. Annotations can be used to provide additional information that is available in Get-PSRuleBaseline output. The following reserved annotation exists: obsolete - Marks the baseline as obsolete when set to true . PSRule will generate a warning when an obsolete baseline is used. YAML example: --- # Synopsis: This is an example baseline that is obsolete apiVersion : github.com/microsoft/PSRule/v1 kind : Baseline metadata : name : ObsoleteBaseline annotations : obsolete : true spec : { } JSON example: [ { // Synopsis: This is an example baseline that is obsolete \"apiVersion\" : \"github.com/microsoft/PSRule/v1\" , \"kind\" : \"Baseline\" , \"metadata\" : { \"name\" : \"ObsoleteBaseline\" , \"annotations\" : { \"obsolete\" : true } }, \"spec\" : {} } ] Examples # Example Baseline.Rule.yaml # # Example Baseline.Rule.yaml --- # Synopsis: This is an example baseline apiVersion : github.com/microsoft/PSRule/v1 kind : Baseline metadata : name : TestBaseline1 spec : binding : targetName : - AlternateName targetType : - kind rule : include : - 'WithBaseline' configuration : key1 : value1 --- # Synopsis: This is an example baseline apiVersion : github.com/microsoft/PSRule/v1 kind : Baseline metadata : name : TestBaseline2 spec : binding : targetName : - AlternateName targetType : - kind rule : include : - 'WithBaseline' configuration : key1 : value1 Example Baseline.Rule.json # // Example Baseline.Rule.json [ { // Synopsis: This is an example baseline \"apiVersion\" : \"github.com/microsoft/PSRule/v1\" , \"kind\" : \"Baseline\" , \"metadata\" : { \"name\" : \"TestBaseline1\" }, \"spec\" : { \"binding\" : { \"targetName\" : [ \"AlternateName\" ], \"targetType\" : [ \"kind\" ] }, \"rule\" : { \"include\" : [ \"WithBaseline\" ] }, \"configuration\" : { \"key1\" : \"value1\" } } }, { // Synopsis: This is an example baseline \"apiVersion\" : \"github.com/microsoft/PSRule/v1\" , \"kind\" : \"Baseline\" , \"metadata\" : { \"name\" : \"TestBaseline2\" }, \"spec\" : { \"binding\" : { \"targetName\" : [ \"AlternateName\" ], \"targetType\" : [ \"kind\" ] }, \"rule\" : { \"include\" : [ \"WithBaseline\" ] }, \"configuration\" : { \"key1\" : \"value1\" } } } ]","title":"Baselines"},{"location":"concepts/PSRule/en-US/about_PSRule_Baseline/#baselines","text":"Describes usage of baselines within PSRule.","title":"Baselines"},{"location":"concepts/PSRule/en-US/about_PSRule_Baseline/#description","text":"PSRule lets you define a baseline. A baseline includes a set of rule and configuration options that are used for evaluating objects. The following baseline options can be configured: Binding.Field Binding.IgnoreCase Binding.NameSeparator Binding.PreferTargetInfo Binding.TargetName Binding.TargetType Binding.UseQualifiedName Configuration Rule.Include Rule.IncludeLocal Rule.Exclude Rule.Tag Baseline options can be: Included as a baseline spec within a YAML or JSON file. When using this method, multiple baseline specs can be defined within the same YAML/JSON file. Each YAML baseline spec is separated using --- . Each JSON baseline spec is separated by JSON objects in a JSON array. Set within a workspace options file like ps-rule.yaml or ps-rule.json . Only a single baseline can be specified. See about_PSRule_Options for details on using this method.","title":"Description"},{"location":"concepts/PSRule/en-US/about_PSRule_Baseline/#baseline-specs","text":"YAML baseline specs are saved within a YAML file with a .Rule.yaml or .Rule.yml extension, for example Baseline.Rule.yaml . JSON baseline specs are saved within a file with a .Rule.json or .Rule.jsonc extension, for example Baseline.Rule.json . Use .jsonc to view JSON with Comments in Visual Studio Code. To define a YAML baseline spec use the following structure: --- # Synopsis: <synopsis> apiVersion : github.com/microsoft/PSRule/v1 kind : Baseline metadata : name : <name> annotations : { } spec : # One or more baseline options binding : { } rule : { } configuration : { } For example: --- # Synopsis: This is an example baseline apiVersion : github.com/microsoft/PSRule/v1 kind : Baseline metadata : name : Baseline1 spec : binding : field : id : - ResourceId targetName : - Name - ResourceName - ResourceGroupName targetType : - ResourceType rule : include : - Rule1 - Rule2 configuration : allowedLocations : - 'Australia East' - 'Australia South East' --- # Synopsis: This is an example baseline apiVersion : github.com/microsoft/PSRule/v1 kind : Baseline metadata : name : Baseline2 spec : binding : targetName : - Name - ResourceName - ResourceGroupName targetType : - ResourceType rule : include : - Rule1 - Rule3 configuration : allowedLocations : - 'Australia East' To define a JSON baseline spec use the following structure: [ { // Synopsis: <synopsis> \"apiVersion\" : \"github.com/microsoft/PSRule/v1\" , \"kind\" : \"Baseline\" , \"metadata\" : { \"name\" : \"<name>\" , \"annotations\" : {} }, \"spec\" : { \"binding\" : {}, \"rule\" : {}, \"configuration\" : {} } } ] For example: [ { // Synopsis: This is an example baseline \"apiVersion\" : \"github.com/microsoft/PSRule/v1\" , \"kind\" : \"Baseline\" , \"metadata\" : { \"name\" : \"Baseline1\" }, \"spec\" : { \"binding\" : { \"field\" : { \"id\" : [ \"ResourceId\" ] }, \"targetName\" : [ \"Name\" , \"ResourceName\" , \"ResourceGroupName\" ], \"targetType\" : [ \"ResourceType\" ] }, \"rule\" : { \"include\" : [ \"Rule1\" , \"Rule2\" ] }, \"configuration\" : { \"allowedLocations\" : [ \"Australia East\" , \"Australia South East\" ] } } }, { // Synopsis: This is an example baseline \"apiVersion\" : \"github.com/microsoft/PSRule/v1\" , \"kind\" : \"Baseline\" , \"metadata\" : { \"name\" : \"Baseline2\" }, \"spec\" : { \"binding\" : { \"targetName\" : [ \"Name\" , \"ResourceName\" , \"ResourceGroupName\" ], \"targetType\" : [ \"ResourceType\" ] }, \"rule\" : { \"include\" : [ \"Rule1\" , \"Rule3\" ] }, \"configuration\" : { \"allowedLocations\" : [ \"Australia East\" ] } } } ]","title":"Baseline specs"},{"location":"concepts/PSRule/en-US/about_PSRule_Baseline/#baseline-scopes","text":"When baseline options are set, PSRule uses the following order to determine precedence. Parameter - -Name and -Tag . Explicit - A named baseline specified with -Baseline . Workspace - Included in ps-rule.yaml or specified on the command line with -Option . Module - A baseline object included in a .Rule.yaml or .Rule.json file. After precedence is determined, baselines are merged and null values are ignored, such that:","title":"Baseline scopes"},{"location":"concepts/PSRule/en-US/about_PSRule_Baseline/#annotations","text":"Additional baseline annotations can be provided as key/ value pairs. Annotations can be used to provide additional information that is available in Get-PSRuleBaseline output. The following reserved annotation exists: obsolete - Marks the baseline as obsolete when set to true . PSRule will generate a warning when an obsolete baseline is used. YAML example: --- # Synopsis: This is an example baseline that is obsolete apiVersion : github.com/microsoft/PSRule/v1 kind : Baseline metadata : name : ObsoleteBaseline annotations : obsolete : true spec : { } JSON example: [ { // Synopsis: This is an example baseline that is obsolete \"apiVersion\" : \"github.com/microsoft/PSRule/v1\" , \"kind\" : \"Baseline\" , \"metadata\" : { \"name\" : \"ObsoleteBaseline\" , \"annotations\" : { \"obsolete\" : true } }, \"spec\" : {} } ]","title":"Annotations"},{"location":"concepts/PSRule/en-US/about_PSRule_Baseline/#examples","text":"","title":"Examples"},{"location":"concepts/PSRule/en-US/about_PSRule_Baseline/#example-baselineruleyaml","text":"# Example Baseline.Rule.yaml --- # Synopsis: This is an example baseline apiVersion : github.com/microsoft/PSRule/v1 kind : Baseline metadata : name : TestBaseline1 spec : binding : targetName : - AlternateName targetType : - kind rule : include : - 'WithBaseline' configuration : key1 : value1 --- # Synopsis: This is an example baseline apiVersion : github.com/microsoft/PSRule/v1 kind : Baseline metadata : name : TestBaseline2 spec : binding : targetName : - AlternateName targetType : - kind rule : include : - 'WithBaseline' configuration : key1 : value1","title":"Example Baseline.Rule.yaml"},{"location":"concepts/PSRule/en-US/about_PSRule_Baseline/#example-baselinerulejson","text":"// Example Baseline.Rule.json [ { // Synopsis: This is an example baseline \"apiVersion\" : \"github.com/microsoft/PSRule/v1\" , \"kind\" : \"Baseline\" , \"metadata\" : { \"name\" : \"TestBaseline1\" }, \"spec\" : { \"binding\" : { \"targetName\" : [ \"AlternateName\" ], \"targetType\" : [ \"kind\" ] }, \"rule\" : { \"include\" : [ \"WithBaseline\" ] }, \"configuration\" : { \"key1\" : \"value1\" } } }, { // Synopsis: This is an example baseline \"apiVersion\" : \"github.com/microsoft/PSRule/v1\" , \"kind\" : \"Baseline\" , \"metadata\" : { \"name\" : \"TestBaseline2\" }, \"spec\" : { \"binding\" : { \"targetName\" : [ \"AlternateName\" ], \"targetType\" : [ \"kind\" ] }, \"rule\" : { \"include\" : [ \"WithBaseline\" ] }, \"configuration\" : { \"key1\" : \"value1\" } } } ]","title":"Example Baseline.Rule.json"},{"location":"concepts/PSRule/en-US/about_PSRule_Conventions/","text":"Conventions # Describes PSRule Conventions including how to use and author them. Description # PSRule executes rules to validate an object from input. When processing input it may be necessary to perform custom actions before or after rules execute. Conventions provide an extensibility point that can be shipped with or external to standard rules. Each convention, hooks into one or more places within the pipeline. Using conventions # A convention can be included by using the -Convention parameter when executing a PSRule cmdlet. Alternatively, conventions can be included with options. To use a convention specify the name of the convention by name. For example: Invoke-PSRule -Convention 'ExampleConvention' ; If multiple conventions are specified in an array, all are executed in they are specified. As a result, the convention specified last may override state set by earlier conventions. Assert-PSRule -Convention 'ExampleConvention1' , 'ExampleConvention2' ; Defining conventions # To define a convention, add a Export-PSRuleConvention block within a .Rule.ps1 file. The .Rule.ps1 must be in an included path or module with -Path or -Module . The Export-PSRuleConvention block works similar to the Rule block. Each convention must have a unique name. For example: # Synopsis: An example convention. Export-PSRuleConvention 'ExampleConvention' { # Add code here } Initialize Begin Process End blocks # Conventions define four executable blocks Initialize , Begin , Process , End similar to a PowerShell function. Each block is injected in a different part of the pipeline as follows: Initialize occurs once at the beginning of the pipeline. Use Initialize to perform any initialization required by the convention. Begin occurs once per object before the any rules are executed. Use Begin blocks to perform expansion, set data, or alter the object before rules are processed. Process occurs once per object after all rules are executed. Use Process blocks to perform per object tasks such as generate badges. End occurs only once after all objects have been processed. Use End blocks to upload results to an external service. Convention block limitations: Initialize can not use automatic variables except $PSRule . Most methods and properties of $PSRule are not available in Initialize . Begin and Process can not use rule specific variables such as $Rule . These blocks are executed outside of the context of a single rule. End can not use automatic variables except $PSRule . Most methods and properties of $PSRule are not available in End . By default, the Process block used. For example: # Synopsis: The default { } executes the process block Export-PSRuleConvention 'ExampleConvention' { # Process block } # Synopsis: With optional -Process parameter name Export-PSRuleConvention 'ExampleConvention' -Process { # Process block } To use Initialize , Begin , or End explicitly add these blocks. For example: Export-PSRuleConvention 'ExampleConvention' -Process { # Process block } -Begin { # Begin block } -End { # End block } -Initialize { # Initialize block } Including with options # Conventions can be included by name within options in addition to using the -Convention parameter. To specify a convention within YAML options use the following: # Example ps-docs.yaml convention : include : - 'ExampleConvention1' - 'ExampleConvention2' Using within modules # Conventions can be shipped within a module using the same packaging and distribution process as rules. Additionally, conventions shipped within a module can be automatically included. By default, PSRule does not include conventions shipped within a module. To use a convention included in a module use the -Convention parameter or options configuration. A module can automatically include a convention by specifying the convention by name in module configuration. For example: # Example Config.Rule.yaml --- apiVersion : github.com/microsoft/PSRule/v1 kind : ModuleConfig metadata : name : ExampleModule spec : convention : include : - 'ExampleConvention1' - 'ExampleConvention2' Execution order # Conventions are executed in the order they are specified. This is true for Initialize , Begin , Process , and End blocks. i.e. In the following example ExampleConvention1 is execute before ExampleConvention2 . Assert-PSRule -Convention 'ExampleConvention1' , 'ExampleConvention2' ; When conventions are specified from multiple locations PSRule orders conventions as follows: Using -Convention parameter. PSRule options. Module configuration. Links # Invoke-PSRule","title":"Conventions"},{"location":"concepts/PSRule/en-US/about_PSRule_Conventions/#conventions","text":"Describes PSRule Conventions including how to use and author them.","title":"Conventions"},{"location":"concepts/PSRule/en-US/about_PSRule_Conventions/#description","text":"PSRule executes rules to validate an object from input. When processing input it may be necessary to perform custom actions before or after rules execute. Conventions provide an extensibility point that can be shipped with or external to standard rules. Each convention, hooks into one or more places within the pipeline.","title":"Description"},{"location":"concepts/PSRule/en-US/about_PSRule_Conventions/#using-conventions","text":"A convention can be included by using the -Convention parameter when executing a PSRule cmdlet. Alternatively, conventions can be included with options. To use a convention specify the name of the convention by name. For example: Invoke-PSRule -Convention 'ExampleConvention' ; If multiple conventions are specified in an array, all are executed in they are specified. As a result, the convention specified last may override state set by earlier conventions. Assert-PSRule -Convention 'ExampleConvention1' , 'ExampleConvention2' ;","title":"Using conventions"},{"location":"concepts/PSRule/en-US/about_PSRule_Conventions/#defining-conventions","text":"To define a convention, add a Export-PSRuleConvention block within a .Rule.ps1 file. The .Rule.ps1 must be in an included path or module with -Path or -Module . The Export-PSRuleConvention block works similar to the Rule block. Each convention must have a unique name. For example: # Synopsis: An example convention. Export-PSRuleConvention 'ExampleConvention' { # Add code here }","title":"Defining conventions"},{"location":"concepts/PSRule/en-US/about_PSRule_Conventions/#initialize-begin-process-end-blocks","text":"Conventions define four executable blocks Initialize , Begin , Process , End similar to a PowerShell function. Each block is injected in a different part of the pipeline as follows: Initialize occurs once at the beginning of the pipeline. Use Initialize to perform any initialization required by the convention. Begin occurs once per object before the any rules are executed. Use Begin blocks to perform expansion, set data, or alter the object before rules are processed. Process occurs once per object after all rules are executed. Use Process blocks to perform per object tasks such as generate badges. End occurs only once after all objects have been processed. Use End blocks to upload results to an external service. Convention block limitations: Initialize can not use automatic variables except $PSRule . Most methods and properties of $PSRule are not available in Initialize . Begin and Process can not use rule specific variables such as $Rule . These blocks are executed outside of the context of a single rule. End can not use automatic variables except $PSRule . Most methods and properties of $PSRule are not available in End . By default, the Process block used. For example: # Synopsis: The default { } executes the process block Export-PSRuleConvention 'ExampleConvention' { # Process block } # Synopsis: With optional -Process parameter name Export-PSRuleConvention 'ExampleConvention' -Process { # Process block } To use Initialize , Begin , or End explicitly add these blocks. For example: Export-PSRuleConvention 'ExampleConvention' -Process { # Process block } -Begin { # Begin block } -End { # End block } -Initialize { # Initialize block }","title":"Initialize Begin Process End blocks"},{"location":"concepts/PSRule/en-US/about_PSRule_Conventions/#including-with-options","text":"Conventions can be included by name within options in addition to using the -Convention parameter. To specify a convention within YAML options use the following: # Example ps-docs.yaml convention : include : - 'ExampleConvention1' - 'ExampleConvention2'","title":"Including with options"},{"location":"concepts/PSRule/en-US/about_PSRule_Conventions/#using-within-modules","text":"Conventions can be shipped within a module using the same packaging and distribution process as rules. Additionally, conventions shipped within a module can be automatically included. By default, PSRule does not include conventions shipped within a module. To use a convention included in a module use the -Convention parameter or options configuration. A module can automatically include a convention by specifying the convention by name in module configuration. For example: # Example Config.Rule.yaml --- apiVersion : github.com/microsoft/PSRule/v1 kind : ModuleConfig metadata : name : ExampleModule spec : convention : include : - 'ExampleConvention1' - 'ExampleConvention2'","title":"Using within modules"},{"location":"concepts/PSRule/en-US/about_PSRule_Conventions/#execution-order","text":"Conventions are executed in the order they are specified. This is true for Initialize , Begin , Process , and End blocks. i.e. In the following example ExampleConvention1 is execute before ExampleConvention2 . Assert-PSRule -Convention 'ExampleConvention1' , 'ExampleConvention2' ; When conventions are specified from multiple locations PSRule orders conventions as follows: Using -Convention parameter. PSRule options. Module configuration.","title":"Execution order"},{"location":"concepts/PSRule/en-US/about_PSRule_Conventions/#links","text":"Invoke-PSRule","title":"Links"},{"location":"concepts/PSRule/en-US/about_PSRule_Docs/","text":"Documentation # Describes usage of documentation within PSRule. Description # PSRule includes a built-in documentation system that provide culture specific help and metadata for resources. Documentation is composed of markdown files that can be optionally shipped with a module. When markdown documentation is defined, this content will be used instead of inline synopsis comments. Markdown documentation is supported for rules and suppression groups. Getting documentation # To get documentation for a rule use the Get-PSRuleHelp cmdlet. For example: Get-PSRuleHelp < rule-name > Each rule can include the following documentation: Annotations - Additional metadata included in results. Synopsis - A brief description on the intended purpose of the rule. Description - A detailed description on the intended purpose of the rule. Recommendation - A detailed explanation of the requirements to pass the rule. Notes - Any additional information or configuration options. Links - Any links to external references. See cmdlet help for detailed information on the Get-PSRuleHelp cmdlet. Online help # Rule documentation may optionally include a link to an online version. When included, the -Online parameter can be used to open the online version in the default web browser. For example: Get-PSRuleHelp < rule-name > -Online Creating documentation for rules # Rule documentation is composed of markdown files, one per rule. When creating rules for more then one culture, a separate markdown file is created per rule per culture. The markdown files for each rule is automatically discovered based on naming convention. Markdown is saved in a file with the same filename as the rule name with the .md extension. The file name should match the same case exactly, with a lower case extension. As an example, the storageAccounts.UseHttps.md markdown file would be created. # Synopsis: Configure storage accounts to only accept encrypted traffic i.e. HTTPS/SMB Rule 'storageAccounts.UseHttps' -If { ResourceType 'Microsoft.Storage/storageAccounts' } { Recommend 'Storage accounts should only allow secure traffic' $TargetObject . Properties . supportsHttpsTrafficOnly } The markdown of each file uses following structure. --- {{ Annotations }} --- # {{ Name of rule }} {{ A brief summary of the rule }} ## Description {{ A detailed description of the rule }} ## Recommendation {{ A detailed explanation of the steps required to pass the rule }} ## Notes {{ Additional information or configuration options }} ## Links {{ Links to external references }} Optionally, one or more annotations formatted as YAML key value pairs can be included. i.e. severity: Critical Additional sections such as EXAMPLES can be included although are not exposed with Get-PSRuleHelp . Creating documentation for suppression groups # Suppression groups support documentation similar to rules that allows a synopsis to be defined. Other sections can be added to the markdown content, but are ignored. Set the synopsis in markdown to allow a culture specific message to be displayed. The markdown of each file uses following structure. --- {{ Annotations }} --- # {{ Name of suppression group }} {{ A brief summary of the suppression group }} Storing markdown files # The location PSRule uses to find markdown documentation depends on how the rules/ resources are packaged. In each case, documentation will be in a culture /<culture>/ specific subdirectory. Resources can be either shipped as part of a module, or standalone. When resources are standalone, the culture subdirectory is relative to the *.Rule.* file. When packaged in a module, the culture subdirectory is relative to the module manifest .psd1 file. The <culture> subdirectory will be the current culture that PowerShell is executed under. To determine the current culture use (Get-Culture).Name . Alternatively, the culture can set by using the -Culture parameter of PSRule cmdlets. Links # Get-PSRuleHelp","title":"Documentation"},{"location":"concepts/PSRule/en-US/about_PSRule_Docs/#documentation","text":"Describes usage of documentation within PSRule.","title":"Documentation"},{"location":"concepts/PSRule/en-US/about_PSRule_Docs/#description","text":"PSRule includes a built-in documentation system that provide culture specific help and metadata for resources. Documentation is composed of markdown files that can be optionally shipped with a module. When markdown documentation is defined, this content will be used instead of inline synopsis comments. Markdown documentation is supported for rules and suppression groups.","title":"Description"},{"location":"concepts/PSRule/en-US/about_PSRule_Docs/#getting-documentation","text":"To get documentation for a rule use the Get-PSRuleHelp cmdlet. For example: Get-PSRuleHelp < rule-name > Each rule can include the following documentation: Annotations - Additional metadata included in results. Synopsis - A brief description on the intended purpose of the rule. Description - A detailed description on the intended purpose of the rule. Recommendation - A detailed explanation of the requirements to pass the rule. Notes - Any additional information or configuration options. Links - Any links to external references. See cmdlet help for detailed information on the Get-PSRuleHelp cmdlet.","title":"Getting documentation"},{"location":"concepts/PSRule/en-US/about_PSRule_Docs/#online-help","text":"Rule documentation may optionally include a link to an online version. When included, the -Online parameter can be used to open the online version in the default web browser. For example: Get-PSRuleHelp < rule-name > -Online","title":"Online help"},{"location":"concepts/PSRule/en-US/about_PSRule_Docs/#creating-documentation-for-rules","text":"Rule documentation is composed of markdown files, one per rule. When creating rules for more then one culture, a separate markdown file is created per rule per culture. The markdown files for each rule is automatically discovered based on naming convention. Markdown is saved in a file with the same filename as the rule name with the .md extension. The file name should match the same case exactly, with a lower case extension. As an example, the storageAccounts.UseHttps.md markdown file would be created. # Synopsis: Configure storage accounts to only accept encrypted traffic i.e. HTTPS/SMB Rule 'storageAccounts.UseHttps' -If { ResourceType 'Microsoft.Storage/storageAccounts' } { Recommend 'Storage accounts should only allow secure traffic' $TargetObject . Properties . supportsHttpsTrafficOnly } The markdown of each file uses following structure. --- {{ Annotations }} --- # {{ Name of rule }} {{ A brief summary of the rule }} ## Description {{ A detailed description of the rule }} ## Recommendation {{ A detailed explanation of the steps required to pass the rule }} ## Notes {{ Additional information or configuration options }} ## Links {{ Links to external references }} Optionally, one or more annotations formatted as YAML key value pairs can be included. i.e. severity: Critical Additional sections such as EXAMPLES can be included although are not exposed with Get-PSRuleHelp .","title":"Creating documentation for rules"},{"location":"concepts/PSRule/en-US/about_PSRule_Docs/#creating-documentation-for-suppression-groups","text":"Suppression groups support documentation similar to rules that allows a synopsis to be defined. Other sections can be added to the markdown content, but are ignored. Set the synopsis in markdown to allow a culture specific message to be displayed. The markdown of each file uses following structure. --- {{ Annotations }} --- # {{ Name of suppression group }} {{ A brief summary of the suppression group }}","title":"Creating documentation for suppression groups"},{"location":"concepts/PSRule/en-US/about_PSRule_Docs/#storing-markdown-files","text":"The location PSRule uses to find markdown documentation depends on how the rules/ resources are packaged. In each case, documentation will be in a culture /<culture>/ specific subdirectory. Resources can be either shipped as part of a module, or standalone. When resources are standalone, the culture subdirectory is relative to the *.Rule.* file. When packaged in a module, the culture subdirectory is relative to the module manifest .psd1 file. The <culture> subdirectory will be the current culture that PowerShell is executed under. To determine the current culture use (Get-Culture).Name . Alternatively, the culture can set by using the -Culture parameter of PSRule cmdlets.","title":"Storing markdown files"},{"location":"concepts/PSRule/en-US/about_PSRule_Docs/#links","text":"Get-PSRuleHelp","title":"Links"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/","tags":["language"],"text":"Expressions # Describes PSRule expressions and how to use them. Description # PSRule expressions are used within YAML-based rules or selectors to evaluate an object. Expressions are comprised of nested conditions, operators, and comparison properties. The following conditions are available: Contains Count Equals EndsWith Exists Greater GreaterOrEquals HasDefault HasSchema HasValue In IsLower IsString IsArray IsBoolean IsDateTime IsInteger IsNumeric IsUpper Less LessOrEquals Like Match NotContains NotCount NotEndsWith NotEquals NotIn NotLike NotMatch NotStartsWith NotWithinPath SetOf StartsWith Subset WithinPath Version The following operators are available: AllOf AnyOf Not The following comparison properties are available: Field Name Scope Source Type AllOf # The allOf operator is used to require all nested expressions to match. When any nested expression does not match, allOf does not match. This is similar to a logical and operation. Syntax: allOf : <expression[]> For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleAllOf' spec : condition : allOf : # Both Name and Description must exist. - field : 'Name' exists : true - field : 'Description' exists : true --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleAllOf' spec : if : allOf : # Both Name and Description must exist. - field : 'Name' exists : true - field : 'Description' exists : true AnyOf # The anyOf operator is used to require one or more nested expressions to match. When any nested expression matches, allOf matches. This is similar to a logical or operation. Syntax: anyOf : <expression[]> For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleAnyOf' spec : condition : anyOf : # Name and/ or AlternativeName must exist. - field : 'Name' exists : true - field : 'AlternativeName' exists : true --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleAnyOf' spec : if : anyOf : # Name and/ or AlternativeName must exist. - field : 'Name' exists : true - field : 'AlternativeName' exists : true Contains # The contains condition can be used to determine if the operand contains a specified sub-string. One or more strings to compare can be specified. caseSensitive - Optionally, a case sensitive-comparison can be performed. By default, case-insensitive comparison is performed. convert - Optionally, types can be converted to string type. By default convert is false . Syntax: contains : <string | array> caseSensitive : <boolean> convert : <boolean> If the operand is a field, and the field does not exist, contains always returns false . For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleContains' spec : condition : anyOf : - field : 'url' contains : '/azure/' - field : 'url' contains : - 'github.io' - 'github.com' --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleContains' spec : if : anyOf : - field : 'url' contains : '/azure/' - field : 'url' contains : - 'github.io' - 'github.com' Count # The count condition is used to determine if the operand contains a specified number of items. Syntax: count : <int> For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleCount' spec : condition : field : 'items' count : 2 --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleCount' spec : if : field : 'items' count : 2 Equals # The equals condition can be used to compare if the operand is equal to a supplied value. caseSensitive - Optionally, a case sensitive-comparison can be performed. This only applies to string comparisons. By default, case-insensitive comparison is performed. convert - Optionally, perform type conversion on operand type. By default convert is false . Syntax: equals : <string | int | bool> caseSensitive : <boolean> convert : <boolean> For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleEquals' spec : condition : field : 'Name' equals : 'TargetObject1' --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleEquals' spec : if : field : 'Name' equals : 'TargetObject1' EndsWith # The endsWith condition can be used to determine if the operand ends with a specified string. One or more strings to compare can be specified. caseSensitive - Optionally, a case sensitive-comparison can be performed. By default, case-insensitive comparison is performed. convert - Optionally, types can be converted to string type. By default convert is false . Syntax: endsWith : <string | array> caseSensitive : <boolean> convert : <boolean> If the operand is a field, and the field does not exist, endsWith always returns false . For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleEndsWith' spec : condition : anyOf : - field : 'hostname' endsWith : '.com' - field : 'hostname' endsWith : - '.com.au' - '.com' --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleEndsWith' spec : if : anyOf : - field : 'hostname' endsWith : '.com' - field : 'hostname' endsWith : - '.com.au' - '.com' Exists # The exists condition determines if the specified field exists. Syntax: exists : <bool> When exists: true , exists will return true if the field exists. When exists: false , exists will return true if the field does not exist. For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleExists' spec : condition : field : 'Name' exists : true --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleExists' spec : if : field : 'Name' exists : true Field # The comparison property field is used with a condition to determine field of the object to evaluate. A field can be: A property name. A key within a hashtable or dictionary. An index in an array or collection. A nested path through an object. Syntax: field : <string> For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleField' spec : condition : field : 'Properties.securityRules[0].name' exists : true --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleField' spec : if : field : 'Properties.securityRules[0].name' exists : true Greater # The greater condition determines if the operand is greater than a supplied value. The field value can either be an integer, float, array, or string. convert - Optionally, perform type conversion on operand type. By default convert is false . When the field value is: An integer or float, a numerical comparison is used. An array, the number of elements is compared. A string, the length of the string is compared. If convert is true , the string is converted a number instead. A DateTime, the number of days from the current time is compared. Syntax: greater : <int> convert : <boolean> For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleGreater' spec : condition : field : 'Name' greater : 3 --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleGreater' spec : if : field : 'Name' greater : 3 GreaterOrEquals # The greaterOrEquals condition determines if the operand is greater or equal to the supplied value. The field value can either be an integer, float, array, or string. convert - Optionally, perform type conversion on operand type. By default convert is false . When the field value is: An integer or float, a numerical comparison is used. An array, the number of elements is compared. A string, the length of the string is compared. If convert is true , the string is converted a number instead. A DateTime, the number of days from the current time is compared. Syntax: greaterOrEquals : <int> convert : <boolean> For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleGreaterOrEquals' spec : condition : field : 'Name' greaterOrEquals : 3 --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleGreaterOrEquals' spec : if : field : 'Name' greaterOrEquals : 3 HasDefault # The hasDefault condition determines if the field exists that it is set to the specified value. If the field does not exist, the condition will return true . The following properties are accepted: caseSensitive - Optionally, a case-sensitive comparison can be performed for string values. By default, case-insensitive comparison is performed. Syntax: hasDefault : <string | int | bool> caseSensitive : <bool> For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleHasDefault' spec : condition : field : 'enabled' hasDefault : true --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleHasDefault' spec : if : field : 'enabled' hasDefault : true HasSchema # The hasSchema condition determines if the operand has a $schema property defined. If the $schema property is defined, it must match one of the specified schemas. If a trailing # is specified it is ignored. The following properties are accepted: caseSensitive - Optionally, a case-sensitive comparison can be performed. By default, case-insensitive comparison is performed. ignoreScheme - Optionally, the URI scheme is ignored in the comparison. By default, the scheme is compared. When true , the schema will match if either http:// or https:// is specified. Syntax: hasSchema : <array> caseSensitive : <bool> ignoreScheme : <bool> When hasSchema: [] , hasSchema will return true if any non-empty $schema property is defined. For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleHasSchema' spec : condition : field : '.' hasSchema : - https://schema.management.azure.com/schemas/2019-04-01/deploymentParameters.json# --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleHasSchema' spec : if : field : '.' hasSchema : - https://schema.management.azure.com/schemas/2019-04-01/deploymentParameters.json# - https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json# ignoreScheme : true --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleHasAnySchema' spec : if : field : '.' hasSchema : [] HasValue # The hasValue condition determines if the field exists and has a non-empty value. Syntax: hasValue : <bool> When hasValue: true , hasValue will return true if the field is not empty. When hasValue: false , hasValue will return true if the field is empty. For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleHasValue' spec : condition : field : 'Name' hasValue : true --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleHasValue' spec : if : field : 'Name' hasValue : true In # The in condition can be used to compare if a field contains one of the specified values. Syntax: in : <array> For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleIn' spec : condition : field : 'Name' in : - 'Value1' - 'Value2' --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleIn' spec : if : field : 'Name' in : - 'Value1' - 'Value2' IsLower # The isLower condition determines if the operand is a lowercase string. Syntax: isLower : <bool> When isLower: true , isLower will return true if the operand is a lowercase string. Non-letter characters are ignored. When isLower: false , isLower will return true if the operand is not a lowercase string. If the operand is a field, and the field does not exist isLower always returns false . For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleIsLower' spec : condition : field : 'Name' isLower : true --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleIsLower' spec : if : field : 'Name' isLower : true IsString # The isString condition determines if the operand is a string or other type. Syntax: isString : <bool> When isString: true , isString will return true if the operand is a string. When isString: false , isString will return true if the operand is not a string or is null. If the operand is a field, and the field does not exist isString always returns false . For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleIsString' spec : condition : field : 'Name' isString : true --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleIsString' spec : if : field : 'Name' isString : true IsArray # The isArray condition determines if the operand is an array or other type. Syntax: isArray : <bool> When isArray: true , isArray will return true if the operand is an array. When isArray: false , isArray will return true if the operand is not an array or null. If the operand is a field, and the field does not exist, isArray always returns false . For example: --- # Synopsis: Using isArray apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : IsArrayExample spec : if : field : 'Value' isArray : true IsBoolean # The isBoolean condition determines if the operand is a boolean or other type. convert - Optionally, types can be converted to boolean type. E.g. 'true' can be converted to true . By default convert is false . isBoolean : <bool> convert : <bool> When isBoolean: true , isBoolean will return true if the operand is a boolean. When isBoolean: false , isBoolean will return false if the operand is not a boolean or null. When convert: true , types will be converted to boolean before condition is evaluated. For example: --- # Synopsis: Using isBoolean apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : IsBooleanExample spec : if : field : 'Value' isBoolean : true --- # Synopsis: Using isBoolean with conversion apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : IsBooleanExampleWithConversion spec : if : field : 'Value' isBoolean : true convert : true IsDateTime # The isDateTime condition determines if the operand is a datetime or other type. convert - Optionally, types can be converted to datetime type. E.g. '2021-04-03T15:00:00.00+10:00' can be converted to a datetime. By default convert is false . isDateTime : <bool> convert : <bool> When isDateTime: true , isDateTime will return true if the operand is a datetime. When isDateTime: false , isDateTime will return false if the operand is not a datetime or null. When convert: true , types will be converted to datetime before condition is evaluated. For example: --- # Synopsis: Using isDateTime apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : IsDateTimeExample spec : if : field : 'Value' isDateTime : true --- # Synopsis: Using isDateTime with conversion apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : IsDateTimeExampleWithConversion spec : if : field : 'Value' isDateTime : true convert : true IsInteger # The isInteger condition determines if the operand is a an integer or other type. The following types are considered integer types int , long , byte . convert - Optionally, types can be converted to integer type. E.g. '123' can be converted to 123 . By default convert is false . isInteger : <bool> convert : <bool> When isInteger: true , isInteger will return true if the operand is an integer. When isInteger: false , isInteger will return false if the operand is not an integer or null. When convert: true , types will be converted to integer before condition is evaluated. For example: --- # Synopsis: Using isInteger apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : IsIntegerExample spec : if : field : 'Value' isInteger : true --- # Synopsis: Using isInteger with conversion apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : IsIntegerExampleWithConversion spec : if : field : 'Value' isInteger : true convert : true IsNumeric # The isNumeric condition determines if the operand is a a numeric or other type. The following types are considered numeric types int , long , float , byte , double . convert - Optionally, types can be converted to numeric type. E.g. '123' can be converted to 123 . By default convert is false . isNumeric : <bool> convert : <bool> When isNumeric: true , isNumeric will return true if the operand is a numeric. When isNumeric: false , isNumeric will return false if the operand is not a numeric or null. When convert: true , types will be converted to numeric before condition is evaluated. For example: --- # Synopsis: Using isNumeric apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : IsNumericExample spec : if : field : 'Value' isNumeric : true --- # Synopsis: Using isNumeric with conversion apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : IsNumercExampleWithConversion spec : if : field : 'Value' isNumeric : true convert : true IsUpper # The isUpper condition determines if the operand is an uppercase string. Syntax: isUpper : <bool> When isUpper: true , isUpper will return true if the operand is an uppercase string. Non-letter characters are ignored. When isUpper: false , isUpper will return true if the operand is not an uppercase string. If the operand is a field, and the field does not exist isUpper always returns false . For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleIsUpper' spec : condition : field : 'Name' isUpper : true --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleIsUpper' spec : if : field : 'Name' isUpper : true Less # The less condition determines if the operand is less than a supplied value. The field value can either be an integer, float, array, or string. convert - Optionally, perform type conversion on operand type. By default convert is false . When the field value is: An integer or float, a numerical comparison is used. An array, the number of elements is compared. A string, the length of the string is compared. If convert is true , the string is converted a number instead. A DateTime, the number of days from the current time is compared. Syntax: less : <int> convert : <boolean> For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleLess' spec : condition : field : 'Name' less : 3 --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleLess' spec : if : field : 'Name' less : 3 LessOrEquals # The lessOrEquals condition determines if the operand is less or equal to the supplied value. The field value can either be an integer, float, array, or string. convert - Optionally, perform type conversion on operand type. By default convert is false . When the field value is: An integer or float, a numerical comparison is used. An array, the number of elements is compared. A string, the length of the string is compared. If convert is true , the string is converted a number instead. A DateTime, the number of days from the current time is compared. Syntax: lessOrEquals : <int> convert : <boolean> For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleLessOrEquals' spec : condition : field : 'Name' lessOrEquals : 3 --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleLessOrEquals' spec : if : field : 'Name' lessOrEquals : 3 Like # The like condition can be used to determine if the operand matches a wildcard pattern. One or more patterns to compare can be specified. caseSensitive - Optionally, a case sensitive-comparison can be performed. By default, case-insensitive comparison is performed. convert - Optionally, types can be converted to string type. By default convert is false . Syntax: like : <string | array> caseSensitive : <boolean> convert : <boolean> If the operand is a field, and the field does not exist, like always returns false . For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleLike' spec : condition : anyOf : - field : 'url' like : 'http://*' - field : 'url' like : - 'http://*' - 'https://*' --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleLike' spec : if : anyOf : - field : 'url' like : 'http://*' - field : 'url' like : - 'http://*' - 'https://*' Match # The match condition can be used to compare if a field matches a supplied regular expression. Syntax: match : <string> For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleMatch' spec : condition : field : 'Name' match : '$(abc|efg)$' --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleMatch' spec : if : field : 'Name' match : '$(abc|efg)$' Name # The comparison property name is used with a condition to evaluate the target name of the object. The name property must be set to . . Any other value will cause the condition to evaluate to false . Syntax: name : '.' For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleName' spec : condition : name : '.' equals : 'TargetObject1' --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleName' spec : if : name : '.' in : - 'TargetObject1' - 'TargetObject2' Not # The any operator is used to invert the result of the nested expression. When a nested expression matches, not does not match. When a nested expression does not match, not matches. Syntax: not : <expression> For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleNot' spec : condition : not : # The AlternativeName field must not exist. field : 'AlternativeName' exists : true --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleNot' spec : if : not : # The AlternativeName field must not exist. field : 'AlternativeName' exists : true NotContains # The notContains condition can be used to determine if the operand contains a specified sub-string. This condition fails when any of the specified sub-strings are found in the operand. One or more strings to compare can be specified. caseSensitive - Optionally, a case sensitive-comparison can be performed. By default, case-insensitive comparison is performed. convert - Optionally, types can be converted to string type. By default convert is false . Syntax: notContains : <string | array> caseSensitive : <boolean> convert : <boolean> If the operand is a field, and the field does not exist, notContains always returns false . For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleNotContains' spec : condition : anyOf : - field : 'url' notContains : '/azure/' - field : 'url' notContains : - 'github.io' - 'github.com' --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleNotContains' spec : if : anyOf : - field : 'url' notContains : '/azure/' - field : 'url' notContains : - 'github.io' - 'github.com' NotCount # The notCount condition is used to determine if the operand does not contain a specified number of items. Syntax: notCount : <int> For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleNotCount' spec : condition : field : 'items' notCount : 2 --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleNotCount' spec : if : field : 'items' notCount : 2 NotEndsWith # The notEndsWith condition can be used to determine if the operand ends with a specified string. This condition fails when any of the specified sub-strings are found at the end of the operand. One or more strings to compare can be specified. caseSensitive - Optionally, a case sensitive-comparison can be performed. By default, case-insensitive comparison is performed. convert - Optionally, types can be converted to string type. By default convert is false . Syntax: notEndsWith : <string | array> caseSensitive : <boolean> convert : <boolean> If the operand is a field, and the field does not exist, notEndsWith always returns false . For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleNotEndsWith' spec : condition : anyOf : - field : 'hostname' notEndsWith : '.com' - field : 'hostname' notEndsWith : - '.com.au' - '.com' --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleNotEndsWith' spec : if : anyOf : - field : 'hostname' notEndsWith : '.com' - field : 'hostname' notEndsWith : - '.com.au' - '.com' NotEquals # The notEquals condition can be used to compare if a field is equal to a supplied value. caseSensitive - Optionally, a case sensitive-comparison can be performed. This only applies to string comparisons. By default, case-insensitive comparison is performed. convert - Optionally, perform type conversion on operand type. By default convert is false . Syntax: notEquals : <string | int | bool> caseSensitive : <boolean> convert : <boolean> For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleNotEquals' spec : condition : field : 'Name' notEquals : 'TargetObject1' --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleNotEquals' spec : if : field : 'Name' notEquals : 'TargetObject1' NotIn # The notIn condition can be used to compare if a field does not contains one of the specified values. Syntax: notIn : <array> For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleNotIn' spec : condition : field : 'Name' notIn : - 'Value1' - 'Value2' --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleNotIn' spec : if : field : 'Name' notIn : - 'Value1' - 'Value2' NotLike # The notLike condition can be used to determine if the operand matches a wildcard pattern. This condition fails when any of the specified patterns match the operand. One or more patterns to compare can be specified. caseSensitive - Optionally, a case sensitive-comparison can be performed. By default, case-insensitive comparison is performed. convert - Optionally, types can be converted to string type. By default convert is false . Syntax: notLike : <string | array> caseSensitive : <boolean> convert : <boolean> If the operand is a field, and the field does not exist, notLike always returns false . For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleNotLike' spec : condition : anyOf : - field : 'url' notLike : 'http://*' - field : 'url' notLike : - 'http://' - 'https://' --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleNotLike' spec : if : anyOf : - field : 'url' notLike : 'http://*' - field : 'url' notLike : - 'http://' - 'https://' NotMatch # The notMatch condition can be used to compare if a field does not matches a supplied regular expression. Syntax: notMatch : <string> For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleNotMatch' spec : condition : field : 'Name' notMatch : '$(abc|efg)$' --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleNotMatch' spec : if : field : 'Name' notMatch : '$(abc|efg)$' NotStartsWith # The notStartsWith condition can be used to determine if the operand starts with a specified string. This condition fails when any of the specified sub-strings are found at the start of the operand. One or more strings to compare can be specified. caseSensitive - Optionally, a case sensitive-comparison can be performed. By default, case-insensitive comparison is performed. convert - Optionally, types can be converted to string type. By default convert is false . Syntax: notStartsWith : <string | array> caseSensitive : <boolean> convert : <boolean> If the operand is a field, and the field does not exist, notStartsWith always returns false . For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleNotStartsWith' spec : condition : anyOf : - field : 'url' notStartsWith : 'http' - field : 'url' notStartsWith : - 'http://' - 'https://' --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleNotStartsWith' spec : if : anyOf : - field : 'url' notStartsWith : 'http' - field : 'url' notStartsWith : - 'http://' - 'https://' NotWithinPath # The notWithinPath condition determines if a file path is not within a required path. If the path is not within the required path, the condition will return true . If the path is within the required path, the condition will return false . The following properties are accepted: caseSensitive - Optionally, a case-sensitive comparison can be performed for string values. By default, case-insensitive comparison is performed. For example: --- # Synopsis: Test notWithinPath with source apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : YamlSourceNotWithinPath spec : if : source : 'Template' notWithinPath : - \"deployments/path/\" --- # Synopsis: Test notWithinPath with source and case sensitive apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : YamlSourceNotWithinPathCaseSensitive spec : if : source : 'Template' notWithinPath : - \"Deployments/Path/\" caseSensitive : true Scope # The comparison property scope is used with a condition to evaluate the scope of the object. The scope property must be set to . . Any other value will cause the condition to evaluate to false . Syntax: scope : '.' For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleScope' spec : condition : scope : '.' startsWith : '/' --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleScope' spec : if : scope : '.' startsWith : '/' SetOf # The setOf condition can be used to determine if the operand is a set of specified values. Additionally the following properties are accepted: caseSensitive - Optionally, a case sensitive-comparison can be performed. By default, case-insensitive comparison is performed. Syntax: setOf : <array> caseSensitive : <bool> For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleSetOf' spec : condition : field : 'zones' setOf : - 1 - 2 - 3 caseSensitive : false --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleSetOf' spec : if : field : 'zones' setOf : - 1 - 2 - 3 caseSensitive : false Source # The comparison property source is used with a condition to expose the source path for the resource. The source property can be set to any value. The default is file when objects loaded from a file don't identify a source. Syntax: source : 'file' For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : IgnoreTestFiles spec : if : source : 'file' withinPath : 'tests/PSRule.Tests/' StartsWith # The startsWith condition can be used to determine if the operand starts with a specified string. One or more strings to compare can be specified. caseSensitive - Optionally, a case sensitive-comparison can be performed. By default, case-insensitive comparison is performed. convert - Optionally, types can be converted to string type. By default convert is false . Syntax: startsWith : <string | array> caseSensitive : <boolean> convert : <boolean> If the operand is a field, and the field does not exist, startsWith always returns false . For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleStartsWith' spec : condition : anyOf : - field : 'url' startsWith : 'http' - field : 'url' startsWith : - 'http://' - 'https://' --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleStartsWith' spec : if : anyOf : - field : 'url' startsWith : 'http' - field : 'url' startsWith : - 'http://' - 'https://' Subset # The subset condition can be used to determine if the operand is a set of specified values. The following properties are accepted: caseSensitive - Optionally, a case-sensitive comparison can be performed. By default, case-insensitive comparison is performed. unique - Optionally, the operand must not contain duplicates. By default, duplicates are allowed. Syntax: subset : <array> caseSensitive : <bool> unique : <bool> For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleSubset' spec : condition : field : 'logs' subset : - 'cluster-autoscaler' - 'kube-apiserver' - 'kube-scheduler' caseSensitive : true unique : true --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleSubset' spec : if : field : 'logs' subset : - 'cluster-autoscaler' - 'kube-apiserver' - 'kube-scheduler' caseSensitive : true unique : true Type # The comparison property type is used with a condition to evaluate the target type of the object. The type property must be set to . . Any other value will cause the condition to evaluate to false . Syntax: type : '.' For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleType' spec : condition : type : '.' equals : 'CustomType' --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleType' spec : if : type : '.' in : - 'Microsoft.Storage/storageAccounts' - 'Microsoft.Storage/storageAccounts/blobServices' Version # The version condition determines if the operand is a valid semantic version. A constraint can optionally be provided to require the semantic version to be within a range. Supported version constraints for expression are the same as the $Assert.Version assertion helper. Syntax: version : <string> includePrerelease : <bool> For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleVersion' spec : condition : field : 'engine.version' version : '^1.2.3' --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleAnyVersion' spec : if : field : 'engine.version' version : '' --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleVersionIncludingPrerelease' spec : if : field : 'engine.version' version : '>=1.5.0' includePrerelease : true WithinPath # The withinPath condition determines if a file path is within a required path. If the path is within the required path, the condition will return true . If the path is not within the required path, the condition will return false . The following properties are accepted: caseSensitive - Optionally, a case-sensitive comparison can be performed for string values. By default, case-insensitive comparison is performed. For example: --- # Synopsis: Test withinPath with source apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : YamlSourceWithinPath spec : if : source : 'Template' withinPath : - \"deployments/path/\" --- # Synopsis: Test withinPath with source and case sensitive apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : YamlSourceWithinPathCaseSensitive spec : if : source : 'Template' withinPath : - \"Deployments/Path/\" caseSensitive : true Links # Invoke-PSRule","title":"Expressions"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/#expressions","text":"Describes PSRule expressions and how to use them.","title":"Expressions"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/#description","text":"PSRule expressions are used within YAML-based rules or selectors to evaluate an object. Expressions are comprised of nested conditions, operators, and comparison properties. The following conditions are available: Contains Count Equals EndsWith Exists Greater GreaterOrEquals HasDefault HasSchema HasValue In IsLower IsString IsArray IsBoolean IsDateTime IsInteger IsNumeric IsUpper Less LessOrEquals Like Match NotContains NotCount NotEndsWith NotEquals NotIn NotLike NotMatch NotStartsWith NotWithinPath SetOf StartsWith Subset WithinPath Version The following operators are available: AllOf AnyOf Not The following comparison properties are available: Field Name Scope Source Type","title":"Description"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/#allof","text":"The allOf operator is used to require all nested expressions to match. When any nested expression does not match, allOf does not match. This is similar to a logical and operation. Syntax: allOf : <expression[]> For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleAllOf' spec : condition : allOf : # Both Name and Description must exist. - field : 'Name' exists : true - field : 'Description' exists : true --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleAllOf' spec : if : allOf : # Both Name and Description must exist. - field : 'Name' exists : true - field : 'Description' exists : true","title":"AllOf"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/#anyof","text":"The anyOf operator is used to require one or more nested expressions to match. When any nested expression matches, allOf matches. This is similar to a logical or operation. Syntax: anyOf : <expression[]> For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleAnyOf' spec : condition : anyOf : # Name and/ or AlternativeName must exist. - field : 'Name' exists : true - field : 'AlternativeName' exists : true --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleAnyOf' spec : if : anyOf : # Name and/ or AlternativeName must exist. - field : 'Name' exists : true - field : 'AlternativeName' exists : true","title":"AnyOf"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/#contains","text":"The contains condition can be used to determine if the operand contains a specified sub-string. One or more strings to compare can be specified. caseSensitive - Optionally, a case sensitive-comparison can be performed. By default, case-insensitive comparison is performed. convert - Optionally, types can be converted to string type. By default convert is false . Syntax: contains : <string | array> caseSensitive : <boolean> convert : <boolean> If the operand is a field, and the field does not exist, contains always returns false . For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleContains' spec : condition : anyOf : - field : 'url' contains : '/azure/' - field : 'url' contains : - 'github.io' - 'github.com' --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleContains' spec : if : anyOf : - field : 'url' contains : '/azure/' - field : 'url' contains : - 'github.io' - 'github.com'","title":"Contains"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/#count","text":"The count condition is used to determine if the operand contains a specified number of items. Syntax: count : <int> For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleCount' spec : condition : field : 'items' count : 2 --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleCount' spec : if : field : 'items' count : 2","title":"Count"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/#equals","text":"The equals condition can be used to compare if the operand is equal to a supplied value. caseSensitive - Optionally, a case sensitive-comparison can be performed. This only applies to string comparisons. By default, case-insensitive comparison is performed. convert - Optionally, perform type conversion on operand type. By default convert is false . Syntax: equals : <string | int | bool> caseSensitive : <boolean> convert : <boolean> For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleEquals' spec : condition : field : 'Name' equals : 'TargetObject1' --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleEquals' spec : if : field : 'Name' equals : 'TargetObject1'","title":"Equals"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/#endswith","text":"The endsWith condition can be used to determine if the operand ends with a specified string. One or more strings to compare can be specified. caseSensitive - Optionally, a case sensitive-comparison can be performed. By default, case-insensitive comparison is performed. convert - Optionally, types can be converted to string type. By default convert is false . Syntax: endsWith : <string | array> caseSensitive : <boolean> convert : <boolean> If the operand is a field, and the field does not exist, endsWith always returns false . For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleEndsWith' spec : condition : anyOf : - field : 'hostname' endsWith : '.com' - field : 'hostname' endsWith : - '.com.au' - '.com' --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleEndsWith' spec : if : anyOf : - field : 'hostname' endsWith : '.com' - field : 'hostname' endsWith : - '.com.au' - '.com'","title":"EndsWith"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/#exists","text":"The exists condition determines if the specified field exists. Syntax: exists : <bool> When exists: true , exists will return true if the field exists. When exists: false , exists will return true if the field does not exist. For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleExists' spec : condition : field : 'Name' exists : true --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleExists' spec : if : field : 'Name' exists : true","title":"Exists"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/#field","text":"The comparison property field is used with a condition to determine field of the object to evaluate. A field can be: A property name. A key within a hashtable or dictionary. An index in an array or collection. A nested path through an object. Syntax: field : <string> For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleField' spec : condition : field : 'Properties.securityRules[0].name' exists : true --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleField' spec : if : field : 'Properties.securityRules[0].name' exists : true","title":"Field"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/#greater","text":"The greater condition determines if the operand is greater than a supplied value. The field value can either be an integer, float, array, or string. convert - Optionally, perform type conversion on operand type. By default convert is false . When the field value is: An integer or float, a numerical comparison is used. An array, the number of elements is compared. A string, the length of the string is compared. If convert is true , the string is converted a number instead. A DateTime, the number of days from the current time is compared. Syntax: greater : <int> convert : <boolean> For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleGreater' spec : condition : field : 'Name' greater : 3 --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleGreater' spec : if : field : 'Name' greater : 3","title":"Greater"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/#greaterorequals","text":"The greaterOrEquals condition determines if the operand is greater or equal to the supplied value. The field value can either be an integer, float, array, or string. convert - Optionally, perform type conversion on operand type. By default convert is false . When the field value is: An integer or float, a numerical comparison is used. An array, the number of elements is compared. A string, the length of the string is compared. If convert is true , the string is converted a number instead. A DateTime, the number of days from the current time is compared. Syntax: greaterOrEquals : <int> convert : <boolean> For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleGreaterOrEquals' spec : condition : field : 'Name' greaterOrEquals : 3 --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleGreaterOrEquals' spec : if : field : 'Name' greaterOrEquals : 3","title":"GreaterOrEquals"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/#hasdefault","text":"The hasDefault condition determines if the field exists that it is set to the specified value. If the field does not exist, the condition will return true . The following properties are accepted: caseSensitive - Optionally, a case-sensitive comparison can be performed for string values. By default, case-insensitive comparison is performed. Syntax: hasDefault : <string | int | bool> caseSensitive : <bool> For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleHasDefault' spec : condition : field : 'enabled' hasDefault : true --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleHasDefault' spec : if : field : 'enabled' hasDefault : true","title":"HasDefault"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/#hasschema","text":"The hasSchema condition determines if the operand has a $schema property defined. If the $schema property is defined, it must match one of the specified schemas. If a trailing # is specified it is ignored. The following properties are accepted: caseSensitive - Optionally, a case-sensitive comparison can be performed. By default, case-insensitive comparison is performed. ignoreScheme - Optionally, the URI scheme is ignored in the comparison. By default, the scheme is compared. When true , the schema will match if either http:// or https:// is specified. Syntax: hasSchema : <array> caseSensitive : <bool> ignoreScheme : <bool> When hasSchema: [] , hasSchema will return true if any non-empty $schema property is defined. For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleHasSchema' spec : condition : field : '.' hasSchema : - https://schema.management.azure.com/schemas/2019-04-01/deploymentParameters.json# --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleHasSchema' spec : if : field : '.' hasSchema : - https://schema.management.azure.com/schemas/2019-04-01/deploymentParameters.json# - https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json# ignoreScheme : true --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleHasAnySchema' spec : if : field : '.' hasSchema : []","title":"HasSchema"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/#hasvalue","text":"The hasValue condition determines if the field exists and has a non-empty value. Syntax: hasValue : <bool> When hasValue: true , hasValue will return true if the field is not empty. When hasValue: false , hasValue will return true if the field is empty. For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleHasValue' spec : condition : field : 'Name' hasValue : true --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleHasValue' spec : if : field : 'Name' hasValue : true","title":"HasValue"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/#in","text":"The in condition can be used to compare if a field contains one of the specified values. Syntax: in : <array> For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleIn' spec : condition : field : 'Name' in : - 'Value1' - 'Value2' --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleIn' spec : if : field : 'Name' in : - 'Value1' - 'Value2'","title":"In"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/#islower","text":"The isLower condition determines if the operand is a lowercase string. Syntax: isLower : <bool> When isLower: true , isLower will return true if the operand is a lowercase string. Non-letter characters are ignored. When isLower: false , isLower will return true if the operand is not a lowercase string. If the operand is a field, and the field does not exist isLower always returns false . For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleIsLower' spec : condition : field : 'Name' isLower : true --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleIsLower' spec : if : field : 'Name' isLower : true","title":"IsLower"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/#isstring","text":"The isString condition determines if the operand is a string or other type. Syntax: isString : <bool> When isString: true , isString will return true if the operand is a string. When isString: false , isString will return true if the operand is not a string or is null. If the operand is a field, and the field does not exist isString always returns false . For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleIsString' spec : condition : field : 'Name' isString : true --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleIsString' spec : if : field : 'Name' isString : true","title":"IsString"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/#isarray","text":"The isArray condition determines if the operand is an array or other type. Syntax: isArray : <bool> When isArray: true , isArray will return true if the operand is an array. When isArray: false , isArray will return true if the operand is not an array or null. If the operand is a field, and the field does not exist, isArray always returns false . For example: --- # Synopsis: Using isArray apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : IsArrayExample spec : if : field : 'Value' isArray : true","title":"IsArray"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/#isboolean","text":"The isBoolean condition determines if the operand is a boolean or other type. convert - Optionally, types can be converted to boolean type. E.g. 'true' can be converted to true . By default convert is false . isBoolean : <bool> convert : <bool> When isBoolean: true , isBoolean will return true if the operand is a boolean. When isBoolean: false , isBoolean will return false if the operand is not a boolean or null. When convert: true , types will be converted to boolean before condition is evaluated. For example: --- # Synopsis: Using isBoolean apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : IsBooleanExample spec : if : field : 'Value' isBoolean : true --- # Synopsis: Using isBoolean with conversion apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : IsBooleanExampleWithConversion spec : if : field : 'Value' isBoolean : true convert : true","title":"IsBoolean"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/#isdatetime","text":"The isDateTime condition determines if the operand is a datetime or other type. convert - Optionally, types can be converted to datetime type. E.g. '2021-04-03T15:00:00.00+10:00' can be converted to a datetime. By default convert is false . isDateTime : <bool> convert : <bool> When isDateTime: true , isDateTime will return true if the operand is a datetime. When isDateTime: false , isDateTime will return false if the operand is not a datetime or null. When convert: true , types will be converted to datetime before condition is evaluated. For example: --- # Synopsis: Using isDateTime apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : IsDateTimeExample spec : if : field : 'Value' isDateTime : true --- # Synopsis: Using isDateTime with conversion apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : IsDateTimeExampleWithConversion spec : if : field : 'Value' isDateTime : true convert : true","title":"IsDateTime"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/#isinteger","text":"The isInteger condition determines if the operand is a an integer or other type. The following types are considered integer types int , long , byte . convert - Optionally, types can be converted to integer type. E.g. '123' can be converted to 123 . By default convert is false . isInteger : <bool> convert : <bool> When isInteger: true , isInteger will return true if the operand is an integer. When isInteger: false , isInteger will return false if the operand is not an integer or null. When convert: true , types will be converted to integer before condition is evaluated. For example: --- # Synopsis: Using isInteger apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : IsIntegerExample spec : if : field : 'Value' isInteger : true --- # Synopsis: Using isInteger with conversion apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : IsIntegerExampleWithConversion spec : if : field : 'Value' isInteger : true convert : true","title":"IsInteger"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/#isnumeric","text":"The isNumeric condition determines if the operand is a a numeric or other type. The following types are considered numeric types int , long , float , byte , double . convert - Optionally, types can be converted to numeric type. E.g. '123' can be converted to 123 . By default convert is false . isNumeric : <bool> convert : <bool> When isNumeric: true , isNumeric will return true if the operand is a numeric. When isNumeric: false , isNumeric will return false if the operand is not a numeric or null. When convert: true , types will be converted to numeric before condition is evaluated. For example: --- # Synopsis: Using isNumeric apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : IsNumericExample spec : if : field : 'Value' isNumeric : true --- # Synopsis: Using isNumeric with conversion apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : IsNumercExampleWithConversion spec : if : field : 'Value' isNumeric : true convert : true","title":"IsNumeric"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/#isupper","text":"The isUpper condition determines if the operand is an uppercase string. Syntax: isUpper : <bool> When isUpper: true , isUpper will return true if the operand is an uppercase string. Non-letter characters are ignored. When isUpper: false , isUpper will return true if the operand is not an uppercase string. If the operand is a field, and the field does not exist isUpper always returns false . For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleIsUpper' spec : condition : field : 'Name' isUpper : true --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleIsUpper' spec : if : field : 'Name' isUpper : true","title":"IsUpper"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/#less","text":"The less condition determines if the operand is less than a supplied value. The field value can either be an integer, float, array, or string. convert - Optionally, perform type conversion on operand type. By default convert is false . When the field value is: An integer or float, a numerical comparison is used. An array, the number of elements is compared. A string, the length of the string is compared. If convert is true , the string is converted a number instead. A DateTime, the number of days from the current time is compared. Syntax: less : <int> convert : <boolean> For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleLess' spec : condition : field : 'Name' less : 3 --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleLess' spec : if : field : 'Name' less : 3","title":"Less"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/#lessorequals","text":"The lessOrEquals condition determines if the operand is less or equal to the supplied value. The field value can either be an integer, float, array, or string. convert - Optionally, perform type conversion on operand type. By default convert is false . When the field value is: An integer or float, a numerical comparison is used. An array, the number of elements is compared. A string, the length of the string is compared. If convert is true , the string is converted a number instead. A DateTime, the number of days from the current time is compared. Syntax: lessOrEquals : <int> convert : <boolean> For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleLessOrEquals' spec : condition : field : 'Name' lessOrEquals : 3 --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleLessOrEquals' spec : if : field : 'Name' lessOrEquals : 3","title":"LessOrEquals"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/#like","text":"The like condition can be used to determine if the operand matches a wildcard pattern. One or more patterns to compare can be specified. caseSensitive - Optionally, a case sensitive-comparison can be performed. By default, case-insensitive comparison is performed. convert - Optionally, types can be converted to string type. By default convert is false . Syntax: like : <string | array> caseSensitive : <boolean> convert : <boolean> If the operand is a field, and the field does not exist, like always returns false . For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleLike' spec : condition : anyOf : - field : 'url' like : 'http://*' - field : 'url' like : - 'http://*' - 'https://*' --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleLike' spec : if : anyOf : - field : 'url' like : 'http://*' - field : 'url' like : - 'http://*' - 'https://*'","title":"Like"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/#match","text":"The match condition can be used to compare if a field matches a supplied regular expression. Syntax: match : <string> For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleMatch' spec : condition : field : 'Name' match : '$(abc|efg)$' --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleMatch' spec : if : field : 'Name' match : '$(abc|efg)$'","title":"Match"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/#name","text":"The comparison property name is used with a condition to evaluate the target name of the object. The name property must be set to . . Any other value will cause the condition to evaluate to false . Syntax: name : '.' For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleName' spec : condition : name : '.' equals : 'TargetObject1' --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleName' spec : if : name : '.' in : - 'TargetObject1' - 'TargetObject2'","title":"Name"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/#not","text":"The any operator is used to invert the result of the nested expression. When a nested expression matches, not does not match. When a nested expression does not match, not matches. Syntax: not : <expression> For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleNot' spec : condition : not : # The AlternativeName field must not exist. field : 'AlternativeName' exists : true --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleNot' spec : if : not : # The AlternativeName field must not exist. field : 'AlternativeName' exists : true","title":"Not"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/#notcontains","text":"The notContains condition can be used to determine if the operand contains a specified sub-string. This condition fails when any of the specified sub-strings are found in the operand. One or more strings to compare can be specified. caseSensitive - Optionally, a case sensitive-comparison can be performed. By default, case-insensitive comparison is performed. convert - Optionally, types can be converted to string type. By default convert is false . Syntax: notContains : <string | array> caseSensitive : <boolean> convert : <boolean> If the operand is a field, and the field does not exist, notContains always returns false . For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleNotContains' spec : condition : anyOf : - field : 'url' notContains : '/azure/' - field : 'url' notContains : - 'github.io' - 'github.com' --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleNotContains' spec : if : anyOf : - field : 'url' notContains : '/azure/' - field : 'url' notContains : - 'github.io' - 'github.com'","title":"NotContains"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/#notcount","text":"The notCount condition is used to determine if the operand does not contain a specified number of items. Syntax: notCount : <int> For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleNotCount' spec : condition : field : 'items' notCount : 2 --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleNotCount' spec : if : field : 'items' notCount : 2","title":"NotCount"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/#notendswith","text":"The notEndsWith condition can be used to determine if the operand ends with a specified string. This condition fails when any of the specified sub-strings are found at the end of the operand. One or more strings to compare can be specified. caseSensitive - Optionally, a case sensitive-comparison can be performed. By default, case-insensitive comparison is performed. convert - Optionally, types can be converted to string type. By default convert is false . Syntax: notEndsWith : <string | array> caseSensitive : <boolean> convert : <boolean> If the operand is a field, and the field does not exist, notEndsWith always returns false . For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleNotEndsWith' spec : condition : anyOf : - field : 'hostname' notEndsWith : '.com' - field : 'hostname' notEndsWith : - '.com.au' - '.com' --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleNotEndsWith' spec : if : anyOf : - field : 'hostname' notEndsWith : '.com' - field : 'hostname' notEndsWith : - '.com.au' - '.com'","title":"NotEndsWith"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/#notequals","text":"The notEquals condition can be used to compare if a field is equal to a supplied value. caseSensitive - Optionally, a case sensitive-comparison can be performed. This only applies to string comparisons. By default, case-insensitive comparison is performed. convert - Optionally, perform type conversion on operand type. By default convert is false . Syntax: notEquals : <string | int | bool> caseSensitive : <boolean> convert : <boolean> For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleNotEquals' spec : condition : field : 'Name' notEquals : 'TargetObject1' --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleNotEquals' spec : if : field : 'Name' notEquals : 'TargetObject1'","title":"NotEquals"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/#notin","text":"The notIn condition can be used to compare if a field does not contains one of the specified values. Syntax: notIn : <array> For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleNotIn' spec : condition : field : 'Name' notIn : - 'Value1' - 'Value2' --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleNotIn' spec : if : field : 'Name' notIn : - 'Value1' - 'Value2'","title":"NotIn"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/#notlike","text":"The notLike condition can be used to determine if the operand matches a wildcard pattern. This condition fails when any of the specified patterns match the operand. One or more patterns to compare can be specified. caseSensitive - Optionally, a case sensitive-comparison can be performed. By default, case-insensitive comparison is performed. convert - Optionally, types can be converted to string type. By default convert is false . Syntax: notLike : <string | array> caseSensitive : <boolean> convert : <boolean> If the operand is a field, and the field does not exist, notLike always returns false . For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleNotLike' spec : condition : anyOf : - field : 'url' notLike : 'http://*' - field : 'url' notLike : - 'http://' - 'https://' --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleNotLike' spec : if : anyOf : - field : 'url' notLike : 'http://*' - field : 'url' notLike : - 'http://' - 'https://'","title":"NotLike"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/#notmatch","text":"The notMatch condition can be used to compare if a field does not matches a supplied regular expression. Syntax: notMatch : <string> For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleNotMatch' spec : condition : field : 'Name' notMatch : '$(abc|efg)$' --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleNotMatch' spec : if : field : 'Name' notMatch : '$(abc|efg)$'","title":"NotMatch"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/#notstartswith","text":"The notStartsWith condition can be used to determine if the operand starts with a specified string. This condition fails when any of the specified sub-strings are found at the start of the operand. One or more strings to compare can be specified. caseSensitive - Optionally, a case sensitive-comparison can be performed. By default, case-insensitive comparison is performed. convert - Optionally, types can be converted to string type. By default convert is false . Syntax: notStartsWith : <string | array> caseSensitive : <boolean> convert : <boolean> If the operand is a field, and the field does not exist, notStartsWith always returns false . For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleNotStartsWith' spec : condition : anyOf : - field : 'url' notStartsWith : 'http' - field : 'url' notStartsWith : - 'http://' - 'https://' --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleNotStartsWith' spec : if : anyOf : - field : 'url' notStartsWith : 'http' - field : 'url' notStartsWith : - 'http://' - 'https://'","title":"NotStartsWith"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/#notwithinpath","text":"The notWithinPath condition determines if a file path is not within a required path. If the path is not within the required path, the condition will return true . If the path is within the required path, the condition will return false . The following properties are accepted: caseSensitive - Optionally, a case-sensitive comparison can be performed for string values. By default, case-insensitive comparison is performed. For example: --- # Synopsis: Test notWithinPath with source apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : YamlSourceNotWithinPath spec : if : source : 'Template' notWithinPath : - \"deployments/path/\" --- # Synopsis: Test notWithinPath with source and case sensitive apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : YamlSourceNotWithinPathCaseSensitive spec : if : source : 'Template' notWithinPath : - \"Deployments/Path/\" caseSensitive : true","title":"NotWithinPath"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/#scope","text":"The comparison property scope is used with a condition to evaluate the scope of the object. The scope property must be set to . . Any other value will cause the condition to evaluate to false . Syntax: scope : '.' For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleScope' spec : condition : scope : '.' startsWith : '/' --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleScope' spec : if : scope : '.' startsWith : '/'","title":"Scope"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/#setof","text":"The setOf condition can be used to determine if the operand is a set of specified values. Additionally the following properties are accepted: caseSensitive - Optionally, a case sensitive-comparison can be performed. By default, case-insensitive comparison is performed. Syntax: setOf : <array> caseSensitive : <bool> For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleSetOf' spec : condition : field : 'zones' setOf : - 1 - 2 - 3 caseSensitive : false --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleSetOf' spec : if : field : 'zones' setOf : - 1 - 2 - 3 caseSensitive : false","title":"SetOf"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/#source","text":"The comparison property source is used with a condition to expose the source path for the resource. The source property can be set to any value. The default is file when objects loaded from a file don't identify a source. Syntax: source : 'file' For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : IgnoreTestFiles spec : if : source : 'file' withinPath : 'tests/PSRule.Tests/'","title":"Source"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/#startswith","text":"The startsWith condition can be used to determine if the operand starts with a specified string. One or more strings to compare can be specified. caseSensitive - Optionally, a case sensitive-comparison can be performed. By default, case-insensitive comparison is performed. convert - Optionally, types can be converted to string type. By default convert is false . Syntax: startsWith : <string | array> caseSensitive : <boolean> convert : <boolean> If the operand is a field, and the field does not exist, startsWith always returns false . For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleStartsWith' spec : condition : anyOf : - field : 'url' startsWith : 'http' - field : 'url' startsWith : - 'http://' - 'https://' --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleStartsWith' spec : if : anyOf : - field : 'url' startsWith : 'http' - field : 'url' startsWith : - 'http://' - 'https://'","title":"StartsWith"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/#subset","text":"The subset condition can be used to determine if the operand is a set of specified values. The following properties are accepted: caseSensitive - Optionally, a case-sensitive comparison can be performed. By default, case-insensitive comparison is performed. unique - Optionally, the operand must not contain duplicates. By default, duplicates are allowed. Syntax: subset : <array> caseSensitive : <bool> unique : <bool> For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleSubset' spec : condition : field : 'logs' subset : - 'cluster-autoscaler' - 'kube-apiserver' - 'kube-scheduler' caseSensitive : true unique : true --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleSubset' spec : if : field : 'logs' subset : - 'cluster-autoscaler' - 'kube-apiserver' - 'kube-scheduler' caseSensitive : true unique : true","title":"Subset"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/#type","text":"The comparison property type is used with a condition to evaluate the target type of the object. The type property must be set to . . Any other value will cause the condition to evaluate to false . Syntax: type : '.' For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleType' spec : condition : type : '.' equals : 'CustomType' --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleType' spec : if : type : '.' in : - 'Microsoft.Storage/storageAccounts' - 'Microsoft.Storage/storageAccounts/blobServices'","title":"Type"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/#version","text":"The version condition determines if the operand is a valid semantic version. A constraint can optionally be provided to require the semantic version to be within a range. Supported version constraints for expression are the same as the $Assert.Version assertion helper. Syntax: version : <string> includePrerelease : <bool> For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleVersion' spec : condition : field : 'engine.version' version : '^1.2.3' --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleAnyVersion' spec : if : field : 'engine.version' version : '' --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleVersionIncludingPrerelease' spec : if : field : 'engine.version' version : '>=1.5.0' includePrerelease : true","title":"Version"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/#withinpath","text":"The withinPath condition determines if a file path is within a required path. If the path is within the required path, the condition will return true . If the path is not within the required path, the condition will return false . The following properties are accepted: caseSensitive - Optionally, a case-sensitive comparison can be performed for string values. By default, case-insensitive comparison is performed. For example: --- # Synopsis: Test withinPath with source apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : YamlSourceWithinPath spec : if : source : 'Template' withinPath : - \"deployments/path/\" --- # Synopsis: Test withinPath with source and case sensitive apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : YamlSourceWithinPathCaseSensitive spec : if : source : 'Template' withinPath : - \"Deployments/Path/\" caseSensitive : true","title":"WithinPath"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/#links","text":"Invoke-PSRule","title":"Links"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/","text":"Options # Describes additional options that can be used during rule execution. Description # PSRule lets you use options when calling cmdlets such as Invoke-PSRule and Test-PSRuleTarget to change how rules are processed. This topic describes what options are available, when to and how to use them. The following workspace options are available for use: Convention.Include Execution.AliasReferenceWarning Execution.DuplicateResourceId Execution.LanguageMode Execution.InconclusiveWarning Execution.InvariantCultureWarning Execution.InitialSessionState Execution.NotProcessedWarning Execution.SuppressedRuleWarning Execution.SuppressionGroupExpired Include.Module Include.Path Input.Format Input.IgnoreGitPath Input.IgnoreObjectSource Input.IgnoreRepositoryCommon Input.IgnoreUnchangedPath Input.ObjectPath Input.PathIgnore Input.TargetType Logging.LimitDebug Logging.LimitVerbose Logging.RuleFail Logging.RulePass Output.As Output.Banner Output.Culture Output.Encoding Output.Footer Output.Format Output.JobSummaryPath Output.JsonIndent Output.Outcome Output.Path Output.SarifProblemsOnly Output.Style Repository.BaseRef Repository.Url Requires Suppression Additionally the following baseline options can be included: Binding.Field Binding.IgnoreCase Binding.NameSeparator Binding.PreferTargetInfo Binding.TargetName Binding.TargetType Binding.UseQualifiedName Configuration Rule.Baseline Rule.Include Rule.IncludeLocal Rule.Exclude Rule.Tag See about_PSRule_Baseline for more information on baseline options. Options can be used with the following PSRule cmdlets: Export-PSRuleBaseline Get-PSRule Get-PSRuleBaseline Get-PSRuleHelp Invoke-PSRule Test-PSRuleTarget Each of these cmdlets support: Using the -Option parameter with an object created with the New-PSRuleOption cmdlet. See cmdlet help for syntax and examples. Using the -Option parameter with a hashtable object. Using the -Option parameter with a YAML file path. When using a hashtable object @{} , one or more options can be specified as keys using a dotted notation. For example: $option = @{ 'Output.Format' = 'Yaml' }; Invoke-PSRule -Path . -Option $option ; Invoke-PSRule -Path . -Option @{ 'Output.Format' = 'Yaml' }; The above example shows how the Output.Format option as a hashtable key can be used. Continue reading for a full list of options and how each can be used. Alternatively, options can be stored in a YAML formatted file and loaded from disk. Storing options as YAML allows different configurations to be loaded in a repeatable way instead of having to create an options object each time. Options are stored as YAML properties using a lower camel case naming convention, for example: output : format : Yaml The Set-PSRuleOption cmdlet can be used to set options stored in YAML or the YAML file can be manually edited. Set-PSRuleOption -OutputFormat Yaml ; By default, PSRule will automatically look for a default YAML options file in the current working directory. Alternatively, you can specify a specific file path. For example: Invoke-PSRule -Option '.\\myconfig.yml' ; New-PSRuleOption -Path '.\\myconfig.yaml' ; PSRule uses any of the following file names (in order) as the default YAML options file. If more than one of these files exist, the following order will be used to find the first match. ps-rule.yaml ps-rule.yml psrule.yaml psrule.yml We recommend only using lowercase characters as shown above. This is because not all operating systems treat case in the same way. Most options can be set using environment variables. When configuring environment variables we recommend that all capital letters are used. This is because environment variables are case-sensitive on some operating systems. PSRule environment variables use a consistent naming pattern of PSRULE_<PARENT>_<NAME> . Where <PARENT> is the parent class and <NAME> is the specific option. For example: Execution.InconclusiveWarning is configured by PSRULE_EXECUTION_INCONCLUSIVEWARNING . Input.TargetType is configured by PSRULE_INPUT_TARGETTYPE . Output.Format is configured by PSRULE_OUTPUT_FORMAT . When setting environment variables: Enum values are set by string. For example PSRULE_OUTPUT_FORMAT could be set to Yaml . Enum values are case-insensitive. Boolean values are set by true , false , 1 , or 0 . For example PSRULE_EXECUTION_INCONCLUSIVEWARNING could be set to false . Boolean values are case-insensitive. String array values can specify multiple items by using a semi-colon separator. For example PSRULE_INPUT_TARGETTYPE could be set to virtualMachine;virtualNetwork . Binding.Field # When an object is passed from the pipeline, PSRule automatically extracts fields from object properties. PSRule provides standard fields such as TargetName and TargetType . In addition to standard fields, custom fields can be bound. Custom fields are available to rules and included in output. PSRule uses the following logic to determine which property should be used for binding: By default PSRule will not extract any custom fields. If custom fields are configured, PSRule will attempt to bind the field. If none of the configured property names exist, the field will be skipped. If more then one property name is configured, the order they are specified in the configuration determines precedence. i.e. The first configured property name will take precedence over the second property name. By default the property name will be matched ignoring case sensitivity. To use a case sensitive match, configure the Binding.IgnoreCase option. Custom field bindings can be specified using: # PowerShell: Using the BindingField parameter $option = New-PSRuleOption -BindingField @{ id = 'ResourceId' , 'AlternativeId' }; # PowerShell: Using the Binding.Field hashtable key $option = New-PSRuleOption -Option @{ 'Binding.Field' = @{ id = 'ResourceId' , 'AlternativeId' } }; # PowerShell: Using the BindingField parameter to set YAML Set-PSRuleOption -BindingField @{ id = 'ResourceId' , 'AlternativeId' }; # YAML: Using the binding/field property binding : field : id : - ResourceId - AlternativeId Binding.IgnoreCase # When evaluating an object, PSRule extracts a few key properties from the object to help filter rules and display output results. The process of extract these key properties is called binding . The properties that PSRule uses for binding can be customized by providing a order list of alternative properties to use. See Binding.TargetName and Binding.TargetType for these options. By default, custom property binding finds the first matching property by name regardless of case. i.e. Binding.IgnoreCase is true . To make custom bindings case sensitive, set the Binding.IgnoreCase option to false . Changing this option will affect custom property bindings for both TargetName and TargetType . Setting this option has no affect on binding defaults or custom scripts. This option can be specified using: # PowerShell: Using the BindingIgnoreCase parameter $option = New-PSRuleOption -BindingIgnoreCase $False ; # PowerShell: Using the Binding.IgnoreCase hashtable key $option = New-PSRuleOption -Option @{ 'Binding.IgnoreCase' = $False }; # PowerShell: Using the BindingIgnoreCase parameter to set YAML Set-PSRuleOption -BindingIgnoreCase $False ; # YAML: Using the binding/ignoreCase property binding : ignoreCase : false # Bash: Using environment variable export PSRULE_BINDING_IGNORECASE = false # GitHub Actions: Using environment variable env : PSRULE_BINDING_IGNORECASE : false # Azure Pipelines: Using environment variable variables : - name : PSRULE_BINDING_IGNORECASE value : false Binding.NameSeparator # When an object is passed from the pipeline, PSRule assigns the object a TargetName . TargetName is used in output results to identify one object from another. In cases where different types of objects share the same TargetName , this may become confusing. Using a qualified name, prefixes the TargetName with TargetType . i.e. TargetType/TargetName To use a qualified name, see the Binding.UseQualifiedName option. By default, PSRule uses / to separate TargetType from TargetName . This option configures the separator that PSRule uses between the two components. This option can be specified using: # PowerShell: Using the BindingNameSeparator parameter $option = New-PSRuleOption -BindingNameSeparator '::' ; # PowerShell: Using the Binding.NameSeparator hashtable key $option = New-PSRuleOption -Option @{ 'Binding.NameSeparator' = '::' }; # PowerShell: Using the BindingNameSeparator parameter to set YAML Set-PSRuleOption -BindingNameSeparator '::' ; # YAML: Using the binding/nameSeparator property binding : nameSeparator : '::' # Bash: Using environment variable export PSRULE_BINDING_NAMESEPARATOR = '::' # GitHub Actions: Using environment variable env : PSRULE_BINDING_NAMESEPARATOR : '::' # Azure Pipelines: Using environment variable variables : - name : PSRULE_BINDING_NAMESEPARATOR value : '::' Binding.PreferTargetInfo # Some built-in objects within PSRule perform automatic binding of TargetName and TargetType. These built-in objects provide their own target info. When binding has been configured these values override automatic binding by default. This can occur when the built-in object uses one of the fields specified by the custom configuration. The common occurrences of this are on fields such as Name and FullName which are widely used. To prefer automatic binding when specified set this option to $True . This option can be specified using: # PowerShell: Using the BindingPreferTargetInfo parameter $option = New-PSRuleOption -BindingPreferTargetInfo $True ; # PowerShell: Using the Binding.PreferTargetInfo hashtable key $option = New-PSRuleOption -Option @{ 'Binding.PreferTargetInfo' = $True }; # PowerShell: Using the BindingPreferTargetInfo parameter to set YAML Set-PSRuleOption -BindingPreferTargetInfo $True ; # YAML: Using the binding/preferTargetInfo property binding : preferTargetInfo : true # Bash: Using environment variable export PSRULE_BINDING_PREFERTARGETINFO = false # GitHub Actions: Using environment variable env : PSRULE_BINDING_PREFERTARGETINFO : false # Azure Pipelines: Using environment variable variables : - name : PSRULE_BINDING_PREFERTARGETINFO value : false Binding.TargetName # When an object is passed from the pipeline, PSRule assigns the object a TargetName . TargetName is used in output results to identify one object from another. Many objects could be passed down the pipeline at the same time, so using a TargetName that is meaningful is important. TargetName is also used for advanced features such as rule suppression. The value that PSRule uses for TargetName is configurable. PSRule uses the following logic to determine what TargetName should be used: By default PSRule will: Use TargetName or Name properties on the object. These property names are case insensitive. If both TargetName and Name properties exist, TargetName will take precedence over Name . If neither TargetName or Name properties exist, a SHA1 hash of the object will be used as TargetName . If custom TargetName binding properties are configured, the property names specified will override the defaults. If none of the configured property names exist, PSRule will revert back to TargetName then Name . If more then one property name is configured, the order they are specified in the configuration determines precedence. i.e. The first configured property name will take precedence over the second property name. By default the property name will be matched ignoring case sensitivity. To use a case sensitive match, configure the Binding.IgnoreCase option. If a custom TargetName binding function is specified, the function will be evaluated first before any other option. If the function returns $Null then custom properties, TargetName and Name properties will be used. The custom binding function is executed outside the PSRule engine, so PSRule keywords and variables will not be available. Custom binding functions are blocked in constrained language mode is used. See language mode for more information. Custom property names to use for binding can be specified using: # PowerShell: Using the TargetName parameter $option = New-PSRuleOption -TargetName 'ResourceName' , 'AlternateName' ; # PowerShell: Using the Binding.TargetName hashtable key $option = New-PSRuleOption -Option @{ 'Binding.TargetName' = 'ResourceName' , 'AlternateName' }; # PowerShell: Using the TargetName parameter to set YAML Set-PSRuleOption -TargetName 'ResourceName' , 'AlternateName' ; # YAML: Using the binding/targetName property binding : targetName : - ResourceName - AlternateName # Bash: Using environment variable export PSRULE_BINDING_TARGETNAME = 'ResourceName;AlternateName' # GitHub Actions: Using environment variable env : PSRULE_BINDING_TARGETNAME : 'ResourceName;AlternateName' # Azure Pipelines: Using environment variable variables : - name : PSRULE_BINDING_TARGETNAME value : 'ResourceName;AlternateName' To specify a custom binding function use: # Create a custom function that returns a TargetName string $bindFn = { param ( $TargetObject ) $otherName = $TargetObject . PSObject . Properties [ 'OtherName' ]; if ( $Null -eq $otherName ) { return $Null } return $otherName . Value ; } # Specify the binding function script block code to execute $option = New-PSRuleOption -BindTargetName $bindFn ; Binding.TargetType # When an object is passed from the pipeline, PSRule assigns the object a TargetType . TargetType is used to filter rules based on object type and appears in output results. The value that PSRule uses for TargetType is configurable. PSRule uses the following logic to determine what TargetType should be used: By default PSRule will: Use the default type presented by PowerShell from TypeNames . i.e. .PSObject.TypeNames[0] If custom TargetType binding properties are configured, the property names specified will override the defaults. If none of the configured property names exist, PSRule will revert back to the type presented by PowerShell. If more then one property name is configured, the order they are specified in the configuration determines precedence. i.e. The first configured property name will take precedence over the second property name. By default the property name will be matched ignoring case sensitivity. To use a case sensitive match, configure the Binding.IgnoreCase option. If a custom TargetType binding function is specified, the function will be evaluated first before any other option. If the function returns $Null then custom properties, or the type presented by PowerShell will be used in order instead. The custom binding function is executed outside the PSRule engine, so PSRule keywords and variables will not be available. Custom binding functions are blocked in constrained language mode is used. See language mode for more information. Custom property names to use for binding can be specified using: # PowerShell: Using the TargetType parameter $option = New-PSRuleOption -TargetType 'ResourceType' , 'kind' ; # PowerShell: Using the Binding.TargetType hashtable key $option = New-PSRuleOption -Option @{ 'Binding.TargetType' = 'ResourceType' , 'kind' }; # PowerShell: Using the TargetType parameter to set YAML Set-PSRuleOption -TargetType 'ResourceType' , 'kind' ; # YAML: Using the binding/targetType property binding : targetType : - ResourceType - kind # Bash: Using environment variable export PSRULE_BINDING_TARGETTYPE = 'ResourceType;kind' # GitHub Actions: Using environment variable env : PSRULE_BINDING_TARGETTYPE : 'ResourceType;kind' # Azure Pipelines: Using environment variable variables : - name : PSRULE_BINDING_TARGETTYPE value : 'ResourceType;kind' To specify a custom binding function use: # Create a custom function that returns a TargetType string $bindFn = { param ( $TargetObject ) $otherType = $TargetObject . PSObject . Properties [ 'OtherType' ]; if ( $otherType -eq $Null ) { return $Null } return $otherType . Value ; } # Specify the binding function script block code to execute $option = New-PSRuleOption -BindTargetType $bindFn ; Binding.UseQualifiedName # When an object is passed from the pipeline, PSRule assigns the object a TargetName . TargetName is used in output results to identify one object from another. In cases where different types of objects share the same TargetName , this may become confusing. Using a qualified name, prefixes the TargetName with TargetType . i.e. TargetType/TargetName This option determines if PSRule uses qualified or unqualified names (default). By default, PSRule uses / to separate TargetType from TargetName . Set Binding.NameSeparator to change. This option can be specified using: # PowerShell: Using the BindingUseQualifiedName parameter $option = New-PSRuleOption -BindingUseQualifiedName $True ; # PowerShell: Using the Binding.UseQualifiedName hashtable key $option = New-PSRuleOption -Option @{ 'Binding.UseQualifiedName' = $True }; # PowerShell: Using the BindingUseQualifiedName parameter to set YAML Set-PSRuleOption -BindingUseQualifiedName $True ; # YAML: Using the binding/useQualifiedName property binding : useQualifiedName : true # Bash: Using environment variable export PSRULE_BINDING_USEQUALIFIEDNAME = false # GitHub Actions: Using environment variable env : PSRULE_BINDING_USEQUALIFIEDNAME : false # Azure Pipelines: Using environment variable variables : - name : PSRULE_BINDING_USEQUALIFIEDNAME value : false Configuration # Configures a set of baseline configuration values that can be used in rule definitions. Configuration values can be overridden at different scopes. This option can be specified using: # PowerShell: Using the Configuration option with a hashtable $option = New-PSRuleOption -Configuration @{ LOCAL_APPSERVICEMININSTANCECOUNT = 2 }; # YAML: Using the configuration property configuration : LOCAL_APPSERVICEMININSTANCECOUNT : 2 Configuration values can be specified using environment variables. To specify a configuration value, prefix the configuration value with PSRULE_CONFIGURATION_ . # Bash: Using environment variable export PSRULE_CONFIGURATION_LOCAL_APPSERVICEMININSTANCECOUNT = 2 # GitHub Actions: Using environment variable env : PSRULE_CONFIGURATION_LOCAL_APPSERVICEMININSTANCECOUNT : '2' # Azure Pipelines: Using environment variable variables : - name : PSRULE_CONFIGURATION_LOCAL_APPSERVICEMININSTANCECOUNT value : '2' Convention.Include # Specifies conventions to execute when the pipeline run. Conventions are included by name and must be defined within files included in -Path or -Module . This option can be specified using: # PowerShell: Using the Convention parameter $option = New-PSRuleOption -Convention 'Convention1' , 'Convention2' ; # PowerShell: Using the Convention.Include hashtable key $option = New-PSRuleOption -Option @{ 'Convention.Include' = $True }; # PowerShell: Using the Convention parameter to set YAML Set-PSRuleOption -Convention 'Convention1' , 'Convention2' ; # YAML: Using the convention/include property convention : include : - 'Convention1' - 'Convention2' # Bash: Using environment variable export PSRULE_CONVENTION_INCLUDE = 'Convention1;Convention2' # GitHub Actions: Using environment variable env : PSRULE_CONVENTION_INCLUDE : 'Convention1;Convention2' # Azure Pipelines: Using environment variable variables : - name : PSRULE_CONVENTION_INCLUDE value : 'Convention1;Convention2' Execution.AliasReferenceWarning # Rules may define one or more aliases. These aliases are alternative names to identify the rule. An alias may be used to reference the rule anywhere a rule name is used. The primary purpose of an alias is to provide a non-breaking method to change the rule name. Alises can be removed at a later revision once the rule is no longer referenced by the alias. A warning is logged by default to help identify when an alias is used. We recommend taking action to update your usage of the alis to use the rule name or ref instead. Alternatively, the alias reference warning can be disabled by using: # PowerShell: Using the AliasReferenceWarning parameter $option = New-PSRuleOption -AliasReferenceWarning $False ; # PowerShell: Using the Execution.AliasReferenceWarning hashtable key $option = New-PSRuleOption -Option @{ 'Execution.AliasReferenceWarning' = $False }; # PowerShell: Using the AliasReferenceWarning parameter to set YAML Set-PSRuleOption -AliasReferenceWarning $False ; # YAML: Using the execution/aliasReferenceWarning property execution : aliasReferenceWarning : false # Bash: Using environment variable export PSRULE_EXECUTION_ALIASREFERENCEWARNING = false # GitHub Actions: Using environment variable env : PSRULE_EXECUTION_ALIASREFERENCEWARNING : false # Azure Pipelines: Using environment variable variables : - name : PSRULE_EXECUTION_ALIASREFERENCEWARNING value : false Execution.DuplicateResourceId # Determines how to handle duplicate resources identifiers during execution. A duplicate resource identifier may exist if two resources are defined with the same name, ref, or alias. By defaut, an error is thrown, however this behaviour can be modified by this option. If this option is configured to Warn or Ignore only the first resource will be used, however PSRule will continue to execute. The following preferences are available: None (0) - No preference. Inherits the default of Error . Ignore (1) - Continue to execute silently. Warn (2) - Continue to execute but log a warning. Error (3) - Abort and throw an error. This is the default. Debug (4) - Continue to execute but log a debug message. # PowerShell: Using the DuplicateResourceId parameter $option = New-PSRuleOption -DuplicateResourceId 'Warn' ; # PowerShell: Using the Execution.DuplicateResourceId hashtable key $option = New-PSRuleOption -Option @{ 'Execution.DuplicateResourceId' = 'Warn' }; # PowerShell: Using the DuplicateResourceId parameter to set YAML Set-PSRuleOption -DuplicateResourceId 'Warn' ; # YAML: Using the execution/duplicateResourceId property execution : duplicateResourceId : Warn # Bash: Using environment variable export PSRULE_EXECUTION_DUPLICATERESOURCEID = Warn # GitHub Actions: Using environment variable env : PSRULE_EXECUTION_DUPLICATERESOURCEID : Warn # Azure Pipelines: Using environment variable variables : - name : PSRULE_EXECUTION_DUPLICATERESOURCEID value : Warn Execution.LanguageMode # Unless PowerShell has been constrained, full language features of PowerShell are available to use within rule definitions. In locked down environments, a reduced set of language features may be desired. When PSRule is executed in an environment configured for Device Guard, only constrained language features are available. The following language modes are available for use in PSRule: FullLanguage ConstrainedLanguage This option can be specified using: # PowerShell: Using the Execution.LanguageMode hashtable key $option = New-PSRuleOption -Option @{ 'Execution.LanguageMode' = 'ConstrainedLanguage' }; # YAML: Using the execution/languageMode property execution : languageMode : ConstrainedLanguage # Bash: Using environment variable export PSRULE_EXECUTION_LANGUAGEMODE = ConstrainedLanguage # GitHub Actions: Using environment variable env : PSRULE_EXECUTION_LANGUAGEMODE : ConstrainedLanguage # Azure Pipelines: Using environment variable variables : - name : PSRULE_EXECUTION_LANGUAGEMODE value : ConstrainedLanguage Execution.InconclusiveWarning # When defining rules, it is possible not return a valid $True or $False result within the definition script block. Rule authors should not intentionally avoid returning a result, however a possible cause for not returning a result may be a rule logic error. If a rule should not be evaluated, use pre-conditions to avoid processing the rule for objects where the rule is not applicable. In cases where the rule does not return a result it is marked as inconclusive. Inconclusive results will: Generate a warning by default. Fail the object. Outcome will be reported as Fail with an OutcomeReason of Inconclusive . The inconclusive warning can be disabled by using: # PowerShell: Using the InconclusiveWarning parameter $option = New-PSRuleOption -InconclusiveWarning $False ; # PowerShell: Using the Execution.InconclusiveWarning hashtable key $option = New-PSRuleOption -Option @{ 'Execution.InconclusiveWarning' = $False }; # PowerShell: Using the InconclusiveWarning parameter to set YAML Set-PSRuleOption -InconclusiveWarning $False ; # YAML: Using the execution/inconclusiveWarning property execution : inconclusiveWarning : false # Bash: Using environment variable export PSRULE_EXECUTION_INCONCLUSIVEWARNING = false # GitHub Actions: Using environment variable env : PSRULE_EXECUTION_INCONCLUSIVEWARNING : false # Azure Pipelines: Using environment variable variables : - name : PSRULE_EXECUTION_INCONCLUSIVEWARNING value : false Execution.InvariantCultureWarning # When evaluating rules inside a CI host, if invariant culture is used, a warning is shown by default. You can suppress this warning if you set the culture with -Culture or the Output.Culture option. This warning can also be suppressed by using: # PowerShell: Using the InvariantCultureWarning parameter $option = New-PSRuleOption -InvariantCultureWarning $False ; # PowerShell: Using the Execution.InvariantCultureWarning hashtable key $option = New-PSRuleOption -Option @{ 'Execution.InvariantCultureWarning' = $False }; # PowerShell: Using the InvariantCultureWarning parameter to set YAML Set-PSRuleOption -InvariantCultureWarning $False ; # YAML: Using the execution/invariantCultureWarning property execution : invariantCultureWarning : false # Bash: Using environment variable export PSRULE_EXECUTION_INVARIANTCULTUREWARNING = false # GitHub Actions: Using environment variable env : PSRULE_EXECUTION_INVARIANTCULTUREWARNING : false # Azure Pipelines: Using environment variable variables : - name : PSRULE_EXECUTION_INVARIANTCULTUREWARNING value : false Execution.InitialSessionState # Determines how the initial session state for executing PowerShell code is created. The following preferences are available: BuiltIn (0) - Create the initial session state with all built-in cmdlets loaded. This is the default. Minimal (1) - Create the initial session state with only a minimum set of cmdlets loaded. # PowerShell: Using the InitialSessionState parameter $option = New-PSRuleOption -InitialSessionState 'Minimal' ; # PowerShell: Using the Execution.InitialSessionState hashtable key $option = New-PSRuleOption -Option @{ 'Execution.InitialSessionState' = 'Minimal' }; # PowerShell: Using the InitialSessionState parameter to set YAML Set-PSRuleOption -InitialSessionState 'Minimal' ; # YAML: Using the execution/initialSessionState property execution : initialSessionState : Minimal # Bash: Using environment variable export PSRULE_EXECUTION_INITIALSESSIONSTATE = Minimal # GitHub Actions: Using environment variable env : PSRULE_EXECUTION_INITIALSESSIONSTATE : Minimal # Azure Pipelines: Using environment variable variables : - name : PSRULE_EXECUTION_INITIALSESSIONSTATE value : Minimal Execution.NotProcessedWarning # When evaluating rules, it is possible to incorrectly select a path with rules that use pre-conditions that do not accept the pipeline object. In this case the object has not been processed by any rule. Not processed objects will: Generate a warning by default. Pass the object. Outcome will be reported as None . The not processed warning can be disabled by using: # PowerShell: Using the NotProcessedWarning parameter $option = New-PSRuleOption -NotProcessedWarning $False ; # PowerShell: Using the Execution.NotProcessedWarning hashtable key $option = New-PSRuleOption -Option @{ 'Execution.NotProcessedWarning' = $False }; # PowerShell: Using the NotProcessedWarning parameter to set YAML Set-PSRuleOption -NotProcessedWarning $False ; # YAML: Using the execution/notProcessedWarning property execution : notProcessedWarning : false # Bash: Using environment variable export PSRULE_EXECUTION_NOTPROCESSEDWARNING = false # GitHub Actions: Using environment variable env : PSRULE_EXECUTION_NOTPROCESSEDWARNING : false # Azure Pipelines: Using environment variable variables : - name : PSRULE_EXECUTION_NOTPROCESSEDWARNING value : false Execution.SuppressedRuleWarning # When evaluating rules, it is possible to output suppressed rules as warnings. Suppressed rules will: Output a warning by default. Show which rules were suppressed when Output.As is set to Detail . Show how many rules were suppressed when Output.As is set to Summary . The suppressed rule can be disabled by using: # PowerShell: Using the SuppressedRuleWarning parameter $option = New-PSRuleOption -SuppressedRuleWarning $False ; # PowerShell: Using the Execution.SuppressedRuleWarning hashtable key $option = New-PSRuleOption -Option @{ 'Execution.SuppressedRuleWarning' = $False }; # PowerShell: Using the SuppressedRuleWarning parameter to set YAML Set-PSRuleOption -SuppressedRuleWarning $False ; # YAML: Using the execution/suppressedRuleWarning property execution : suppressedRuleWarning : false # Bash: Using environment variable export PSRULE_EXECUTION_SUPPRESSEDRULEWARNING = false # GitHub Actions: Using environment variable env : PSRULE_EXECUTION_SUPPRESSEDRULEWARNING : false # Azure Pipelines: Using environment variable variables : - name : PSRULE_EXECUTION_SUPPRESSEDRULEWARNING value : false Execution.SuppressionGroupExpired # Determines how to handle expired suppression groups. Regardless of the value, an expired suppression group will be ignored. By defaut, a warning is generated, however this behaviour can be modified by this option. The following preferences are available: None (0) - No preference. Inherits the default of Warn . Ignore (1) - Continue to execute silently. Warn (2) - Continue to execute but log a warning. This is the default. Error (3) - Abort and throw an error. Debug (4) - Continue to execute but log a debug message. # PowerShell: Using the SuppressionGroupExpired parameter $option = New-PSRuleOption -SuppressionGroupExpired 'Error' ; # PowerShell: Using the Execution.SuppressionGroupExpired hashtable key $option = New-PSRuleOption -Option @{ 'Execution.SuppressionGroupExpired' = 'Error' }; # PowerShell: Using the SuppressionGroupExpired parameter to set YAML Set-PSRuleOption -SuppressionGroupExpired 'Error' ; # YAML: Using the execution/suppressionGroupExpired property execution : suppressionGroupExpired : Error # Bash: Using environment variable export PSRULE_EXECUTION_SUPPRESSIONGROUPEXPIRED = Error # GitHub Actions: Using environment variable env : PSRULE_EXECUTION_SUPPRESSIONGROUPEXPIRED : Error # Azure Pipelines: Using environment variable variables : - name : PSRULE_EXECUTION_SUPPRESSIONGROUPEXPIRED value : Error Include.Module # Automatically include rules and resources from the specified module. To automatically import and include a module specify the module by name. The module must already be installed on the system. When $PSModuleAutoLoadingPreference is set to a value other then All the module must be imported. This option is equivalent to using the -Module parameter on PSRule cmdlets, with the following addition: Modules specified with Include.Module are combined with -Module . Both sets of modules will be imported and used using execution. This option can be specified using: # PowerShell: Using the IncludeModule parameter $option = New-PSRuleOption -IncludeModule 'TestModule1' , 'TestModule2' ; # PowerShell: Using the Include.Module hashtable key $option = New-PSRuleOption -Option @{ 'Include.Module' = 'TestModule1' , 'TestModule2' }; # PowerShell: Using the IncludeModule parameter to set YAML Set-PSRuleOption -IncludeModule 'TestModule1' , 'TestModule2' ; # YAML: Using the include/module property include : module : - TestModule1 # Bash: Using environment variable export PSRULE_INCLUDE_MODULE = TestModule1 ; TestModule2 # GitHub Actions: Using environment variable env : PSRULE_INCLUDE_MODULE : TestModule1;TestModule2 # Azure Pipelines: Using environment variable variables : - name : PSRULE_INCLUDE_MODULE value : TestModule1;TestModule2 Include.Path # Automatically include rules and resources from the specified path. By default, .ps-rule/ is included. This option is equivalent to using the -Path parameter on PSRule cmdlets, with the following additions: Paths specified with Include.Path are combined with -Path . Both sets of paths will be imported and used using execution. The Include.Path option defaults to .ps-rule/ . To override this default, specify one or more alternative paths or an empty array. This option can be specified using: # PowerShell: Using the IncludePath parameter $option = New-PSRuleOption -IncludePath '.ps-rule/' , 'custom-rules/' ; # PowerShell: Using the Include.Path hashtable key $option = New-PSRuleOption -Option @{ 'Include.Path' = '.ps-rule/' , 'custom-rules/' }; # PowerShell: Using the IncludePath parameter to set YAML Set-PSRuleOption -IncludePath '.ps-rule/' , 'custom-rules/' ; # YAML: Using the include/path property include : path : - custom-rules/ # Bash: Using environment variable export PSRULE_INCLUDE_PATH = .ps-rule/ ; custom-rules/ # GitHub Actions: Using environment variable env : PSRULE_INCLUDE_PATH : .ps-rule/;custom-rules/ # Azure Pipelines: Using environment variable variables : - name : PSRULE_INCLUDE_PATH value : .ps-rule/;custom-rules/ Input.Format # Configures the input format for when a string is passed in as a target object. This option determines if the target object is deserialized into an alternative form. Use this option with Assert-PSRule , Invoke-PSRule or Test-PSRuleTarget . Set this option to either Yaml , Json , Markdown , PowerShellData to deserialize as a specific format. The -Format parameter will override any value set in configuration. When the -InputObject parameter or pipeline input is used, strings are treated as plain text by default. FileInfo objects for supported file formats will be deserialized based on file extension. When the -InputPath parameter is used, supported file formats will be deserialized based on file extension. The -InputPath parameter can be used with a file path or URL. The following formats are available: None - Treat strings as plain text and do not deserialize files. Yaml - Deserialize as one or more YAML objects. Json - Deserialize as one or more JSON objects. Markdown - Deserialize as a markdown object. PowerShellData - Deserialize as a PowerShell data object. File - Files are not deserialized. Detect - Detect format based on file extension. This is the default. If the Detect format is used, the file extension will be used to automatically detect the format. When the file extension can not be determined Detect is the same as None . The Markdown format does not parse the whole markdown document. Specifically this format deserializes YAML front matter from the top of the document if any exists. The File format does not deserialize file contents. Each file is returned as an object. Files within .git sub-directories are ignored. Path specs specified in .gitignore directly in the current working path are ignored. A RepositoryInfo object is generated if the current working path if a .git sub-directory is present. Additionally, PSRule performs automatic type binding for file objects, using the extension as the type. When files have no extension the whole file name is used. Detect uses the following file extensions: Yaml - .yaml or .yml Json - .json or .jsonc Markdown - .md or .markdown PowerShellData - .psd1 This option can be specified using: # PowerShell: Using the Format parameter $option = New-PSRuleOption -Format Yaml ; # PowerShell: Using the Input.Format hashtable key $option = New-PSRuleOption -Option @{ 'Input.Format' = 'Yaml' }; # PowerShell: Using the Format parameter to set YAML Set-PSRuleOption -Format Yaml ; # YAML: Using the input/format property input : format : Yaml # Bash: Using environment variable export PSRULE_INPUT_FORMAT = Yaml # GitHub Actions: Using environment variable env : PSRULE_INPUT_FORMAT : Yaml # Azure Pipelines: Using environment variable variables : - name : PSRULE_INPUT_FORMAT value : Yaml Input.IgnoreGitPath # When reading files from an input path, files within the .git sub-directory are ignored by default. Files stored within the .git sub-directory are system repository files used by git. To read files stored within the .git path, set this option to $False . This option can be specified using: # PowerShell: Using the InputIgnoreGitPath parameter $option = New-PSRuleOption -InputIgnoreGitPath $False ; # PowerShell: Using the Input.IgnoreGitPath hashtable key $option = New-PSRuleOption -Option @{ 'Input.IgnoreGitPath' = $False }; # PowerShell: Using the InputIgnoreGitPath parameter to set YAML Set-PSRuleOption -InputIgnoreGitPath $False ; # YAML: Using the input/ignoreGitPath property input : ignoreGitPath : false # Bash: Using environment variable export PSRULE_INPUT_IGNOREGITPATH = false # GitHub Actions: Using environment variable env : PSRULE_INPUT_IGNOREGITPATH : false # Azure Pipelines: Using environment variable variables : - name : PSRULE_INPUT_IGNOREGITPATH value : false Input.IgnoreObjectSource # By default, objects read from file using inputPath will be skipped if the file path has been ignored. When set to true, additionally objects with a source path that has been ignored will be skipped. This will include FileInfo objects, and objects with a source set using the _PSRule.source property. File paths to ignore are set by Input.PathIgnore , Input.IgnoreGitPath , and Input.IgnoreRepositoryCommon . This option can be specified using: # PowerShell: Using the InputIgnoreObjectSource parameter $option = New-PSRuleOption -InputIgnoreObjectSource $True ; # PowerShell: Using the Input.IgnoreObjectSource hashtable key $option = New-PSRuleOption -Option @{ 'Input.IgnoreObjectSource' = $True }; # PowerShell: Using the InputIgnoreObjectSource parameter to set YAML Set-PSRuleOption -InputIgnoreObjectSource $True ; # YAML: Using the input/ignoreObjectSource property input : ignoreObjectSource : true # Bash: Using environment variable export PSRULE_INPUT_IGNOREOBJECTSOURCE = true # GitHub Actions: Using environment variable env : PSRULE_INPUT_IGNOREOBJECTSOURCE : true # Azure Pipelines: Using environment variable variables : - name : PSRULE_INPUT_IGNOREOBJECTSOURCE value : true Input.IgnoreRepositoryCommon # When reading files from an input path, files are discovered recursively. A number of files are commonly found within a private and open-source repositories. In many cases these files are of no interest for analysis and should be ignored by rules. PSRule will ignore the following files by default: README.md .DS_Store .gitignore .gitattributes .gitmodules LICENSE LICENSE.txt CODE_OF_CONDUCT.md CONTRIBUTING.md SECURITY.md SUPPORT.md .vscode/*.json .vscode/*.code-snippets .github/**/*.md .github/CODEOWNERS .pipelines/**/*.yml .pipelines/**/*.yaml .azure-pipelines/**/*.yml .azure-pipelines/**/*.yaml .azuredevops/*.md To include these files, set this option to $False . This option can be specified using: # PowerShell: Using the InputIgnoreRepositoryCommon parameter $option = New-PSRuleOption -InputIgnoreRepositoryCommon $False ; # PowerShell: Using the Input.IgnoreRepositoryCommon hashtable key $option = New-PSRuleOption -Option @{ 'Input.IgnoreRepositoryCommon' = $False }; # PowerShell: Using the InputIgnoreRepositoryCommon parameter to set YAML Set-PSRuleOption -InputIgnoreRepositoryCommon $False ; # YAML: Using the input/ignoreRepositoryCommon property input : ignoreRepositoryCommon : false # Bash: Using environment variable export PSRULE_INPUT_IGNOREREPOSITORYCOMMON = false # GitHub Actions: Using environment variable env : PSRULE_INPUT_IGNOREREPOSITORYCOMMON : false # Azure Pipelines: Using environment variable variables : - name : PSRULE_INPUT_IGNOREREPOSITORYCOMMON value : false Input.IgnoreUnchangedPath # By default, PSRule will process all files within an input path. For large repositories, this can result in a large number of files being processed. Additionally, for a pull request you may only be interested in files that have changed. When set to true , files that have not changed will be ignored. This option can be specified using: # PowerShell: Using the InputIgnoreUnchangedPath parameter $option = New-PSRuleOption -InputIgnoreUnchangedPath $True ; # PowerShell: Using the Input.IgnoreUnchangedPath hashtable key $option = New-PSRuleOption -Option @{ 'Input.IgnoreUnchangedPath' = $True }; # PowerShell: Using the InputIgnoreUnchangedPath parameter to set YAML Set-PSRuleOption -InputIgnoreUnchangedPath $True ; # YAML: Using the input/ignoreUnchangedPath property input : ignoreUnchangedPath : true # Bash: Using environment variable export PSRULE_INPUT_IGNOREUNCHANGEDPATH = true # GitHub Actions: Using environment variable env : PSRULE_INPUT_IGNOREUNCHANGEDPATH : true # Azure Pipelines: Using environment variable variables : - name : PSRULE_INPUT_IGNOREUNCHANGEDPATH value : true Input.ObjectPath # The object path to a property to use instead of the pipeline object. By default, PSRule processes objects passed from the pipeline against selected rules. When this option is set, instead of evaluating the pipeline object, PSRule looks for a property of the pipeline object specified by ObjectPath and uses that instead. If the property specified by ObjectPath is a collection/ array, then each item is evaluated separately. If the property specified by ObjectPath does not exist, PSRule skips the object. When using Invoke-PSRule , Test-PSRuleTarget and Assert-PSRule the -ObjectPath parameter will override any value set in configuration. This option can be specified using: # PowerShell: Using the ObjectPath parameter $option = New-PSRuleOption -ObjectPath 'items' ; # PowerShell: Using the Input.ObjectPath hashtable key $option = New-PSRuleOption -Option @{ 'Input.ObjectPath' = 'items' }; # PowerShell: Using the ObjectPath parameter to set YAML Set-PSRuleOption -ObjectPath 'items' ; # YAML: Using the input/objectPath property input : objectPath : items # Bash: Using environment variable export PSRULE_INPUT_OBJECTPATH = items # GitHub Actions: Using environment variable env : PSRULE_INPUT_OBJECTPATH : items # Azure Pipelines: Using environment variable variables : - name : PSRULE_INPUT_OBJECTPATH value : items Input.PathIgnore # Ignores input files that match the path spec when using -InputPath . If specified, files that match the path spec will not be processed. By default, all files are processed. This option can be specified using: # PowerShell: Using the InputPathIgnore parameter $option = New-PSRuleOption -InputPathIgnore '*.Designer.cs' ; # PowerShell: Using the Input.PathIgnore hashtable key $option = New-PSRuleOption -Option @{ 'Input.PathIgnore' = '*.Designer.cs' }; # PowerShell: Using the InputPathIgnore parameter to set YAML Set-PSRuleOption -InputPathIgnore '*.Designer.cs' ; # YAML: Using the input/pathIgnore property input : pathIgnore : - '*.Designer.cs' # Bash: Using environment variable export PSRULE_INPUT_PATHIGNORE = *.Designer.cs # GitHub Actions: Using environment variable env : PSRULE_INPUT_PATHIGNORE : '*.Designer.cs' # Azure Pipelines: Using environment variable variables : - name : PSRULE_INPUT_PATHIGNORE value : '*.Designer.cs' Input.TargetType # Filters input objects by TargetType. If specified, only objects with the specified TargetType are processed. Objects that do not match TargetType are ignored. If multiple values are specified, only one TargetType must match. This option is not case-sensitive. By default, all objects are processed. To change the field TargetType is bound to set the Binding.TargetType option. When using Invoke-PSRule , Test-PSRuleTarget and Assert-PSRule the -TargetType parameter will override any value set in configuration. This option can be specified using: # PowerShell: Using the InputTargetType parameter $option = New-PSRuleOption -InputTargetType 'virtualMachine' , 'virtualNetwork' ; # PowerShell: Using the Input.TargetType hashtable key $option = New-PSRuleOption -Option @{ 'Input.TargetType' = 'virtualMachine' , 'virtualNetwork' }; # PowerShell: Using the InputTargetType parameter to set YAML Set-PSRuleOption -InputTargetType 'virtualMachine' , 'virtualNetwork' ; # YAML: Using the input/targetType property input : targetType : - virtualMachine # Bash: Using environment variable export PSRULE_INPUT_TARGETTYPE = virtualMachine ; virtualNetwork # GitHub Actions: Using environment variable env : PSRULE_INPUT_TARGETTYPE : virtualMachine;virtualNetwork # Azure Pipelines: Using environment variable variables : - name : PSRULE_INPUT_TARGETTYPE value : virtualMachine;virtualNetwork Logging.LimitDebug # Limits debug messages to a list of named debug scopes. When using the -Debug switch or preference variable, by default PSRule cmdlets log all debug output. When using debug output for debugging a specific rule, it may be helpful to limit debug message to a specific rule. To identify a rule to include in debug output use the rule name. The following built-in scopes exist in addition to rule names: [Discovery.Source] - Discovery messages for .Rule.ps1 files and rule modules. [Discovery.Rule] - Discovery messages for individual rules within .Rule.ps1 files. This option can be specified using: # PowerShell: Using the LoggingLimitDebug parameter $option = New-PSRuleOption -LoggingLimitDebug Rule1 , Rule2 ; # PowerShell: Using the Logging.LimitDebug hashtable key $option = New-PSRuleOption -Option @{ 'Logging.LimitDebug' = Rule1 , Rule2 }; # PowerShell: Using the LoggingLimitDebug parameter to set YAML Set-PSRuleOption -LoggingLimitDebug Rule1 , Rule2 ; # YAML: Using the logging/limitDebug property logging : limitDebug : - Rule1 - Rule2 Logging.LimitVerbose # Limits verbose messages to a list of named verbose scopes. When using the -Verbose switch or preference variable, by default PSRule cmdlets log all verbose output. When using verbose output for troubleshooting a specific rule, it may be helpful to limit verbose messages to a specific rule. To identify a rule to include in verbose output use the rule name. The following built-in scopes exist in addition to rule names: [Discovery.Source] - Discovery messages for .Rule.ps1 files and rule modules. [Discovery.Rule] - Discovery messages for individual rules within .Rule.ps1 files. This option can be specified using: # PowerShell: Using the LoggingLimitVerbose parameter $option = New-PSRuleOption -LoggingLimitVerbose Rule1 , Rule2 ; # PowerShell: Using the Logging.LimitVerbose hashtable key $option = New-PSRuleOption -Option @{ 'Logging.LimitVerbose' = Rule1 , Rule2 }; # PowerShell: Using the LoggingLimitVerbose parameter to set YAML Set-PSRuleOption -LoggingLimitVerbose Rule1 , Rule2 ; # YAML: Using the logging/limitVerbose property logging : limitVerbose : - Rule1 - Rule2 Logging.RuleFail # When an object fails a rule condition the results are written to output as a structured object marked with the outcome of Fail . If the rule executed successfully regardless of outcome no other informational messages are shown by default. In some circumstances such as a continuous integration (CI) pipeline, it may be preferable to see informational messages or abort the CI process if one or more Fail outcomes are returned. By settings this option, error, warning or information messages will be generated for each rule fail outcome in addition to structured output. By default, outcomes are not logged to an informational stream (i.e. None). The following streams available: None Error Warning Information This option can be specified using: # PowerShell: Using the LoggingRuleFail parameter $option = New-PSRuleOption -LoggingRuleFail Error ; # PowerShell: Using the Logging.RuleFail hashtable key $option = New-PSRuleOption -Option @{ 'Logging.RuleFail' = 'Error' }; # PowerShell: Using the LoggingRuleFail parameter to set YAML Set-PSRuleOption -LoggingRuleFail Error ; # YAML: Using the logging/ruleFail property logging : ruleFail : Error Logging.RulePass # When an object passes a rule condition the results are written to output as a structured object marked with the outcome of Pass . If the rule executed successfully regardless of outcome no other informational messages are shown by default. In some circumstances such as a continuous integration (CI) pipeline, it may be preferable to see informational messages. By settings this option, error, warning or information messages will be generated for each rule pass outcome in addition to structured output. By default, outcomes are not logged to an informational stream (i.e. None). The following streams available: None Error Warning Information This option can be specified using: # PowerShell: Using the LoggingRulePass parameter $option = New-PSRuleOption -LoggingRulePass Information ; # PowerShell: Using the Logging.RulePass hashtable key $option = New-PSRuleOption -Option @{ 'Logging.RulePass' = 'Information' }; # PowerShell: Using the LoggingRulePass parameter to set YAML Set-PSRuleOption -LoggingRulePass Information ; # YAML: Using the logging/rulePass property logging : rulePass : Information Output.As # Configures the type of results to produce. This option only applies to Invoke-PSRule and Assert-PSRule . Invoke-PSRule and Assert-PSRule also include a -As parameter to set this option at runtime. If specified, the -As parameter take precedence, over this option. The following options are available: Detail - Return a record per rule per object. Summary - Return summary results. This option can be specified using: # PowerShell: Using the OutputAs parameter $option = New-PSRuleOption -OutputAs Summary ; # PowerShell: Using the Output.As hashtable key $option = New-PSRuleOption -Option @{ 'Output.As' = 'Summary' }; # PowerShell: Using the OutputAs parameter to set YAML Set-PSRuleOption -OutputAs Summary ; # YAML: Using the output/as property output : as : Summary # Bash: Using environment variable export PSRULE_OUTPUT_AS = Summary # GitHub Actions: Using environment variable env : PSRULE_OUTPUT_AS : Summary # Azure Pipelines: Using environment variable variables : - name : PSRULE_OUTPUT_AS value : Summary Output.Banner # The information displayed for PSRule banner. This option is only applicable when using Assert-PSRule cmdlet. The following information can be shown or hidden by configuring this option. Title (1) - Shows the PSRule title ASCII text. Source (2) - Shows rules module versions used in this run. SupportLinks (4) - Shows supporting links for PSRule and rules modules. RepositoryInfo (8) - Show information about the repository where PSRule is being run from. Additionally the following rollup options exist: Default - Shows Title , Source , SupportLinks , RepositoryInfo . This is the default option. Minimal - Shows Source . This option can be configured using one of the named values described above. Alternatively, this value can be configured by specifying a bit mask as an integer. For example 6 would show Source , and SupportLinks . This option can be specified using: # PowerShell: Using the OutputBanner parameter $option = New-PSRuleOption -OutputBanner Minimal ; # PowerShell: Using the Output.Banner hashtable key $option = New-PSRuleOption -Option @{ 'Output.Banner' = 'Minimal' }; # PowerShell: Using the OutputBanner parameter to set YAML Set-PSRuleOption -OutputBanner Minimal ; # YAML: Using the output/banner property output : banner : Minimal # Bash: Using environment variable export PSRULE_OUTPUT_BANNER = Minimal # GitHub Actions: Using environment variable env : PSRULE_OUTPUT_BANNER : Minimal # Azure Pipelines: Using environment variable variables : - name : PSRULE_OUTPUT_BANNER value : Minimal Output.Culture # Specified the name of one or more cultures to use for generating output. When multiple cultures are specified, the first matching culture will be used. If a culture is not specified, PSRule will use the current PowerShell culture. PSRule cmdlets also include a -Culture parameter to set this option at runtime. If specified, the -Culture parameter take precedence, over this option. To get a list of cultures use the Get-Culture -ListAvailable cmdlet. This option can be specified using: # PowerShell: Using the OutputCulture parameter $option = New-PSRuleOption -OutputCulture 'en-AU' ; # PowerShell: Using the Output.Culture hashtable key $option = New-PSRuleOption -Option @{ 'Output.Culture' = 'en-AU' }; # PowerShell: Using the OutputCulture parameter to set YAML Set-PSRuleOption -OutputCulture 'en-AU' , 'en-US' ; # YAML: Using the output/culture property output : culture : [ 'en-AU' , 'en-US' ] # Bash: Using environment variable export PSRULE_OUTPUT_CULTURE = en-AU ; en-US # GitHub Actions: Using environment variable env : PSRULE_OUTPUT_CULTURE : en-AU;en-US # Azure Pipelines: Using environment variable variables : - name : PSRULE_OUTPUT_CULTURE value : en-AU;en-US Output.Encoding # Configures the encoding used when output is written to file. This option has no affect when Output.Path is not set. The following encoding options are available: Default UTF-8 UTF-7 Unicode UTF-32 ASCII This option can be specified using: # PowerShell: Using the OutputEncoding parameter $option = New-PSRuleOption -OutputEncoding UTF8 ; # PowerShell: Using the Output.Format hashtable key $option = New-PSRuleOption -Option @{ 'Output.Encoding' = 'UTF8' }; # PowerShell: Using the OutputEncoding parameter to set YAML Set-PSRuleOption -OutputEncoding UTF8 ; # YAML: Using the output/encoding property output : encoding : UTF8 # Bash: Using environment variable export PSRULE_OUTPUT_ENCODING = UTF8 # GitHub Actions: Using environment variable env : PSRULE_OUTPUT_ENCODING : UTF8 # Azure Pipelines: Using environment variable variables : - name : PSRULE_OUTPUT_ENCODING value : UTF8 Output.Footer # The information displayed for PSRule footer. This option is only applicable when using Assert-PSRule cmdlet. The following information can be shown or hidden by configuring this option. RuleCount (1) - Shows a summary of rules processed. RunInfo (2) - Shows information about the run. OutputFile (4) - Shows information about the output file if an output path is set. Additionally the following rollup options exist: Default - Shows RuleCount , RunInfo , and OutputFile . This is the default option. This option can be configured using one of the named values described above. Alternatively, this value can be configured by specifying a bit mask as an integer. For example 3 would show RunInfo , and RuleCount . This option can be specified using: # PowerShell: Using the OutputFooter parameter $option = New-PSRuleOption -OutputFooter RuleCount ; # PowerShell: Using the Output.Footer hashtable key $option = New-PSRuleOption -Option @{ 'Output.Footer' = 'RuleCount' }; # PowerShell: Using the OutputFooter parameter to set YAML Set-PSRuleOption -OutputFooter RuleCount ; # YAML: Using the output/footer property output : footer : RuleCount # Bash: Using environment variable export PSRULE_OUTPUT_FOOTER = RuleCount # GitHub Actions: Using environment variable env : PSRULE_OUTPUT_FOOTER : RuleCount # Azure Pipelines: Using environment variable variables : - name : PSRULE_OUTPUT_FOOTER value : RuleCount Output.Format # Configures the format that results will be presented in. This option applies to Invoke-PSRule , Assert-PSRule , Get-PSRule and Get-PSRuleBaseline . This options is ignored by other cmdlets. The following format options are available: None - Output is presented as an object using PowerShell defaults. This is the default. Yaml - Output is serialized as YAML. Json - Output is serialized as JSON. Markdown - Output is serialized as Markdown. NUnit3 - Output is serialized as NUnit3 (XML). Csv - Output is serialized as a comma-separated values (CSV). The following columns are included for Detail output: RuleName, TargetName, TargetType, Outcome, OutcomeReason, Synopsis, Recommendation The following columns are included for Summary output: RuleName, Pass, Fail, Outcome, Synopsis, Recommendation Wide - Output is presented using the wide table format, which includes reason and wraps columns. Sarif - Output is serialized as SARIF. The Wide format is ignored by Assert-PSRule . Get-PSRule only accepts None , Wide , Yaml and Json . Usage of other formats are treated as None . The Get-PSRuleBaseline cmdlet only accepts None or Yaml . The Export-PSRuleBaseline cmdlet only accepts Yaml . This option can be specified using: # PowerShell: Using the OutputFormat parameter $option = New-PSRuleOption -OutputFormat Yaml ; # PowerShell: Using the Output.Format hashtable key $option = New-PSRuleOption -Option @{ 'Output.Format' = 'Yaml' }; # PowerShell: Using the OutputFormat parameter to set YAML Set-PSRuleOption -OutputFormat Yaml ; # YAML: Using the output/format property output : format : Yaml # Bash: Using environment variable export PSRULE_OUTPUT_FORMAT = Yaml # GitHub Actions: Using environment variable env : PSRULE_OUTPUT_FORMAT : Yaml # Azure Pipelines: Using environment variable variables : - name : PSRULE_OUTPUT_FORMAT value : Yaml Output.Outcome # Filters output to include results with the specified outcome. The following outcome options are available: None (0) - Results for rules that did not get processed are returned. This include rules that have been suppressed or were not run against a target object. Fail (1) - Results for rules that failed are returned. Pass (2) - Results for rules that passed are returned. Error (4) - Results for rules that raised an error are returned. Additionally the following rollup options exist: Processed - Results for rules with the Fail , Pass , or Error outcome. This is the default option. Problem - Results for rules with the Fail , or Error outcome. All - All results for rules are returned. This option can be specified using: # PowerShell: Using the OutputOutcome parameter $option = New-PSRuleOption -OutputOutcome Fail ; # PowerShell: Using the Output.Outcome hashtable key $option = New-PSRuleOption -Option @{ 'Output.Outcome' = 'Fail' }; # PowerShell: Using the OutputOutcome parameter to set YAML Set-PSRuleOption -OutputOutcome Fail ; # YAML: Using the output/outcome property output : outcome : 'Fail' # Bash: Using environment variable export PSRULE_OUTPUT_OUTCOME = Fail # GitHub Actions: Using environment variable env : PSRULE_OUTPUT_OUTCOME : Fail # Azure Pipelines: Using environment variable variables : - name : PSRULE_OUTPUT_OUTCOME value : Fail Output.Path # Specifies the output file path to write results. Directories along the file path will automatically be created if they do not exist. This option only applies to Invoke-PSRule . Invoke-PSRule also includes a parameter -OutputPath to set this option at runtime. If specified, the -OutputPath parameter take precedence, over this option. Syntax: output : path : string Default: output : path : null This option can be specified using: # PowerShell: Using the OutputPath parameter $option = New-PSRuleOption -OutputPath 'out/results.yaml' ; # PowerShell: Using the Output.Path hashtable key $option = New-PSRuleOption -Option @{ 'Output.Path' = 'out/results.yaml' }; # PowerShell: Using the OutputPath parameter to set YAML Set-PSRuleOption -OutputPath 'out/results.yaml' ; # YAML: Using the output/path property output : path : 'out/results.yaml' # Bash: Using environment variable export PSRULE_OUTPUT_PATH = out/results.yaml # GitHub Actions: Using environment variable env : PSRULE_OUTPUT_PATH : out/results.yaml # Azure Pipelines: Using environment variable variables : - name : PSRULE_OUTPUT_PATH value : out/results.yaml Output.SarifProblemsOnly # Determines if SARIF output only includes rules with fail or error outcomes. By default, only rules with fail or error outcomes are included for compatibility with external tools. To include rules with pass outcomes, set this option to false . This option only applies when the output format is Sarif . Syntax: output : sarifProblemsOnly : boolean Default: output : sarifProblemsOnly : true This option can be specified using: # PowerShell: Using the OutputSarifProblemsOnly parameter $option = New-PSRuleOption -OutputSarifProblemsOnly $False ; # PowerShell: Using the Output.SarifProblemsOnly hashtable key $option = New-PSRuleOption -Option @{ 'Output.SarifProblemsOnly' = $False }; # PowerShell: Using the OutputSarifProblemsOnly parameter to set YAML Set-PSRuleOption -OutputSarifProblemsOnly $False ; # YAML: Using the output/sarifProblemsOnly property output : sarifProblemsOnly : false # Bash: Using environment variable export PSRULE_OUTPUT_SARIFPROBLEMSONLY = false # GitHub Actions: Using environment variable env : PSRULE_OUTPUT_SARIFPROBLEMSONLY : false # Azure Pipelines: Using environment variable variables : - name : PSRULE_OUTPUT_SARIFPROBLEMSONLY value : false Output.Style # Configures the style that results will be presented in. This option only applies to output generated from Assert-PSRule . Assert-PSRule also include a parameter -Style to set this option at runtime. If specified, the -Style parameter takes precedence, over this option. The following styles are available: Client - Output is written to the host directly in green/ red to indicate outcome. Plain - Output is written as an unformatted string. This option can be redirected to a file. AzurePipelines - Output is written for integration Azure Pipelines. GitHubActions - Output is written for integration GitHub Actions. VisualStudioCode - Output is written for integration with Visual Studio Code. Detect - Output style will be detected by checking the environment variables. This is the default. Detect uses the following logic: If the TF_BUILD environment variable is set to true , AzurePipelines will be used. If the GITHUB_ACTIONS environment variable is set to true , GitHubActions will be used. If the TERM_PROGRAM environment variable is set to vscode , VisualStudioCode will be used. Use Client . Syntax: output : style : string Default: output : style : Detect This option can be specified using: # PowerShell: Using the OutputStyle parameter $option = New-PSRuleOption -OutputStyle AzurePipelines ; # PowerShell: Using the Output.Style hashtable key $option = New-PSRuleOption -Option @{ 'Output.Style' = 'AzurePipelines' }; # PowerShell: Using the OutputStyle parameter to set YAML Set-PSRuleOption -OutputFormat AzurePipelines ; # YAML: Using the output/style property output : style : AzurePipelines # Bash: Using environment variable export PSRULE_OUTPUT_STYLE = AzurePipelines # GitHub Actions: Using environment variable env : PSRULE_OUTPUT_STYLE : AzurePipelines # Azure Pipelines: Using environment variable variables : - name : PSRULE_OUTPUT_STYLE value : AzurePipelines Output.JobSummaryPath # Configures the file path a job summary will be written to when using Assert-PSRule . A job summary is a markdown file that summarizes the results of a job. When not specified, a job summary will not be generated. Syntax: output : jobSummaryPath : string Default: output : jobSummaryPath : null This option can be specified using: # PowerShell: Using the OutputJobSummaryPath parameter $option = New-PSRuleOption -OutputJobSummaryPath 'reports/summary.md' ; # PowerShell: Using the Output.JobSummaryPath hashtable key $option = New-PSRuleOption -Option @{ 'Output.JobSummaryPath' = 'reports/summary.md' }; # PowerShell: Using the OutputJobSummaryPath parameter to set YAML Set-PSRuleOption -OutputJobSummaryPath 'reports/summary.md' ; # YAML: Using the output/jobSummaryPath property output : jobSummaryPath : 'reports/summary.md' # Bash: Using environment variable export PSRULE_OUTPUT_JOBSUMMARYPATH = 'reports/summary.md' # PowerShell: Using environment variable $env:PSRULE_OUTPUT_JOBSUMMARYPATH = 'reports/summary.md' ; # GitHub Actions: Using environment variable env : PSRULE_OUTPUT_JOBSUMMARYPATH : reports/summary.md # Azure Pipelines: Using environment variable variables : - name : PSRULE_OUTPUT_JOBSUMMARYPATH value : reports/summary.md Output.JsonIndent # Configures the number of spaces to indent JSON properties and elements. The default number of spaces is 0. This option applies to output generated from -OutputFormat Json for Get-PSRule and Invoke-PSRule . This option also applies to output generated from -OutputPath for Assert-PSRule . The range of indentation accepts a minimum of 0 (machine first) spaces and a maximum of 4 spaces. This option can be specified using: # PowerShell: Using the OutputJsonIndent parameter $option = New-PSRuleOption -OutputJsonIndent 2 ; # PowerShell: Using the Output.JsonIndent hashtable key $option = New-PSRuleOption -Option @{ 'Output.JsonIndent' = 2 }; # PowerShell: Using the OutputJsonIndent parameter to set YAML Set-PSRuleOption -OutputJsonIndent 2 ; # YAML: Using the output/jsonIndent property output : jsonIndent : 2 # Bash: Using environment variable export PSRULE_OUTPUT_JSONINDENT = 2 # PowerShell: Using environment variable $env:PSRULE_OUTPUT_JSONINDENT = 2 ; # GitHub Actions: Using environment variable env : PSRULE_OUTPUT_JSONINDENT : 2 # Azure Pipelines: Using environment variable variables : - name : PSRULE_OUTPUT_JSONINDENT value : 2 Repository.BaseRef # This option is used for specify the base branch for pull requests. When evaluating changes files only PSRule uses this option for comparison with the current branch. By default, the base ref is detected from environment variables set by the build system. This option can be specified using: # PowerShell: Using the RepositoryBaseRef parameter $option = New-PSRuleOption -RepositoryBaseRef 'main' ; # PowerShell: Using the Repository.BaseRef hashtable key $option = New-PSRuleOption -Option @{ 'Repository.BaseRef' = 'main' }; # PowerShell: Using the RepositoryBaseRef parameter to set YAML Set-PSRuleOption -RepositoryBaseRef 'main' ; # YAML: Using the repository/baseRef property repository : baseRef : main # Bash: Using environment variable export PSRULE_REPOSITORY_BASEREF = 'main' # PowerShell: Using environment variable $env:PSRULE_REPOSITORY_BASEREF = 'main' ; Repository.Url # This option can be configured to set the repository URL reported in output. By default, the repository URL is detected from environment variables set by the build system. In GitHub Actions, the repository URL is detected from the GITHUB_REPOSITORY environment variable. In Azure Pipelines, the repository URL is detected from the BUILD_REPOSITORY_URI environment variable. This option can be specified using: # PowerShell: Using the RepositoryUrl parameter $option = New-PSRuleOption -RepositoryUrl 'https://github.com/microsoft/PSRule' ; # PowerShell: Using the Repository.Url hashtable key $option = New-PSRuleOption -Option @{ 'Repository.Url' = 'https://github.com/microsoft/PSRule' }; # PowerShell: Using the RepositoryUrl parameter to set YAML Set-PSRuleOption -RepositoryUrl 'https://github.com/microsoft/PSRule' ; # YAML: Using the repository/url property repository : url : 'https://github.com/microsoft/PSRule' # Bash: Using environment variable export PSRULE_REPOSITORY_URL = 'https://github.com/microsoft/PSRule' # PowerShell: Using environment variable $env:PSRULE_REPOSITORY_URL = 'https://github.com/microsoft/PSRule' ; Requires # Specifies module version constraints for running PSRule. When set PSRule will error if a module version is used that does not satisfy the requirements. The format for version constraints are the same as the Version assertion method. See [about_PSRule_Assert] for more information. Module version constraints a not enforced prior to PSRule v0.19.0. The version constraint for a rule module is enforced when the module is included with -Module . A version constraint does not require a rule module to be included. Use the Include.Module option to automatically include a rule module. This option can be specified using: # PowerShell: Using the Requires.module hashtable key $option = New-PSRuleOption -Option @{ 'Requires.PSRule' = '>=1.0.0' }; # YAML: Using the requires property requires : PSRule : '>=1.0.0' # Require v1.0.0 or greater. PSRule.Rules.Azure : '>=1.0.0' # Require v1.0.0 or greater. PSRule.Rules.CAF : '@pre >=0.1.0' # Require stable or pre-releases v0.1.0 or greater. This option can be configured using environment variables. To specify a module version constraint, prefix the module name with PSRULE_REQUIRES_ . When the module name includes a dot ( . ) use an underscore ( _ ) instead. # Bash: Using environment variable export PSRULE_REQUIRES_PSRULE = '>=1.0.0' export PSRULE_REQUIRES_PSRULE_RULES_AZURE = '>=1.0.0' export PSRULE_REQUIRES_PSRULE_RULES_CAF = '@pre >=0.1.0' # GitHub Actions: Using environment variable env : PSRULE_REQUIRES_PSRULE : '>=1.0.0' PSRULE_REQUIRES_PSRULE_RULES_AZURE : '>=1.0.0' PSRULE_REQUIRES_PSRULE_RULES_CAF : '@pre >=0.1.0' # Azure Pipelines: Using environment variable variables : - name : PSRULE_REQUIRES_PSRULE value : '>=1.0.0' - name : PSRULE_REQUIRES_PSRULE_RULES_AZURE value : '>=1.0.0' - name : PSRULE_REQUIRES_PSRULE_RULES_CAF value : '@pre >=0.1.0' Rule.Baseline # The name of a default baseline to use for the module. Currently this option can only be set within a module configuration resource. For example: --- # Synopsis: Example module configuration for Enterprise.Rules module. apiVersion : github.com/microsoft/PSRule/v1 kind : ModuleConfig metadata : name : Enterprise.Rules spec : rule : baseline : Enterprise.Baseline1 Rule.Include # The name of specific rules to evaluate. If this option is not specified all rules in search paths will be evaluated. This option can be overridden at runtime by using the -Name cmdlet parameter. This option can be specified using: # PowerShell: Using the Rule.Include hashtable key $option = New-PSRuleOption -Option @{ 'Rule.Include' = 'Rule1' , 'Rule2' }; # YAML: Using the rule/include property rule : include : - Rule1 - Rule2 # Bash: Using environment variable export PSRULE_RULE_INCLUDE = 'Rule1;Rule2' # GitHub Actions: Using environment variable env : PSRULE_RULE_INCLUDE : 'Rule1;Rule2' # Azure Pipelines: Using environment variable variables : - name : PSRULE_RULE_INCLUDE value : 'Rule1;Rule2' Rule.IncludeLocal # Automatically include all local rules in the search path unless they have been explicitly excluded. This option will include local rules even when they do not match Rule.Include or Rule.Tag filters. By default, local rules will be filtered with Rule.Include and Rule.Tag filters. This option is useful when you want to include local rules not included in a baseline. This option can be specified using: # PowerShell: Using the RuleIncludeLocal parameter $option = New-PSRuleOption -RuleIncludeLocal $True ; # PowerShell: Using the Rule.IncludeLocal hashtable key $option = New-PSRuleOption -Option @{ 'Rule.IncludeLocal' = $True }; # PowerShell: Using the RuleIncludeLocal parameter to set YAML Set-PSRuleOption -RuleIncludeLocal $True ; # YAML: Using the rule/includeLocal property rule : includeLocal : true # Bash: Using environment variable export PSRULE_RULE_INCLUDELOCAL = true # GitHub Actions: Using environment variable env : PSRULE_RULE_INCLUDELOCAL : true # Azure Pipelines: Using environment variable variables : - name : PSRULE_RULE_INCLUDELOCAL value : true Rule.Exclude # The name of specific rules to exclude from being evaluated. This will exclude rules specified by Rule.Include or discovered from a search path. This option can be specified using: # PowerShell: Using the Rule.Exclude hashtable key $option = New-PSRuleOption -Option @{ 'Rule.Exclude' = 'Rule3' , 'Rule4' }; # YAML: Using the rule/exclude property rule : exclude : - Rule3 - Rule4 # Bash: Using environment variable export PSRULE_RULE_EXCLUDE = 'Rule3;Rule4' # GitHub Actions: Using environment variable env : PSRULE_RULE_EXCLUDE : 'Rule3;Rule4' # Azure Pipelines: Using environment variable variables : - name : PSRULE_RULE_EXCLUDE value : 'Rule3;Rule4' Rule.Tag # A set of required key value pairs (tags) that rules must have applied to them to be included. Multiple values can be specified for the same tag. When multiple values are used, only one must match. This option can be overridden at runtime by using the -Tag cmdlet parameter. This option can be specified using: # PowerShell: Using the Rule.Tag hashtable key $option = New-PSRuleOption -Option @{ 'Rule.Tag' = @{ severity = 'Critical' , 'Warning' } }; # YAML: Using the rule/tag property rule : tag : severity : Critical # YAML: Using the rule/tag property, with multiple values rule : tag : severity : - Critical - Warning In the example above, rules must have a tag of severity set to either Critical or Warning to be included. Suppression # In certain circumstances it may be necessary to exclude or suppress rules from processing objects that are in a known failed state. PSRule allows objects to be suppressed for a rule by TargetName. Objects that are suppressed are not processed by the rule at all but will continue to be processed by other rules. Rule suppression complements pre-filtering and pre-conditions. This option can be specified using: # PowerShell: Using the SuppressTargetName option with a hashtable $option = New-PSRuleOption -SuppressTargetName @{ 'storageAccounts.UseHttps' = 'TestObject1' , 'TestObject3' }; # YAML: Using the suppression property suppression : storageAccounts.UseHttps : targetName : - TestObject1 - TestObject3 In both of the above examples, TestObject1 and TestObject3 have been suppressed from being processed by a rule named storageAccounts.UseHttps . When to use rule suppression: A temporary exclusion for an object that is in a known failed state. When not to use rule suppression: An object should never be processed by any rule. Pre-filter the pipeline instead. The rule is not applicable because the object is the wrong type. Use pre-conditions on the rule instead. An example of pre-filtering: # Define objects to validate $items = @(); $items += [PSCustomObject] @{ Name = 'Fridge' ; Type = 'Equipment' ; Category = 'White goods' ; }; $items += [PSCustomObject] @{ Name = 'Apple' ; Type = 'Food' ; Category = 'Produce' ; }; $items += [PSCustomObject] @{ Name = 'Carrot' ; Type = 'Food' ; Category = 'Produce' ; }; # Example of pre-filtering, only food items are sent to Invoke-PSRule $items | Where-Object { $_ . Type -eq 'Food' } | Invoke-PSRule ; An example of pre-conditions: # A rule with a pre-condition to only process produce Rule 'isFruit' -If { $TargetObject . Category -eq 'Produce' } { # Condition to determine if the object is fruit $TargetObject . Name -in 'Apple' , 'Orange' , 'Pear' } Examples # Example ps-rule.yaml # # # PSRule example configuration # # Configures the repository repository : url : https://github.com/microsoft/PSRule baseRef : main # Configure required module versions requires : PSRule.Rules.Azure : '>=1.1.0' # Configure convention options convention : include : - 'Convention1' # Configure execution options execution : aliasReferenceWarning : false duplicateResourceId : Warn languageMode : ConstrainedLanguage inconclusiveWarning : false notProcessedWarning : false suppressedRuleWarning : false suppressionGroupExpired : Error # Configure include options include : module : - 'PSRule.Rules.Azure' path : [ ] # Configures input options input : format : Yaml ignoreGitPath : false ignoreObjectSource : true ignoreRepositoryCommon : false ignoreUnchangedPath : true objectPath : items pathIgnore : - '*.Designer.cs' targetType : - Microsoft.Compute/virtualMachines - Microsoft.Network/virtualNetworks # Configures outcome logging options logging : limitDebug : - Rule1 - Rule2 limitVerbose : - Rule1 - Rule2 ruleFail : Error rulePass : Information output : as : Summary banner : Minimal culture : - en-US encoding : UTF8 footer : RuleCount format : Json jobSummaryPath : reports/summary.md outcome : Fail sarifProblemsOnly : false style : GitHubActions # Configure rule suppression suppression : storageAccounts.UseHttps : targetName : - TestObject1 - TestObject3 # Configure baseline options binding : field : id : - ResourceId - AlternativeId ignoreCase : false nameSeparator : '::' preferTargetInfo : true targetName : - ResourceName - AlternateName targetType : - ResourceType - kind useQualifiedName : true configuration : appServiceMinInstanceCount : 2 rule : include : - rule1 - rule2 includeLocal : true exclude : - rule3 - rule4 tag : severity : - Critical - Warning Default ps-rule.yaml # # # PSRule defaults # # Note: Only properties that differ from the default values need to be specified. # Configure required module versions requires : { } # Configure convention options convention : include : [ ] # Configure execution options execution : aliasReferenceWarning : true duplicateResourceId : Error languageMode : FullLanguage inconclusiveWarning : true notProcessedWarning : true suppressedRuleWarning : true suppressionGroupExpired : Warn # Configure include options include : module : [ ] path : - '.ps-rule/' # Configures input options input : format : Detect ignoreGitPath : true ignoreObjectSource : false ignoreRepositoryCommon : true ignoreUnchangedPath : false objectPath : null pathIgnore : [ ] targetType : [ ] # Configures outcome logging options logging : limitDebug : [ ] limitVerbose : [ ] ruleFail : None rulePass : None output : as : Detail banner : Default culture : [ ] encoding : Default footer : Default format : None jobSummaryPath : null outcome : Processed sarifProblemsOnly : true style : Detect # Configure rule suppression suppression : { } # Configure baseline options binding : field : { } ignoreCase : true nameSeparator : '/' preferTargetInfo : false targetName : - TargetName - Name targetType : - PSObject.TypeNames[0] useQualifiedName : false configuration : { } rule : include : [ ] includeLocal : false exclude : [ ] tag : { } Links # Invoke-PSRule New-PSRuleOption Set-PSRuleOption","title":"Options"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#options","text":"Describes additional options that can be used during rule execution.","title":"Options"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#description","text":"PSRule lets you use options when calling cmdlets such as Invoke-PSRule and Test-PSRuleTarget to change how rules are processed. This topic describes what options are available, when to and how to use them. The following workspace options are available for use: Convention.Include Execution.AliasReferenceWarning Execution.DuplicateResourceId Execution.LanguageMode Execution.InconclusiveWarning Execution.InvariantCultureWarning Execution.InitialSessionState Execution.NotProcessedWarning Execution.SuppressedRuleWarning Execution.SuppressionGroupExpired Include.Module Include.Path Input.Format Input.IgnoreGitPath Input.IgnoreObjectSource Input.IgnoreRepositoryCommon Input.IgnoreUnchangedPath Input.ObjectPath Input.PathIgnore Input.TargetType Logging.LimitDebug Logging.LimitVerbose Logging.RuleFail Logging.RulePass Output.As Output.Banner Output.Culture Output.Encoding Output.Footer Output.Format Output.JobSummaryPath Output.JsonIndent Output.Outcome Output.Path Output.SarifProblemsOnly Output.Style Repository.BaseRef Repository.Url Requires Suppression Additionally the following baseline options can be included: Binding.Field Binding.IgnoreCase Binding.NameSeparator Binding.PreferTargetInfo Binding.TargetName Binding.TargetType Binding.UseQualifiedName Configuration Rule.Baseline Rule.Include Rule.IncludeLocal Rule.Exclude Rule.Tag See about_PSRule_Baseline for more information on baseline options. Options can be used with the following PSRule cmdlets: Export-PSRuleBaseline Get-PSRule Get-PSRuleBaseline Get-PSRuleHelp Invoke-PSRule Test-PSRuleTarget Each of these cmdlets support: Using the -Option parameter with an object created with the New-PSRuleOption cmdlet. See cmdlet help for syntax and examples. Using the -Option parameter with a hashtable object. Using the -Option parameter with a YAML file path. When using a hashtable object @{} , one or more options can be specified as keys using a dotted notation. For example: $option = @{ 'Output.Format' = 'Yaml' }; Invoke-PSRule -Path . -Option $option ; Invoke-PSRule -Path . -Option @{ 'Output.Format' = 'Yaml' }; The above example shows how the Output.Format option as a hashtable key can be used. Continue reading for a full list of options and how each can be used. Alternatively, options can be stored in a YAML formatted file and loaded from disk. Storing options as YAML allows different configurations to be loaded in a repeatable way instead of having to create an options object each time. Options are stored as YAML properties using a lower camel case naming convention, for example: output : format : Yaml The Set-PSRuleOption cmdlet can be used to set options stored in YAML or the YAML file can be manually edited. Set-PSRuleOption -OutputFormat Yaml ; By default, PSRule will automatically look for a default YAML options file in the current working directory. Alternatively, you can specify a specific file path. For example: Invoke-PSRule -Option '.\\myconfig.yml' ; New-PSRuleOption -Path '.\\myconfig.yaml' ; PSRule uses any of the following file names (in order) as the default YAML options file. If more than one of these files exist, the following order will be used to find the first match. ps-rule.yaml ps-rule.yml psrule.yaml psrule.yml We recommend only using lowercase characters as shown above. This is because not all operating systems treat case in the same way. Most options can be set using environment variables. When configuring environment variables we recommend that all capital letters are used. This is because environment variables are case-sensitive on some operating systems. PSRule environment variables use a consistent naming pattern of PSRULE_<PARENT>_<NAME> . Where <PARENT> is the parent class and <NAME> is the specific option. For example: Execution.InconclusiveWarning is configured by PSRULE_EXECUTION_INCONCLUSIVEWARNING . Input.TargetType is configured by PSRULE_INPUT_TARGETTYPE . Output.Format is configured by PSRULE_OUTPUT_FORMAT . When setting environment variables: Enum values are set by string. For example PSRULE_OUTPUT_FORMAT could be set to Yaml . Enum values are case-insensitive. Boolean values are set by true , false , 1 , or 0 . For example PSRULE_EXECUTION_INCONCLUSIVEWARNING could be set to false . Boolean values are case-insensitive. String array values can specify multiple items by using a semi-colon separator. For example PSRULE_INPUT_TARGETTYPE could be set to virtualMachine;virtualNetwork .","title":"Description"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#bindingfield","text":"When an object is passed from the pipeline, PSRule automatically extracts fields from object properties. PSRule provides standard fields such as TargetName and TargetType . In addition to standard fields, custom fields can be bound. Custom fields are available to rules and included in output. PSRule uses the following logic to determine which property should be used for binding: By default PSRule will not extract any custom fields. If custom fields are configured, PSRule will attempt to bind the field. If none of the configured property names exist, the field will be skipped. If more then one property name is configured, the order they are specified in the configuration determines precedence. i.e. The first configured property name will take precedence over the second property name. By default the property name will be matched ignoring case sensitivity. To use a case sensitive match, configure the Binding.IgnoreCase option. Custom field bindings can be specified using: # PowerShell: Using the BindingField parameter $option = New-PSRuleOption -BindingField @{ id = 'ResourceId' , 'AlternativeId' }; # PowerShell: Using the Binding.Field hashtable key $option = New-PSRuleOption -Option @{ 'Binding.Field' = @{ id = 'ResourceId' , 'AlternativeId' } }; # PowerShell: Using the BindingField parameter to set YAML Set-PSRuleOption -BindingField @{ id = 'ResourceId' , 'AlternativeId' }; # YAML: Using the binding/field property binding : field : id : - ResourceId - AlternativeId","title":"Binding.Field"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#bindingignorecase","text":"When evaluating an object, PSRule extracts a few key properties from the object to help filter rules and display output results. The process of extract these key properties is called binding . The properties that PSRule uses for binding can be customized by providing a order list of alternative properties to use. See Binding.TargetName and Binding.TargetType for these options. By default, custom property binding finds the first matching property by name regardless of case. i.e. Binding.IgnoreCase is true . To make custom bindings case sensitive, set the Binding.IgnoreCase option to false . Changing this option will affect custom property bindings for both TargetName and TargetType . Setting this option has no affect on binding defaults or custom scripts. This option can be specified using: # PowerShell: Using the BindingIgnoreCase parameter $option = New-PSRuleOption -BindingIgnoreCase $False ; # PowerShell: Using the Binding.IgnoreCase hashtable key $option = New-PSRuleOption -Option @{ 'Binding.IgnoreCase' = $False }; # PowerShell: Using the BindingIgnoreCase parameter to set YAML Set-PSRuleOption -BindingIgnoreCase $False ; # YAML: Using the binding/ignoreCase property binding : ignoreCase : false # Bash: Using environment variable export PSRULE_BINDING_IGNORECASE = false # GitHub Actions: Using environment variable env : PSRULE_BINDING_IGNORECASE : false # Azure Pipelines: Using environment variable variables : - name : PSRULE_BINDING_IGNORECASE value : false","title":"Binding.IgnoreCase"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#bindingnameseparator","text":"When an object is passed from the pipeline, PSRule assigns the object a TargetName . TargetName is used in output results to identify one object from another. In cases where different types of objects share the same TargetName , this may become confusing. Using a qualified name, prefixes the TargetName with TargetType . i.e. TargetType/TargetName To use a qualified name, see the Binding.UseQualifiedName option. By default, PSRule uses / to separate TargetType from TargetName . This option configures the separator that PSRule uses between the two components. This option can be specified using: # PowerShell: Using the BindingNameSeparator parameter $option = New-PSRuleOption -BindingNameSeparator '::' ; # PowerShell: Using the Binding.NameSeparator hashtable key $option = New-PSRuleOption -Option @{ 'Binding.NameSeparator' = '::' }; # PowerShell: Using the BindingNameSeparator parameter to set YAML Set-PSRuleOption -BindingNameSeparator '::' ; # YAML: Using the binding/nameSeparator property binding : nameSeparator : '::' # Bash: Using environment variable export PSRULE_BINDING_NAMESEPARATOR = '::' # GitHub Actions: Using environment variable env : PSRULE_BINDING_NAMESEPARATOR : '::' # Azure Pipelines: Using environment variable variables : - name : PSRULE_BINDING_NAMESEPARATOR value : '::'","title":"Binding.NameSeparator"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#bindingprefertargetinfo","text":"Some built-in objects within PSRule perform automatic binding of TargetName and TargetType. These built-in objects provide their own target info. When binding has been configured these values override automatic binding by default. This can occur when the built-in object uses one of the fields specified by the custom configuration. The common occurrences of this are on fields such as Name and FullName which are widely used. To prefer automatic binding when specified set this option to $True . This option can be specified using: # PowerShell: Using the BindingPreferTargetInfo parameter $option = New-PSRuleOption -BindingPreferTargetInfo $True ; # PowerShell: Using the Binding.PreferTargetInfo hashtable key $option = New-PSRuleOption -Option @{ 'Binding.PreferTargetInfo' = $True }; # PowerShell: Using the BindingPreferTargetInfo parameter to set YAML Set-PSRuleOption -BindingPreferTargetInfo $True ; # YAML: Using the binding/preferTargetInfo property binding : preferTargetInfo : true # Bash: Using environment variable export PSRULE_BINDING_PREFERTARGETINFO = false # GitHub Actions: Using environment variable env : PSRULE_BINDING_PREFERTARGETINFO : false # Azure Pipelines: Using environment variable variables : - name : PSRULE_BINDING_PREFERTARGETINFO value : false","title":"Binding.PreferTargetInfo"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#bindingtargetname","text":"When an object is passed from the pipeline, PSRule assigns the object a TargetName . TargetName is used in output results to identify one object from another. Many objects could be passed down the pipeline at the same time, so using a TargetName that is meaningful is important. TargetName is also used for advanced features such as rule suppression. The value that PSRule uses for TargetName is configurable. PSRule uses the following logic to determine what TargetName should be used: By default PSRule will: Use TargetName or Name properties on the object. These property names are case insensitive. If both TargetName and Name properties exist, TargetName will take precedence over Name . If neither TargetName or Name properties exist, a SHA1 hash of the object will be used as TargetName . If custom TargetName binding properties are configured, the property names specified will override the defaults. If none of the configured property names exist, PSRule will revert back to TargetName then Name . If more then one property name is configured, the order they are specified in the configuration determines precedence. i.e. The first configured property name will take precedence over the second property name. By default the property name will be matched ignoring case sensitivity. To use a case sensitive match, configure the Binding.IgnoreCase option. If a custom TargetName binding function is specified, the function will be evaluated first before any other option. If the function returns $Null then custom properties, TargetName and Name properties will be used. The custom binding function is executed outside the PSRule engine, so PSRule keywords and variables will not be available. Custom binding functions are blocked in constrained language mode is used. See language mode for more information. Custom property names to use for binding can be specified using: # PowerShell: Using the TargetName parameter $option = New-PSRuleOption -TargetName 'ResourceName' , 'AlternateName' ; # PowerShell: Using the Binding.TargetName hashtable key $option = New-PSRuleOption -Option @{ 'Binding.TargetName' = 'ResourceName' , 'AlternateName' }; # PowerShell: Using the TargetName parameter to set YAML Set-PSRuleOption -TargetName 'ResourceName' , 'AlternateName' ; # YAML: Using the binding/targetName property binding : targetName : - ResourceName - AlternateName # Bash: Using environment variable export PSRULE_BINDING_TARGETNAME = 'ResourceName;AlternateName' # GitHub Actions: Using environment variable env : PSRULE_BINDING_TARGETNAME : 'ResourceName;AlternateName' # Azure Pipelines: Using environment variable variables : - name : PSRULE_BINDING_TARGETNAME value : 'ResourceName;AlternateName' To specify a custom binding function use: # Create a custom function that returns a TargetName string $bindFn = { param ( $TargetObject ) $otherName = $TargetObject . PSObject . Properties [ 'OtherName' ]; if ( $Null -eq $otherName ) { return $Null } return $otherName . Value ; } # Specify the binding function script block code to execute $option = New-PSRuleOption -BindTargetName $bindFn ;","title":"Binding.TargetName"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#bindingtargettype","text":"When an object is passed from the pipeline, PSRule assigns the object a TargetType . TargetType is used to filter rules based on object type and appears in output results. The value that PSRule uses for TargetType is configurable. PSRule uses the following logic to determine what TargetType should be used: By default PSRule will: Use the default type presented by PowerShell from TypeNames . i.e. .PSObject.TypeNames[0] If custom TargetType binding properties are configured, the property names specified will override the defaults. If none of the configured property names exist, PSRule will revert back to the type presented by PowerShell. If more then one property name is configured, the order they are specified in the configuration determines precedence. i.e. The first configured property name will take precedence over the second property name. By default the property name will be matched ignoring case sensitivity. To use a case sensitive match, configure the Binding.IgnoreCase option. If a custom TargetType binding function is specified, the function will be evaluated first before any other option. If the function returns $Null then custom properties, or the type presented by PowerShell will be used in order instead. The custom binding function is executed outside the PSRule engine, so PSRule keywords and variables will not be available. Custom binding functions are blocked in constrained language mode is used. See language mode for more information. Custom property names to use for binding can be specified using: # PowerShell: Using the TargetType parameter $option = New-PSRuleOption -TargetType 'ResourceType' , 'kind' ; # PowerShell: Using the Binding.TargetType hashtable key $option = New-PSRuleOption -Option @{ 'Binding.TargetType' = 'ResourceType' , 'kind' }; # PowerShell: Using the TargetType parameter to set YAML Set-PSRuleOption -TargetType 'ResourceType' , 'kind' ; # YAML: Using the binding/targetType property binding : targetType : - ResourceType - kind # Bash: Using environment variable export PSRULE_BINDING_TARGETTYPE = 'ResourceType;kind' # GitHub Actions: Using environment variable env : PSRULE_BINDING_TARGETTYPE : 'ResourceType;kind' # Azure Pipelines: Using environment variable variables : - name : PSRULE_BINDING_TARGETTYPE value : 'ResourceType;kind' To specify a custom binding function use: # Create a custom function that returns a TargetType string $bindFn = { param ( $TargetObject ) $otherType = $TargetObject . PSObject . Properties [ 'OtherType' ]; if ( $otherType -eq $Null ) { return $Null } return $otherType . Value ; } # Specify the binding function script block code to execute $option = New-PSRuleOption -BindTargetType $bindFn ;","title":"Binding.TargetType"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#bindingusequalifiedname","text":"When an object is passed from the pipeline, PSRule assigns the object a TargetName . TargetName is used in output results to identify one object from another. In cases where different types of objects share the same TargetName , this may become confusing. Using a qualified name, prefixes the TargetName with TargetType . i.e. TargetType/TargetName This option determines if PSRule uses qualified or unqualified names (default). By default, PSRule uses / to separate TargetType from TargetName . Set Binding.NameSeparator to change. This option can be specified using: # PowerShell: Using the BindingUseQualifiedName parameter $option = New-PSRuleOption -BindingUseQualifiedName $True ; # PowerShell: Using the Binding.UseQualifiedName hashtable key $option = New-PSRuleOption -Option @{ 'Binding.UseQualifiedName' = $True }; # PowerShell: Using the BindingUseQualifiedName parameter to set YAML Set-PSRuleOption -BindingUseQualifiedName $True ; # YAML: Using the binding/useQualifiedName property binding : useQualifiedName : true # Bash: Using environment variable export PSRULE_BINDING_USEQUALIFIEDNAME = false # GitHub Actions: Using environment variable env : PSRULE_BINDING_USEQUALIFIEDNAME : false # Azure Pipelines: Using environment variable variables : - name : PSRULE_BINDING_USEQUALIFIEDNAME value : false","title":"Binding.UseQualifiedName"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#configuration","text":"Configures a set of baseline configuration values that can be used in rule definitions. Configuration values can be overridden at different scopes. This option can be specified using: # PowerShell: Using the Configuration option with a hashtable $option = New-PSRuleOption -Configuration @{ LOCAL_APPSERVICEMININSTANCECOUNT = 2 }; # YAML: Using the configuration property configuration : LOCAL_APPSERVICEMININSTANCECOUNT : 2 Configuration values can be specified using environment variables. To specify a configuration value, prefix the configuration value with PSRULE_CONFIGURATION_ . # Bash: Using environment variable export PSRULE_CONFIGURATION_LOCAL_APPSERVICEMININSTANCECOUNT = 2 # GitHub Actions: Using environment variable env : PSRULE_CONFIGURATION_LOCAL_APPSERVICEMININSTANCECOUNT : '2' # Azure Pipelines: Using environment variable variables : - name : PSRULE_CONFIGURATION_LOCAL_APPSERVICEMININSTANCECOUNT value : '2'","title":"Configuration"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#conventioninclude","text":"Specifies conventions to execute when the pipeline run. Conventions are included by name and must be defined within files included in -Path or -Module . This option can be specified using: # PowerShell: Using the Convention parameter $option = New-PSRuleOption -Convention 'Convention1' , 'Convention2' ; # PowerShell: Using the Convention.Include hashtable key $option = New-PSRuleOption -Option @{ 'Convention.Include' = $True }; # PowerShell: Using the Convention parameter to set YAML Set-PSRuleOption -Convention 'Convention1' , 'Convention2' ; # YAML: Using the convention/include property convention : include : - 'Convention1' - 'Convention2' # Bash: Using environment variable export PSRULE_CONVENTION_INCLUDE = 'Convention1;Convention2' # GitHub Actions: Using environment variable env : PSRULE_CONVENTION_INCLUDE : 'Convention1;Convention2' # Azure Pipelines: Using environment variable variables : - name : PSRULE_CONVENTION_INCLUDE value : 'Convention1;Convention2'","title":"Convention.Include"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#executionaliasreferencewarning","text":"Rules may define one or more aliases. These aliases are alternative names to identify the rule. An alias may be used to reference the rule anywhere a rule name is used. The primary purpose of an alias is to provide a non-breaking method to change the rule name. Alises can be removed at a later revision once the rule is no longer referenced by the alias. A warning is logged by default to help identify when an alias is used. We recommend taking action to update your usage of the alis to use the rule name or ref instead. Alternatively, the alias reference warning can be disabled by using: # PowerShell: Using the AliasReferenceWarning parameter $option = New-PSRuleOption -AliasReferenceWarning $False ; # PowerShell: Using the Execution.AliasReferenceWarning hashtable key $option = New-PSRuleOption -Option @{ 'Execution.AliasReferenceWarning' = $False }; # PowerShell: Using the AliasReferenceWarning parameter to set YAML Set-PSRuleOption -AliasReferenceWarning $False ; # YAML: Using the execution/aliasReferenceWarning property execution : aliasReferenceWarning : false # Bash: Using environment variable export PSRULE_EXECUTION_ALIASREFERENCEWARNING = false # GitHub Actions: Using environment variable env : PSRULE_EXECUTION_ALIASREFERENCEWARNING : false # Azure Pipelines: Using environment variable variables : - name : PSRULE_EXECUTION_ALIASREFERENCEWARNING value : false","title":"Execution.AliasReferenceWarning"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#executionduplicateresourceid","text":"Determines how to handle duplicate resources identifiers during execution. A duplicate resource identifier may exist if two resources are defined with the same name, ref, or alias. By defaut, an error is thrown, however this behaviour can be modified by this option. If this option is configured to Warn or Ignore only the first resource will be used, however PSRule will continue to execute. The following preferences are available: None (0) - No preference. Inherits the default of Error . Ignore (1) - Continue to execute silently. Warn (2) - Continue to execute but log a warning. Error (3) - Abort and throw an error. This is the default. Debug (4) - Continue to execute but log a debug message. # PowerShell: Using the DuplicateResourceId parameter $option = New-PSRuleOption -DuplicateResourceId 'Warn' ; # PowerShell: Using the Execution.DuplicateResourceId hashtable key $option = New-PSRuleOption -Option @{ 'Execution.DuplicateResourceId' = 'Warn' }; # PowerShell: Using the DuplicateResourceId parameter to set YAML Set-PSRuleOption -DuplicateResourceId 'Warn' ; # YAML: Using the execution/duplicateResourceId property execution : duplicateResourceId : Warn # Bash: Using environment variable export PSRULE_EXECUTION_DUPLICATERESOURCEID = Warn # GitHub Actions: Using environment variable env : PSRULE_EXECUTION_DUPLICATERESOURCEID : Warn # Azure Pipelines: Using environment variable variables : - name : PSRULE_EXECUTION_DUPLICATERESOURCEID value : Warn","title":"Execution.DuplicateResourceId"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#executionlanguagemode","text":"Unless PowerShell has been constrained, full language features of PowerShell are available to use within rule definitions. In locked down environments, a reduced set of language features may be desired. When PSRule is executed in an environment configured for Device Guard, only constrained language features are available. The following language modes are available for use in PSRule: FullLanguage ConstrainedLanguage This option can be specified using: # PowerShell: Using the Execution.LanguageMode hashtable key $option = New-PSRuleOption -Option @{ 'Execution.LanguageMode' = 'ConstrainedLanguage' }; # YAML: Using the execution/languageMode property execution : languageMode : ConstrainedLanguage # Bash: Using environment variable export PSRULE_EXECUTION_LANGUAGEMODE = ConstrainedLanguage # GitHub Actions: Using environment variable env : PSRULE_EXECUTION_LANGUAGEMODE : ConstrainedLanguage # Azure Pipelines: Using environment variable variables : - name : PSRULE_EXECUTION_LANGUAGEMODE value : ConstrainedLanguage","title":"Execution.LanguageMode"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#executioninconclusivewarning","text":"When defining rules, it is possible not return a valid $True or $False result within the definition script block. Rule authors should not intentionally avoid returning a result, however a possible cause for not returning a result may be a rule logic error. If a rule should not be evaluated, use pre-conditions to avoid processing the rule for objects where the rule is not applicable. In cases where the rule does not return a result it is marked as inconclusive. Inconclusive results will: Generate a warning by default. Fail the object. Outcome will be reported as Fail with an OutcomeReason of Inconclusive . The inconclusive warning can be disabled by using: # PowerShell: Using the InconclusiveWarning parameter $option = New-PSRuleOption -InconclusiveWarning $False ; # PowerShell: Using the Execution.InconclusiveWarning hashtable key $option = New-PSRuleOption -Option @{ 'Execution.InconclusiveWarning' = $False }; # PowerShell: Using the InconclusiveWarning parameter to set YAML Set-PSRuleOption -InconclusiveWarning $False ; # YAML: Using the execution/inconclusiveWarning property execution : inconclusiveWarning : false # Bash: Using environment variable export PSRULE_EXECUTION_INCONCLUSIVEWARNING = false # GitHub Actions: Using environment variable env : PSRULE_EXECUTION_INCONCLUSIVEWARNING : false # Azure Pipelines: Using environment variable variables : - name : PSRULE_EXECUTION_INCONCLUSIVEWARNING value : false","title":"Execution.InconclusiveWarning"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#executioninvariantculturewarning","text":"When evaluating rules inside a CI host, if invariant culture is used, a warning is shown by default. You can suppress this warning if you set the culture with -Culture or the Output.Culture option. This warning can also be suppressed by using: # PowerShell: Using the InvariantCultureWarning parameter $option = New-PSRuleOption -InvariantCultureWarning $False ; # PowerShell: Using the Execution.InvariantCultureWarning hashtable key $option = New-PSRuleOption -Option @{ 'Execution.InvariantCultureWarning' = $False }; # PowerShell: Using the InvariantCultureWarning parameter to set YAML Set-PSRuleOption -InvariantCultureWarning $False ; # YAML: Using the execution/invariantCultureWarning property execution : invariantCultureWarning : false # Bash: Using environment variable export PSRULE_EXECUTION_INVARIANTCULTUREWARNING = false # GitHub Actions: Using environment variable env : PSRULE_EXECUTION_INVARIANTCULTUREWARNING : false # Azure Pipelines: Using environment variable variables : - name : PSRULE_EXECUTION_INVARIANTCULTUREWARNING value : false","title":"Execution.InvariantCultureWarning"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#executioninitialsessionstate","text":"Determines how the initial session state for executing PowerShell code is created. The following preferences are available: BuiltIn (0) - Create the initial session state with all built-in cmdlets loaded. This is the default. Minimal (1) - Create the initial session state with only a minimum set of cmdlets loaded. # PowerShell: Using the InitialSessionState parameter $option = New-PSRuleOption -InitialSessionState 'Minimal' ; # PowerShell: Using the Execution.InitialSessionState hashtable key $option = New-PSRuleOption -Option @{ 'Execution.InitialSessionState' = 'Minimal' }; # PowerShell: Using the InitialSessionState parameter to set YAML Set-PSRuleOption -InitialSessionState 'Minimal' ; # YAML: Using the execution/initialSessionState property execution : initialSessionState : Minimal # Bash: Using environment variable export PSRULE_EXECUTION_INITIALSESSIONSTATE = Minimal # GitHub Actions: Using environment variable env : PSRULE_EXECUTION_INITIALSESSIONSTATE : Minimal # Azure Pipelines: Using environment variable variables : - name : PSRULE_EXECUTION_INITIALSESSIONSTATE value : Minimal","title":"Execution.InitialSessionState"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#executionnotprocessedwarning","text":"When evaluating rules, it is possible to incorrectly select a path with rules that use pre-conditions that do not accept the pipeline object. In this case the object has not been processed by any rule. Not processed objects will: Generate a warning by default. Pass the object. Outcome will be reported as None . The not processed warning can be disabled by using: # PowerShell: Using the NotProcessedWarning parameter $option = New-PSRuleOption -NotProcessedWarning $False ; # PowerShell: Using the Execution.NotProcessedWarning hashtable key $option = New-PSRuleOption -Option @{ 'Execution.NotProcessedWarning' = $False }; # PowerShell: Using the NotProcessedWarning parameter to set YAML Set-PSRuleOption -NotProcessedWarning $False ; # YAML: Using the execution/notProcessedWarning property execution : notProcessedWarning : false # Bash: Using environment variable export PSRULE_EXECUTION_NOTPROCESSEDWARNING = false # GitHub Actions: Using environment variable env : PSRULE_EXECUTION_NOTPROCESSEDWARNING : false # Azure Pipelines: Using environment variable variables : - name : PSRULE_EXECUTION_NOTPROCESSEDWARNING value : false","title":"Execution.NotProcessedWarning"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#executionsuppressedrulewarning","text":"When evaluating rules, it is possible to output suppressed rules as warnings. Suppressed rules will: Output a warning by default. Show which rules were suppressed when Output.As is set to Detail . Show how many rules were suppressed when Output.As is set to Summary . The suppressed rule can be disabled by using: # PowerShell: Using the SuppressedRuleWarning parameter $option = New-PSRuleOption -SuppressedRuleWarning $False ; # PowerShell: Using the Execution.SuppressedRuleWarning hashtable key $option = New-PSRuleOption -Option @{ 'Execution.SuppressedRuleWarning' = $False }; # PowerShell: Using the SuppressedRuleWarning parameter to set YAML Set-PSRuleOption -SuppressedRuleWarning $False ; # YAML: Using the execution/suppressedRuleWarning property execution : suppressedRuleWarning : false # Bash: Using environment variable export PSRULE_EXECUTION_SUPPRESSEDRULEWARNING = false # GitHub Actions: Using environment variable env : PSRULE_EXECUTION_SUPPRESSEDRULEWARNING : false # Azure Pipelines: Using environment variable variables : - name : PSRULE_EXECUTION_SUPPRESSEDRULEWARNING value : false","title":"Execution.SuppressedRuleWarning"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#executionsuppressiongroupexpired","text":"Determines how to handle expired suppression groups. Regardless of the value, an expired suppression group will be ignored. By defaut, a warning is generated, however this behaviour can be modified by this option. The following preferences are available: None (0) - No preference. Inherits the default of Warn . Ignore (1) - Continue to execute silently. Warn (2) - Continue to execute but log a warning. This is the default. Error (3) - Abort and throw an error. Debug (4) - Continue to execute but log a debug message. # PowerShell: Using the SuppressionGroupExpired parameter $option = New-PSRuleOption -SuppressionGroupExpired 'Error' ; # PowerShell: Using the Execution.SuppressionGroupExpired hashtable key $option = New-PSRuleOption -Option @{ 'Execution.SuppressionGroupExpired' = 'Error' }; # PowerShell: Using the SuppressionGroupExpired parameter to set YAML Set-PSRuleOption -SuppressionGroupExpired 'Error' ; # YAML: Using the execution/suppressionGroupExpired property execution : suppressionGroupExpired : Error # Bash: Using environment variable export PSRULE_EXECUTION_SUPPRESSIONGROUPEXPIRED = Error # GitHub Actions: Using environment variable env : PSRULE_EXECUTION_SUPPRESSIONGROUPEXPIRED : Error # Azure Pipelines: Using environment variable variables : - name : PSRULE_EXECUTION_SUPPRESSIONGROUPEXPIRED value : Error","title":"Execution.SuppressionGroupExpired"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#includemodule","text":"Automatically include rules and resources from the specified module. To automatically import and include a module specify the module by name. The module must already be installed on the system. When $PSModuleAutoLoadingPreference is set to a value other then All the module must be imported. This option is equivalent to using the -Module parameter on PSRule cmdlets, with the following addition: Modules specified with Include.Module are combined with -Module . Both sets of modules will be imported and used using execution. This option can be specified using: # PowerShell: Using the IncludeModule parameter $option = New-PSRuleOption -IncludeModule 'TestModule1' , 'TestModule2' ; # PowerShell: Using the Include.Module hashtable key $option = New-PSRuleOption -Option @{ 'Include.Module' = 'TestModule1' , 'TestModule2' }; # PowerShell: Using the IncludeModule parameter to set YAML Set-PSRuleOption -IncludeModule 'TestModule1' , 'TestModule2' ; # YAML: Using the include/module property include : module : - TestModule1 # Bash: Using environment variable export PSRULE_INCLUDE_MODULE = TestModule1 ; TestModule2 # GitHub Actions: Using environment variable env : PSRULE_INCLUDE_MODULE : TestModule1;TestModule2 # Azure Pipelines: Using environment variable variables : - name : PSRULE_INCLUDE_MODULE value : TestModule1;TestModule2","title":"Include.Module"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#includepath","text":"Automatically include rules and resources from the specified path. By default, .ps-rule/ is included. This option is equivalent to using the -Path parameter on PSRule cmdlets, with the following additions: Paths specified with Include.Path are combined with -Path . Both sets of paths will be imported and used using execution. The Include.Path option defaults to .ps-rule/ . To override this default, specify one or more alternative paths or an empty array. This option can be specified using: # PowerShell: Using the IncludePath parameter $option = New-PSRuleOption -IncludePath '.ps-rule/' , 'custom-rules/' ; # PowerShell: Using the Include.Path hashtable key $option = New-PSRuleOption -Option @{ 'Include.Path' = '.ps-rule/' , 'custom-rules/' }; # PowerShell: Using the IncludePath parameter to set YAML Set-PSRuleOption -IncludePath '.ps-rule/' , 'custom-rules/' ; # YAML: Using the include/path property include : path : - custom-rules/ # Bash: Using environment variable export PSRULE_INCLUDE_PATH = .ps-rule/ ; custom-rules/ # GitHub Actions: Using environment variable env : PSRULE_INCLUDE_PATH : .ps-rule/;custom-rules/ # Azure Pipelines: Using environment variable variables : - name : PSRULE_INCLUDE_PATH value : .ps-rule/;custom-rules/","title":"Include.Path"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#inputformat","text":"Configures the input format for when a string is passed in as a target object. This option determines if the target object is deserialized into an alternative form. Use this option with Assert-PSRule , Invoke-PSRule or Test-PSRuleTarget . Set this option to either Yaml , Json , Markdown , PowerShellData to deserialize as a specific format. The -Format parameter will override any value set in configuration. When the -InputObject parameter or pipeline input is used, strings are treated as plain text by default. FileInfo objects for supported file formats will be deserialized based on file extension. When the -InputPath parameter is used, supported file formats will be deserialized based on file extension. The -InputPath parameter can be used with a file path or URL. The following formats are available: None - Treat strings as plain text and do not deserialize files. Yaml - Deserialize as one or more YAML objects. Json - Deserialize as one or more JSON objects. Markdown - Deserialize as a markdown object. PowerShellData - Deserialize as a PowerShell data object. File - Files are not deserialized. Detect - Detect format based on file extension. This is the default. If the Detect format is used, the file extension will be used to automatically detect the format. When the file extension can not be determined Detect is the same as None . The Markdown format does not parse the whole markdown document. Specifically this format deserializes YAML front matter from the top of the document if any exists. The File format does not deserialize file contents. Each file is returned as an object. Files within .git sub-directories are ignored. Path specs specified in .gitignore directly in the current working path are ignored. A RepositoryInfo object is generated if the current working path if a .git sub-directory is present. Additionally, PSRule performs automatic type binding for file objects, using the extension as the type. When files have no extension the whole file name is used. Detect uses the following file extensions: Yaml - .yaml or .yml Json - .json or .jsonc Markdown - .md or .markdown PowerShellData - .psd1 This option can be specified using: # PowerShell: Using the Format parameter $option = New-PSRuleOption -Format Yaml ; # PowerShell: Using the Input.Format hashtable key $option = New-PSRuleOption -Option @{ 'Input.Format' = 'Yaml' }; # PowerShell: Using the Format parameter to set YAML Set-PSRuleOption -Format Yaml ; # YAML: Using the input/format property input : format : Yaml # Bash: Using environment variable export PSRULE_INPUT_FORMAT = Yaml # GitHub Actions: Using environment variable env : PSRULE_INPUT_FORMAT : Yaml # Azure Pipelines: Using environment variable variables : - name : PSRULE_INPUT_FORMAT value : Yaml","title":"Input.Format"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#inputignoregitpath","text":"When reading files from an input path, files within the .git sub-directory are ignored by default. Files stored within the .git sub-directory are system repository files used by git. To read files stored within the .git path, set this option to $False . This option can be specified using: # PowerShell: Using the InputIgnoreGitPath parameter $option = New-PSRuleOption -InputIgnoreGitPath $False ; # PowerShell: Using the Input.IgnoreGitPath hashtable key $option = New-PSRuleOption -Option @{ 'Input.IgnoreGitPath' = $False }; # PowerShell: Using the InputIgnoreGitPath parameter to set YAML Set-PSRuleOption -InputIgnoreGitPath $False ; # YAML: Using the input/ignoreGitPath property input : ignoreGitPath : false # Bash: Using environment variable export PSRULE_INPUT_IGNOREGITPATH = false # GitHub Actions: Using environment variable env : PSRULE_INPUT_IGNOREGITPATH : false # Azure Pipelines: Using environment variable variables : - name : PSRULE_INPUT_IGNOREGITPATH value : false","title":"Input.IgnoreGitPath"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#inputignoreobjectsource","text":"By default, objects read from file using inputPath will be skipped if the file path has been ignored. When set to true, additionally objects with a source path that has been ignored will be skipped. This will include FileInfo objects, and objects with a source set using the _PSRule.source property. File paths to ignore are set by Input.PathIgnore , Input.IgnoreGitPath , and Input.IgnoreRepositoryCommon . This option can be specified using: # PowerShell: Using the InputIgnoreObjectSource parameter $option = New-PSRuleOption -InputIgnoreObjectSource $True ; # PowerShell: Using the Input.IgnoreObjectSource hashtable key $option = New-PSRuleOption -Option @{ 'Input.IgnoreObjectSource' = $True }; # PowerShell: Using the InputIgnoreObjectSource parameter to set YAML Set-PSRuleOption -InputIgnoreObjectSource $True ; # YAML: Using the input/ignoreObjectSource property input : ignoreObjectSource : true # Bash: Using environment variable export PSRULE_INPUT_IGNOREOBJECTSOURCE = true # GitHub Actions: Using environment variable env : PSRULE_INPUT_IGNOREOBJECTSOURCE : true # Azure Pipelines: Using environment variable variables : - name : PSRULE_INPUT_IGNOREOBJECTSOURCE value : true","title":"Input.IgnoreObjectSource"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#inputignorerepositorycommon","text":"When reading files from an input path, files are discovered recursively. A number of files are commonly found within a private and open-source repositories. In many cases these files are of no interest for analysis and should be ignored by rules. PSRule will ignore the following files by default: README.md .DS_Store .gitignore .gitattributes .gitmodules LICENSE LICENSE.txt CODE_OF_CONDUCT.md CONTRIBUTING.md SECURITY.md SUPPORT.md .vscode/*.json .vscode/*.code-snippets .github/**/*.md .github/CODEOWNERS .pipelines/**/*.yml .pipelines/**/*.yaml .azure-pipelines/**/*.yml .azure-pipelines/**/*.yaml .azuredevops/*.md To include these files, set this option to $False . This option can be specified using: # PowerShell: Using the InputIgnoreRepositoryCommon parameter $option = New-PSRuleOption -InputIgnoreRepositoryCommon $False ; # PowerShell: Using the Input.IgnoreRepositoryCommon hashtable key $option = New-PSRuleOption -Option @{ 'Input.IgnoreRepositoryCommon' = $False }; # PowerShell: Using the InputIgnoreRepositoryCommon parameter to set YAML Set-PSRuleOption -InputIgnoreRepositoryCommon $False ; # YAML: Using the input/ignoreRepositoryCommon property input : ignoreRepositoryCommon : false # Bash: Using environment variable export PSRULE_INPUT_IGNOREREPOSITORYCOMMON = false # GitHub Actions: Using environment variable env : PSRULE_INPUT_IGNOREREPOSITORYCOMMON : false # Azure Pipelines: Using environment variable variables : - name : PSRULE_INPUT_IGNOREREPOSITORYCOMMON value : false","title":"Input.IgnoreRepositoryCommon"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#inputignoreunchangedpath","text":"By default, PSRule will process all files within an input path. For large repositories, this can result in a large number of files being processed. Additionally, for a pull request you may only be interested in files that have changed. When set to true , files that have not changed will be ignored. This option can be specified using: # PowerShell: Using the InputIgnoreUnchangedPath parameter $option = New-PSRuleOption -InputIgnoreUnchangedPath $True ; # PowerShell: Using the Input.IgnoreUnchangedPath hashtable key $option = New-PSRuleOption -Option @{ 'Input.IgnoreUnchangedPath' = $True }; # PowerShell: Using the InputIgnoreUnchangedPath parameter to set YAML Set-PSRuleOption -InputIgnoreUnchangedPath $True ; # YAML: Using the input/ignoreUnchangedPath property input : ignoreUnchangedPath : true # Bash: Using environment variable export PSRULE_INPUT_IGNOREUNCHANGEDPATH = true # GitHub Actions: Using environment variable env : PSRULE_INPUT_IGNOREUNCHANGEDPATH : true # Azure Pipelines: Using environment variable variables : - name : PSRULE_INPUT_IGNOREUNCHANGEDPATH value : true","title":"Input.IgnoreUnchangedPath"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#inputobjectpath","text":"The object path to a property to use instead of the pipeline object. By default, PSRule processes objects passed from the pipeline against selected rules. When this option is set, instead of evaluating the pipeline object, PSRule looks for a property of the pipeline object specified by ObjectPath and uses that instead. If the property specified by ObjectPath is a collection/ array, then each item is evaluated separately. If the property specified by ObjectPath does not exist, PSRule skips the object. When using Invoke-PSRule , Test-PSRuleTarget and Assert-PSRule the -ObjectPath parameter will override any value set in configuration. This option can be specified using: # PowerShell: Using the ObjectPath parameter $option = New-PSRuleOption -ObjectPath 'items' ; # PowerShell: Using the Input.ObjectPath hashtable key $option = New-PSRuleOption -Option @{ 'Input.ObjectPath' = 'items' }; # PowerShell: Using the ObjectPath parameter to set YAML Set-PSRuleOption -ObjectPath 'items' ; # YAML: Using the input/objectPath property input : objectPath : items # Bash: Using environment variable export PSRULE_INPUT_OBJECTPATH = items # GitHub Actions: Using environment variable env : PSRULE_INPUT_OBJECTPATH : items # Azure Pipelines: Using environment variable variables : - name : PSRULE_INPUT_OBJECTPATH value : items","title":"Input.ObjectPath"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#inputpathignore","text":"Ignores input files that match the path spec when using -InputPath . If specified, files that match the path spec will not be processed. By default, all files are processed. This option can be specified using: # PowerShell: Using the InputPathIgnore parameter $option = New-PSRuleOption -InputPathIgnore '*.Designer.cs' ; # PowerShell: Using the Input.PathIgnore hashtable key $option = New-PSRuleOption -Option @{ 'Input.PathIgnore' = '*.Designer.cs' }; # PowerShell: Using the InputPathIgnore parameter to set YAML Set-PSRuleOption -InputPathIgnore '*.Designer.cs' ; # YAML: Using the input/pathIgnore property input : pathIgnore : - '*.Designer.cs' # Bash: Using environment variable export PSRULE_INPUT_PATHIGNORE = *.Designer.cs # GitHub Actions: Using environment variable env : PSRULE_INPUT_PATHIGNORE : '*.Designer.cs' # Azure Pipelines: Using environment variable variables : - name : PSRULE_INPUT_PATHIGNORE value : '*.Designer.cs'","title":"Input.PathIgnore"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#inputtargettype","text":"Filters input objects by TargetType. If specified, only objects with the specified TargetType are processed. Objects that do not match TargetType are ignored. If multiple values are specified, only one TargetType must match. This option is not case-sensitive. By default, all objects are processed. To change the field TargetType is bound to set the Binding.TargetType option. When using Invoke-PSRule , Test-PSRuleTarget and Assert-PSRule the -TargetType parameter will override any value set in configuration. This option can be specified using: # PowerShell: Using the InputTargetType parameter $option = New-PSRuleOption -InputTargetType 'virtualMachine' , 'virtualNetwork' ; # PowerShell: Using the Input.TargetType hashtable key $option = New-PSRuleOption -Option @{ 'Input.TargetType' = 'virtualMachine' , 'virtualNetwork' }; # PowerShell: Using the InputTargetType parameter to set YAML Set-PSRuleOption -InputTargetType 'virtualMachine' , 'virtualNetwork' ; # YAML: Using the input/targetType property input : targetType : - virtualMachine # Bash: Using environment variable export PSRULE_INPUT_TARGETTYPE = virtualMachine ; virtualNetwork # GitHub Actions: Using environment variable env : PSRULE_INPUT_TARGETTYPE : virtualMachine;virtualNetwork # Azure Pipelines: Using environment variable variables : - name : PSRULE_INPUT_TARGETTYPE value : virtualMachine;virtualNetwork","title":"Input.TargetType"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#logginglimitdebug","text":"Limits debug messages to a list of named debug scopes. When using the -Debug switch or preference variable, by default PSRule cmdlets log all debug output. When using debug output for debugging a specific rule, it may be helpful to limit debug message to a specific rule. To identify a rule to include in debug output use the rule name. The following built-in scopes exist in addition to rule names: [Discovery.Source] - Discovery messages for .Rule.ps1 files and rule modules. [Discovery.Rule] - Discovery messages for individual rules within .Rule.ps1 files. This option can be specified using: # PowerShell: Using the LoggingLimitDebug parameter $option = New-PSRuleOption -LoggingLimitDebug Rule1 , Rule2 ; # PowerShell: Using the Logging.LimitDebug hashtable key $option = New-PSRuleOption -Option @{ 'Logging.LimitDebug' = Rule1 , Rule2 }; # PowerShell: Using the LoggingLimitDebug parameter to set YAML Set-PSRuleOption -LoggingLimitDebug Rule1 , Rule2 ; # YAML: Using the logging/limitDebug property logging : limitDebug : - Rule1 - Rule2","title":"Logging.LimitDebug"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#logginglimitverbose","text":"Limits verbose messages to a list of named verbose scopes. When using the -Verbose switch or preference variable, by default PSRule cmdlets log all verbose output. When using verbose output for troubleshooting a specific rule, it may be helpful to limit verbose messages to a specific rule. To identify a rule to include in verbose output use the rule name. The following built-in scopes exist in addition to rule names: [Discovery.Source] - Discovery messages for .Rule.ps1 files and rule modules. [Discovery.Rule] - Discovery messages for individual rules within .Rule.ps1 files. This option can be specified using: # PowerShell: Using the LoggingLimitVerbose parameter $option = New-PSRuleOption -LoggingLimitVerbose Rule1 , Rule2 ; # PowerShell: Using the Logging.LimitVerbose hashtable key $option = New-PSRuleOption -Option @{ 'Logging.LimitVerbose' = Rule1 , Rule2 }; # PowerShell: Using the LoggingLimitVerbose parameter to set YAML Set-PSRuleOption -LoggingLimitVerbose Rule1 , Rule2 ; # YAML: Using the logging/limitVerbose property logging : limitVerbose : - Rule1 - Rule2","title":"Logging.LimitVerbose"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#loggingrulefail","text":"When an object fails a rule condition the results are written to output as a structured object marked with the outcome of Fail . If the rule executed successfully regardless of outcome no other informational messages are shown by default. In some circumstances such as a continuous integration (CI) pipeline, it may be preferable to see informational messages or abort the CI process if one or more Fail outcomes are returned. By settings this option, error, warning or information messages will be generated for each rule fail outcome in addition to structured output. By default, outcomes are not logged to an informational stream (i.e. None). The following streams available: None Error Warning Information This option can be specified using: # PowerShell: Using the LoggingRuleFail parameter $option = New-PSRuleOption -LoggingRuleFail Error ; # PowerShell: Using the Logging.RuleFail hashtable key $option = New-PSRuleOption -Option @{ 'Logging.RuleFail' = 'Error' }; # PowerShell: Using the LoggingRuleFail parameter to set YAML Set-PSRuleOption -LoggingRuleFail Error ; # YAML: Using the logging/ruleFail property logging : ruleFail : Error","title":"Logging.RuleFail"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#loggingrulepass","text":"When an object passes a rule condition the results are written to output as a structured object marked with the outcome of Pass . If the rule executed successfully regardless of outcome no other informational messages are shown by default. In some circumstances such as a continuous integration (CI) pipeline, it may be preferable to see informational messages. By settings this option, error, warning or information messages will be generated for each rule pass outcome in addition to structured output. By default, outcomes are not logged to an informational stream (i.e. None). The following streams available: None Error Warning Information This option can be specified using: # PowerShell: Using the LoggingRulePass parameter $option = New-PSRuleOption -LoggingRulePass Information ; # PowerShell: Using the Logging.RulePass hashtable key $option = New-PSRuleOption -Option @{ 'Logging.RulePass' = 'Information' }; # PowerShell: Using the LoggingRulePass parameter to set YAML Set-PSRuleOption -LoggingRulePass Information ; # YAML: Using the logging/rulePass property logging : rulePass : Information","title":"Logging.RulePass"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#outputas","text":"Configures the type of results to produce. This option only applies to Invoke-PSRule and Assert-PSRule . Invoke-PSRule and Assert-PSRule also include a -As parameter to set this option at runtime. If specified, the -As parameter take precedence, over this option. The following options are available: Detail - Return a record per rule per object. Summary - Return summary results. This option can be specified using: # PowerShell: Using the OutputAs parameter $option = New-PSRuleOption -OutputAs Summary ; # PowerShell: Using the Output.As hashtable key $option = New-PSRuleOption -Option @{ 'Output.As' = 'Summary' }; # PowerShell: Using the OutputAs parameter to set YAML Set-PSRuleOption -OutputAs Summary ; # YAML: Using the output/as property output : as : Summary # Bash: Using environment variable export PSRULE_OUTPUT_AS = Summary # GitHub Actions: Using environment variable env : PSRULE_OUTPUT_AS : Summary # Azure Pipelines: Using environment variable variables : - name : PSRULE_OUTPUT_AS value : Summary","title":"Output.As"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#outputbanner","text":"The information displayed for PSRule banner. This option is only applicable when using Assert-PSRule cmdlet. The following information can be shown or hidden by configuring this option. Title (1) - Shows the PSRule title ASCII text. Source (2) - Shows rules module versions used in this run. SupportLinks (4) - Shows supporting links for PSRule and rules modules. RepositoryInfo (8) - Show information about the repository where PSRule is being run from. Additionally the following rollup options exist: Default - Shows Title , Source , SupportLinks , RepositoryInfo . This is the default option. Minimal - Shows Source . This option can be configured using one of the named values described above. Alternatively, this value can be configured by specifying a bit mask as an integer. For example 6 would show Source , and SupportLinks . This option can be specified using: # PowerShell: Using the OutputBanner parameter $option = New-PSRuleOption -OutputBanner Minimal ; # PowerShell: Using the Output.Banner hashtable key $option = New-PSRuleOption -Option @{ 'Output.Banner' = 'Minimal' }; # PowerShell: Using the OutputBanner parameter to set YAML Set-PSRuleOption -OutputBanner Minimal ; # YAML: Using the output/banner property output : banner : Minimal # Bash: Using environment variable export PSRULE_OUTPUT_BANNER = Minimal # GitHub Actions: Using environment variable env : PSRULE_OUTPUT_BANNER : Minimal # Azure Pipelines: Using environment variable variables : - name : PSRULE_OUTPUT_BANNER value : Minimal","title":"Output.Banner"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#outputculture","text":"Specified the name of one or more cultures to use for generating output. When multiple cultures are specified, the first matching culture will be used. If a culture is not specified, PSRule will use the current PowerShell culture. PSRule cmdlets also include a -Culture parameter to set this option at runtime. If specified, the -Culture parameter take precedence, over this option. To get a list of cultures use the Get-Culture -ListAvailable cmdlet. This option can be specified using: # PowerShell: Using the OutputCulture parameter $option = New-PSRuleOption -OutputCulture 'en-AU' ; # PowerShell: Using the Output.Culture hashtable key $option = New-PSRuleOption -Option @{ 'Output.Culture' = 'en-AU' }; # PowerShell: Using the OutputCulture parameter to set YAML Set-PSRuleOption -OutputCulture 'en-AU' , 'en-US' ; # YAML: Using the output/culture property output : culture : [ 'en-AU' , 'en-US' ] # Bash: Using environment variable export PSRULE_OUTPUT_CULTURE = en-AU ; en-US # GitHub Actions: Using environment variable env : PSRULE_OUTPUT_CULTURE : en-AU;en-US # Azure Pipelines: Using environment variable variables : - name : PSRULE_OUTPUT_CULTURE value : en-AU;en-US","title":"Output.Culture"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#outputencoding","text":"Configures the encoding used when output is written to file. This option has no affect when Output.Path is not set. The following encoding options are available: Default UTF-8 UTF-7 Unicode UTF-32 ASCII This option can be specified using: # PowerShell: Using the OutputEncoding parameter $option = New-PSRuleOption -OutputEncoding UTF8 ; # PowerShell: Using the Output.Format hashtable key $option = New-PSRuleOption -Option @{ 'Output.Encoding' = 'UTF8' }; # PowerShell: Using the OutputEncoding parameter to set YAML Set-PSRuleOption -OutputEncoding UTF8 ; # YAML: Using the output/encoding property output : encoding : UTF8 # Bash: Using environment variable export PSRULE_OUTPUT_ENCODING = UTF8 # GitHub Actions: Using environment variable env : PSRULE_OUTPUT_ENCODING : UTF8 # Azure Pipelines: Using environment variable variables : - name : PSRULE_OUTPUT_ENCODING value : UTF8","title":"Output.Encoding"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#outputfooter","text":"The information displayed for PSRule footer. This option is only applicable when using Assert-PSRule cmdlet. The following information can be shown or hidden by configuring this option. RuleCount (1) - Shows a summary of rules processed. RunInfo (2) - Shows information about the run. OutputFile (4) - Shows information about the output file if an output path is set. Additionally the following rollup options exist: Default - Shows RuleCount , RunInfo , and OutputFile . This is the default option. This option can be configured using one of the named values described above. Alternatively, this value can be configured by specifying a bit mask as an integer. For example 3 would show RunInfo , and RuleCount . This option can be specified using: # PowerShell: Using the OutputFooter parameter $option = New-PSRuleOption -OutputFooter RuleCount ; # PowerShell: Using the Output.Footer hashtable key $option = New-PSRuleOption -Option @{ 'Output.Footer' = 'RuleCount' }; # PowerShell: Using the OutputFooter parameter to set YAML Set-PSRuleOption -OutputFooter RuleCount ; # YAML: Using the output/footer property output : footer : RuleCount # Bash: Using environment variable export PSRULE_OUTPUT_FOOTER = RuleCount # GitHub Actions: Using environment variable env : PSRULE_OUTPUT_FOOTER : RuleCount # Azure Pipelines: Using environment variable variables : - name : PSRULE_OUTPUT_FOOTER value : RuleCount","title":"Output.Footer"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#outputformat","text":"Configures the format that results will be presented in. This option applies to Invoke-PSRule , Assert-PSRule , Get-PSRule and Get-PSRuleBaseline . This options is ignored by other cmdlets. The following format options are available: None - Output is presented as an object using PowerShell defaults. This is the default. Yaml - Output is serialized as YAML. Json - Output is serialized as JSON. Markdown - Output is serialized as Markdown. NUnit3 - Output is serialized as NUnit3 (XML). Csv - Output is serialized as a comma-separated values (CSV). The following columns are included for Detail output: RuleName, TargetName, TargetType, Outcome, OutcomeReason, Synopsis, Recommendation The following columns are included for Summary output: RuleName, Pass, Fail, Outcome, Synopsis, Recommendation Wide - Output is presented using the wide table format, which includes reason and wraps columns. Sarif - Output is serialized as SARIF. The Wide format is ignored by Assert-PSRule . Get-PSRule only accepts None , Wide , Yaml and Json . Usage of other formats are treated as None . The Get-PSRuleBaseline cmdlet only accepts None or Yaml . The Export-PSRuleBaseline cmdlet only accepts Yaml . This option can be specified using: # PowerShell: Using the OutputFormat parameter $option = New-PSRuleOption -OutputFormat Yaml ; # PowerShell: Using the Output.Format hashtable key $option = New-PSRuleOption -Option @{ 'Output.Format' = 'Yaml' }; # PowerShell: Using the OutputFormat parameter to set YAML Set-PSRuleOption -OutputFormat Yaml ; # YAML: Using the output/format property output : format : Yaml # Bash: Using environment variable export PSRULE_OUTPUT_FORMAT = Yaml # GitHub Actions: Using environment variable env : PSRULE_OUTPUT_FORMAT : Yaml # Azure Pipelines: Using environment variable variables : - name : PSRULE_OUTPUT_FORMAT value : Yaml","title":"Output.Format"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#outputoutcome","text":"Filters output to include results with the specified outcome. The following outcome options are available: None (0) - Results for rules that did not get processed are returned. This include rules that have been suppressed or were not run against a target object. Fail (1) - Results for rules that failed are returned. Pass (2) - Results for rules that passed are returned. Error (4) - Results for rules that raised an error are returned. Additionally the following rollup options exist: Processed - Results for rules with the Fail , Pass , or Error outcome. This is the default option. Problem - Results for rules with the Fail , or Error outcome. All - All results for rules are returned. This option can be specified using: # PowerShell: Using the OutputOutcome parameter $option = New-PSRuleOption -OutputOutcome Fail ; # PowerShell: Using the Output.Outcome hashtable key $option = New-PSRuleOption -Option @{ 'Output.Outcome' = 'Fail' }; # PowerShell: Using the OutputOutcome parameter to set YAML Set-PSRuleOption -OutputOutcome Fail ; # YAML: Using the output/outcome property output : outcome : 'Fail' # Bash: Using environment variable export PSRULE_OUTPUT_OUTCOME = Fail # GitHub Actions: Using environment variable env : PSRULE_OUTPUT_OUTCOME : Fail # Azure Pipelines: Using environment variable variables : - name : PSRULE_OUTPUT_OUTCOME value : Fail","title":"Output.Outcome"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#outputpath","text":"Specifies the output file path to write results. Directories along the file path will automatically be created if they do not exist. This option only applies to Invoke-PSRule . Invoke-PSRule also includes a parameter -OutputPath to set this option at runtime. If specified, the -OutputPath parameter take precedence, over this option. Syntax: output : path : string Default: output : path : null This option can be specified using: # PowerShell: Using the OutputPath parameter $option = New-PSRuleOption -OutputPath 'out/results.yaml' ; # PowerShell: Using the Output.Path hashtable key $option = New-PSRuleOption -Option @{ 'Output.Path' = 'out/results.yaml' }; # PowerShell: Using the OutputPath parameter to set YAML Set-PSRuleOption -OutputPath 'out/results.yaml' ; # YAML: Using the output/path property output : path : 'out/results.yaml' # Bash: Using environment variable export PSRULE_OUTPUT_PATH = out/results.yaml # GitHub Actions: Using environment variable env : PSRULE_OUTPUT_PATH : out/results.yaml # Azure Pipelines: Using environment variable variables : - name : PSRULE_OUTPUT_PATH value : out/results.yaml","title":"Output.Path"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#outputsarifproblemsonly","text":"Determines if SARIF output only includes rules with fail or error outcomes. By default, only rules with fail or error outcomes are included for compatibility with external tools. To include rules with pass outcomes, set this option to false . This option only applies when the output format is Sarif . Syntax: output : sarifProblemsOnly : boolean Default: output : sarifProblemsOnly : true This option can be specified using: # PowerShell: Using the OutputSarifProblemsOnly parameter $option = New-PSRuleOption -OutputSarifProblemsOnly $False ; # PowerShell: Using the Output.SarifProblemsOnly hashtable key $option = New-PSRuleOption -Option @{ 'Output.SarifProblemsOnly' = $False }; # PowerShell: Using the OutputSarifProblemsOnly parameter to set YAML Set-PSRuleOption -OutputSarifProblemsOnly $False ; # YAML: Using the output/sarifProblemsOnly property output : sarifProblemsOnly : false # Bash: Using environment variable export PSRULE_OUTPUT_SARIFPROBLEMSONLY = false # GitHub Actions: Using environment variable env : PSRULE_OUTPUT_SARIFPROBLEMSONLY : false # Azure Pipelines: Using environment variable variables : - name : PSRULE_OUTPUT_SARIFPROBLEMSONLY value : false","title":"Output.SarifProblemsOnly"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#outputstyle","text":"Configures the style that results will be presented in. This option only applies to output generated from Assert-PSRule . Assert-PSRule also include a parameter -Style to set this option at runtime. If specified, the -Style parameter takes precedence, over this option. The following styles are available: Client - Output is written to the host directly in green/ red to indicate outcome. Plain - Output is written as an unformatted string. This option can be redirected to a file. AzurePipelines - Output is written for integration Azure Pipelines. GitHubActions - Output is written for integration GitHub Actions. VisualStudioCode - Output is written for integration with Visual Studio Code. Detect - Output style will be detected by checking the environment variables. This is the default. Detect uses the following logic: If the TF_BUILD environment variable is set to true , AzurePipelines will be used. If the GITHUB_ACTIONS environment variable is set to true , GitHubActions will be used. If the TERM_PROGRAM environment variable is set to vscode , VisualStudioCode will be used. Use Client . Syntax: output : style : string Default: output : style : Detect This option can be specified using: # PowerShell: Using the OutputStyle parameter $option = New-PSRuleOption -OutputStyle AzurePipelines ; # PowerShell: Using the Output.Style hashtable key $option = New-PSRuleOption -Option @{ 'Output.Style' = 'AzurePipelines' }; # PowerShell: Using the OutputStyle parameter to set YAML Set-PSRuleOption -OutputFormat AzurePipelines ; # YAML: Using the output/style property output : style : AzurePipelines # Bash: Using environment variable export PSRULE_OUTPUT_STYLE = AzurePipelines # GitHub Actions: Using environment variable env : PSRULE_OUTPUT_STYLE : AzurePipelines # Azure Pipelines: Using environment variable variables : - name : PSRULE_OUTPUT_STYLE value : AzurePipelines","title":"Output.Style"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#outputjobsummarypath","text":"Configures the file path a job summary will be written to when using Assert-PSRule . A job summary is a markdown file that summarizes the results of a job. When not specified, a job summary will not be generated. Syntax: output : jobSummaryPath : string Default: output : jobSummaryPath : null This option can be specified using: # PowerShell: Using the OutputJobSummaryPath parameter $option = New-PSRuleOption -OutputJobSummaryPath 'reports/summary.md' ; # PowerShell: Using the Output.JobSummaryPath hashtable key $option = New-PSRuleOption -Option @{ 'Output.JobSummaryPath' = 'reports/summary.md' }; # PowerShell: Using the OutputJobSummaryPath parameter to set YAML Set-PSRuleOption -OutputJobSummaryPath 'reports/summary.md' ; # YAML: Using the output/jobSummaryPath property output : jobSummaryPath : 'reports/summary.md' # Bash: Using environment variable export PSRULE_OUTPUT_JOBSUMMARYPATH = 'reports/summary.md' # PowerShell: Using environment variable $env:PSRULE_OUTPUT_JOBSUMMARYPATH = 'reports/summary.md' ; # GitHub Actions: Using environment variable env : PSRULE_OUTPUT_JOBSUMMARYPATH : reports/summary.md # Azure Pipelines: Using environment variable variables : - name : PSRULE_OUTPUT_JOBSUMMARYPATH value : reports/summary.md","title":"Output.JobSummaryPath"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#outputjsonindent","text":"Configures the number of spaces to indent JSON properties and elements. The default number of spaces is 0. This option applies to output generated from -OutputFormat Json for Get-PSRule and Invoke-PSRule . This option also applies to output generated from -OutputPath for Assert-PSRule . The range of indentation accepts a minimum of 0 (machine first) spaces and a maximum of 4 spaces. This option can be specified using: # PowerShell: Using the OutputJsonIndent parameter $option = New-PSRuleOption -OutputJsonIndent 2 ; # PowerShell: Using the Output.JsonIndent hashtable key $option = New-PSRuleOption -Option @{ 'Output.JsonIndent' = 2 }; # PowerShell: Using the OutputJsonIndent parameter to set YAML Set-PSRuleOption -OutputJsonIndent 2 ; # YAML: Using the output/jsonIndent property output : jsonIndent : 2 # Bash: Using environment variable export PSRULE_OUTPUT_JSONINDENT = 2 # PowerShell: Using environment variable $env:PSRULE_OUTPUT_JSONINDENT = 2 ; # GitHub Actions: Using environment variable env : PSRULE_OUTPUT_JSONINDENT : 2 # Azure Pipelines: Using environment variable variables : - name : PSRULE_OUTPUT_JSONINDENT value : 2","title":"Output.JsonIndent"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#repositorybaseref","text":"This option is used for specify the base branch for pull requests. When evaluating changes files only PSRule uses this option for comparison with the current branch. By default, the base ref is detected from environment variables set by the build system. This option can be specified using: # PowerShell: Using the RepositoryBaseRef parameter $option = New-PSRuleOption -RepositoryBaseRef 'main' ; # PowerShell: Using the Repository.BaseRef hashtable key $option = New-PSRuleOption -Option @{ 'Repository.BaseRef' = 'main' }; # PowerShell: Using the RepositoryBaseRef parameter to set YAML Set-PSRuleOption -RepositoryBaseRef 'main' ; # YAML: Using the repository/baseRef property repository : baseRef : main # Bash: Using environment variable export PSRULE_REPOSITORY_BASEREF = 'main' # PowerShell: Using environment variable $env:PSRULE_REPOSITORY_BASEREF = 'main' ;","title":"Repository.BaseRef"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#repositoryurl","text":"This option can be configured to set the repository URL reported in output. By default, the repository URL is detected from environment variables set by the build system. In GitHub Actions, the repository URL is detected from the GITHUB_REPOSITORY environment variable. In Azure Pipelines, the repository URL is detected from the BUILD_REPOSITORY_URI environment variable. This option can be specified using: # PowerShell: Using the RepositoryUrl parameter $option = New-PSRuleOption -RepositoryUrl 'https://github.com/microsoft/PSRule' ; # PowerShell: Using the Repository.Url hashtable key $option = New-PSRuleOption -Option @{ 'Repository.Url' = 'https://github.com/microsoft/PSRule' }; # PowerShell: Using the RepositoryUrl parameter to set YAML Set-PSRuleOption -RepositoryUrl 'https://github.com/microsoft/PSRule' ; # YAML: Using the repository/url property repository : url : 'https://github.com/microsoft/PSRule' # Bash: Using environment variable export PSRULE_REPOSITORY_URL = 'https://github.com/microsoft/PSRule' # PowerShell: Using environment variable $env:PSRULE_REPOSITORY_URL = 'https://github.com/microsoft/PSRule' ;","title":"Repository.Url"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#requires","text":"Specifies module version constraints for running PSRule. When set PSRule will error if a module version is used that does not satisfy the requirements. The format for version constraints are the same as the Version assertion method. See [about_PSRule_Assert] for more information. Module version constraints a not enforced prior to PSRule v0.19.0. The version constraint for a rule module is enforced when the module is included with -Module . A version constraint does not require a rule module to be included. Use the Include.Module option to automatically include a rule module. This option can be specified using: # PowerShell: Using the Requires.module hashtable key $option = New-PSRuleOption -Option @{ 'Requires.PSRule' = '>=1.0.0' }; # YAML: Using the requires property requires : PSRule : '>=1.0.0' # Require v1.0.0 or greater. PSRule.Rules.Azure : '>=1.0.0' # Require v1.0.0 or greater. PSRule.Rules.CAF : '@pre >=0.1.0' # Require stable or pre-releases v0.1.0 or greater. This option can be configured using environment variables. To specify a module version constraint, prefix the module name with PSRULE_REQUIRES_ . When the module name includes a dot ( . ) use an underscore ( _ ) instead. # Bash: Using environment variable export PSRULE_REQUIRES_PSRULE = '>=1.0.0' export PSRULE_REQUIRES_PSRULE_RULES_AZURE = '>=1.0.0' export PSRULE_REQUIRES_PSRULE_RULES_CAF = '@pre >=0.1.0' # GitHub Actions: Using environment variable env : PSRULE_REQUIRES_PSRULE : '>=1.0.0' PSRULE_REQUIRES_PSRULE_RULES_AZURE : '>=1.0.0' PSRULE_REQUIRES_PSRULE_RULES_CAF : '@pre >=0.1.0' # Azure Pipelines: Using environment variable variables : - name : PSRULE_REQUIRES_PSRULE value : '>=1.0.0' - name : PSRULE_REQUIRES_PSRULE_RULES_AZURE value : '>=1.0.0' - name : PSRULE_REQUIRES_PSRULE_RULES_CAF value : '@pre >=0.1.0'","title":"Requires"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#rulebaseline","text":"The name of a default baseline to use for the module. Currently this option can only be set within a module configuration resource. For example: --- # Synopsis: Example module configuration for Enterprise.Rules module. apiVersion : github.com/microsoft/PSRule/v1 kind : ModuleConfig metadata : name : Enterprise.Rules spec : rule : baseline : Enterprise.Baseline1","title":"Rule.Baseline"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#ruleinclude","text":"The name of specific rules to evaluate. If this option is not specified all rules in search paths will be evaluated. This option can be overridden at runtime by using the -Name cmdlet parameter. This option can be specified using: # PowerShell: Using the Rule.Include hashtable key $option = New-PSRuleOption -Option @{ 'Rule.Include' = 'Rule1' , 'Rule2' }; # YAML: Using the rule/include property rule : include : - Rule1 - Rule2 # Bash: Using environment variable export PSRULE_RULE_INCLUDE = 'Rule1;Rule2' # GitHub Actions: Using environment variable env : PSRULE_RULE_INCLUDE : 'Rule1;Rule2' # Azure Pipelines: Using environment variable variables : - name : PSRULE_RULE_INCLUDE value : 'Rule1;Rule2'","title":"Rule.Include"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#ruleincludelocal","text":"Automatically include all local rules in the search path unless they have been explicitly excluded. This option will include local rules even when they do not match Rule.Include or Rule.Tag filters. By default, local rules will be filtered with Rule.Include and Rule.Tag filters. This option is useful when you want to include local rules not included in a baseline. This option can be specified using: # PowerShell: Using the RuleIncludeLocal parameter $option = New-PSRuleOption -RuleIncludeLocal $True ; # PowerShell: Using the Rule.IncludeLocal hashtable key $option = New-PSRuleOption -Option @{ 'Rule.IncludeLocal' = $True }; # PowerShell: Using the RuleIncludeLocal parameter to set YAML Set-PSRuleOption -RuleIncludeLocal $True ; # YAML: Using the rule/includeLocal property rule : includeLocal : true # Bash: Using environment variable export PSRULE_RULE_INCLUDELOCAL = true # GitHub Actions: Using environment variable env : PSRULE_RULE_INCLUDELOCAL : true # Azure Pipelines: Using environment variable variables : - name : PSRULE_RULE_INCLUDELOCAL value : true","title":"Rule.IncludeLocal"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#ruleexclude","text":"The name of specific rules to exclude from being evaluated. This will exclude rules specified by Rule.Include or discovered from a search path. This option can be specified using: # PowerShell: Using the Rule.Exclude hashtable key $option = New-PSRuleOption -Option @{ 'Rule.Exclude' = 'Rule3' , 'Rule4' }; # YAML: Using the rule/exclude property rule : exclude : - Rule3 - Rule4 # Bash: Using environment variable export PSRULE_RULE_EXCLUDE = 'Rule3;Rule4' # GitHub Actions: Using environment variable env : PSRULE_RULE_EXCLUDE : 'Rule3;Rule4' # Azure Pipelines: Using environment variable variables : - name : PSRULE_RULE_EXCLUDE value : 'Rule3;Rule4'","title":"Rule.Exclude"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#ruletag","text":"A set of required key value pairs (tags) that rules must have applied to them to be included. Multiple values can be specified for the same tag. When multiple values are used, only one must match. This option can be overridden at runtime by using the -Tag cmdlet parameter. This option can be specified using: # PowerShell: Using the Rule.Tag hashtable key $option = New-PSRuleOption -Option @{ 'Rule.Tag' = @{ severity = 'Critical' , 'Warning' } }; # YAML: Using the rule/tag property rule : tag : severity : Critical # YAML: Using the rule/tag property, with multiple values rule : tag : severity : - Critical - Warning In the example above, rules must have a tag of severity set to either Critical or Warning to be included.","title":"Rule.Tag"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#suppression","text":"In certain circumstances it may be necessary to exclude or suppress rules from processing objects that are in a known failed state. PSRule allows objects to be suppressed for a rule by TargetName. Objects that are suppressed are not processed by the rule at all but will continue to be processed by other rules. Rule suppression complements pre-filtering and pre-conditions. This option can be specified using: # PowerShell: Using the SuppressTargetName option with a hashtable $option = New-PSRuleOption -SuppressTargetName @{ 'storageAccounts.UseHttps' = 'TestObject1' , 'TestObject3' }; # YAML: Using the suppression property suppression : storageAccounts.UseHttps : targetName : - TestObject1 - TestObject3 In both of the above examples, TestObject1 and TestObject3 have been suppressed from being processed by a rule named storageAccounts.UseHttps . When to use rule suppression: A temporary exclusion for an object that is in a known failed state. When not to use rule suppression: An object should never be processed by any rule. Pre-filter the pipeline instead. The rule is not applicable because the object is the wrong type. Use pre-conditions on the rule instead. An example of pre-filtering: # Define objects to validate $items = @(); $items += [PSCustomObject] @{ Name = 'Fridge' ; Type = 'Equipment' ; Category = 'White goods' ; }; $items += [PSCustomObject] @{ Name = 'Apple' ; Type = 'Food' ; Category = 'Produce' ; }; $items += [PSCustomObject] @{ Name = 'Carrot' ; Type = 'Food' ; Category = 'Produce' ; }; # Example of pre-filtering, only food items are sent to Invoke-PSRule $items | Where-Object { $_ . Type -eq 'Food' } | Invoke-PSRule ; An example of pre-conditions: # A rule with a pre-condition to only process produce Rule 'isFruit' -If { $TargetObject . Category -eq 'Produce' } { # Condition to determine if the object is fruit $TargetObject . Name -in 'Apple' , 'Orange' , 'Pear' }","title":"Suppression"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#examples","text":"","title":"Examples"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#example-ps-ruleyaml","text":"# # PSRule example configuration # # Configures the repository repository : url : https://github.com/microsoft/PSRule baseRef : main # Configure required module versions requires : PSRule.Rules.Azure : '>=1.1.0' # Configure convention options convention : include : - 'Convention1' # Configure execution options execution : aliasReferenceWarning : false duplicateResourceId : Warn languageMode : ConstrainedLanguage inconclusiveWarning : false notProcessedWarning : false suppressedRuleWarning : false suppressionGroupExpired : Error # Configure include options include : module : - 'PSRule.Rules.Azure' path : [ ] # Configures input options input : format : Yaml ignoreGitPath : false ignoreObjectSource : true ignoreRepositoryCommon : false ignoreUnchangedPath : true objectPath : items pathIgnore : - '*.Designer.cs' targetType : - Microsoft.Compute/virtualMachines - Microsoft.Network/virtualNetworks # Configures outcome logging options logging : limitDebug : - Rule1 - Rule2 limitVerbose : - Rule1 - Rule2 ruleFail : Error rulePass : Information output : as : Summary banner : Minimal culture : - en-US encoding : UTF8 footer : RuleCount format : Json jobSummaryPath : reports/summary.md outcome : Fail sarifProblemsOnly : false style : GitHubActions # Configure rule suppression suppression : storageAccounts.UseHttps : targetName : - TestObject1 - TestObject3 # Configure baseline options binding : field : id : - ResourceId - AlternativeId ignoreCase : false nameSeparator : '::' preferTargetInfo : true targetName : - ResourceName - AlternateName targetType : - ResourceType - kind useQualifiedName : true configuration : appServiceMinInstanceCount : 2 rule : include : - rule1 - rule2 includeLocal : true exclude : - rule3 - rule4 tag : severity : - Critical - Warning","title":"Example ps-rule.yaml"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#default-ps-ruleyaml","text":"# # PSRule defaults # # Note: Only properties that differ from the default values need to be specified. # Configure required module versions requires : { } # Configure convention options convention : include : [ ] # Configure execution options execution : aliasReferenceWarning : true duplicateResourceId : Error languageMode : FullLanguage inconclusiveWarning : true notProcessedWarning : true suppressedRuleWarning : true suppressionGroupExpired : Warn # Configure include options include : module : [ ] path : - '.ps-rule/' # Configures input options input : format : Detect ignoreGitPath : true ignoreObjectSource : false ignoreRepositoryCommon : true ignoreUnchangedPath : false objectPath : null pathIgnore : [ ] targetType : [ ] # Configures outcome logging options logging : limitDebug : [ ] limitVerbose : [ ] ruleFail : None rulePass : None output : as : Detail banner : Default culture : [ ] encoding : Default footer : Default format : None jobSummaryPath : null outcome : Processed sarifProblemsOnly : true style : Detect # Configure rule suppression suppression : { } # Configure baseline options binding : field : { } ignoreCase : true nameSeparator : '/' preferTargetInfo : false targetName : - TargetName - Name targetType : - PSObject.TypeNames[0] useQualifiedName : false configuration : { } rule : include : [ ] includeLocal : false exclude : [ ] tag : { }","title":"Default ps-rule.yaml"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#links","text":"Invoke-PSRule New-PSRuleOption Set-PSRuleOption","title":"Links"},{"location":"concepts/PSRule/en-US/about_PSRule_Rules/","text":"Rules # Describes PSRule rules including how to use and author them. Description # PSRule executes rules to validate an object from input either from a file or PowerShell pipeline. The PowerShell pipeline only available when running PSRule directly. PSRule can also be run from a continuous integration (CI) pipeline or Visual Studio Code. When using these methods, the PowerShell pipeline is not available. To evaluate an object PSRule can use rules defined in script or YAML. When using script rules: Each rule is defined PowerShell within a .Rule.ps1 file by using a Rule block. PowerShell variables, functions, and cmdlets can be used just like regular PowerShell scripts. Built-in assertion helpers can be used to quickly build out rules. Pre-conditions can be defined with using a script block, type binding, or YAML-based selector. To learn more about assertion helpers see about_PSRule_Assert . When using YAML rules: Each rule is defined in a .Rule.yaml file by using the Rule resource. YAML-based expressions can be used. Pre-conditions can be defined with using a type binding, or YAML-based selector. To learn more about YAML-based expressions see about_PSRule_Expressions . Using pre-conditions # Pre-conditions are used to determine if a rule should be executed. While pre-conditions are not required for each rule, it is a good practice to define them. If a rule does not specify a pre-condition it may be executed against an object it does not expect. Pre-conditions come in three forms: Script - A PowerShell script block that is executed and if true will cause the rule to be executed. Script block pre-conditions only work with script rules. To use a script block pre-condition, specify the -If script parameter on the Rule block. Type - A type string that is compared against the bound object type. When the type matches the rule will be executed. To use a type pre-conditions, specify the -Type script parameter or type YAML/JSON property. Selector - A YAML/JSON based expression that is evaluated against the object. When the expression matches the rule will be executed. To use a selector pre-conditions, specify the -With script parameter or with YAML/JSON property. Different forms of pre-conditions can be combined. When combining pre-conditions, different forms must be all true (logical AND). i.e. Script AND Type AND Selector must be all be true for the rule to be executed. Multiple Type and Selector pre-conditions can be specified. If multiple Type and Selector pre-conditions are specified, only one must be true (logical OR). For example: # Synopsis: An example script rule with pre-conditions. Rule 'ScriptRule' -If { $True } -Type 'CustomType1' , 'CustomType2' -With 'Selector.1' , 'Selector.2' { # Rule condition } --- # Synopsis: An example YAML rule with pre-conditions. apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'YamlRule' spec : type : - 'CustomType1' - 'CustomType2' with : - 'Selector.1' - 'Selector.2' condition : { } [ { // Synopsis: An example YAML rule with pre-conditions. \"apiVersion\": \"github.com/microsoft/PSRule/v1\", \"kind\": \"Rule\", \"metadata\": { \"name\": \"YamlRule\" }, \"spec\": { \"type\": [ \"CustomType1\", \"CustomType2\" ], \"with\": [ \"Selector.1\", \"Selector.2\" ], \"condition\": {} } } ] Pre-conditions are evaluated in the following order: Selector, Type, then Script. Defining script rules # To define a script rule use the Rule keyword followed by a name and a pair of squiggly brackets { . Within the { } one or more conditions can be used. Script rule must be defined within .Rule.ps1 files. Multiple rules can be defined in a single file by creating multiple Rule blocks. Rule blocks can not be nested within each other. Within the Rule block, define one or more conditions to determine pass or fail of the rule. Syntax: Rule [-Name] <string> [-Tag <hashtable>] [-When <string[]>] [-Type <string[]>] [-If <scriptBlock>] [-DependsOn <string[]>] [-Configure <hashtable>] [-ErrorAction <ActionPreference>] [-Body] { ... } Example: # Synopsis: Use a Standard load-balancer with AKS clusters. Rule 'Azure.AKS.StandardLB' -Type 'Microsoft.ContainerService/managedClusters' -Tag @{ release = 'GA' ; ruleSet = '2020_06' } { $Assert . HasFieldValue ( $TargetObject , 'Properties.networkProfile.loadBalancerSku' , 'standard' ); } Defining YAML rules # To define a YAML rule use the Rule resource in a YAML file. Each rule must be defined within a .Rule.yaml file following a standard schema. Multiple rules can be defined in a single YAML file by separating each rule with a --- . Within the Rule resource, the condition property specifies conditions to pass or fail the rule. Syntax: --- # Synopsis: {{ Synopsis }} apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : '{{ Name }}' tags : { } spec : type : [ ] with : [ ] condition : { } Example: --- # Synopsis: Use a Standard load-balancer with AKS clusters. apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'Azure.AKS.StandardLB' tags : release : 'GA' ruleSet : '2020_06' spec : type : - Microsoft.ContainerService/managedClusters condition : field : 'Properties.networkProfile.loadBalancerSku' equals : 'standard' Defining JSON rules # To define a JSON rule use the Rule resource in a JSON file. Each rule must be defined within a .Rule.jsonc file following a standard schema. One or more rules can be defined in a single JSON array separating each rule in a JSON object. Within the Rule resource, the condition property specifies conditions to pass or fail the rule. Rules can also be defined within .json files. We recommend using .jsonc to view JSON with Comments in Visual Studio Code. Syntax: [ { // Synopsis: {{ Synopsis }} \"apiVersion\": \"github.com/microsoft/PSRule/v1\", \"kind\": \"Rule\", \"metadata\": { \"name\": \"{{ Name }}\", \"tags\": {} }, \"spec\": { \"type\": [], \"with\": [], \"condition\": {} } } ] Example: [ { // Synopsis: Use a Standard load-balancer with AKS clusters. \"apiVersion\": \"github.com/microsoft/PSRule/v1\", \"kind\": \"Rule\", \"metadata\": { \"name\": \"Azure.AKS.StandardLB\", \"tags\": { \"release\": \"GA\", \"ruleSet\": \"2020_06\" } }, \"spec\": { \"type\": [ \"Microsoft.ContainerService/managedClusters\" ], \"condition\": { \"field\": \"Properties.networkProfile.loadBalancerSku\", \"equals\": \"standard\" } } } ] Links # Invoke-PSRule","title":"Rules"},{"location":"concepts/PSRule/en-US/about_PSRule_Rules/#rules","text":"Describes PSRule rules including how to use and author them.","title":"Rules"},{"location":"concepts/PSRule/en-US/about_PSRule_Rules/#description","text":"PSRule executes rules to validate an object from input either from a file or PowerShell pipeline. The PowerShell pipeline only available when running PSRule directly. PSRule can also be run from a continuous integration (CI) pipeline or Visual Studio Code. When using these methods, the PowerShell pipeline is not available. To evaluate an object PSRule can use rules defined in script or YAML. When using script rules: Each rule is defined PowerShell within a .Rule.ps1 file by using a Rule block. PowerShell variables, functions, and cmdlets can be used just like regular PowerShell scripts. Built-in assertion helpers can be used to quickly build out rules. Pre-conditions can be defined with using a script block, type binding, or YAML-based selector. To learn more about assertion helpers see about_PSRule_Assert . When using YAML rules: Each rule is defined in a .Rule.yaml file by using the Rule resource. YAML-based expressions can be used. Pre-conditions can be defined with using a type binding, or YAML-based selector. To learn more about YAML-based expressions see about_PSRule_Expressions .","title":"Description"},{"location":"concepts/PSRule/en-US/about_PSRule_Rules/#using-pre-conditions","text":"Pre-conditions are used to determine if a rule should be executed. While pre-conditions are not required for each rule, it is a good practice to define them. If a rule does not specify a pre-condition it may be executed against an object it does not expect. Pre-conditions come in three forms: Script - A PowerShell script block that is executed and if true will cause the rule to be executed. Script block pre-conditions only work with script rules. To use a script block pre-condition, specify the -If script parameter on the Rule block. Type - A type string that is compared against the bound object type. When the type matches the rule will be executed. To use a type pre-conditions, specify the -Type script parameter or type YAML/JSON property. Selector - A YAML/JSON based expression that is evaluated against the object. When the expression matches the rule will be executed. To use a selector pre-conditions, specify the -With script parameter or with YAML/JSON property. Different forms of pre-conditions can be combined. When combining pre-conditions, different forms must be all true (logical AND). i.e. Script AND Type AND Selector must be all be true for the rule to be executed. Multiple Type and Selector pre-conditions can be specified. If multiple Type and Selector pre-conditions are specified, only one must be true (logical OR). For example: # Synopsis: An example script rule with pre-conditions. Rule 'ScriptRule' -If { $True } -Type 'CustomType1' , 'CustomType2' -With 'Selector.1' , 'Selector.2' { # Rule condition } --- # Synopsis: An example YAML rule with pre-conditions. apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'YamlRule' spec : type : - 'CustomType1' - 'CustomType2' with : - 'Selector.1' - 'Selector.2' condition : { } [ { // Synopsis: An example YAML rule with pre-conditions. \"apiVersion\": \"github.com/microsoft/PSRule/v1\", \"kind\": \"Rule\", \"metadata\": { \"name\": \"YamlRule\" }, \"spec\": { \"type\": [ \"CustomType1\", \"CustomType2\" ], \"with\": [ \"Selector.1\", \"Selector.2\" ], \"condition\": {} } } ] Pre-conditions are evaluated in the following order: Selector, Type, then Script.","title":"Using pre-conditions"},{"location":"concepts/PSRule/en-US/about_PSRule_Rules/#defining-script-rules","text":"To define a script rule use the Rule keyword followed by a name and a pair of squiggly brackets { . Within the { } one or more conditions can be used. Script rule must be defined within .Rule.ps1 files. Multiple rules can be defined in a single file by creating multiple Rule blocks. Rule blocks can not be nested within each other. Within the Rule block, define one or more conditions to determine pass or fail of the rule. Syntax: Rule [-Name] <string> [-Tag <hashtable>] [-When <string[]>] [-Type <string[]>] [-If <scriptBlock>] [-DependsOn <string[]>] [-Configure <hashtable>] [-ErrorAction <ActionPreference>] [-Body] { ... } Example: # Synopsis: Use a Standard load-balancer with AKS clusters. Rule 'Azure.AKS.StandardLB' -Type 'Microsoft.ContainerService/managedClusters' -Tag @{ release = 'GA' ; ruleSet = '2020_06' } { $Assert . HasFieldValue ( $TargetObject , 'Properties.networkProfile.loadBalancerSku' , 'standard' ); }","title":"Defining script rules"},{"location":"concepts/PSRule/en-US/about_PSRule_Rules/#defining-yaml-rules","text":"To define a YAML rule use the Rule resource in a YAML file. Each rule must be defined within a .Rule.yaml file following a standard schema. Multiple rules can be defined in a single YAML file by separating each rule with a --- . Within the Rule resource, the condition property specifies conditions to pass or fail the rule. Syntax: --- # Synopsis: {{ Synopsis }} apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : '{{ Name }}' tags : { } spec : type : [ ] with : [ ] condition : { } Example: --- # Synopsis: Use a Standard load-balancer with AKS clusters. apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'Azure.AKS.StandardLB' tags : release : 'GA' ruleSet : '2020_06' spec : type : - Microsoft.ContainerService/managedClusters condition : field : 'Properties.networkProfile.loadBalancerSku' equals : 'standard'","title":"Defining YAML rules"},{"location":"concepts/PSRule/en-US/about_PSRule_Rules/#defining-json-rules","text":"To define a JSON rule use the Rule resource in a JSON file. Each rule must be defined within a .Rule.jsonc file following a standard schema. One or more rules can be defined in a single JSON array separating each rule in a JSON object. Within the Rule resource, the condition property specifies conditions to pass or fail the rule. Rules can also be defined within .json files. We recommend using .jsonc to view JSON with Comments in Visual Studio Code. Syntax: [ { // Synopsis: {{ Synopsis }} \"apiVersion\": \"github.com/microsoft/PSRule/v1\", \"kind\": \"Rule\", \"metadata\": { \"name\": \"{{ Name }}\", \"tags\": {} }, \"spec\": { \"type\": [], \"with\": [], \"condition\": {} } } ] Example: [ { // Synopsis: Use a Standard load-balancer with AKS clusters. \"apiVersion\": \"github.com/microsoft/PSRule/v1\", \"kind\": \"Rule\", \"metadata\": { \"name\": \"Azure.AKS.StandardLB\", \"tags\": { \"release\": \"GA\", \"ruleSet\": \"2020_06\" } }, \"spec\": { \"type\": [ \"Microsoft.ContainerService/managedClusters\" ], \"condition\": { \"field\": \"Properties.networkProfile.loadBalancerSku\", \"equals\": \"standard\" } } } ]","title":"Defining JSON rules"},{"location":"concepts/PSRule/en-US/about_PSRule_Rules/#links","text":"Invoke-PSRule","title":"Links"},{"location":"concepts/PSRule/en-US/about_PSRule_Selectors/","text":"Selectors # Describes PSRule Selectors including how to use and author them. Description # PSRule executes rules to validate an object from input. When evaluating an object from input, PSRule can use selectors to perform complex matches of an object. A selector is a YAML/JSON based expression that evaluates an object. Each selector is comprised of nested conditions, operators, and comparison properties. Selectors must use one or more available conditions with a comparison property to evaluate the object. Optionally a condition can be nested in an operator. Operators can be nested within other operators. The following conditions are available: Contains Count Equals EndsWith Exists Greater GreaterOrEquals HasDefault HasSchema HasValue In IsLower IsString IsArray IsBoolean IsDateTime IsInteger IsNumeric IsUpper Less LessOrEquals Match NotEquals NotIn NotMatch SetOf StartsWith Subset Version The following operators are available: AllOf AnyOf Not The following comparison properties are available: Field Name Type To learn more about conditions, operators, and properties see about_PSRule_Expressions . Currently the following limitations apply: Selectors can evaluate: Fields of the target object. Type and name binding of the target object by using name and type comparison properties. State variables such has $PSRule can not be evaluated. Bound fields can not be evaluated. Using selectors as pre-conditions # Selectors can be referenced by name as a rule pre-condition by using the -With parameter. For example: Rule 'RuleWithSelector' -With 'BasicSelector' { # Rule condition } Selector pre-conditions can be used together with type and script block pre-conditions. If one or more selector pre-conditions are used, they are evaluated before type or script block pre-conditions. Defining selectors # Selectors can be defined with either YAML or JSON format, and can be included with a module or standalone .Rule.yaml or .Rule.jsonc file. In either case, define a selector within a file ending with the .Rule.yaml or .Rule.jsonc extension. A selector can be defined side-by-side with other resources such as baselines or module configurations. Selectors can also be defined within .json files. We recommend using .jsonc to view JSON with Comments in Visual Studio Code. Use the following template to define a selector: --- # Synopsis: {{ Synopsis }} apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : '{{ Name }}' spec : if : { } [ { // Synopsis: {{ Synopsis }} \"apiVersion\": \"github.com/microsoft/PSRule/v1\", \"kind\": \"Selector\", \"metadata\": { \"name\": \"{{ Name }}\" }, \"spec\": { \"if\": {} } } ] Within the if object, one or more conditions or logical operators can be used. Examples # Example Selectors.Rule.yaml # # Example Selectors.Rule.yaml --- # Synopsis: Require the CustomValue field. apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : RequireCustomValue spec : if : field : 'CustomValue' exists : true --- # Synopsis: Require a Name or AlternativeName. apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : RequireName spec : if : anyOf : - field : 'AlternateName' exists : true - field : 'Name' exists : true --- # Synopsis: Require a specific CustomValue apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : RequireSpecificCustomValue spec : if : field : 'CustomValue' in : - 'Value1' - 'Value2' Example Selectors.Rule.jsonc # // Example Selectors.Rule.jsonc [ { // Synopsis: Require the CustomValue field. \"apiVersion\": \"github.com/microsoft/PSRule/v1\", \"kind\": \"Selector\", \"metadata\": { \"name\": \"RequireCustomValue\" }, \"spec\": { \"if\": { \"field\": \"CustomValue\", \"exists\": true } } }, { // Synopsis: Require a Name or AlternativeName. \"apiVersion\": \"github.com/microsoft/PSRule/v1\", \"kind\": \"Selector\", \"metadata\": { \"name\": \"RequireName\" }, \"spec\": { \"if\": { \"anyOf\": [ { \"field\": \"AlternateName\", \"exists\": true }, { \"field\": \"Name\", \"exists\": true } ] } } }, { // Synopsis: Require a specific CustomValue \"apiVersion\": \"github.com/microsoft/PSRule/v1\", \"kind\": \"Selector\", \"metadata\": { \"name\": \"RequireSpecificCustomValue\" }, \"spec\": { \"if\": { \"field\": \"CustomValue\", \"in\": [ \"Value1\", \"Value2\" ] } } } ] Links # Invoke-PSRule","title":"Selectors"},{"location":"concepts/PSRule/en-US/about_PSRule_Selectors/#selectors","text":"Describes PSRule Selectors including how to use and author them.","title":"Selectors"},{"location":"concepts/PSRule/en-US/about_PSRule_Selectors/#description","text":"PSRule executes rules to validate an object from input. When evaluating an object from input, PSRule can use selectors to perform complex matches of an object. A selector is a YAML/JSON based expression that evaluates an object. Each selector is comprised of nested conditions, operators, and comparison properties. Selectors must use one or more available conditions with a comparison property to evaluate the object. Optionally a condition can be nested in an operator. Operators can be nested within other operators. The following conditions are available: Contains Count Equals EndsWith Exists Greater GreaterOrEquals HasDefault HasSchema HasValue In IsLower IsString IsArray IsBoolean IsDateTime IsInteger IsNumeric IsUpper Less LessOrEquals Match NotEquals NotIn NotMatch SetOf StartsWith Subset Version The following operators are available: AllOf AnyOf Not The following comparison properties are available: Field Name Type To learn more about conditions, operators, and properties see about_PSRule_Expressions . Currently the following limitations apply: Selectors can evaluate: Fields of the target object. Type and name binding of the target object by using name and type comparison properties. State variables such has $PSRule can not be evaluated. Bound fields can not be evaluated.","title":"Description"},{"location":"concepts/PSRule/en-US/about_PSRule_Selectors/#using-selectors-as-pre-conditions","text":"Selectors can be referenced by name as a rule pre-condition by using the -With parameter. For example: Rule 'RuleWithSelector' -With 'BasicSelector' { # Rule condition } Selector pre-conditions can be used together with type and script block pre-conditions. If one or more selector pre-conditions are used, they are evaluated before type or script block pre-conditions.","title":"Using selectors as pre-conditions"},{"location":"concepts/PSRule/en-US/about_PSRule_Selectors/#defining-selectors","text":"Selectors can be defined with either YAML or JSON format, and can be included with a module or standalone .Rule.yaml or .Rule.jsonc file. In either case, define a selector within a file ending with the .Rule.yaml or .Rule.jsonc extension. A selector can be defined side-by-side with other resources such as baselines or module configurations. Selectors can also be defined within .json files. We recommend using .jsonc to view JSON with Comments in Visual Studio Code. Use the following template to define a selector: --- # Synopsis: {{ Synopsis }} apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : '{{ Name }}' spec : if : { } [ { // Synopsis: {{ Synopsis }} \"apiVersion\": \"github.com/microsoft/PSRule/v1\", \"kind\": \"Selector\", \"metadata\": { \"name\": \"{{ Name }}\" }, \"spec\": { \"if\": {} } } ] Within the if object, one or more conditions or logical operators can be used.","title":"Defining selectors"},{"location":"concepts/PSRule/en-US/about_PSRule_Selectors/#examples","text":"","title":"Examples"},{"location":"concepts/PSRule/en-US/about_PSRule_Selectors/#example-selectorsruleyaml","text":"# Example Selectors.Rule.yaml --- # Synopsis: Require the CustomValue field. apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : RequireCustomValue spec : if : field : 'CustomValue' exists : true --- # Synopsis: Require a Name or AlternativeName. apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : RequireName spec : if : anyOf : - field : 'AlternateName' exists : true - field : 'Name' exists : true --- # Synopsis: Require a specific CustomValue apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : RequireSpecificCustomValue spec : if : field : 'CustomValue' in : - 'Value1' - 'Value2'","title":"Example Selectors.Rule.yaml"},{"location":"concepts/PSRule/en-US/about_PSRule_Selectors/#example-selectorsrulejsonc","text":"// Example Selectors.Rule.jsonc [ { // Synopsis: Require the CustomValue field. \"apiVersion\": \"github.com/microsoft/PSRule/v1\", \"kind\": \"Selector\", \"metadata\": { \"name\": \"RequireCustomValue\" }, \"spec\": { \"if\": { \"field\": \"CustomValue\", \"exists\": true } } }, { // Synopsis: Require a Name or AlternativeName. \"apiVersion\": \"github.com/microsoft/PSRule/v1\", \"kind\": \"Selector\", \"metadata\": { \"name\": \"RequireName\" }, \"spec\": { \"if\": { \"anyOf\": [ { \"field\": \"AlternateName\", \"exists\": true }, { \"field\": \"Name\", \"exists\": true } ] } } }, { // Synopsis: Require a specific CustomValue \"apiVersion\": \"github.com/microsoft/PSRule/v1\", \"kind\": \"Selector\", \"metadata\": { \"name\": \"RequireSpecificCustomValue\" }, \"spec\": { \"if\": { \"field\": \"CustomValue\", \"in\": [ \"Value1\", \"Value2\" ] } } } ]","title":"Example Selectors.Rule.jsonc"},{"location":"concepts/PSRule/en-US/about_PSRule_Selectors/#links","text":"Invoke-PSRule","title":"Links"},{"location":"concepts/PSRule/en-US/about_PSRule_SuppressionGroups/","text":"Suppression Groups # Describes PSRule Suppression Groups including how to use and author them. Description # PSRule executes rules to validate an object from input. When an evaluating each object, PSRule can use suppression groups to suppress rules based on a condition. Suppression groups use a Selector to determine if the rule is suppressed. Defining suppression groups # Suppression groups can be defined using either YAML or JSON format. A suppression group can be in a standalone file or included in a module. Define suppression groups in .Rule.yaml or .Rule.jsonc files. Each suppression group may be defined individually or side-by-side with resources such as rules or baselines. Suppression groups can also be defined within .json files. We recommend using .jsonc to view JSON with Comments in Visual Studio Code. Use the following template to define a suppression group: --- # Synopsis: {{ Synopsis }} apiVersion : github.com/microsoft/PSRule/v1 kind : SuppressionGroup metadata : name : '{{ Name }}' spec : expiresOn : null rule : [] if : { } [ { // Synopsis: {{ Synopsis }} \"apiVersion\": \"github.com/microsoft/PSRule/v1\", \"kind\": \"SuppressionGroup\", \"metadata\": { \"name\": \"{{ Name }}\" }, \"spec\": { \"expiresOn\": null, \"rule\": [], \"if\": {} } } ] Set the synopsis to describe the justification for the suppression. Within the rule array, one or more rule names can be used. If no rules are specified, suppression will occur for all rules. Within the if object, one or more conditions or logical operators can be used. When the if condition is true the object will be suppressed for the current rule. Optionally, an expiry can be set using the expiresOn property. When the expiry date is reached, the suppression will no longer be applied. To configure an expiry, set a RFC3339 (ISO 8601) formatted date time using the format yyyy-MM-ddTHH:mm:ssZ . Documentation # Suppression groups can be configured with a synopsis. When set, the synopsis will be included in output for any suppression warnings that are shown. The synopsis helps provide justification for the suppression, in a short single line message. To set the synopsis, include a comment above the suppression group apiVersion property. Alternatively, a localized synopsis can be provided in a separate markdown file. See about_PSRule_Docs for details. Some examples of a suppression group synopsis include: Ignore test objects by name. Ignore test objects by type. Ignore objects with non-production tag. Examples # Example SuppressionGroups.Rule.yaml # # Example SuppressionGroups.Rule.yaml --- # Synopsis: Ignore test objects by name. apiVersion : github.com/microsoft/PSRule/v1 kind : SuppressionGroup metadata : name : SuppressWithTargetName spec : rule : - 'FromFile1' - 'FromFile2' if : name : '.' in : - 'TestObject1' - 'TestObject2' --- # Synopsis: Ignore test objects by type. apiVersion : github.com/microsoft/PSRule/v1 kind : SuppressionGroup metadata : name : SuppressWithTestType spec : expiresOn : '2030-01-01T00:00:00Z' rule : - 'FromFile3' - 'FromFile5' if : type : '.' equals : 'TestType' Example SuppressionGroups.Rule.jsonc # // Example SuppressionGroups.Rule.jsonc [ { // Synopsis: Ignore test objects by name. \"apiVersion\": \"github.com/microsoft/PSRule/v1\", \"kind\": \"SuppressionGroup\", \"metadata\": { \"name\": \"SuppressWithTargetName\" }, \"spec\": { \"rule\": [ \"FromFile1\", \"FromFile2\" ], \"if\": { \"name\": \".\", \"in\": [ \"TestObject1\", \"TestObject2\" ] } } }, { // Synopsis: Ignore test objects by type. \"apiVersion\": \"github.com/microsoft/PSRule/v1\", \"kind\": \"SuppressionGroup\", \"metadata\": { \"name\": \"SuppressWithTestType\" }, \"spec\": { \"expiresOn\": \"2030-01-01T00:00:00Z\", \"rule\": [ \"FromFile3\", \"FromFile5\" ], \"if\": { \"type\": \".\", \"equals\": \"TestType\" } } } ] Links # Invoke-PSRule","title":"Suppression Groups"},{"location":"concepts/PSRule/en-US/about_PSRule_SuppressionGroups/#suppression-groups","text":"Describes PSRule Suppression Groups including how to use and author them.","title":"Suppression Groups"},{"location":"concepts/PSRule/en-US/about_PSRule_SuppressionGroups/#description","text":"PSRule executes rules to validate an object from input. When an evaluating each object, PSRule can use suppression groups to suppress rules based on a condition. Suppression groups use a Selector to determine if the rule is suppressed.","title":"Description"},{"location":"concepts/PSRule/en-US/about_PSRule_SuppressionGroups/#defining-suppression-groups","text":"Suppression groups can be defined using either YAML or JSON format. A suppression group can be in a standalone file or included in a module. Define suppression groups in .Rule.yaml or .Rule.jsonc files. Each suppression group may be defined individually or side-by-side with resources such as rules or baselines. Suppression groups can also be defined within .json files. We recommend using .jsonc to view JSON with Comments in Visual Studio Code. Use the following template to define a suppression group: --- # Synopsis: {{ Synopsis }} apiVersion : github.com/microsoft/PSRule/v1 kind : SuppressionGroup metadata : name : '{{ Name }}' spec : expiresOn : null rule : [] if : { } [ { // Synopsis: {{ Synopsis }} \"apiVersion\": \"github.com/microsoft/PSRule/v1\", \"kind\": \"SuppressionGroup\", \"metadata\": { \"name\": \"{{ Name }}\" }, \"spec\": { \"expiresOn\": null, \"rule\": [], \"if\": {} } } ] Set the synopsis to describe the justification for the suppression. Within the rule array, one or more rule names can be used. If no rules are specified, suppression will occur for all rules. Within the if object, one or more conditions or logical operators can be used. When the if condition is true the object will be suppressed for the current rule. Optionally, an expiry can be set using the expiresOn property. When the expiry date is reached, the suppression will no longer be applied. To configure an expiry, set a RFC3339 (ISO 8601) formatted date time using the format yyyy-MM-ddTHH:mm:ssZ .","title":"Defining suppression groups"},{"location":"concepts/PSRule/en-US/about_PSRule_SuppressionGroups/#documentation","text":"Suppression groups can be configured with a synopsis. When set, the synopsis will be included in output for any suppression warnings that are shown. The synopsis helps provide justification for the suppression, in a short single line message. To set the synopsis, include a comment above the suppression group apiVersion property. Alternatively, a localized synopsis can be provided in a separate markdown file. See about_PSRule_Docs for details. Some examples of a suppression group synopsis include: Ignore test objects by name. Ignore test objects by type. Ignore objects with non-production tag.","title":"Documentation"},{"location":"concepts/PSRule/en-US/about_PSRule_SuppressionGroups/#examples","text":"","title":"Examples"},{"location":"concepts/PSRule/en-US/about_PSRule_SuppressionGroups/#example-suppressiongroupsruleyaml","text":"# Example SuppressionGroups.Rule.yaml --- # Synopsis: Ignore test objects by name. apiVersion : github.com/microsoft/PSRule/v1 kind : SuppressionGroup metadata : name : SuppressWithTargetName spec : rule : - 'FromFile1' - 'FromFile2' if : name : '.' in : - 'TestObject1' - 'TestObject2' --- # Synopsis: Ignore test objects by type. apiVersion : github.com/microsoft/PSRule/v1 kind : SuppressionGroup metadata : name : SuppressWithTestType spec : expiresOn : '2030-01-01T00:00:00Z' rule : - 'FromFile3' - 'FromFile5' if : type : '.' equals : 'TestType'","title":"Example SuppressionGroups.Rule.yaml"},{"location":"concepts/PSRule/en-US/about_PSRule_SuppressionGroups/#example-suppressiongroupsrulejsonc","text":"// Example SuppressionGroups.Rule.jsonc [ { // Synopsis: Ignore test objects by name. \"apiVersion\": \"github.com/microsoft/PSRule/v1\", \"kind\": \"SuppressionGroup\", \"metadata\": { \"name\": \"SuppressWithTargetName\" }, \"spec\": { \"rule\": [ \"FromFile1\", \"FromFile2\" ], \"if\": { \"name\": \".\", \"in\": [ \"TestObject1\", \"TestObject2\" ] } } }, { // Synopsis: Ignore test objects by type. \"apiVersion\": \"github.com/microsoft/PSRule/v1\", \"kind\": \"SuppressionGroup\", \"metadata\": { \"name\": \"SuppressWithTestType\" }, \"spec\": { \"expiresOn\": \"2030-01-01T00:00:00Z\", \"rule\": [ \"FromFile3\", \"FromFile5\" ], \"if\": { \"type\": \".\", \"equals\": \"TestType\" } } } ]","title":"Example SuppressionGroups.Rule.jsonc"},{"location":"concepts/PSRule/en-US/about_PSRule_SuppressionGroups/#links","text":"Invoke-PSRule","title":"Links"},{"location":"concepts/PSRule/en-US/about_PSRule_Variables/","text":"Variables # Describes the automatic variables that can be used within PSRule rule definitions. Description # PSRule lets you define rules using PowerShell blocks. A rule is defined within script files by using the rule keyword. Within a rule definition, PSRule exposes a number of automatic variables that can be read to assist with rule execution. Overwriting these variables or variable properties is not supported. These variables are only available while Invoke-PSRule is executing. The following variables are available for use: $Assert $Configuration $LocalizedData $PSRule $Rule $TargetObject Assert # An assertion helper with methods to evaluate objects. The $Assert object provides a set of built-in methods and provides a consistent variable for extension. Each $Assert method returns an AssertResult object that contains the result of the condition. The following built-in assertion methods are provided: Contains - The field value must contain at least one of the strings. EndsWith - The field value must match at least one suffix. FileHeader - The file must contain a comment header. FilePath - The file path must exist. Greater - The field value must be greater. GreaterOrEqual - The field value must be greater or equal to. HasDefaultValue - The object should not have the field or the field value is set to the default value. HasField - The object must have any of the specified fields. HasFields - The object must have all of the specified fields. HasFieldValue - The object must have the specified field and that field is not empty. HasJsonSchema - The object must reference a JSON schema with the $schema field. In - The field value must be included in the set. IsArray - The field value must be an array. IsBoolean - The field value must be a boolean. IsInteger - The field value must be an integer. IsLower - The field value must include only lowercase characters. IsNumeric - The field value must be a numeric type. IsString - The field value must be a string. IsUpper - The field value must include only uppercase characters. JsonSchema - The object must validate successfully against a JSON schema. Less - The field value must be less. LessOrEqual - The field value must be less or equal to. Match - The field value matches a regular expression pattern. NotIn - The field value must not be included in the set. NotMatch - The field value does not match a regular expression pattern. NullOrEmpty - The object must not have the specified field or it must be empty. TypeOf - The field value must be of the specified type. StartsWith - The field value must match at least one prefix. Version - The field value must be a semantic version string. The $Assert variable can only be used within a rule definition block. For detailed information on the assertion helper see about_PSRule_Assert . Syntax: $Assert Examples: # Synopsis: Determine if $TargetObject is valid against the provided schema Rule 'UseJsonSchema' { $Assert . JsonSchema ( $TargetObject , 'schemas/PSRule-options.schema.json' ) } Configuration # A dynamic object with properties names that map to configuration values set in the baseline. When accessing configuration: Configuration keys are case sensitive. Configuration values are read only. Configuration values can be accessed through helper methods. The following helper methods are available: GetStringValues(string configurationKey) - Returns an array of strings, based on configurationKey . Syntax: $Configuration .< configurationKey > $Configuration . GetStringValues (< configurationKey >) Examples: # Synopsis: This rule uses a threshold stored as $Configuration.appServiceMinInstanceCount Rule 'appServicePlan.MinInstanceCount' -If { $TargetObject . ResourceType -eq 'Microsoft.Web/serverfarms' } { $TargetObject . Sku . capacity -ge $Configuration . appServiceMinInstanceCount } -Configure @{ appServiceMinInstanceCount = 2 } LocalizedData # A dynamic object with properties names that map to localized data messages in a .psd1 file. When using localized data, PSRule loads localized strings as a hashtable from PSRule-rules.psd1 . The following logic is used to locate PSRule-rules.psd1 : If the rules are loose (not part of a module), PSRule will search for PSRule-rules.psd1 in the .\\<culture>\\ subdirectory relative to where the rule script .ps1 file is located. When the rules are shipped as part of a module, PSRule will search for PSRule-rules.psd1 in the .\\<culture>\\ subdirectory relative to where the module manifest .psd1 file is located. When accessing localized data: Message names are case sensitive. Message values are read only. Syntax: $LocalizedData .< messageName > Examples: # Data for rules stored in PSRule-rules.psd1 @{ WithLocalizedDataMessage = 'LocalizedMessage for en-ZZ. Format={0}.' } # Synopsis: Use -f to generate a formatted localized warning Rule 'WithLocalizedData' { Write-Warning -Message ( $LocalizedData . WithLocalizedDataMessage -f $TargetObject . Type ) } This rule returns a warning message similar to: LocalizedMessage for en-ZZ. Format=TestType. PSRule # An object representing the current context during execution. The following properties are available for read access: Badges - A helper to generate badges within PSRule. This property can only be called within the -End block of a convention. Field - A hashtable of custom bound fields. See option Binding.Field for more information. Input - Allows adding additional input paths to the pipeline. Repository - Provides access to information about the current repository. Scope - The scope of the object currently being processed by the pipeline. Source - A collection of sources for the object currently being processed on the pipeline. TargetObject - The object currently being processed on the pipeline. TargetName - The name of the object currently being processed on the pipeline. This property will automatically default to TargetName or Name properties of the object if they exist. TargetType - The type of the object currently being processed on the pipeline. This property will automatically bind to PSObject.TypeNames[0] by default. Output - The output of all rules. This property can only be called within the -End block of a convention. The following properties are available for read/ write access: Data - A hashtable of custom data. This property can be populated during rule or begin/ process convention execution. Custom data is not used by PSRule directly, and is intended to be used by downstream processes that need to interpret PSRule results. To bind fields that already exist on the target object use custom binding and Binding.Field . Use custom data to store data that must be calculated during rule execution. The following helper methods are available: GetContent(PSObject sourceObject) - Returns the content of a file as one or more objects. The parameter sourceObject should be a InputFileInfo , FileInfo , or Uri object. GetContentField(PSObject sourceObject, string field) - Returns the content of a file as one or more objects. The parameter sourceObject should be a InputFileInfo , FileInfo , or Uri object. The parameter field is an field within each object to return. If the field does not exist on the object, an object is not returned. GetContentFirstOrDefault(PSObject sourceObject) - Returns the content of a file as on object. The parameter sourceObject should be a InputFileInfo , FileInfo , or Uri object. If more than one object is contained in the file, only the first object is returned. When the source file contains no objects null is returned. Import(PSObject[] sourceObject) - Imports one or more source objects into the pipeline. This method can only be called within the -Begin block of a convention. Use this method to expand an object into child objects that will be processed independently. Objects imported using this method will be excluded from the Input.ObjectPath option if set. AddService(string id, object service) - Add a service to the current context. The service can be retrieved using $PSRule.GetService(id) . The service object will be available to all rules and cleaned up after all rules are executed. Services should implement the IDisposable interface to perform additional cleanup. This method can only be called within the -Initialize block of a convention. GetService(string id) - Retrieves a service previously added by a convention. GetPath(object sourceObject, string path) - Evalute an object path expression and returns the resulting objects. The file format is detected based on the same file formats as the option Input.Format . i.e. Yaml, Json, Markdown, and PowerShell Data. Syntax: $PSRule Examples: # Synopsis: This rule determines if the target object matches the naming convention Rule 'NamingConvention' { $PSRule . TargetName . ToLower () -ceq $PSRule . TargetName } # Synopsis: Use allowed environment tags Rule 'CustomData' { Recommend 'Environment must be set to an allowed value' Within 'Tags.environment' 'production' , 'test' , 'development' if ( $TargetObject . Tags . environment -in 'prod' ) { $PSRule . Data [ 'targetEnvironment' ] = 'production' } elseif ( $TargetObject . Tags . environment -in 'dev' , 'develop' ) { $PSRule . Data [ 'targetEnvironment' ] = 'development' } elseif ( $TargetObject . Tags . environment -in 'tst' , 'testing' ) { $PSRule . Data [ 'targetEnvironment' ] = 'test' } } Rule # An object representing the current rule during execution. The following properties are available for read access: RuleName - The name of the rule. RuleId - A unique identifier for the rule. Syntax: $Rule Examples: # Synopsis: This rule determines if the target object matches the naming convention Rule 'resource.NamingConvention' { $PSRule . TargetName . ToLower () -ceq $PSRule . TargetName } TargetObject # The value of the pipeline object currently being processed. $TargetObject is set by using the -InputObject parameter of Invoke-PSRule . When more than one input object is set, each object will be processed sequentially. Syntax: $TargetObject Examples: # Synopsis: Check that sku capacity is set to at least 2 Rule 'HasMinInstances' { $TargetObject . Sku . capacity -ge 2 } Links # Invoke-PSRule","title":"Variables"},{"location":"concepts/PSRule/en-US/about_PSRule_Variables/#variables","text":"Describes the automatic variables that can be used within PSRule rule definitions.","title":"Variables"},{"location":"concepts/PSRule/en-US/about_PSRule_Variables/#description","text":"PSRule lets you define rules using PowerShell blocks. A rule is defined within script files by using the rule keyword. Within a rule definition, PSRule exposes a number of automatic variables that can be read to assist with rule execution. Overwriting these variables or variable properties is not supported. These variables are only available while Invoke-PSRule is executing. The following variables are available for use: $Assert $Configuration $LocalizedData $PSRule $Rule $TargetObject","title":"Description"},{"location":"concepts/PSRule/en-US/about_PSRule_Variables/#assert","text":"An assertion helper with methods to evaluate objects. The $Assert object provides a set of built-in methods and provides a consistent variable for extension. Each $Assert method returns an AssertResult object that contains the result of the condition. The following built-in assertion methods are provided: Contains - The field value must contain at least one of the strings. EndsWith - The field value must match at least one suffix. FileHeader - The file must contain a comment header. FilePath - The file path must exist. Greater - The field value must be greater. GreaterOrEqual - The field value must be greater or equal to. HasDefaultValue - The object should not have the field or the field value is set to the default value. HasField - The object must have any of the specified fields. HasFields - The object must have all of the specified fields. HasFieldValue - The object must have the specified field and that field is not empty. HasJsonSchema - The object must reference a JSON schema with the $schema field. In - The field value must be included in the set. IsArray - The field value must be an array. IsBoolean - The field value must be a boolean. IsInteger - The field value must be an integer. IsLower - The field value must include only lowercase characters. IsNumeric - The field value must be a numeric type. IsString - The field value must be a string. IsUpper - The field value must include only uppercase characters. JsonSchema - The object must validate successfully against a JSON schema. Less - The field value must be less. LessOrEqual - The field value must be less or equal to. Match - The field value matches a regular expression pattern. NotIn - The field value must not be included in the set. NotMatch - The field value does not match a regular expression pattern. NullOrEmpty - The object must not have the specified field or it must be empty. TypeOf - The field value must be of the specified type. StartsWith - The field value must match at least one prefix. Version - The field value must be a semantic version string. The $Assert variable can only be used within a rule definition block. For detailed information on the assertion helper see about_PSRule_Assert . Syntax: $Assert Examples: # Synopsis: Determine if $TargetObject is valid against the provided schema Rule 'UseJsonSchema' { $Assert . JsonSchema ( $TargetObject , 'schemas/PSRule-options.schema.json' ) }","title":"Assert"},{"location":"concepts/PSRule/en-US/about_PSRule_Variables/#configuration","text":"A dynamic object with properties names that map to configuration values set in the baseline. When accessing configuration: Configuration keys are case sensitive. Configuration values are read only. Configuration values can be accessed through helper methods. The following helper methods are available: GetStringValues(string configurationKey) - Returns an array of strings, based on configurationKey . Syntax: $Configuration .< configurationKey > $Configuration . GetStringValues (< configurationKey >) Examples: # Synopsis: This rule uses a threshold stored as $Configuration.appServiceMinInstanceCount Rule 'appServicePlan.MinInstanceCount' -If { $TargetObject . ResourceType -eq 'Microsoft.Web/serverfarms' } { $TargetObject . Sku . capacity -ge $Configuration . appServiceMinInstanceCount } -Configure @{ appServiceMinInstanceCount = 2 }","title":"Configuration"},{"location":"concepts/PSRule/en-US/about_PSRule_Variables/#localizeddata","text":"A dynamic object with properties names that map to localized data messages in a .psd1 file. When using localized data, PSRule loads localized strings as a hashtable from PSRule-rules.psd1 . The following logic is used to locate PSRule-rules.psd1 : If the rules are loose (not part of a module), PSRule will search for PSRule-rules.psd1 in the .\\<culture>\\ subdirectory relative to where the rule script .ps1 file is located. When the rules are shipped as part of a module, PSRule will search for PSRule-rules.psd1 in the .\\<culture>\\ subdirectory relative to where the module manifest .psd1 file is located. When accessing localized data: Message names are case sensitive. Message values are read only. Syntax: $LocalizedData .< messageName > Examples: # Data for rules stored in PSRule-rules.psd1 @{ WithLocalizedDataMessage = 'LocalizedMessage for en-ZZ. Format={0}.' } # Synopsis: Use -f to generate a formatted localized warning Rule 'WithLocalizedData' { Write-Warning -Message ( $LocalizedData . WithLocalizedDataMessage -f $TargetObject . Type ) } This rule returns a warning message similar to: LocalizedMessage for en-ZZ. Format=TestType.","title":"LocalizedData"},{"location":"concepts/PSRule/en-US/about_PSRule_Variables/#psrule","text":"An object representing the current context during execution. The following properties are available for read access: Badges - A helper to generate badges within PSRule. This property can only be called within the -End block of a convention. Field - A hashtable of custom bound fields. See option Binding.Field for more information. Input - Allows adding additional input paths to the pipeline. Repository - Provides access to information about the current repository. Scope - The scope of the object currently being processed by the pipeline. Source - A collection of sources for the object currently being processed on the pipeline. TargetObject - The object currently being processed on the pipeline. TargetName - The name of the object currently being processed on the pipeline. This property will automatically default to TargetName or Name properties of the object if they exist. TargetType - The type of the object currently being processed on the pipeline. This property will automatically bind to PSObject.TypeNames[0] by default. Output - The output of all rules. This property can only be called within the -End block of a convention. The following properties are available for read/ write access: Data - A hashtable of custom data. This property can be populated during rule or begin/ process convention execution. Custom data is not used by PSRule directly, and is intended to be used by downstream processes that need to interpret PSRule results. To bind fields that already exist on the target object use custom binding and Binding.Field . Use custom data to store data that must be calculated during rule execution. The following helper methods are available: GetContent(PSObject sourceObject) - Returns the content of a file as one or more objects. The parameter sourceObject should be a InputFileInfo , FileInfo , or Uri object. GetContentField(PSObject sourceObject, string field) - Returns the content of a file as one or more objects. The parameter sourceObject should be a InputFileInfo , FileInfo , or Uri object. The parameter field is an field within each object to return. If the field does not exist on the object, an object is not returned. GetContentFirstOrDefault(PSObject sourceObject) - Returns the content of a file as on object. The parameter sourceObject should be a InputFileInfo , FileInfo , or Uri object. If more than one object is contained in the file, only the first object is returned. When the source file contains no objects null is returned. Import(PSObject[] sourceObject) - Imports one or more source objects into the pipeline. This method can only be called within the -Begin block of a convention. Use this method to expand an object into child objects that will be processed independently. Objects imported using this method will be excluded from the Input.ObjectPath option if set. AddService(string id, object service) - Add a service to the current context. The service can be retrieved using $PSRule.GetService(id) . The service object will be available to all rules and cleaned up after all rules are executed. Services should implement the IDisposable interface to perform additional cleanup. This method can only be called within the -Initialize block of a convention. GetService(string id) - Retrieves a service previously added by a convention. GetPath(object sourceObject, string path) - Evalute an object path expression and returns the resulting objects. The file format is detected based on the same file formats as the option Input.Format . i.e. Yaml, Json, Markdown, and PowerShell Data. Syntax: $PSRule Examples: # Synopsis: This rule determines if the target object matches the naming convention Rule 'NamingConvention' { $PSRule . TargetName . ToLower () -ceq $PSRule . TargetName } # Synopsis: Use allowed environment tags Rule 'CustomData' { Recommend 'Environment must be set to an allowed value' Within 'Tags.environment' 'production' , 'test' , 'development' if ( $TargetObject . Tags . environment -in 'prod' ) { $PSRule . Data [ 'targetEnvironment' ] = 'production' } elseif ( $TargetObject . Tags . environment -in 'dev' , 'develop' ) { $PSRule . Data [ 'targetEnvironment' ] = 'development' } elseif ( $TargetObject . Tags . environment -in 'tst' , 'testing' ) { $PSRule . Data [ 'targetEnvironment' ] = 'test' } }","title":"PSRule"},{"location":"concepts/PSRule/en-US/about_PSRule_Variables/#rule","text":"An object representing the current rule during execution. The following properties are available for read access: RuleName - The name of the rule. RuleId - A unique identifier for the rule. Syntax: $Rule Examples: # Synopsis: This rule determines if the target object matches the naming convention Rule 'resource.NamingConvention' { $PSRule . TargetName . ToLower () -ceq $PSRule . TargetName }","title":"Rule"},{"location":"concepts/PSRule/en-US/about_PSRule_Variables/#targetobject","text":"The value of the pipeline object currently being processed. $TargetObject is set by using the -InputObject parameter of Invoke-PSRule . When more than one input object is set, each object will be processed sequentially. Syntax: $TargetObject Examples: # Synopsis: Check that sku capacity is set to at least 2 Rule 'HasMinInstances' { $TargetObject . Sku . capacity -ge 2 }","title":"TargetObject"},{"location":"concepts/PSRule/en-US/about_PSRule_Variables/#links","text":"Invoke-PSRule","title":"Links"},{"location":"expressions/functions/","text":"Functions # Abstract Functions are an advanced lanaguage feature specific to YAML and JSON expressions. That extend the language to allow for more complex use cases with expressions. Functions don't apply to script expressions because PowerShell already has rich support for complex manipulation. Experimental Functions are a work in progress and subject to change. We hope to add more functions, broader support, and more detailed documentation in the future. Join or start a disucssion to let us know how we can improve this feature going forward. Functions cover two (2) main scenarios: Transformation \u2014 you need to perform minor transformation before a condition. Configuration \u2014 you want to configure an input into a condition. Using functions # It may be necessary to perform minor transformation before evaluating a condition. boolean - Convert a value to a boolean. string - Convert a value to a string. integer - Convert a value to an integer. concat - Concatenate multiple values. substring - Extract a substring from a string. configuration - Get a configuration value. path - Get a value from an object path. Supported conditions # Currently functions are only supported on a subset of conditions. The conditions that are supported are: equals notEquals count less lessOrEquals greater greaterOrEquals Examples # YAML --- # Synopsis: An expression function example. apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : Yaml.Fn.Example1 spec : if : value : $ : substring : path : name length : 7 equals : TestObj --- # Synopsis: An expression function example. apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : Yaml.Fn.Example2 spec : if : value : $ : configuration : 'ConfigArray' count : 5 --- # Synopsis: An expression function example. apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : Yaml.Fn.Example3 spec : if : value : $ : boolean : true equals : true --- # Synopsis: An expression function example. apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : Yaml.Fn.Example4 spec : if : value : $ : concat : - path : name - string : '-' - path : name equals : TestObject1-TestObject1 --- # Synopsis: An expression function example. apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : Yaml.Fn.Example5 spec : if : value : $ : integer : 6 greater : 5 --- # Synopsis: An expression function example. apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : Yaml.Fn.Example6 spec : if : value : TestObject1-TestObject1 equals : $ : concat : - path : name - string : '-' - path : name","title":"Functions"},{"location":"expressions/functions/#functions","text":"Abstract Functions are an advanced lanaguage feature specific to YAML and JSON expressions. That extend the language to allow for more complex use cases with expressions. Functions don't apply to script expressions because PowerShell already has rich support for complex manipulation. Experimental Functions are a work in progress and subject to change. We hope to add more functions, broader support, and more detailed documentation in the future. Join or start a disucssion to let us know how we can improve this feature going forward. Functions cover two (2) main scenarios: Transformation \u2014 you need to perform minor transformation before a condition. Configuration \u2014 you want to configure an input into a condition.","title":"Functions"},{"location":"expressions/functions/#using-functions","text":"It may be necessary to perform minor transformation before evaluating a condition. boolean - Convert a value to a boolean. string - Convert a value to a string. integer - Convert a value to an integer. concat - Concatenate multiple values. substring - Extract a substring from a string. configuration - Get a configuration value. path - Get a value from an object path.","title":"Using functions"},{"location":"expressions/functions/#supported-conditions","text":"Currently functions are only supported on a subset of conditions. The conditions that are supported are: equals notEquals count less lessOrEquals greater greaterOrEquals","title":"Supported conditions"},{"location":"expressions/functions/#examples","text":"YAML --- # Synopsis: An expression function example. apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : Yaml.Fn.Example1 spec : if : value : $ : substring : path : name length : 7 equals : TestObj --- # Synopsis: An expression function example. apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : Yaml.Fn.Example2 spec : if : value : $ : configuration : 'ConfigArray' count : 5 --- # Synopsis: An expression function example. apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : Yaml.Fn.Example3 spec : if : value : $ : boolean : true equals : true --- # Synopsis: An expression function example. apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : Yaml.Fn.Example4 spec : if : value : $ : concat : - path : name - string : '-' - path : name equals : TestObject1-TestObject1 --- # Synopsis: An expression function example. apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : Yaml.Fn.Example5 spec : if : value : $ : integer : 6 greater : 5 --- # Synopsis: An expression function example. apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : Yaml.Fn.Example6 spec : if : value : TestObject1-TestObject1 equals : $ : concat : - path : name - string : '-' - path : name","title":"Examples"},{"location":"expressions/sub-selectors/","text":"Sub-selectors # Abstract This topic covers sub-selectors which are a PSRule language feature specific to YAML and JSON expressions. They are useful for filtering out objects that you do not want to evaluate. Sub-selectors don't apply to script expressions because PowerShell already has rich support for filtering. Experimental Sub-selectors are a work in progress and subject to change. We hope to add broader support, and more detailed documentation in the future. Join or start a disucssion to let us know how we can improve this feature going forward. Sub-selectors cover two (2) main scenarios: Pre-conditions \u2014 you want to filtering out objects before a rule is run. Object filtering \u2014 you want to limit a condition to specific elements in a list of items. Pre-conditions # PSRule can process many different types of objects. Rules however, are normally written to test a specific property or type of object. So it is important that rules only run on objects that you want to evaluate. Pre-condition sub-selectors are one way you can determine if a rule should be run. To use a sub-selector as a pre-condition, use the where property, directly under the spec . The expressions in the sub-selector follow the same form that you can use in rules. For example: YAML JSON --- # Synopsis: A rule with a sub-selector precondition. apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : Yaml.Subselector.Precondition spec : where : field : 'kind' equals : 'api' condition : field : resources count : 10 { // Synopsis: A rule with a sub-selector precondition. \"apiVersion\" : \"github.com/microsoft/PSRule/v1\" , \"kind\" : \"Rule\" , \"metadata\" : { \"name\" : \"Json.Subselector.Precondition\" }, \"spec\" : { \"where\" : { \"field\" : \"kind\" , \"equals\" : \"api\" }, \"condition\" : { \"field\" : \"resources\" , \"count\" : 10 } } } In the example: The where property is the start of a sub-selector. The sub-selector checks if the kind property equals api . The rule does not run if the: The object does not have a kind property. OR The value of the kind property is not api . Tip Other types of pre-conditions also exist that allow you to filter based on type or by a shared selector. Object filter # When you are evaluating an object, you can use sub-selectors to limit the condition. This is helpful when dealing with properties that are a list of items. Properties that contain a list of items may contain a sub-set of items that you want to evaluate. For example, the object may look like this: YAML JSON name : app1 type : Microsoft.Web/sites resources : - name : web type : Microsoft.Web/sites/config properties : detailedErrorLoggingEnabled : true { \"name\" : \"app1\" , \"type\" : \"Microsoft.Web/sites\" , \"resources\" : [ { \"name\" : \"web\" , \"type\" : \"Microsoft.Web/sites/config\" , \"properties\" : { \"detailedErrorLoggingEnabled\" : true } } ] } A rule to test if any sub-resources with the detailedErrorLoggingEnabled set to true exist might look like this: YAML JSON --- # Synopsis: A rule with a sub-selector filter. apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : Yaml.Subselector.Filter spec : condition : field : resources where : type : '.' equals : 'Microsoft.Web/sites/config' allOf : - field : properties.detailedErrorLoggingEnabled equals : true { // Synopsis: A rule with a sub-selector filter. \"apiVersion\" : \"github.com/microsoft/PSRule/v1\" , \"kind\" : \"Rule\" , \"metadata\" : { \"name\" : \"Json.Subselector.Filter\" }, \"spec\" : { \"condition\" : { \"field\" : \"resources\" , \"where\" : { \"type\" : \".\" , \"equals\" : \"Microsoft.Web/sites/config\" }, \"allOf\" : [ { \"field\" : \"properties.detailedErrorLoggingEnabled\" , \"equals\" : true } ] } } } In the example: If the array property resources exists, any items with a type of Microsoft.Web/sites/config are evaluated. Each item must have the properties.detailedErrorLoggingEnabled property set to true to pass. Items without the properties.detailedErrorLoggingEnabled property fail. Items with the properties.detailedErrorLoggingEnabled property set to a value other then true fail. If the resources property does not exist, the rule fails. If the resources property exists but has 0 items of type Microsoft.Web/sites/config , the rule fails. If the resources property exists and has any items of type Microsoft.Web/sites/config but any fail, the rule fails. If the resources property exists and has any items of type Microsoft.Web/sites/config and all pass, the rule passes. When there are no results # Given the example, is important to understand what happens if: The resources property doesn't exist. OR The resources property doesn't contain any items that match the sub-selector condition. In either of these two cases, the sub-selector will return false and fail the rule. The rule fails because there is no secondary conditions that could be used instead. If this was not the desired behavior, you could: Use a pre-condition to avoid running the rule. Group the sub-selector into a anyOf , and provide a secondary condition. For example: YAML JSON --- # Synopsis: A rule with a sub-selector filter. apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : Yaml.Subselector.FilterOr spec : condition : anyOf : - field : resources where : type : '.' equals : 'Microsoft.Web/sites/config' allOf : - field : properties.detailedErrorLoggingEnabled equals : true - field : resources exists : false { // Synopsis: A rule with a sub-selector filter. \"apiVersion\" : \"github.com/microsoft/PSRule/v1\" , \"kind\" : \"Rule\" , \"metadata\" : { \"name\" : \"Json.Subselector.FilterOr\" }, \"spec\" : { \"condition\" : { \"anyOf\" : [ { \"field\" : \"resources\" , \"where\" : { \"type\" : \".\" , \"equals\" : \"Microsoft.Web/sites/config\" }, \"allOf\" : [ { \"field\" : \"properties.detailedErrorLoggingEnabled\" , \"equals\" : true } ] }, { \"field\" : \"resources\" , \"exists\" : false } ] } } } In the example: If the array property resources exists, any items with a type of Microsoft.Web/sites/config are evaluated. Each item must have the properties.detailedErrorLoggingEnabled property set to true to pass. Items without the properties.detailedErrorLoggingEnabled property fail. Items with the properties.detailedErrorLoggingEnabled property set to a value other then true fail. If the resources property does not exist, the rule passes. If the resources property exists but has 0 items of type Microsoft.Web/sites/config , the rule fails. If the resources property exists and has any items of type Microsoft.Web/sites/config but any fail, the rule fails. If the resources property exists and has any items of type Microsoft.Web/sites/config and all pass, the rule passes.","title":"Sub-selectors"},{"location":"expressions/sub-selectors/#sub-selectors","text":"Abstract This topic covers sub-selectors which are a PSRule language feature specific to YAML and JSON expressions. They are useful for filtering out objects that you do not want to evaluate. Sub-selectors don't apply to script expressions because PowerShell already has rich support for filtering. Experimental Sub-selectors are a work in progress and subject to change. We hope to add broader support, and more detailed documentation in the future. Join or start a disucssion to let us know how we can improve this feature going forward. Sub-selectors cover two (2) main scenarios: Pre-conditions \u2014 you want to filtering out objects before a rule is run. Object filtering \u2014 you want to limit a condition to specific elements in a list of items.","title":"Sub-selectors"},{"location":"expressions/sub-selectors/#pre-conditions","text":"PSRule can process many different types of objects. Rules however, are normally written to test a specific property or type of object. So it is important that rules only run on objects that you want to evaluate. Pre-condition sub-selectors are one way you can determine if a rule should be run. To use a sub-selector as a pre-condition, use the where property, directly under the spec . The expressions in the sub-selector follow the same form that you can use in rules. For example: YAML JSON --- # Synopsis: A rule with a sub-selector precondition. apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : Yaml.Subselector.Precondition spec : where : field : 'kind' equals : 'api' condition : field : resources count : 10 { // Synopsis: A rule with a sub-selector precondition. \"apiVersion\" : \"github.com/microsoft/PSRule/v1\" , \"kind\" : \"Rule\" , \"metadata\" : { \"name\" : \"Json.Subselector.Precondition\" }, \"spec\" : { \"where\" : { \"field\" : \"kind\" , \"equals\" : \"api\" }, \"condition\" : { \"field\" : \"resources\" , \"count\" : 10 } } } In the example: The where property is the start of a sub-selector. The sub-selector checks if the kind property equals api . The rule does not run if the: The object does not have a kind property. OR The value of the kind property is not api . Tip Other types of pre-conditions also exist that allow you to filter based on type or by a shared selector.","title":"Pre-conditions"},{"location":"expressions/sub-selectors/#object-filter","text":"When you are evaluating an object, you can use sub-selectors to limit the condition. This is helpful when dealing with properties that are a list of items. Properties that contain a list of items may contain a sub-set of items that you want to evaluate. For example, the object may look like this: YAML JSON name : app1 type : Microsoft.Web/sites resources : - name : web type : Microsoft.Web/sites/config properties : detailedErrorLoggingEnabled : true { \"name\" : \"app1\" , \"type\" : \"Microsoft.Web/sites\" , \"resources\" : [ { \"name\" : \"web\" , \"type\" : \"Microsoft.Web/sites/config\" , \"properties\" : { \"detailedErrorLoggingEnabled\" : true } } ] } A rule to test if any sub-resources with the detailedErrorLoggingEnabled set to true exist might look like this: YAML JSON --- # Synopsis: A rule with a sub-selector filter. apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : Yaml.Subselector.Filter spec : condition : field : resources where : type : '.' equals : 'Microsoft.Web/sites/config' allOf : - field : properties.detailedErrorLoggingEnabled equals : true { // Synopsis: A rule with a sub-selector filter. \"apiVersion\" : \"github.com/microsoft/PSRule/v1\" , \"kind\" : \"Rule\" , \"metadata\" : { \"name\" : \"Json.Subselector.Filter\" }, \"spec\" : { \"condition\" : { \"field\" : \"resources\" , \"where\" : { \"type\" : \".\" , \"equals\" : \"Microsoft.Web/sites/config\" }, \"allOf\" : [ { \"field\" : \"properties.detailedErrorLoggingEnabled\" , \"equals\" : true } ] } } } In the example: If the array property resources exists, any items with a type of Microsoft.Web/sites/config are evaluated. Each item must have the properties.detailedErrorLoggingEnabled property set to true to pass. Items without the properties.detailedErrorLoggingEnabled property fail. Items with the properties.detailedErrorLoggingEnabled property set to a value other then true fail. If the resources property does not exist, the rule fails. If the resources property exists but has 0 items of type Microsoft.Web/sites/config , the rule fails. If the resources property exists and has any items of type Microsoft.Web/sites/config but any fail, the rule fails. If the resources property exists and has any items of type Microsoft.Web/sites/config and all pass, the rule passes.","title":"Object filter"},{"location":"expressions/sub-selectors/#when-there-are-no-results","text":"Given the example, is important to understand what happens if: The resources property doesn't exist. OR The resources property doesn't contain any items that match the sub-selector condition. In either of these two cases, the sub-selector will return false and fail the rule. The rule fails because there is no secondary conditions that could be used instead. If this was not the desired behavior, you could: Use a pre-condition to avoid running the rule. Group the sub-selector into a anyOf , and provide a secondary condition. For example: YAML JSON --- # Synopsis: A rule with a sub-selector filter. apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : Yaml.Subselector.FilterOr spec : condition : anyOf : - field : resources where : type : '.' equals : 'Microsoft.Web/sites/config' allOf : - field : properties.detailedErrorLoggingEnabled equals : true - field : resources exists : false { // Synopsis: A rule with a sub-selector filter. \"apiVersion\" : \"github.com/microsoft/PSRule/v1\" , \"kind\" : \"Rule\" , \"metadata\" : { \"name\" : \"Json.Subselector.FilterOr\" }, \"spec\" : { \"condition\" : { \"anyOf\" : [ { \"field\" : \"resources\" , \"where\" : { \"type\" : \".\" , \"equals\" : \"Microsoft.Web/sites/config\" }, \"allOf\" : [ { \"field\" : \"properties.detailedErrorLoggingEnabled\" , \"equals\" : true } ] }, { \"field\" : \"resources\" , \"exists\" : false } ] } } } In the example: If the array property resources exists, any items with a type of Microsoft.Web/sites/config are evaluated. Each item must have the properties.detailedErrorLoggingEnabled property set to true to pass. Items without the properties.detailedErrorLoggingEnabled property fail. Items with the properties.detailedErrorLoggingEnabled property set to a value other then true fail. If the resources property does not exist, the rule passes. If the resources property exists but has 0 items of type Microsoft.Web/sites/config , the rule fails. If the resources property exists and has any items of type Microsoft.Web/sites/config but any fail, the rule fails. If the resources property exists and has any items of type Microsoft.Web/sites/config and all pass, the rule passes.","title":"When there are no results"},{"location":"keywords/PSRule/en-US/about_PSRule_Keywords/","text":"Keywords # Describes the language keywords that can be used within PSRule rule definitions. Description # PSRule lets you define rules using PowerShell blocks. To define a rule use the Rule keyword. Rule - Creates a rule definition. The following are the built-in keywords that can be used within a rule definition: AnyOf - Assert that any of the child expressions must be true. AllOf - Assert that all of the child expressions must be true. Exists - Assert that a field or property must exist. Match - Assert that the field must match any of the regular expressions. Reason - Return a reason for why the rule failed. Recommend - Return a recommendation to resolve the issue and pass the rule. TypeOf - Assert that the object must be of a specific type. Within - Assert that the field must match any of the values. A subset of built-in keywords can be used within script preconditions: Exists - Assert that a field or property must exist. Match - Assert that the field must match any of the regular expressions. TypeOf - Assert that the object must be of a specific type. Within - Assert that the field must match any of the values. Rule # A Rule definition describes an individual business rule that will be executed against each input object. Input objects can be passed on the PowerShell pipeline or supplied from file. To define a Rule use the Rule keyword followed by a name and a pair of squiggly brackets { . Within the { } one or more conditions can be used. Conditions determine if the input object either Pass or Fail the rule. Syntax: Rule [-Name] <string> [-Ref <string>] [-Alias <string[]>] [-Tag <hashtable>] [-When <string[]>] [-Type <string[]>] [-If <scriptBlock>] [-DependsOn <string[]>] [-Configure <hashtable>] [-ErrorAction <ActionPreference>] [-Body] { ... } Name - The name of the rule definition. Each rule name must be unique. When packaging rules within a module, rule names must only be unique within the module. Ref - An optional stable and opaque identifier that can be used to reference the rule. Alias - A list of alternative names that can be used to reference the rule. Tag - A hashtable of key/ value metadata that can be used to filter and identify rules and rule results. When - A selector precondition that must evaluate true before the rule is executed. Type - A type precondition that must match the TargetType of the pipeline object before the rule is executed. If - A script precondition that must evaluate to $True before the rule is executed. DependsOn - A list of rules this rule depends on. Rule dependencies must execute successfully before this rule is executed. Configure - A set of default configuration values. These values are only used when the baseline configuration does not contain the key. ErrorAction - The action to take when an error occur. Only a subset of preferences are supported, either Stop or Ignore . When -ErrorAction is not specified the default preference is Stop . When errors are ignored a rule will pass or fail based on the rule condition. Uncaught exceptions will still cause rule return an error outcome. Body - A script block that specifies one or more conditions that are required for the rule to Pass . A condition is any valid PowerShell that return either $True or $False . Optionally, PSRule keywords can be used to help build out conditions quickly. When a rule contains more then one condition, all must return $True for the rule to Pass . If any one condition returns $False the rule has failed. The following restrictions apply: Rule conditions should only return $True or $False . Other objects should be caught with Out-Null or null assigned like $Null = SomeCommand . The Rule keyword can not be nested in a Rule definition. Variables and functions defined within .Rule.ps1 files, but outside the Rule definition block are not accessible unless the Global scope is applied. Functions and variables within the caller's scope (the scope calling Invoke-PSRule , Get-PSRule , Test-PSRuleTarget ) are not accessible. Cmdlets that require user interaction are not supported, i.e. Read-Host . Script preconditions can contain Exists , Match , TypeOf and Within keywords. Examples: # Synopsis: This rule checks for the presence of a name field Rule 'NameMustExist' { Exists 'Name' } # Synopsis: This rule checks that the title field is valid, when the rule NameMustExist is successful Rule 'TitleIsValid' -DependsOn 'NameMustExist' { Within 'Title' 'Mr' , 'Miss' , 'Mrs' , 'Ms' } # Synopsis: This rule uses a threshold stored as $Configuration.minInstanceCount Rule 'HasMinInstances' { $TargetObject . Sku . capacity -ge $Configuration . minInstanceCount } -Configure @{ minInstanceCount = 2 } # Synopsis: This rule still passes because errors are ignored Rule 'WithRuleErrorActionIgnore' -ErrorAction Ignore { Write-Error 'Some error' ; $True ; } Exists # The Exists assertion is used within a Rule definition to assert that a field or property must exist on the pipeline object. Syntax: Exists [-Field] <string[]> [-CaseSensitive] [-Not] [-All] [-Reason <string>] [-InputObject <PSObject>] Field - One or more fields/ properties that must exist on the pipeline object. CaseSensitive - The field name must match exact case. Not - Instead of checking if the field names exists they should not exist. All - All fields must exist on the pipeline object, instead of only one. Reason - A custom reason provided if the condition fails. InputObject - Supports objects being piped directly. Examples: # Synopsis: Checks for the presence of a name property Rule 'nameMustExist' { Exists 'Name' } # Synopsis: Checks for the presence of name nested under the metadata property Rule 'nameMustExist' { Exists 'metadata.name' } # Synopsis: Checks for the presence of name nested under the metadata property Rule 'nameMustExist' { $TargetObject . metadata | Exists 'name' } # Synopsis: Checks that the NotName property does not exist Rule 'NotNameMustNotExist' { Exists -Not 'NotName' } # Synopsis: Checks one of Name or AlternativeName properties exist Rule 'EitherMustExist' { Exists 'Name' , 'AlternativeName' } # Synopsis: Checks that both Name and Type properties exist Rule 'AllMustExist' { Exists 'Name' , 'Type' -All } Output: If any the specified fields exists then Exists will return $True , otherwise $False . If -Not is used, then if any of the fields exist then Exists will return $False otherwise $True . If -All is used, then then all of the fields must exist, or not with the -Not switch. If all fields exist then Exists will return $True , otherwise $False . If -Not is used with -All , if all of the fields exist Exists will return $False otherwise $True . Match # The Match assertion is used within a Rule definition to assert that the value of a field or property from pipeline data must match one or more regular expressions. To optionally perform a case sensitive match use the -CaseSensitive switch, otherwise a case insensitive match will be used. Syntax: Match [-Field] <string> [-Expression] <string[]> [-CaseSensitive] [-Not] [-Reason <string>] [-InputObject <PSObject>] Field - The name of the field that will be evaluated on the pipeline object. Expression - One or more regular expressions that will be used to match the value of the field. CaseSensitive - The field value must match exact case. Not - Instead of checking the field value matches, the field value must not match any of the expressions. Reason - A custom reason provided if the condition fails. InputObject - Supports objects being piped directly. Examples: # Synopsis: Check that PhoneNumber is complete and formatted correctly Rule 'validatePhoneNumber' { Match 'PhoneNumber' '^(\\+61|0)([0-9] {0,1}){8}[0-9]$' } Output: If any of the specified regular expressions match the field value then Match returns $True , otherwise $False . When -Not is used, if any of the regular expressions match the field value with Match return $False , otherwise $True . Within # The Within assertion is used within a Rule definition to assert that the value of a field or property from pipeline data must equal an item from a supplied list of allowed values. To optionally perform a case sensitive match use the -CaseSensitive switch, otherwise a case insensitive match will be used. Syntax: Within [-Field] <string> [-Not] [-Like] [-Value] <PSObject[]> [-CaseSensitive] [-Reason <string>] [-InputObject <PSObject>] Field - The name of the field that will be evaluated on the pipeline object. Value - A list of values that the field value must match. CaseSensitive - The field value must match exact case. Only applies when the field value and allowed values are strings. Not - Instead of checking the field value matches, the field value must not match any of the supplied values. Like - Instead of using an exact match, a wildcard match is used. This switch can only be used when Value a string type. Reason - A custom reason provided if the condition fails. InputObject - Supports objects being piped directly. Examples: # Synopsis: Ensure that the title field has one of the allowed values Rule 'validateTitle' { Within 'Title' 'Mr' , 'Miss' , 'Mrs' , 'Ms' } # Synopsis: Ensure that the title field is not one of the specified values Rule 'validateTitle' { Within 'Title' -Not 'Mr' , 'Sir' } # Synopsis: Ensure that the title field has one of the allowed values Rule 'validateTitle' { Within 'Title' -Like 'Mr' , 'M*s' } Output: If any of the values match the field value then Within returns $True , otherwise $False . When -Not is used, if any of the values match the field value with Within return $False , otherwise $True . When -Like is used, the field value is matched against one or more wildcard expressions. AllOf # The AllOf assertion is used within a Rule definition to aggregate the result of assertions within a pair of squiggly brackets { } . AllOf is functionally equivalent to a binary and , where when all of the contained assertions return $True , AllOf will return $True . Syntax: AllOf [-Body] { <assertion> [<assertion>] ... } Body - A script block definition of the containing one or more PSRule keywords and PowerShell expressions. Examples: # Synopsis: The Name field must exist and have a value of either John or Jane Rule 'nameCheck' { AllOf { Exists 'Name' Within 'Name' 'John' , 'Jane' } } Output: If all of the assertions return $True AllOf will return $True , otherwise $False . AnyOf # The AnyOf assertion is used within a Rule definition to aggregate the result of assertions within a pair of squiggly brackets { } . AnyOf is functionally equivalent to a binary or , where if any of the contained assertions returns $True , AnyOf will return $True . Syntax: AnyOf [-Body] { <assertion> [<assertion>] ... } Body - A script block definition of the containing one or more PSRule keywords and PowerShell expressions. Examples: # Synopsis: The Last or Surname field must exist Rule 'personCheck' { AnyOf { Exists 'Last' Exists 'Surname' } } Output: If any of the assertions return $True AnyOf will return $True , otherwise $False . TypeOf # The TypeOf assertion is used within a Rule definition to evaluate if the pipeline object matches one or more of the supplied type names. Syntax: TypeOf [-TypeName] <string[]> [-Reason <string>] [-InputObject <PSObject>] TypeName - One or more type names which will be evaluated against the pipeline object. TypeName is case sensitive. Reason - A custom reason provided if the condition fails. InputObject - Supports objects being piped directly. Examples: # Synopsis: The object must be a hashtable Rule 'objectType' { TypeOf 'System.Collections.Hashtable' } Output: If any the specified type names match the pipeline object then TypeOf will return $True , otherwise $False . Reason # The Reason keyword is used within a Rule definition to provide a message that indicates the reason the rule failed. The reason is included in detailed results. A reason is only included when the rule fails or errors. The outcomes Pass and None do not include reason. Use this keyword when you want to implement custom logic. Built-in keywords including Exists , Match , Within and TypeOf automatically include a reason when they fail. Syntax: Reason [-Text] <string> Text - A message that includes the reason for the failure. Examples: # Synopsis: Provide reason the rule failed Rule 'objectRecommend' { Reason 'A minimum of two (2) instances are required' $TargetObject . count -ge 2 } Output: None. Recommend # The Recommend keyword is used within a Rule definition to provide a recommendation to resolve the issue and pass the rule. This may include manual steps to change that state of the object or the desired state accessed by the rule. The recommendation can only be set once per rule. Each object will use the same recommendation. Syntax: Recommend [-Text] <string> Text - A message that includes the process to resolve the issue and pass the rule. Examples: # Synopsis: Provide recommendation to resolve the issue Rule 'objectRecommend' { Recommend 'Use at least two (2) instances' $TargetObject . count -ge 2 } Output: None. Examples # # Synopsis: App Service Plan has multiple instances Rule 'appServicePlan.MinInstanceCount' -If { $TargetObject . ResourceType -eq 'Microsoft.Web/serverfarms' } { Recommend 'Use at least two (2) instances' $TargetObject . Sku . capacity -ge 2 } Links # [Invoke-PSRule]","title":"Keywords"},{"location":"keywords/PSRule/en-US/about_PSRule_Keywords/#keywords","text":"Describes the language keywords that can be used within PSRule rule definitions.","title":"Keywords"},{"location":"keywords/PSRule/en-US/about_PSRule_Keywords/#description","text":"PSRule lets you define rules using PowerShell blocks. To define a rule use the Rule keyword. Rule - Creates a rule definition. The following are the built-in keywords that can be used within a rule definition: AnyOf - Assert that any of the child expressions must be true. AllOf - Assert that all of the child expressions must be true. Exists - Assert that a field or property must exist. Match - Assert that the field must match any of the regular expressions. Reason - Return a reason for why the rule failed. Recommend - Return a recommendation to resolve the issue and pass the rule. TypeOf - Assert that the object must be of a specific type. Within - Assert that the field must match any of the values. A subset of built-in keywords can be used within script preconditions: Exists - Assert that a field or property must exist. Match - Assert that the field must match any of the regular expressions. TypeOf - Assert that the object must be of a specific type. Within - Assert that the field must match any of the values.","title":"Description"},{"location":"keywords/PSRule/en-US/about_PSRule_Keywords/#rule","text":"A Rule definition describes an individual business rule that will be executed against each input object. Input objects can be passed on the PowerShell pipeline or supplied from file. To define a Rule use the Rule keyword followed by a name and a pair of squiggly brackets { . Within the { } one or more conditions can be used. Conditions determine if the input object either Pass or Fail the rule. Syntax: Rule [-Name] <string> [-Ref <string>] [-Alias <string[]>] [-Tag <hashtable>] [-When <string[]>] [-Type <string[]>] [-If <scriptBlock>] [-DependsOn <string[]>] [-Configure <hashtable>] [-ErrorAction <ActionPreference>] [-Body] { ... } Name - The name of the rule definition. Each rule name must be unique. When packaging rules within a module, rule names must only be unique within the module. Ref - An optional stable and opaque identifier that can be used to reference the rule. Alias - A list of alternative names that can be used to reference the rule. Tag - A hashtable of key/ value metadata that can be used to filter and identify rules and rule results. When - A selector precondition that must evaluate true before the rule is executed. Type - A type precondition that must match the TargetType of the pipeline object before the rule is executed. If - A script precondition that must evaluate to $True before the rule is executed. DependsOn - A list of rules this rule depends on. Rule dependencies must execute successfully before this rule is executed. Configure - A set of default configuration values. These values are only used when the baseline configuration does not contain the key. ErrorAction - The action to take when an error occur. Only a subset of preferences are supported, either Stop or Ignore . When -ErrorAction is not specified the default preference is Stop . When errors are ignored a rule will pass or fail based on the rule condition. Uncaught exceptions will still cause rule return an error outcome. Body - A script block that specifies one or more conditions that are required for the rule to Pass . A condition is any valid PowerShell that return either $True or $False . Optionally, PSRule keywords can be used to help build out conditions quickly. When a rule contains more then one condition, all must return $True for the rule to Pass . If any one condition returns $False the rule has failed. The following restrictions apply: Rule conditions should only return $True or $False . Other objects should be caught with Out-Null or null assigned like $Null = SomeCommand . The Rule keyword can not be nested in a Rule definition. Variables and functions defined within .Rule.ps1 files, but outside the Rule definition block are not accessible unless the Global scope is applied. Functions and variables within the caller's scope (the scope calling Invoke-PSRule , Get-PSRule , Test-PSRuleTarget ) are not accessible. Cmdlets that require user interaction are not supported, i.e. Read-Host . Script preconditions can contain Exists , Match , TypeOf and Within keywords. Examples: # Synopsis: This rule checks for the presence of a name field Rule 'NameMustExist' { Exists 'Name' } # Synopsis: This rule checks that the title field is valid, when the rule NameMustExist is successful Rule 'TitleIsValid' -DependsOn 'NameMustExist' { Within 'Title' 'Mr' , 'Miss' , 'Mrs' , 'Ms' } # Synopsis: This rule uses a threshold stored as $Configuration.minInstanceCount Rule 'HasMinInstances' { $TargetObject . Sku . capacity -ge $Configuration . minInstanceCount } -Configure @{ minInstanceCount = 2 } # Synopsis: This rule still passes because errors are ignored Rule 'WithRuleErrorActionIgnore' -ErrorAction Ignore { Write-Error 'Some error' ; $True ; }","title":"Rule"},{"location":"keywords/PSRule/en-US/about_PSRule_Keywords/#exists","text":"The Exists assertion is used within a Rule definition to assert that a field or property must exist on the pipeline object. Syntax: Exists [-Field] <string[]> [-CaseSensitive] [-Not] [-All] [-Reason <string>] [-InputObject <PSObject>] Field - One or more fields/ properties that must exist on the pipeline object. CaseSensitive - The field name must match exact case. Not - Instead of checking if the field names exists they should not exist. All - All fields must exist on the pipeline object, instead of only one. Reason - A custom reason provided if the condition fails. InputObject - Supports objects being piped directly. Examples: # Synopsis: Checks for the presence of a name property Rule 'nameMustExist' { Exists 'Name' } # Synopsis: Checks for the presence of name nested under the metadata property Rule 'nameMustExist' { Exists 'metadata.name' } # Synopsis: Checks for the presence of name nested under the metadata property Rule 'nameMustExist' { $TargetObject . metadata | Exists 'name' } # Synopsis: Checks that the NotName property does not exist Rule 'NotNameMustNotExist' { Exists -Not 'NotName' } # Synopsis: Checks one of Name or AlternativeName properties exist Rule 'EitherMustExist' { Exists 'Name' , 'AlternativeName' } # Synopsis: Checks that both Name and Type properties exist Rule 'AllMustExist' { Exists 'Name' , 'Type' -All } Output: If any the specified fields exists then Exists will return $True , otherwise $False . If -Not is used, then if any of the fields exist then Exists will return $False otherwise $True . If -All is used, then then all of the fields must exist, or not with the -Not switch. If all fields exist then Exists will return $True , otherwise $False . If -Not is used with -All , if all of the fields exist Exists will return $False otherwise $True .","title":"Exists"},{"location":"keywords/PSRule/en-US/about_PSRule_Keywords/#match","text":"The Match assertion is used within a Rule definition to assert that the value of a field or property from pipeline data must match one or more regular expressions. To optionally perform a case sensitive match use the -CaseSensitive switch, otherwise a case insensitive match will be used. Syntax: Match [-Field] <string> [-Expression] <string[]> [-CaseSensitive] [-Not] [-Reason <string>] [-InputObject <PSObject>] Field - The name of the field that will be evaluated on the pipeline object. Expression - One or more regular expressions that will be used to match the value of the field. CaseSensitive - The field value must match exact case. Not - Instead of checking the field value matches, the field value must not match any of the expressions. Reason - A custom reason provided if the condition fails. InputObject - Supports objects being piped directly. Examples: # Synopsis: Check that PhoneNumber is complete and formatted correctly Rule 'validatePhoneNumber' { Match 'PhoneNumber' '^(\\+61|0)([0-9] {0,1}){8}[0-9]$' } Output: If any of the specified regular expressions match the field value then Match returns $True , otherwise $False . When -Not is used, if any of the regular expressions match the field value with Match return $False , otherwise $True .","title":"Match"},{"location":"keywords/PSRule/en-US/about_PSRule_Keywords/#within","text":"The Within assertion is used within a Rule definition to assert that the value of a field or property from pipeline data must equal an item from a supplied list of allowed values. To optionally perform a case sensitive match use the -CaseSensitive switch, otherwise a case insensitive match will be used. Syntax: Within [-Field] <string> [-Not] [-Like] [-Value] <PSObject[]> [-CaseSensitive] [-Reason <string>] [-InputObject <PSObject>] Field - The name of the field that will be evaluated on the pipeline object. Value - A list of values that the field value must match. CaseSensitive - The field value must match exact case. Only applies when the field value and allowed values are strings. Not - Instead of checking the field value matches, the field value must not match any of the supplied values. Like - Instead of using an exact match, a wildcard match is used. This switch can only be used when Value a string type. Reason - A custom reason provided if the condition fails. InputObject - Supports objects being piped directly. Examples: # Synopsis: Ensure that the title field has one of the allowed values Rule 'validateTitle' { Within 'Title' 'Mr' , 'Miss' , 'Mrs' , 'Ms' } # Synopsis: Ensure that the title field is not one of the specified values Rule 'validateTitle' { Within 'Title' -Not 'Mr' , 'Sir' } # Synopsis: Ensure that the title field has one of the allowed values Rule 'validateTitle' { Within 'Title' -Like 'Mr' , 'M*s' } Output: If any of the values match the field value then Within returns $True , otherwise $False . When -Not is used, if any of the values match the field value with Within return $False , otherwise $True . When -Like is used, the field value is matched against one or more wildcard expressions.","title":"Within"},{"location":"keywords/PSRule/en-US/about_PSRule_Keywords/#allof","text":"The AllOf assertion is used within a Rule definition to aggregate the result of assertions within a pair of squiggly brackets { } . AllOf is functionally equivalent to a binary and , where when all of the contained assertions return $True , AllOf will return $True . Syntax: AllOf [-Body] { <assertion> [<assertion>] ... } Body - A script block definition of the containing one or more PSRule keywords and PowerShell expressions. Examples: # Synopsis: The Name field must exist and have a value of either John or Jane Rule 'nameCheck' { AllOf { Exists 'Name' Within 'Name' 'John' , 'Jane' } } Output: If all of the assertions return $True AllOf will return $True , otherwise $False .","title":"AllOf"},{"location":"keywords/PSRule/en-US/about_PSRule_Keywords/#anyof","text":"The AnyOf assertion is used within a Rule definition to aggregate the result of assertions within a pair of squiggly brackets { } . AnyOf is functionally equivalent to a binary or , where if any of the contained assertions returns $True , AnyOf will return $True . Syntax: AnyOf [-Body] { <assertion> [<assertion>] ... } Body - A script block definition of the containing one or more PSRule keywords and PowerShell expressions. Examples: # Synopsis: The Last or Surname field must exist Rule 'personCheck' { AnyOf { Exists 'Last' Exists 'Surname' } } Output: If any of the assertions return $True AnyOf will return $True , otherwise $False .","title":"AnyOf"},{"location":"keywords/PSRule/en-US/about_PSRule_Keywords/#typeof","text":"The TypeOf assertion is used within a Rule definition to evaluate if the pipeline object matches one or more of the supplied type names. Syntax: TypeOf [-TypeName] <string[]> [-Reason <string>] [-InputObject <PSObject>] TypeName - One or more type names which will be evaluated against the pipeline object. TypeName is case sensitive. Reason - A custom reason provided if the condition fails. InputObject - Supports objects being piped directly. Examples: # Synopsis: The object must be a hashtable Rule 'objectType' { TypeOf 'System.Collections.Hashtable' } Output: If any the specified type names match the pipeline object then TypeOf will return $True , otherwise $False .","title":"TypeOf"},{"location":"keywords/PSRule/en-US/about_PSRule_Keywords/#reason","text":"The Reason keyword is used within a Rule definition to provide a message that indicates the reason the rule failed. The reason is included in detailed results. A reason is only included when the rule fails or errors. The outcomes Pass and None do not include reason. Use this keyword when you want to implement custom logic. Built-in keywords including Exists , Match , Within and TypeOf automatically include a reason when they fail. Syntax: Reason [-Text] <string> Text - A message that includes the reason for the failure. Examples: # Synopsis: Provide reason the rule failed Rule 'objectRecommend' { Reason 'A minimum of two (2) instances are required' $TargetObject . count -ge 2 } Output: None.","title":"Reason"},{"location":"keywords/PSRule/en-US/about_PSRule_Keywords/#recommend","text":"The Recommend keyword is used within a Rule definition to provide a recommendation to resolve the issue and pass the rule. This may include manual steps to change that state of the object or the desired state accessed by the rule. The recommendation can only be set once per rule. Each object will use the same recommendation. Syntax: Recommend [-Text] <string> Text - A message that includes the process to resolve the issue and pass the rule. Examples: # Synopsis: Provide recommendation to resolve the issue Rule 'objectRecommend' { Recommend 'Use at least two (2) instances' $TargetObject . count -ge 2 } Output: None.","title":"Recommend"},{"location":"keywords/PSRule/en-US/about_PSRule_Keywords/#examples","text":"# Synopsis: App Service Plan has multiple instances Rule 'appServicePlan.MinInstanceCount' -If { $TargetObject . ResourceType -eq 'Microsoft.Web/serverfarms' } { Recommend 'Use at least two (2) instances' $TargetObject . Sku . capacity -ge 2 }","title":"Examples"},{"location":"keywords/PSRule/en-US/about_PSRule_Keywords/#links","text":"[Invoke-PSRule]","title":"Links"},{"location":"quickstart/standalone-rule/","text":"Create a standalone rule # You can use PSRule to create tests for PowerShell objects piped to PSRule for validation. Each test is called a rule . PSRule allows you to write rules using YAML, JSON, or PowerShell. Regardless of the format you choose, any combination of YAML, JSON, or PowerShell rules can be used together. Abstract This topic covers how to create a rule using YAML, JSON, and PowerShell by example. In this quickstart, will be using native PowerShell objects. For an example of reading objects from disk, continue reading Testing infrastructure . Prerequisites # For this quickstart, PSRule must be installed locally on MacOS, Linux, or Windows. To install PSRule locally, open PowerShell and run the following Install-Module command. If you don't have PowerShell installed, complete Installing PowerShell first. PowerShell Install-Module -Name 'PSRule' -Repository PSGallery -Scope CurrentUser Tip PowerShell is installed by default on Windows. If these instructions don't work for you, your administrator may have restricted how PowerShell can be used in your environment. You or your administrator may be able to install PSRule for all users as a local administrator. See Getting the modules for instructions on how to do this. Tip To make you editing experience even better, consider installing the Visual Studio Code extension. Scenario - Test for image files # In our quickstart scenario, we have been tasked with creating a rule to test for image files. When a file ending with the .jpg or .png extension is found the rule should fail. We will be using the following PowerShell code to get a list of files. PowerShell $pathToSearch = $Env:HOME ; $files = Get-ChildItem -Path $pathToSearch -File -Recurse ; Info The path to search $Env:HOME defaults to the current user's home directory. This directory is used so this quickstart works on Windows and Linux operating systems. Feel free to update this path to a more suitable directory on your local machine. Define the file type rule # Before an object can be tested with PSRule, one or more rules must be defined. Each rule is defined in a file named with the suffix .Rule.yaml , .Rule.jsonc , or .Rule.ps1 . Multiple rules can be defined in a single file. A rule that fail on files with .jpg or .png extensions is shown in YAML, JSON, and PowerShell formats. You only need to choose one format, however you can choose to create all three to try out each format. YAML JSON PowerShell Create the FileType.Rule.yaml file with the following contents. This file can be created in Visual Studio Code or any text editor. Make a note of the location you save FileType.Rule.yaml . YAML --- # Synopsis: Image files are not permitted. apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : Yaml.FileType spec : type : - System.IO.FileInfo condition : field : Extension notIn : - .jpg - .png Use a short Synopsis: to describe your rule in a line comment above your rule. This will be shown in output as the default recommendation. For this to be interpreted by PSRule, only a single line is allowed. Name your rule with a unique name Yaml.FileType . The type property ensures the rule will only run for file info objects. Other objects that might be piped to PSRule will be skipped by the Yaml.FileType rule. The condition property determines the checks PSRule will use to test each file returned with Get-ChildItem . Specifically, the Extension property of each FileInfo object will be compared. The value of Extension should not be either .jpg or .png . Create the FileType.Rule.jsonc file with the following contents. This file can be created in Visual Studio Code or any text editor. Make a note of the location you save FileType.Rule.jsonc . JSON [ { // Synopsis: Image files are not permitted. \"apiVersion\" : \"github.com/microsoft/PSRule/v1\" , \"kind\" : \"Rule\" , \"metadata\" : { \"name\" : \"Json.FileType\" }, \"spec\" : { \"type\" : [ \"System.IO.FileInfo\" ], \"condition\" : { \"field\" : \"Extension\" , \"notIn\" : [ \".jpg\" , \".png\" ] } } } ] Use a short Synopsis: to describe your rule in a line comment above your rule. This will be shown in output as the default recommendation. For this to be interpreted by PSRule, only a single line is allowed. Name your rule with a unique name Json.FileType . The type property ensures the rule will only run for file info objects. Other objects that might be piped to PSRule will be skipped by the Json.FileType rule. The condition property determines the checks PSRule will use to test each file returned with Get-ChildItem . Specifically, the Extension property of each FileInfo object will be compared. The value of Extension should not be either .jpg or .png . Create the FileType.Rule.ps1 file with the following contents. This file can be created in Visual Studio Code, Windows PowerShell ISE, or any text editor. Make a note of the location you save FileType.Rule.ps1 . PowerShell # Synopsis: Image files are not permitted. Rule 'PS.FileType' -Type 'System.IO.FileInfo' { $Assert . NotIn ( $TargetObject , 'Extension' , @( '.jpg' , '.png' )) } Use a short Synopsis: to describe your rule in a line comment above your rule. This will be shown in output as the default recommendation. For this to be interpreted by PSRule, only a single line is allowed. Name your rule with a unique name PS.FileType . The -Type parameter ensures the rule will only run for file info objects. Other objects that might be piped to PSRule will be skipped by the PS.FileType rule. The condition contained within the curly braces { } determines the checks PSRule will use to test each file returned with Get-ChildItem . The $Assert.NotIn method checks the Extension property is not set to .jpg or .png . Testing file extensions # You can test the rule by using the Invoke-PSRule command. For example: PowerShell $pathToSearch = $Env:HOME ; $files = Get-ChildItem -Path $pathToSearch -File -Recurse ; # The path to the rule file. Update this to the location of your saved file. $rulePath = 'C:\\temp\\FileType.Rule.ps1' # Or the directory can be used to find all rules in the path: # $rulePath = 'C:\\temp\\' # Test the rule $files | Invoke-PSRule -Path $rulePath After running Invoke-PSRule you will get output which includes all files in the pathToSeach . Files with a .jpg or .png extension should have the outcome of Fail . All other files should report an outcome of Pass . For example: Output TargetName: main.html RuleName Outcome Recommendation -------- ------- -------------- Yaml.FileType Pass Image files are not permitted. TargetName: favicon.png RuleName Outcome Recommendation -------- ------- -------------- Yaml.FileType Fail Image files are not permitted. Tip If you didn't get any results with Fail try creating or saving a .jpg file in pathToSeach . If you have too many Pass results you can filter the output to only fails by using -Outcome Fail . For example: $files | Invoke-PSRule -Path $rulePath -Outcome Fail Scenario - Test for service status # v2.0.0 In our quickstart scenario, we have been tasked to: Find any services that are set to start automatically with StartType beginning with Automatic . Fail for any service with a Status other than Running . We will be using the following PowerShell code to get a list of local services. PowerShell $services = Get-Service Note This scenario is designed for Windows clients. The PowerShell cmdlet Get-Service is only available on Windows. Define a selector # A selector can be used to filter a list of all services to only services that are set to start automatically. Selectors use YAML or JSON expressions and are similar to rules in many ways. A selector determines if the rule will be run or skipped. If the selector is true then the rule will be run and either pass or fail. If the selector is false then the rule will be skipped. YAML JSON Create the Service.Rule.yaml file with the following contents. This file can be created in Visual Studio Code or any text editor. Make a note of the location you save Service.Rule.yaml . YAML --- # Synopsis: Find services with an automatic start type. apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : Yaml.IsAutomaticService spec : if : field : StartType startsWith : Automatic convert : true Use a short Synopsis: to describe your selector in a line comment above your rule. Name your selector with a unique name Yaml.IsAutomaticService . The if property determines if PSRule will evaluate the service rule. Specifically, the StartType property of each service object will be compared. The value of StartType must start with Automatic . The convert property automatically converts the enum type of StartType to a string. Create the Service.Rule.jsonc file with the following contents. This file can be created in Visual Studio Code or any text editor. Make a note of the location you save Service.Rule.jsonc . JSON [ { // Synopsis: Find services with an automatic start type. \"apiVersion\" : \"github.com/microsoft/PSRule/v1\" , \"kind\" : \"Selector\" , \"metadata\" : { \"name\" : \"Json.IsAutomaticService\" }, \"spec\" : { \"if\" : { \"field\" : \"StartType\" , \"startsWith\" : \"Automatic\" , \"convert\" : true } } } ] Use a short Synopsis: to describe your selector in a line comment above your rule. Name your selector with a unique name Json.IsAutomaticService . The if property determines if PSRule will evaluate the service rule. Specifically, the StartType property of each service object will be compared. The value of StartType must start with Automatic . The convert property automatically converts the enum type of StartType to a string. Define the service rule # Similar to the selector, the Status field will be tested to determine if the service is Running . YAML JSON PowerShell Append the following contents to the existing Service.Rule.yaml file. YAML --- # Synopsis: Automatic services should be running. apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : Yaml.ServiceStarted spec : with : - Yaml.IsAutomaticService condition : field : Status equals : Running convert : true Use a short Synopsis: to describe your rule in a line comment above your rule. This will be shown in output as the default recommendation. For this to be interpreted by PSRule, only a single line is allowed. Name your rule with a unique name Yaml.ServiceStarted . The with property indicates to only run this rule on selected service objects. The Yaml.IsAutomaticService selector must first return true otherwise this rule will be skipped. The condition property determines the checks PSRule will use to test each service. Specifically, the Status property will be compared. The value of Status must be Running . The convert property automatically converts the enum type of Status to a string. Update the contents of Service.Rule.jsonc to the following. JSON [ { // Synopsis: Find services with an automatic start type. \"apiVersion\" : \"github.com/microsoft/PSRule/v1\" , \"kind\" : \"Selector\" , \"metadata\" : { \"name\" : \"Json.IsAutomaticService\" }, \"spec\" : { \"if\" : { \"field\" : \"StartType\" , \"startsWith\" : \"Automatic\" , \"convert\" : true } } }, { // Synopsis: Automatic services should be running. \"apiVersion\" : \"github.com/microsoft/PSRule/v1\" , \"kind\" : \"Rule\" , \"metadata\" : { \"name\" : \"Json.ServiceStarted\" }, \"spec\" : { \"with\" : [ \"Json.IsAutomaticService\" ], \"condition\" : { \"field\" : \"Status\" , \"equals\" : \"Running\" , \"convert\" : true } } } ] Use a short Synopsis: to describe your rule in a line comment above your rule. This will be shown in output as the default recommendation. For this to be interpreted by PSRule, only a single line is allowed. Name your rule with a unique name Json.ServiceStarted . The with property indicates to only run this rule on selected service objects. The Json.IsAutomaticService selector must first return true otherwise this rule will be skipped. The condition property determines the checks PSRule will use to test each service. Specifically, the Status property will be compared. The value of Status must be Running . The convert property automatically converts the enum type of Status to a string. Create the Service.Rule.ps1 file with the following contents. This file can be created in Visual Studio Code, Windows PowerShell ISE, or any text editor. Make a note of the location you save Service.Rule.ps1 . PowerShell # Synopsis: Automatic services should be running. Rule 'PS.ServiceStarted' -With 'Yaml.IsAutomaticService' { $status = $TargetObject . Status . ToString () $Assert . HasFieldValue ( $status , '.' , 'Running' ) } Use a short Synopsis: to describe your rule in a line comment above your rule. This will be shown in output as the default recommendation. For this to be interpreted by PSRule, only a single line is allowed. Name your rule with a unique name PS.ServiceStarted . The -With parameter indicates to only run this rule on selected service objects. The Yaml.IsAutomaticService selector must first return true otherwise this rule will be skipped. The condition contained within the curly braces { } determines the checks PSRule will use to test each service object. The Status enum property is converted to a string. The $Assert.HasFieldValue method checks the converted Status property is set to Running . Testing service objects # You can test the rule with service object by using the Invoke-PSRule command. For example: PowerShell $services = Get-Service # The directory path to the rule file. Update this to the location of your saved file. $rulePath = 'C:\\temp\\' # Test the rule $services | Invoke-PSRule -Path $rulePath After running Invoke-PSRule you will get output which include for services that start automatically. Services that are Running should pass whereas other stopped services should fail. For manual or disabled services a warning will be generated indicating that no matching rules were found. For example: Output TargetName: edgeupdate RuleName Outcome Recommendation -------- ------- -------------- PS.ServiceStarted Fail Automatic services should be running. Yaml.ServiceStarted Fail Automatic services should be running. Json.ServiceStarted Fail Automatic services should be running. TargetName: EventLog RuleName Outcome Recommendation -------- ------- -------------- PS.ServiceStarted Pass Automatic services should be running. Yaml.ServiceStarted Pass Automatic services should be running. Json.ServiceStarted Pass Automatic services should be running. WARNING: Target object 'TermService' has not been processed because no matching rules were found. Tip You can disable the warning by setting Execution.NotProcessedWarning option. Alternatively you can ignore all warnings by using the -WarningAction SilentlyContinue parameter.","title":"Create a standalone rule"},{"location":"quickstart/standalone-rule/#create-a-standalone-rule","text":"You can use PSRule to create tests for PowerShell objects piped to PSRule for validation. Each test is called a rule . PSRule allows you to write rules using YAML, JSON, or PowerShell. Regardless of the format you choose, any combination of YAML, JSON, or PowerShell rules can be used together. Abstract This topic covers how to create a rule using YAML, JSON, and PowerShell by example. In this quickstart, will be using native PowerShell objects. For an example of reading objects from disk, continue reading Testing infrastructure .","title":"Create a standalone rule"},{"location":"quickstart/standalone-rule/#prerequisites","text":"For this quickstart, PSRule must be installed locally on MacOS, Linux, or Windows. To install PSRule locally, open PowerShell and run the following Install-Module command. If you don't have PowerShell installed, complete Installing PowerShell first. PowerShell Install-Module -Name 'PSRule' -Repository PSGallery -Scope CurrentUser Tip PowerShell is installed by default on Windows. If these instructions don't work for you, your administrator may have restricted how PowerShell can be used in your environment. You or your administrator may be able to install PSRule for all users as a local administrator. See Getting the modules for instructions on how to do this. Tip To make you editing experience even better, consider installing the Visual Studio Code extension.","title":"Prerequisites"},{"location":"quickstart/standalone-rule/#scenario-test-for-image-files","text":"In our quickstart scenario, we have been tasked with creating a rule to test for image files. When a file ending with the .jpg or .png extension is found the rule should fail. We will be using the following PowerShell code to get a list of files. PowerShell $pathToSearch = $Env:HOME ; $files = Get-ChildItem -Path $pathToSearch -File -Recurse ; Info The path to search $Env:HOME defaults to the current user's home directory. This directory is used so this quickstart works on Windows and Linux operating systems. Feel free to update this path to a more suitable directory on your local machine.","title":"Scenario - Test for image files"},{"location":"quickstart/standalone-rule/#define-the-file-type-rule","text":"Before an object can be tested with PSRule, one or more rules must be defined. Each rule is defined in a file named with the suffix .Rule.yaml , .Rule.jsonc , or .Rule.ps1 . Multiple rules can be defined in a single file. A rule that fail on files with .jpg or .png extensions is shown in YAML, JSON, and PowerShell formats. You only need to choose one format, however you can choose to create all three to try out each format. YAML JSON PowerShell Create the FileType.Rule.yaml file with the following contents. This file can be created in Visual Studio Code or any text editor. Make a note of the location you save FileType.Rule.yaml . YAML --- # Synopsis: Image files are not permitted. apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : Yaml.FileType spec : type : - System.IO.FileInfo condition : field : Extension notIn : - .jpg - .png Use a short Synopsis: to describe your rule in a line comment above your rule. This will be shown in output as the default recommendation. For this to be interpreted by PSRule, only a single line is allowed. Name your rule with a unique name Yaml.FileType . The type property ensures the rule will only run for file info objects. Other objects that might be piped to PSRule will be skipped by the Yaml.FileType rule. The condition property determines the checks PSRule will use to test each file returned with Get-ChildItem . Specifically, the Extension property of each FileInfo object will be compared. The value of Extension should not be either .jpg or .png . Create the FileType.Rule.jsonc file with the following contents. This file can be created in Visual Studio Code or any text editor. Make a note of the location you save FileType.Rule.jsonc . JSON [ { // Synopsis: Image files are not permitted. \"apiVersion\" : \"github.com/microsoft/PSRule/v1\" , \"kind\" : \"Rule\" , \"metadata\" : { \"name\" : \"Json.FileType\" }, \"spec\" : { \"type\" : [ \"System.IO.FileInfo\" ], \"condition\" : { \"field\" : \"Extension\" , \"notIn\" : [ \".jpg\" , \".png\" ] } } } ] Use a short Synopsis: to describe your rule in a line comment above your rule. This will be shown in output as the default recommendation. For this to be interpreted by PSRule, only a single line is allowed. Name your rule with a unique name Json.FileType . The type property ensures the rule will only run for file info objects. Other objects that might be piped to PSRule will be skipped by the Json.FileType rule. The condition property determines the checks PSRule will use to test each file returned with Get-ChildItem . Specifically, the Extension property of each FileInfo object will be compared. The value of Extension should not be either .jpg or .png . Create the FileType.Rule.ps1 file with the following contents. This file can be created in Visual Studio Code, Windows PowerShell ISE, or any text editor. Make a note of the location you save FileType.Rule.ps1 . PowerShell # Synopsis: Image files are not permitted. Rule 'PS.FileType' -Type 'System.IO.FileInfo' { $Assert . NotIn ( $TargetObject , 'Extension' , @( '.jpg' , '.png' )) } Use a short Synopsis: to describe your rule in a line comment above your rule. This will be shown in output as the default recommendation. For this to be interpreted by PSRule, only a single line is allowed. Name your rule with a unique name PS.FileType . The -Type parameter ensures the rule will only run for file info objects. Other objects that might be piped to PSRule will be skipped by the PS.FileType rule. The condition contained within the curly braces { } determines the checks PSRule will use to test each file returned with Get-ChildItem . The $Assert.NotIn method checks the Extension property is not set to .jpg or .png .","title":"Define the file type rule"},{"location":"quickstart/standalone-rule/#testing-file-extensions","text":"You can test the rule by using the Invoke-PSRule command. For example: PowerShell $pathToSearch = $Env:HOME ; $files = Get-ChildItem -Path $pathToSearch -File -Recurse ; # The path to the rule file. Update this to the location of your saved file. $rulePath = 'C:\\temp\\FileType.Rule.ps1' # Or the directory can be used to find all rules in the path: # $rulePath = 'C:\\temp\\' # Test the rule $files | Invoke-PSRule -Path $rulePath After running Invoke-PSRule you will get output which includes all files in the pathToSeach . Files with a .jpg or .png extension should have the outcome of Fail . All other files should report an outcome of Pass . For example: Output TargetName: main.html RuleName Outcome Recommendation -------- ------- -------------- Yaml.FileType Pass Image files are not permitted. TargetName: favicon.png RuleName Outcome Recommendation -------- ------- -------------- Yaml.FileType Fail Image files are not permitted. Tip If you didn't get any results with Fail try creating or saving a .jpg file in pathToSeach . If you have too many Pass results you can filter the output to only fails by using -Outcome Fail . For example: $files | Invoke-PSRule -Path $rulePath -Outcome Fail","title":"Testing file extensions"},{"location":"quickstart/standalone-rule/#scenario-test-for-service-status","text":"v2.0.0 In our quickstart scenario, we have been tasked to: Find any services that are set to start automatically with StartType beginning with Automatic . Fail for any service with a Status other than Running . We will be using the following PowerShell code to get a list of local services. PowerShell $services = Get-Service Note This scenario is designed for Windows clients. The PowerShell cmdlet Get-Service is only available on Windows.","title":"Scenario - Test for service status"},{"location":"quickstart/standalone-rule/#define-a-selector","text":"A selector can be used to filter a list of all services to only services that are set to start automatically. Selectors use YAML or JSON expressions and are similar to rules in many ways. A selector determines if the rule will be run or skipped. If the selector is true then the rule will be run and either pass or fail. If the selector is false then the rule will be skipped. YAML JSON Create the Service.Rule.yaml file with the following contents. This file can be created in Visual Studio Code or any text editor. Make a note of the location you save Service.Rule.yaml . YAML --- # Synopsis: Find services with an automatic start type. apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : Yaml.IsAutomaticService spec : if : field : StartType startsWith : Automatic convert : true Use a short Synopsis: to describe your selector in a line comment above your rule. Name your selector with a unique name Yaml.IsAutomaticService . The if property determines if PSRule will evaluate the service rule. Specifically, the StartType property of each service object will be compared. The value of StartType must start with Automatic . The convert property automatically converts the enum type of StartType to a string. Create the Service.Rule.jsonc file with the following contents. This file can be created in Visual Studio Code or any text editor. Make a note of the location you save Service.Rule.jsonc . JSON [ { // Synopsis: Find services with an automatic start type. \"apiVersion\" : \"github.com/microsoft/PSRule/v1\" , \"kind\" : \"Selector\" , \"metadata\" : { \"name\" : \"Json.IsAutomaticService\" }, \"spec\" : { \"if\" : { \"field\" : \"StartType\" , \"startsWith\" : \"Automatic\" , \"convert\" : true } } } ] Use a short Synopsis: to describe your selector in a line comment above your rule. Name your selector with a unique name Json.IsAutomaticService . The if property determines if PSRule will evaluate the service rule. Specifically, the StartType property of each service object will be compared. The value of StartType must start with Automatic . The convert property automatically converts the enum type of StartType to a string.","title":"Define a selector"},{"location":"quickstart/standalone-rule/#define-the-service-rule","text":"Similar to the selector, the Status field will be tested to determine if the service is Running . YAML JSON PowerShell Append the following contents to the existing Service.Rule.yaml file. YAML --- # Synopsis: Automatic services should be running. apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : Yaml.ServiceStarted spec : with : - Yaml.IsAutomaticService condition : field : Status equals : Running convert : true Use a short Synopsis: to describe your rule in a line comment above your rule. This will be shown in output as the default recommendation. For this to be interpreted by PSRule, only a single line is allowed. Name your rule with a unique name Yaml.ServiceStarted . The with property indicates to only run this rule on selected service objects. The Yaml.IsAutomaticService selector must first return true otherwise this rule will be skipped. The condition property determines the checks PSRule will use to test each service. Specifically, the Status property will be compared. The value of Status must be Running . The convert property automatically converts the enum type of Status to a string. Update the contents of Service.Rule.jsonc to the following. JSON [ { // Synopsis: Find services with an automatic start type. \"apiVersion\" : \"github.com/microsoft/PSRule/v1\" , \"kind\" : \"Selector\" , \"metadata\" : { \"name\" : \"Json.IsAutomaticService\" }, \"spec\" : { \"if\" : { \"field\" : \"StartType\" , \"startsWith\" : \"Automatic\" , \"convert\" : true } } }, { // Synopsis: Automatic services should be running. \"apiVersion\" : \"github.com/microsoft/PSRule/v1\" , \"kind\" : \"Rule\" , \"metadata\" : { \"name\" : \"Json.ServiceStarted\" }, \"spec\" : { \"with\" : [ \"Json.IsAutomaticService\" ], \"condition\" : { \"field\" : \"Status\" , \"equals\" : \"Running\" , \"convert\" : true } } } ] Use a short Synopsis: to describe your rule in a line comment above your rule. This will be shown in output as the default recommendation. For this to be interpreted by PSRule, only a single line is allowed. Name your rule with a unique name Json.ServiceStarted . The with property indicates to only run this rule on selected service objects. The Json.IsAutomaticService selector must first return true otherwise this rule will be skipped. The condition property determines the checks PSRule will use to test each service. Specifically, the Status property will be compared. The value of Status must be Running . The convert property automatically converts the enum type of Status to a string. Create the Service.Rule.ps1 file with the following contents. This file can be created in Visual Studio Code, Windows PowerShell ISE, or any text editor. Make a note of the location you save Service.Rule.ps1 . PowerShell # Synopsis: Automatic services should be running. Rule 'PS.ServiceStarted' -With 'Yaml.IsAutomaticService' { $status = $TargetObject . Status . ToString () $Assert . HasFieldValue ( $status , '.' , 'Running' ) } Use a short Synopsis: to describe your rule in a line comment above your rule. This will be shown in output as the default recommendation. For this to be interpreted by PSRule, only a single line is allowed. Name your rule with a unique name PS.ServiceStarted . The -With parameter indicates to only run this rule on selected service objects. The Yaml.IsAutomaticService selector must first return true otherwise this rule will be skipped. The condition contained within the curly braces { } determines the checks PSRule will use to test each service object. The Status enum property is converted to a string. The $Assert.HasFieldValue method checks the converted Status property is set to Running .","title":"Define the service rule"},{"location":"quickstart/standalone-rule/#testing-service-objects","text":"You can test the rule with service object by using the Invoke-PSRule command. For example: PowerShell $services = Get-Service # The directory path to the rule file. Update this to the location of your saved file. $rulePath = 'C:\\temp\\' # Test the rule $services | Invoke-PSRule -Path $rulePath After running Invoke-PSRule you will get output which include for services that start automatically. Services that are Running should pass whereas other stopped services should fail. For manual or disabled services a warning will be generated indicating that no matching rules were found. For example: Output TargetName: edgeupdate RuleName Outcome Recommendation -------- ------- -------------- PS.ServiceStarted Fail Automatic services should be running. Yaml.ServiceStarted Fail Automatic services should be running. Json.ServiceStarted Fail Automatic services should be running. TargetName: EventLog RuleName Outcome Recommendation -------- ------- -------------- PS.ServiceStarted Pass Automatic services should be running. Yaml.ServiceStarted Pass Automatic services should be running. Json.ServiceStarted Pass Automatic services should be running. WARNING: Target object 'TermService' has not been processed because no matching rules were found. Tip You can disable the warning by setting Execution.NotProcessedWarning option. Alternatively you can ignore all warnings by using the -WarningAction SilentlyContinue parameter.","title":"Testing service objects"},{"location":"scenarios/","text":"Getting started with PSRule # Define a rule # To define a rule, use a Rule block saved to a file with the .Rule.ps1 extension. Rule 'NameOfRule' { # Rule conditions } Within the body of the rule provide one or more conditions. A condition is valid PowerShell that results in $True or $False . For example: Rule 'isFruit' { # Condition to determine if the object is fruit $TargetObject . Name -in 'Apple' , 'Orange' , 'Pear' } An optional result message can be added to by using the Recommend keyword. Rule 'isFruit' { # An recommendation to display in output Recommend 'Fruit is only Apple, Orange and Pear' # Condition to determine if the object is fruit $TargetObject . Name -in 'Apple' , 'Orange' , 'Pear' } The rule is saved to a file named isFruit.Rule.ps1 file. One or more rules can be defined within a single file. Execute a rule # To execute the rule use Invoke-PSRule . For example: # Define objects to validate $items = @(); $items += [PSCustomObject] @{ Name = 'Fridge' }; $items += [PSCustomObject] @{ Name = 'Apple' }; # Validate each item using rules saved in current working path $items | Invoke-PSRule ; The output of this example is: TargetName: Fridge RuleName Outcome Recommendation -------- ------- -------------- isFruit Fail Fruit is only Apple, Orange and Pear TargetName: Apple RuleName Outcome Recommendation -------- ------- -------------- isFruit Pass Fruit is only Apple, Orange and Pear Additional options # To filter results to only non-fruit results, use Invoke-PSRule -Outcome Fail . Passed, failed and error results are shown by default. # Only show non-fruit results $items | Invoke-PSRule -Outcome Fail ; For a summary of results for each rule use Invoke-PSRule -As Summary . For example: # Show rule summary $items | Invoke-PSRule -As Summary ; The output of this example is: RuleName Pass Fail Outcome -------- ---- ---- ------- isFruit 1 1 Fail An optional failure reason can be added to the rule block by using the Reason keyword. Rule 'isFruit' { # An recommendation to display in output Recommend 'Fruit is only Apple, Orange and Pear' # An failure reason to display for non-fruit Reason \" $( $PSRule . TargetName ) is not fruit.\" # Condition to determine if the object is fruit $TargetObject . Name -in 'Apple' , 'Orange' , 'Pear' } To include the reason with output use Invoke-PSRule -OutputFormat Wide . For example: # Show failure reason for failing results $items | Invoke-PSRule -OutputFormat Wide ; The output of this example is: TargetName: Fridge RuleName Outcome Reason Recommendation -------- ------- ------ -------------- isFruit Fail Fridge is not fruit. Fruit is only Apple, Orange and Pear TargetName: Apple RuleName Outcome Reason Recommendation -------- ------- ------ -------------- isFruit Pass Fruit is only Apple, Orange and Pear The final rule is saved to isFruit.Rule.ps1 . Scenarios # For walk through examples of PSRule usage see: Validate Azure resource configuration Validate Azure resources tags Validate Kubernetes resources Using within continuous integration Packaging rules in a module Writing rule help","title":"Getting started with PSRule"},{"location":"scenarios/#getting-started-with-psrule","text":"","title":"Getting started with PSRule"},{"location":"scenarios/#define-a-rule","text":"To define a rule, use a Rule block saved to a file with the .Rule.ps1 extension. Rule 'NameOfRule' { # Rule conditions } Within the body of the rule provide one or more conditions. A condition is valid PowerShell that results in $True or $False . For example: Rule 'isFruit' { # Condition to determine if the object is fruit $TargetObject . Name -in 'Apple' , 'Orange' , 'Pear' } An optional result message can be added to by using the Recommend keyword. Rule 'isFruit' { # An recommendation to display in output Recommend 'Fruit is only Apple, Orange and Pear' # Condition to determine if the object is fruit $TargetObject . Name -in 'Apple' , 'Orange' , 'Pear' } The rule is saved to a file named isFruit.Rule.ps1 file. One or more rules can be defined within a single file.","title":"Define a rule"},{"location":"scenarios/#execute-a-rule","text":"To execute the rule use Invoke-PSRule . For example: # Define objects to validate $items = @(); $items += [PSCustomObject] @{ Name = 'Fridge' }; $items += [PSCustomObject] @{ Name = 'Apple' }; # Validate each item using rules saved in current working path $items | Invoke-PSRule ; The output of this example is: TargetName: Fridge RuleName Outcome Recommendation -------- ------- -------------- isFruit Fail Fruit is only Apple, Orange and Pear TargetName: Apple RuleName Outcome Recommendation -------- ------- -------------- isFruit Pass Fruit is only Apple, Orange and Pear","title":"Execute a rule"},{"location":"scenarios/#additional-options","text":"To filter results to only non-fruit results, use Invoke-PSRule -Outcome Fail . Passed, failed and error results are shown by default. # Only show non-fruit results $items | Invoke-PSRule -Outcome Fail ; For a summary of results for each rule use Invoke-PSRule -As Summary . For example: # Show rule summary $items | Invoke-PSRule -As Summary ; The output of this example is: RuleName Pass Fail Outcome -------- ---- ---- ------- isFruit 1 1 Fail An optional failure reason can be added to the rule block by using the Reason keyword. Rule 'isFruit' { # An recommendation to display in output Recommend 'Fruit is only Apple, Orange and Pear' # An failure reason to display for non-fruit Reason \" $( $PSRule . TargetName ) is not fruit.\" # Condition to determine if the object is fruit $TargetObject . Name -in 'Apple' , 'Orange' , 'Pear' } To include the reason with output use Invoke-PSRule -OutputFormat Wide . For example: # Show failure reason for failing results $items | Invoke-PSRule -OutputFormat Wide ; The output of this example is: TargetName: Fridge RuleName Outcome Reason Recommendation -------- ------- ------ -------------- isFruit Fail Fridge is not fruit. Fruit is only Apple, Orange and Pear TargetName: Apple RuleName Outcome Reason Recommendation -------- ------- ------ -------------- isFruit Pass Fruit is only Apple, Orange and Pear The final rule is saved to isFruit.Rule.ps1 .","title":"Additional options"},{"location":"scenarios/#scenarios","text":"For walk through examples of PSRule usage see: Validate Azure resource configuration Validate Azure resources tags Validate Kubernetes resources Using within continuous integration Packaging rules in a module Writing rule help","title":"Scenarios"},{"location":"scenarios/azure-resources/azure-resources/","text":"Validate Azure resource configuration # PSRule makes it easy to validate Infrastructure as Code (IaC) such as Azure resources. For example, Azure resources can be validated to match an internal standard or baseline. Note A pre-built module to validate Azure resources already exists. This scenario demonstrates the process and features of PSRule for illustration purposes. Consider using or contributing these pre-built rule modules instead: PSRule.Rules.Azure PSRule.Rules.CAF This scenario covers the following: Defining a basic rule. Adding a recommendation. Using script pre-conditions. Using helper functions. In this scenario we will use a JSON file: resources.json - An export for the Azure resource properties saved for offline use. To generate a similar resources.json file of your own, the use following command. # Get all resources using the Az modules. Alternatively use Get-AzureRmResource if using AzureRm modules. # This command also requires authentication with Connect-AzAccount or Connect-AzureRmAccount Get-AzResource -ExpandProperties | ConvertTo-Json -Depth 10 | Set-Content -path .\\ resources . json ; For this example we ran this command: Get-AzResource -ExpandProperties | ConvertTo-Json -Depth 10 | Set-Content -path docs / scenarios / azure-resources / resources . json ; Define rules # To validate our Azure resources we need to define some rules. Rules are defined by using the Rule keyword in a file ending with the .Rule.ps1 extension. So start we are going to define a storageAccounts.UseHttps rule, which will validate that Azure Storage resources have a Secure Transfer Required enabled. In the example below: We use storageAccounts.UseHttps directly after the Rule keyword to name the rule definition. Each rule must be named uniquely. The # Synopsis: comment is used to add additional metadata interpreted by PSRule. One or more conditions are defined within the curly braces { } . The rule definition is saved within a file named storageAccounts.Rule.ps1 . # Synopsis: Configure storage accounts to only accept encrypted traffic i.e. HTTPS/SMB Rule 'storageAccounts.UseHttps' { # Rule conditions go here } Set rule condition # Conditions can be any valid PowerShell expression that results in a $True or $False , just like an If statement, but without specifically requiring the If keyword to be used. Several PSRule keywords such as Exists and AllOf can supplement PowerShell to quickly build out rules that are easy to read. In resources.json one of our example storage accounts has a property Properties.supportsHttpsTrafficOnly as shown below, which will be how our rule will pass $True or fail $False Azure resources that we throw at it. { \"Name\" : \"storage\" , \"ResourceName\" : \"storage\" , \"ResourceType\" : \"Microsoft.Storage/storageAccounts\" , \"Kind\" : \"Storage\" , \"ResourceGroupName\" : \"test-rg\" , \"Location\" : \"eastus2\" , \"Properties\" : { \"supportsHttpsTrafficOnly\" : false } } In the example below: We use the $TargetObject variable to get the object on the pipeline and access it's properties. The condition will return $True or $False back to the pipeline, where: $True - the object passed the validation check $False - the object failed the validation check # Synopsis: Configure storage accounts to only accept encrypted traffic i.e. HTTPS/SMB Rule 'storageAccounts.UseHttps' { # This property returns true or false, so nothing more needs to be done $TargetObject . Properties . supportsHttpsTrafficOnly # Alternatively this could be written as: # $TargetObject.Properties.supportsHttpsTrafficOnly -eq $True } Add rule recommendation # Additionally to provide feedback to the person or process running the rules, we can use the Recommend keyword to set a message that appears in results. If a recommend message is not provided the synopsis will be used instead. In the example below: Directly after the Recommend keyword is a message to help understand why the rule failed or passed. # Synopsis: Configure storage accounts to only accept encrypted traffic i.e. HTTPS/SMB Rule 'storageAccounts.UseHttps' { Recommend 'Storage accounts should only allow secure traffic' $TargetObject . Properties . supportsHttpsTrafficOnly } Filter with preconditions # So far our rule works for a Storage Account, but there are many type of resources that could be returned by calling Get-AzResource . Most of these resources won't have the Properties.supportsHttpsTrafficOnly property, and if it did, it may use different configuration options instead of just true and false . This is where preconditions help out. Preconditions can be specified by using the -If parameter when defining a rule. When the rule is executed, if the precondition is $True then the rule is processed, otherwise it is skipped. In the example below: A check against $TargetObject.ResourceType ensured that our rule is only processed for Storage Accounts. # Synopsis: Configure storage accounts to only accept encrypted traffic i.e. HTTPS/SMB Rule 'storageAccounts.UseHttps' -If { $TargetObject . ResourceType -eq 'Microsoft.Storage/storageAccounts' } { Recommend 'Storage accounts should only allow secure traffic' $TargetObject . Properties . supportsHttpsTrafficOnly } Skipped rules have the outcome None and are not included in output by default. To include skipped rules use the -Outcome All parameter. Execute rules # With a rule defined, the next step is to execute it. To execute rules, pipe the target object to Invoke-PSRule . For example: # Read resources in from file $resources = Get-Content -Path .\\ resources . json | ConvertFrom-Json ; # Process resources $resources | Invoke-PSRule ; PSRule natively supports reading from YAML and JSON files so this command-line can be simplified to: Invoke-PSRule -InputPath .\\ resources . json ; You will notice, we didn't specify the rule. By default PSRule will look for any .Rule.ps1 files in the current working path. Invoke-PSRule supports -Path , -Name and -Tag parameters that can be used to specify the path to look for rules in or filter rules if you want to run a subset of the rules. For this example we ran these commands: Invoke-PSRule -Path docs / scenarios / azure-resources -InputPath docs / scenarios / azure-resources / resources . json ; Our output looked like this: TargetName: storage RuleName Outcome Recommendation -------- ------- -------------- storageAccounts.UseHttps Fail Storage accounts should only allow secure traffic In our case storageAccounts.UseHttps returns a Fail outcome because our storage account has supportsHttpsTrafficOnly = false , which is exactly what should happen. Define helper functions # Using helper functions is completely optional and not required in many cases. However, you may prefer to use helper functions when rule conditions or preconditions are complex and hard to understand. To use helper functions use a function block within a file with a .Rule.ps1 extension. Any code within .Rule.ps1 files called by Invoke-PSRule will be executed, however to make it available for use within a rule, a global scope modifier must be used. For functions this is done by prefixing the function name with global: . For example: function global: NameOfFunction { # Function body } In our example, we are going to define a ResourceType function in a file named common.Rule.ps1 . This function will be used by preconditions to check the type of Azure resource. # A custom function to filter by resource type function global: ResourceType { param ( [String] $ResourceType ) process { return $TargetObject . ResourceType -eq $ResourceType ; } } Updating our existing storageAccounts.UseHttps rule, our rule definition becomes: # Synopsis: Configure storage accounts to only accept encrypted traffic i.e. HTTPS/SMB Rule 'storageAccounts.UseHttps' -If { ResourceType 'Microsoft.Storage/storageAccounts' } { Recommend 'Storage accounts should only allow secure traffic' $TargetObject . Properties . supportsHttpsTrafficOnly } More information # storageAccounts.Rule.ps1 - Example rules for validating Azure Storage. appService.Rule.ps1 - Example rules for validating Azure App Service. resources.json - Offline export of Azure resources. common.Rule.ps1 - ResourceType helper function.","title":"Validate Azure resource configuration"},{"location":"scenarios/azure-resources/azure-resources/#validate-azure-resource-configuration","text":"PSRule makes it easy to validate Infrastructure as Code (IaC) such as Azure resources. For example, Azure resources can be validated to match an internal standard or baseline. Note A pre-built module to validate Azure resources already exists. This scenario demonstrates the process and features of PSRule for illustration purposes. Consider using or contributing these pre-built rule modules instead: PSRule.Rules.Azure PSRule.Rules.CAF This scenario covers the following: Defining a basic rule. Adding a recommendation. Using script pre-conditions. Using helper functions. In this scenario we will use a JSON file: resources.json - An export for the Azure resource properties saved for offline use. To generate a similar resources.json file of your own, the use following command. # Get all resources using the Az modules. Alternatively use Get-AzureRmResource if using AzureRm modules. # This command also requires authentication with Connect-AzAccount or Connect-AzureRmAccount Get-AzResource -ExpandProperties | ConvertTo-Json -Depth 10 | Set-Content -path .\\ resources . json ; For this example we ran this command: Get-AzResource -ExpandProperties | ConvertTo-Json -Depth 10 | Set-Content -path docs / scenarios / azure-resources / resources . json ;","title":"Validate Azure resource configuration"},{"location":"scenarios/azure-resources/azure-resources/#define-rules","text":"To validate our Azure resources we need to define some rules. Rules are defined by using the Rule keyword in a file ending with the .Rule.ps1 extension. So start we are going to define a storageAccounts.UseHttps rule, which will validate that Azure Storage resources have a Secure Transfer Required enabled. In the example below: We use storageAccounts.UseHttps directly after the Rule keyword to name the rule definition. Each rule must be named uniquely. The # Synopsis: comment is used to add additional metadata interpreted by PSRule. One or more conditions are defined within the curly braces { } . The rule definition is saved within a file named storageAccounts.Rule.ps1 . # Synopsis: Configure storage accounts to only accept encrypted traffic i.e. HTTPS/SMB Rule 'storageAccounts.UseHttps' { # Rule conditions go here }","title":"Define rules"},{"location":"scenarios/azure-resources/azure-resources/#set-rule-condition","text":"Conditions can be any valid PowerShell expression that results in a $True or $False , just like an If statement, but without specifically requiring the If keyword to be used. Several PSRule keywords such as Exists and AllOf can supplement PowerShell to quickly build out rules that are easy to read. In resources.json one of our example storage accounts has a property Properties.supportsHttpsTrafficOnly as shown below, which will be how our rule will pass $True or fail $False Azure resources that we throw at it. { \"Name\" : \"storage\" , \"ResourceName\" : \"storage\" , \"ResourceType\" : \"Microsoft.Storage/storageAccounts\" , \"Kind\" : \"Storage\" , \"ResourceGroupName\" : \"test-rg\" , \"Location\" : \"eastus2\" , \"Properties\" : { \"supportsHttpsTrafficOnly\" : false } } In the example below: We use the $TargetObject variable to get the object on the pipeline and access it's properties. The condition will return $True or $False back to the pipeline, where: $True - the object passed the validation check $False - the object failed the validation check # Synopsis: Configure storage accounts to only accept encrypted traffic i.e. HTTPS/SMB Rule 'storageAccounts.UseHttps' { # This property returns true or false, so nothing more needs to be done $TargetObject . Properties . supportsHttpsTrafficOnly # Alternatively this could be written as: # $TargetObject.Properties.supportsHttpsTrafficOnly -eq $True }","title":"Set rule condition"},{"location":"scenarios/azure-resources/azure-resources/#add-rule-recommendation","text":"Additionally to provide feedback to the person or process running the rules, we can use the Recommend keyword to set a message that appears in results. If a recommend message is not provided the synopsis will be used instead. In the example below: Directly after the Recommend keyword is a message to help understand why the rule failed or passed. # Synopsis: Configure storage accounts to only accept encrypted traffic i.e. HTTPS/SMB Rule 'storageAccounts.UseHttps' { Recommend 'Storage accounts should only allow secure traffic' $TargetObject . Properties . supportsHttpsTrafficOnly }","title":"Add rule recommendation"},{"location":"scenarios/azure-resources/azure-resources/#filter-with-preconditions","text":"So far our rule works for a Storage Account, but there are many type of resources that could be returned by calling Get-AzResource . Most of these resources won't have the Properties.supportsHttpsTrafficOnly property, and if it did, it may use different configuration options instead of just true and false . This is where preconditions help out. Preconditions can be specified by using the -If parameter when defining a rule. When the rule is executed, if the precondition is $True then the rule is processed, otherwise it is skipped. In the example below: A check against $TargetObject.ResourceType ensured that our rule is only processed for Storage Accounts. # Synopsis: Configure storage accounts to only accept encrypted traffic i.e. HTTPS/SMB Rule 'storageAccounts.UseHttps' -If { $TargetObject . ResourceType -eq 'Microsoft.Storage/storageAccounts' } { Recommend 'Storage accounts should only allow secure traffic' $TargetObject . Properties . supportsHttpsTrafficOnly } Skipped rules have the outcome None and are not included in output by default. To include skipped rules use the -Outcome All parameter.","title":"Filter with preconditions"},{"location":"scenarios/azure-resources/azure-resources/#execute-rules","text":"With a rule defined, the next step is to execute it. To execute rules, pipe the target object to Invoke-PSRule . For example: # Read resources in from file $resources = Get-Content -Path .\\ resources . json | ConvertFrom-Json ; # Process resources $resources | Invoke-PSRule ; PSRule natively supports reading from YAML and JSON files so this command-line can be simplified to: Invoke-PSRule -InputPath .\\ resources . json ; You will notice, we didn't specify the rule. By default PSRule will look for any .Rule.ps1 files in the current working path. Invoke-PSRule supports -Path , -Name and -Tag parameters that can be used to specify the path to look for rules in or filter rules if you want to run a subset of the rules. For this example we ran these commands: Invoke-PSRule -Path docs / scenarios / azure-resources -InputPath docs / scenarios / azure-resources / resources . json ; Our output looked like this: TargetName: storage RuleName Outcome Recommendation -------- ------- -------------- storageAccounts.UseHttps Fail Storage accounts should only allow secure traffic In our case storageAccounts.UseHttps returns a Fail outcome because our storage account has supportsHttpsTrafficOnly = false , which is exactly what should happen.","title":"Execute rules"},{"location":"scenarios/azure-resources/azure-resources/#define-helper-functions","text":"Using helper functions is completely optional and not required in many cases. However, you may prefer to use helper functions when rule conditions or preconditions are complex and hard to understand. To use helper functions use a function block within a file with a .Rule.ps1 extension. Any code within .Rule.ps1 files called by Invoke-PSRule will be executed, however to make it available for use within a rule, a global scope modifier must be used. For functions this is done by prefixing the function name with global: . For example: function global: NameOfFunction { # Function body } In our example, we are going to define a ResourceType function in a file named common.Rule.ps1 . This function will be used by preconditions to check the type of Azure resource. # A custom function to filter by resource type function global: ResourceType { param ( [String] $ResourceType ) process { return $TargetObject . ResourceType -eq $ResourceType ; } } Updating our existing storageAccounts.UseHttps rule, our rule definition becomes: # Synopsis: Configure storage accounts to only accept encrypted traffic i.e. HTTPS/SMB Rule 'storageAccounts.UseHttps' -If { ResourceType 'Microsoft.Storage/storageAccounts' } { Recommend 'Storage accounts should only allow secure traffic' $TargetObject . Properties . supportsHttpsTrafficOnly }","title":"Define helper functions"},{"location":"scenarios/azure-resources/azure-resources/#more-information","text":"storageAccounts.Rule.ps1 - Example rules for validating Azure Storage. appService.Rule.ps1 - Example rules for validating Azure App Service. resources.json - Offline export of Azure resources. common.Rule.ps1 - ResourceType helper function.","title":"More information"},{"location":"scenarios/azure-tags/azure-tags/","text":"Azure resource tagging example # This is an example of how PSRule can be used to validate tags on Azure resources to match an internal tagging standard. This scenario covers the following: Defining a basic rule. Basic usage of Exists , Within and Match keywords. Using configuration in a rule definition. Setting configuration in YAML. Running rules with configuration. In this scenario we will use a JSON file: resources.json - An export of Azure resource properties saved for offline use. To generate a similar file of your own, the use following command. # Get all resources using the Az modules. Alternatively use Get-AzureRmResource if using AzureRm modules. # This command also requires authentication with Connect-AzAccount or Connect-AzureRmAccount Get-AzResource -ExpandProperties | ConvertTo-Json -Depth 10 | Set-Content -Path .\\ resources . json ; For this example, we ran this command: Get-AzResource -ExpandProperties | ConvertTo-Json -Depth 10 | Set-Content -Path docs / scenarios / azure-resources / resources . json ; Define rules # To validate our Azure resources, we need to define some rules. Rules are defined by using the Rule keyword in a file ending with the .Rule.ps1 extension. Our business rules for Azure resource tagging can be defined with the following dot points: Tag names should be easy to read and understand. Tag names will use lower-camel/ pascal casing. The following mandatory tags will be used: environment: An operational environment for systems and services. Valid environments are production , testing and development . costCentre: A allocation account within financial systems used for charging costs to a business unit. A cost centre is a number with 5 digits and can't start with a 0. businessUnit: The name of the organizational unit or team that owns the application/ solution. To start we are going to define an environmentTag rule, which will ensure that the environment tag exists and that the value only uses allowed values. In the example below: We use environmentTag directly after the Rule keyword to name the rule definition. Each rule must be named uniquely. The # Synopsis: comment is used to add additional metadata interpreted by PSRule. One or more conditions are defined within the curly braces { } . The rule definition is saved within a file named azureTags.Rule.ps1 . # Synopsis: Resource must have environment tag Rule 'environmentTag' { # Rule conditions go here } Check that tag exists # Conditions can be any valid PowerShell expression that results in a $True or $False , just like an If statement, but without specifically requiring the If keyword to be used. In resources.json one of our example storage accounts has the Tags property as shown below, this is how Azure Resource Manager stores tags for a resource. We will use this property as the basis of our rules to determine if the resource is tagged and what the tag value is. { \"Name\" : \"storage\" , \"ResourceName\" : \"storage\" , \"ResourceType\" : \"Microsoft.Storage/storageAccounts\" , \"Tags\" : { \"role\" : \"deployment\" , \"environment\" : \"production\" } } PSRule also defines several additional keywords to supplement PowerShell. These additional keywords help to create readable rules that can be built out quickly. In the example below: We use the Exists keyword to check if the environment tag exists. The -CaseSensitive switch is also used to ensure that the tag name uses lowercase. The condition will return $True or $False back to the pipeline, where: $True - the environment tag exists. $False - the environment tag does not exist. # Synopsis: Resource must have environment tag Rule 'environmentTag' { Exists 'Tags.environment' -CaseSensitive } Tag uses only allowed values # In our scenario, we have three environments that our environment tag could be set to. In the next example we will ensure that only allowed environment values are used. In the example below: We use the Within keyword to check if the environment tag uses any of the allowed values. The -CaseSensitive switch is also used to ensure that the tag value is only a lowercase environment name. The condition will return $True or $False back to the pipeline, where: $True - an allowed environment is used. $False - the environment tag does not use one of the allowed values. # Synopsis: Resource must have environment tag Rule 'environmentTag' { Exists 'Tags.environment' -CaseSensitive Within 'Tags.environment' 'production' , 'test' , 'development' -CaseSensitive } Alternatively, instead of using the Within keyword the -cin operator could be used. Within provides additional verbose logging, however either syntax is valid. In the example below: $TargetObject automatic variable is used to get the pipeline object being evaluated. We use the -cin operator to check the environment tag only uses allowed values. The -cin operator performs a cases sensitive match on production , test and development . The condition will return $True or $False back to the pipeline, where: $True - an allowed environment is used. $False - the environment tag does not use one of the allowed values. # Synopsis: Resource must have environment tag Rule 'environmentTag' { Exists 'Tags.environment' -CaseSensitive $TargetObject . Tags . environment -cin 'production' , 'test' , 'development' } Tag value matches regular expression # For our second rule ( costCentreTag ), the costCentre tag value must be 5 numbers. We can validate this by using a regular expression. In the example below: We use the Match keyword to check if the costCentre tag uses a numeric only value with 5 digits, not starting with 0. The condition will return $True or $False back to the pipeline, where: $True - the costCentre tag value matches the regular expression. $False - the costCentre tag value does not use match the regular expression. # Synopsis: Resource must have costCentre tag Rule 'costCentreTag' { Exists 'Tags.costCentre' -CaseSensitive Match 'Tags.costCentre' '^([1-9][0-9]{4})$' } An alternative way to write the rule would be to use the -match operator instead of the Match keyword. Like the Within keyword, the Match keyword provides additional verbose logging that the -match operator does not provide. In the example below: $TargetObject automatic variable is used to get the pipeline object being evaluated. We use the -match operator to check the costCentre tag value matches the regular expression. The condition will return $True or $False back to the pipeline, where: $True - the costCentre tag value matches the regular expression. $False - the costCentre tag value does not use match the regular expression. # Synopsis: Resource must have costCentre tag Rule 'costCentreTag' { Exists 'Tags.costCentre' -CaseSensitive $TargetObject . Tags . costCentre -match '^([1-9][0-9]{4})$' } Use business unit name from configuration # For our third rule ( businessUnitTag ), the businessUnit must match a valid business unit. A list of business units will be referenced from configuration instead of hard coded in the rule. Configuration can be used within rule definitions by defining configuration in a YAML file then using the automatic variable $Configuration . In the example below: We use the Within keyword to check if the businessUnit tag uses any of the allowed values. allowedBusinessUnits configuration value can be referenced using the syntax $Configuration.allowedBusinessUnits . The rule definition is defined in azureTags.Rule.ps1 . YAML configuration is defined in ps-rule.yaml . An extract from azureTags.Rule.ps1 : # Synopsis: Resource must have businessUnit tag Rule 'businessUnitTag' { Exists 'Tags.businessUnit' -CaseSensitive Within 'Tags.businessUnit' $Configuration . allowedBusinessUnits } An extract from ps-rule.yaml : # Configure business units that are allowed configuration : allowedBusinessUnits : - 'IT Operations' - 'Finance' - 'HR' Execute rules # With a rule defined, the next step is to execute it. To execute rules, pipe the target object to Invoke-PSRule . For example: # Read resources in from file $resources = Get-Content -Path .\\ resources . json | ConvertFrom-Json ; # Evaluate each resource against tagging rules $resources | Invoke-PSRule -Option .\\ ps-rule . yaml ; The ps-rule.yaml will automatically discovered if it exists in the current working path (i.e. .\\ps-rule.yaml ). Alternatively it can be specified with the -Option parameter as show above. PSRule natively supports reading from YAML and JSON files so this command-line can be simplified to: # Evaluate each resource against tagging rules Invoke-PSRule -InputPath .\\ resources . json ; You will notice, we didn't specify the rule. By default PSRule will look for any .Rule.ps1 files in the current working path. Invoke-PSRule supports -Path , -Name and -Tag parameters that can be used to specify the path to look for rules in or filter rules if you want to run a subset of the rules. The -Option parameter allows us to specify a specific YAML configuration file to use. For this example, we ran these commands: # Evaluate each resource against tagging rules Invoke-PSRule -Path docs / scenarios / azure-tags -InputPath docs / scenarios / azure-tags / resources . json -Outcome Fail -Option docs / scenarios / azure-tags / ps-rule . yaml ; Our output looked like this: TargetName: storage RuleName Outcome Recommendation -------- ------- -------------- costCentreTag Fail Resource must have costCentre tag businessUnitTag Fail Resource must have businessUnit tag TargetName: web-app RuleName Outcome Recommendation -------- ------- -------------- environmentTag Fail Resource must have environment tag costCentreTag Fail Resource must have costCentre tag TargetName: web-app/staging RuleName Outcome Recommendation -------- ------- -------------- environmentTag Fail Resource must have environment tag costCentreTag Fail Resource must have costCentre tag Any resources that don't follow the tagging standard are reported with an outcome of Fail . More information # azureTags.Rule.ps1 - Example rules for validating Azure resource tagging standard rules. resources.json - Offline export of Azure resources. ps-rule.yaml - A YAML configuration file for PSRule.","title":"Azure resource tagging example"},{"location":"scenarios/azure-tags/azure-tags/#azure-resource-tagging-example","text":"This is an example of how PSRule can be used to validate tags on Azure resources to match an internal tagging standard. This scenario covers the following: Defining a basic rule. Basic usage of Exists , Within and Match keywords. Using configuration in a rule definition. Setting configuration in YAML. Running rules with configuration. In this scenario we will use a JSON file: resources.json - An export of Azure resource properties saved for offline use. To generate a similar file of your own, the use following command. # Get all resources using the Az modules. Alternatively use Get-AzureRmResource if using AzureRm modules. # This command also requires authentication with Connect-AzAccount or Connect-AzureRmAccount Get-AzResource -ExpandProperties | ConvertTo-Json -Depth 10 | Set-Content -Path .\\ resources . json ; For this example, we ran this command: Get-AzResource -ExpandProperties | ConvertTo-Json -Depth 10 | Set-Content -Path docs / scenarios / azure-resources / resources . json ;","title":"Azure resource tagging example"},{"location":"scenarios/azure-tags/azure-tags/#define-rules","text":"To validate our Azure resources, we need to define some rules. Rules are defined by using the Rule keyword in a file ending with the .Rule.ps1 extension. Our business rules for Azure resource tagging can be defined with the following dot points: Tag names should be easy to read and understand. Tag names will use lower-camel/ pascal casing. The following mandatory tags will be used: environment: An operational environment for systems and services. Valid environments are production , testing and development . costCentre: A allocation account within financial systems used for charging costs to a business unit. A cost centre is a number with 5 digits and can't start with a 0. businessUnit: The name of the organizational unit or team that owns the application/ solution. To start we are going to define an environmentTag rule, which will ensure that the environment tag exists and that the value only uses allowed values. In the example below: We use environmentTag directly after the Rule keyword to name the rule definition. Each rule must be named uniquely. The # Synopsis: comment is used to add additional metadata interpreted by PSRule. One or more conditions are defined within the curly braces { } . The rule definition is saved within a file named azureTags.Rule.ps1 . # Synopsis: Resource must have environment tag Rule 'environmentTag' { # Rule conditions go here }","title":"Define rules"},{"location":"scenarios/azure-tags/azure-tags/#check-that-tag-exists","text":"Conditions can be any valid PowerShell expression that results in a $True or $False , just like an If statement, but without specifically requiring the If keyword to be used. In resources.json one of our example storage accounts has the Tags property as shown below, this is how Azure Resource Manager stores tags for a resource. We will use this property as the basis of our rules to determine if the resource is tagged and what the tag value is. { \"Name\" : \"storage\" , \"ResourceName\" : \"storage\" , \"ResourceType\" : \"Microsoft.Storage/storageAccounts\" , \"Tags\" : { \"role\" : \"deployment\" , \"environment\" : \"production\" } } PSRule also defines several additional keywords to supplement PowerShell. These additional keywords help to create readable rules that can be built out quickly. In the example below: We use the Exists keyword to check if the environment tag exists. The -CaseSensitive switch is also used to ensure that the tag name uses lowercase. The condition will return $True or $False back to the pipeline, where: $True - the environment tag exists. $False - the environment tag does not exist. # Synopsis: Resource must have environment tag Rule 'environmentTag' { Exists 'Tags.environment' -CaseSensitive }","title":"Check that tag exists"},{"location":"scenarios/azure-tags/azure-tags/#tag-uses-only-allowed-values","text":"In our scenario, we have three environments that our environment tag could be set to. In the next example we will ensure that only allowed environment values are used. In the example below: We use the Within keyword to check if the environment tag uses any of the allowed values. The -CaseSensitive switch is also used to ensure that the tag value is only a lowercase environment name. The condition will return $True or $False back to the pipeline, where: $True - an allowed environment is used. $False - the environment tag does not use one of the allowed values. # Synopsis: Resource must have environment tag Rule 'environmentTag' { Exists 'Tags.environment' -CaseSensitive Within 'Tags.environment' 'production' , 'test' , 'development' -CaseSensitive } Alternatively, instead of using the Within keyword the -cin operator could be used. Within provides additional verbose logging, however either syntax is valid. In the example below: $TargetObject automatic variable is used to get the pipeline object being evaluated. We use the -cin operator to check the environment tag only uses allowed values. The -cin operator performs a cases sensitive match on production , test and development . The condition will return $True or $False back to the pipeline, where: $True - an allowed environment is used. $False - the environment tag does not use one of the allowed values. # Synopsis: Resource must have environment tag Rule 'environmentTag' { Exists 'Tags.environment' -CaseSensitive $TargetObject . Tags . environment -cin 'production' , 'test' , 'development' }","title":"Tag uses only allowed values"},{"location":"scenarios/azure-tags/azure-tags/#tag-value-matches-regular-expression","text":"For our second rule ( costCentreTag ), the costCentre tag value must be 5 numbers. We can validate this by using a regular expression. In the example below: We use the Match keyword to check if the costCentre tag uses a numeric only value with 5 digits, not starting with 0. The condition will return $True or $False back to the pipeline, where: $True - the costCentre tag value matches the regular expression. $False - the costCentre tag value does not use match the regular expression. # Synopsis: Resource must have costCentre tag Rule 'costCentreTag' { Exists 'Tags.costCentre' -CaseSensitive Match 'Tags.costCentre' '^([1-9][0-9]{4})$' } An alternative way to write the rule would be to use the -match operator instead of the Match keyword. Like the Within keyword, the Match keyword provides additional verbose logging that the -match operator does not provide. In the example below: $TargetObject automatic variable is used to get the pipeline object being evaluated. We use the -match operator to check the costCentre tag value matches the regular expression. The condition will return $True or $False back to the pipeline, where: $True - the costCentre tag value matches the regular expression. $False - the costCentre tag value does not use match the regular expression. # Synopsis: Resource must have costCentre tag Rule 'costCentreTag' { Exists 'Tags.costCentre' -CaseSensitive $TargetObject . Tags . costCentre -match '^([1-9][0-9]{4})$' }","title":"Tag value matches regular expression"},{"location":"scenarios/azure-tags/azure-tags/#use-business-unit-name-from-configuration","text":"For our third rule ( businessUnitTag ), the businessUnit must match a valid business unit. A list of business units will be referenced from configuration instead of hard coded in the rule. Configuration can be used within rule definitions by defining configuration in a YAML file then using the automatic variable $Configuration . In the example below: We use the Within keyword to check if the businessUnit tag uses any of the allowed values. allowedBusinessUnits configuration value can be referenced using the syntax $Configuration.allowedBusinessUnits . The rule definition is defined in azureTags.Rule.ps1 . YAML configuration is defined in ps-rule.yaml . An extract from azureTags.Rule.ps1 : # Synopsis: Resource must have businessUnit tag Rule 'businessUnitTag' { Exists 'Tags.businessUnit' -CaseSensitive Within 'Tags.businessUnit' $Configuration . allowedBusinessUnits } An extract from ps-rule.yaml : # Configure business units that are allowed configuration : allowedBusinessUnits : - 'IT Operations' - 'Finance' - 'HR'","title":"Use business unit name from configuration"},{"location":"scenarios/azure-tags/azure-tags/#execute-rules","text":"With a rule defined, the next step is to execute it. To execute rules, pipe the target object to Invoke-PSRule . For example: # Read resources in from file $resources = Get-Content -Path .\\ resources . json | ConvertFrom-Json ; # Evaluate each resource against tagging rules $resources | Invoke-PSRule -Option .\\ ps-rule . yaml ; The ps-rule.yaml will automatically discovered if it exists in the current working path (i.e. .\\ps-rule.yaml ). Alternatively it can be specified with the -Option parameter as show above. PSRule natively supports reading from YAML and JSON files so this command-line can be simplified to: # Evaluate each resource against tagging rules Invoke-PSRule -InputPath .\\ resources . json ; You will notice, we didn't specify the rule. By default PSRule will look for any .Rule.ps1 files in the current working path. Invoke-PSRule supports -Path , -Name and -Tag parameters that can be used to specify the path to look for rules in or filter rules if you want to run a subset of the rules. The -Option parameter allows us to specify a specific YAML configuration file to use. For this example, we ran these commands: # Evaluate each resource against tagging rules Invoke-PSRule -Path docs / scenarios / azure-tags -InputPath docs / scenarios / azure-tags / resources . json -Outcome Fail -Option docs / scenarios / azure-tags / ps-rule . yaml ; Our output looked like this: TargetName: storage RuleName Outcome Recommendation -------- ------- -------------- costCentreTag Fail Resource must have costCentre tag businessUnitTag Fail Resource must have businessUnit tag TargetName: web-app RuleName Outcome Recommendation -------- ------- -------------- environmentTag Fail Resource must have environment tag costCentreTag Fail Resource must have costCentre tag TargetName: web-app/staging RuleName Outcome Recommendation -------- ------- -------------- environmentTag Fail Resource must have environment tag costCentreTag Fail Resource must have costCentre tag Any resources that don't follow the tagging standard are reported with an outcome of Fail .","title":"Execute rules"},{"location":"scenarios/azure-tags/azure-tags/#more-information","text":"azureTags.Rule.ps1 - Example rules for validating Azure resource tagging standard rules. resources.json - Offline export of Azure resources. ps-rule.yaml - A YAML configuration file for PSRule.","title":"More information"},{"location":"scenarios/benchmark/results-v0.17.0/","text":"BenchmarkDotNet = v0.12.1, OS=Windows 10.0.18363.778 (1909/November2018Update/19H2) Intel Core i7-6600U CPU 2.60GHz (Skylake), 1 CPU, 4 logical and 2 physical cores .NET Core SDK = 3.1.201 [Host] : .NET Core 2.1.17 (CoreCLR 4.6.28619.01, CoreFX 4.6.28619.01), X64 RyuJIT DefaultJob : .NET Core 2.1.17 (CoreCLR 4.6.28619.01, CoreFX 4.6.28619.01), X64 RyuJIT | Method | Mean | Error | StdDev | Median | Gen 0 | Gen 1 | Gen 2 | Allocated | |------------------------- |-----------:|----------:|----------:|-----------:|-----------:|------:|------:|------------:| | Invoke | 111.140 ms | 2.1935 ms | 4.5786 ms | 109.312 ms | 8200.0000 | - | - | 16839.42 KB | | InvokeIf | 117.141 ms | 2.2703 ms | 2.2298 ms | 116.398 ms | 9600.0000 | - | - | 19980.62 KB | | InvokeType | 108.648 ms | 0.7983 ms | 0.7467 ms | 108.584 ms | 8200.0000 | - | - | 16870.67 KB | | InvokeSummary | 107.300 ms | 0.8612 ms | 0.8056 ms | 107.115 ms | 8000.0000 | - | - | 16784.76 KB | | Get | 9.003 ms | 0.0643 ms | 0.0602 ms | 9.010 ms | 140.6250 | - | - | 307.96 KB | | GetHelp | 8.902 ms | 0.0831 ms | 0.0649 ms | 8.899 ms | 140.6250 | - | - | 306.34 KB | | Within | 179.522 ms | 1.5483 ms | 1.4483 ms | 179.981 ms | 15666.6667 | - | - | 32400.38 KB | | WithinBulk | 247.883 ms | 2.6279 ms | 2.1944 ms | 248.124 ms | 28500.0000 | - | - | 59306.73 KB | | WithinLike | 238.815 ms | 2.5538 ms | 1.9939 ms | 239.245 ms | 29333.3333 | - | - | 60580.58 KB | | DefaultTargetNameBinding | 2.124 ms | 0.0214 ms | 0.0200 ms | 2.129 ms | 85.9375 | - | - | 179.69 KB | | CustomTargetNameBinding | 2.463 ms | 0.0483 ms | 0.0452 ms | 2.458 ms | 179.6875 | - | - | 375 KB | | NestedTargetNameBinding | 2.433 ms | 0.0370 ms | 0.0328 ms | 2.420 ms | 179.6875 | - | - | 375 KB |","title":"Results v0.17.0"},{"location":"scenarios/benchmark/results-v0.19.0/","text":"BenchmarkDotNet = v0.12.1, OS=Windows 10.0.19041.450 (2004/?/20H1) Intel Core i7-1065G7 CPU 1.30GHz, 1 CPU, 8 logical and 4 physical cores .NET Core SDK = 3.1.401 [Host] : .NET Core 3.1.7 (CoreCLR 4.700.20.36602, CoreFX 4.700.20.37001), X64 RyuJIT DefaultJob : .NET Core 3.1.7 (CoreCLR 4.700.20.36602, CoreFX 4.700.20.37001), X64 RyuJIT | Method | Mean | Error | StdDev | Gen 0 | Gen 1 | Gen 2 | Allocated | |------------------------- |-------------:|------------:|------------:|-----------:|---------:|------:|------------:| | Invoke | 40,943.5 \u03bcs | 581.23 \u03bcs | 515.25 \u03bcs | 4000.0000 | 500.0000 | - | 16452.28 KB | | InvokeIf | 42,806.0 \u03bcs | 477.29 \u03bcs | 423.11 \u03bcs | 4500.0000 | 500.0000 | - | 18703.12 KB | | InvokeType | 40,470.1 \u03bcs | 484.16 \u03bcs | 429.19 \u03bcs | 4000.0000 | 538.4615 | - | 16452.27 KB | | InvokeSummary | 39,768.8 \u03bcs | 462.14 \u03bcs | 385.91 \u03bcs | 4000.0000 | 153.8462 | - | 16397.82 KB | | Get | 11,145.4 \u03bcs | 402.59 \u03bcs | 1,187.03 \u03bcs | 46.8750 | - | - | 252.11 KB | | GetHelp | 10,169.1 \u03bcs | 625.02 \u03bcs | 1,842.88 \u03bcs | 46.8750 | - | - | 250.51 KB | | Within | 78,993.5 \u03bcs | 799.51 \u03bcs | 667.63 \u03bcs | 8000.0000 | 400.0000 | - | 32791.83 KB | | WithinBulk | 118,800.8 \u03bcs | 1,637.36 \u03bcs | 1,531.59 \u03bcs | 14333.3333 | 333.3333 | - | 59817.29 KB | | WithinLike | 106,796.3 \u03bcs | 2,067.20 \u03bcs | 2,538.71 \u03bcs | 11333.3333 | - | - | 47311.07 KB | | DefaultTargetNameBinding | 698.2 \u03bcs | 7.51 \u03bcs | 7.02 \u03bcs | 38.0859 | - | - | 156.25 KB | | CustomTargetNameBinding | 884.7 \u03bcs | 7.11 \u03bcs | 6.65 \u03bcs | 85.9375 | - | - | 351.56 KB | | NestedTargetNameBinding | 883.9 \u03bcs | 14.44 \u03bcs | 12.80 \u03bcs | 85.9375 | - | - | 351.56 KB |","title":"Results v0.19.0"},{"location":"scenarios/benchmark/results-v0.20.0/","text":"BenchmarkDotNet = v0.12.1, OS=Windows 10.0.19041.450 (2004/?/20H1) Intel Core i7-1065G7 CPU 1.30GHz, 1 CPU, 8 logical and 4 physical cores .NET Core SDK = 3.1.401 [Host] : .NET Core 3.1.7 (CoreCLR 4.700.20.36602, CoreFX 4.700.20.37001), X64 RyuJIT DefaultJob : .NET Core 3.1.7 (CoreCLR 4.700.20.36602, CoreFX 4.700.20.37001), X64 RyuJIT | Method | Mean | Error | StdDev | Gen 0 | Gen 1 | Gen 2 | Allocated | |------------------------- |-------------:|------------:|------------:|-----------:|----------:|------:|------------:| | Invoke | 42,162.8 \u03bcs | 827.36 \u03bcs | 1,263.47 \u03bcs | 3833.3333 | - | - | 15952 KB | | InvokeIf | 45,646.4 \u03bcs | 912.31 \u03bcs | 1,924.38 \u03bcs | 4416.6667 | 416.6667 | - | 18202.98 KB | | InvokeType | 41,825.5 \u03bcs | 810.73 \u03bcs | 901.12 \u03bcs | 3833.3333 | - | - | 15952 KB | | InvokeSummary | 41,133.3 \u03bcs | 777.97 \u03bcs | 895.91 \u03bcs | 3833.3333 | 500.0000 | - | 15897.56 KB | | Get | 10,054.3 \u03bcs | 396.83 \u03bcs | 1,170.07 \u03bcs | 46.8750 | - | - | 252.11 KB | | GetHelp | 10,581.4 \u03bcs | 448.15 \u03bcs | 1,321.38 \u03bcs | 46.8750 | - | - | 250.51 KB | | Within | 81,215.1 \u03bcs | 1,532.85 \u03bcs | 1,433.83 \u03bcs | 7750.0000 | 250.0000 | - | 32290.62 KB | | WithinBulk | 123,301.6 \u03bcs | 2,451.51 \u03bcs | 3,958.73 \u03bcs | 14000.0000 | 1000.0000 | - | 59317.29 KB | | WithinLike | 109,738.9 \u03bcs | 1,933.95 \u03bcs | 1,809.02 \u03bcs | 11333.3333 | 1000.0000 | - | 46811.07 KB | | DefaultTargetNameBinding | 696.0 \u03bcs | 12.06 \u03bcs | 10.69 \u03bcs | 38.0859 | - | - | 156.25 KB | | CustomTargetNameBinding | 845.6 \u03bcs | 11.75 \u03bcs | 10.42 \u03bcs | 85.9375 | - | - | 351.56 KB | | NestedTargetNameBinding | 856.0 \u03bcs | 12.29 \u03bcs | 10.90 \u03bcs | 85.9375 | - | - | 351.56 KB |","title":"Results v0.20.0"},{"location":"scenarios/benchmark/results-v0.21.0/","text":"BenchmarkDotNet = v0.12.1, OS=Windows 10.0.19042 Intel Core i7-1065G7 CPU 1.30GHz, 1 CPU, 8 logical and 4 physical cores .NET Core SDK = 3.1.403 [Host] : .NET Core 3.1.9 (CoreCLR 4.700.20.47201, CoreFX 4.700.20.47203), X64 RyuJIT DefaultJob : .NET Core 3.1.9 (CoreCLR 4.700.20.47201, CoreFX 4.700.20.47203), X64 RyuJIT | Method | Mean | Error | StdDev | Gen 0 | Gen 1 | Gen 2 | Allocated | |------------------------- |-------------:|------------:|------------:|-----------:|---------:|------:|------------:| | Invoke | 41,409.3 \u03bcs | 743.11 \u03bcs | 1,089.24 \u03bcs | 3916.6667 | 500.0000 | - | 16124.02 KB | | InvokeIf | 43,138.3 \u03bcs | 510.44 \u03bcs | 426.24 \u03bcs | 4416.6667 | 83.3333 | - | 18374.86 KB | | InvokeType | 41,511.3 \u03bcs | 703.93 \u03bcs | 963.55 \u03bcs | 3923.0769 | 230.7692 | - | 16144.62 KB | | InvokeSummary | 40,319.9 \u03bcs | 795.95 \u03bcs | 705.59 \u03bcs | 3900.0000 | 500.0000 | - | 16124.26 KB | | Get | 9,873.7 \u03bcs | 392.08 \u03bcs | 1,149.89 \u03bcs | 46.8750 | - | - | 253.44 KB | | GetHelp | 9,943.1 \u03bcs | 406.36 \u03bcs | 1,198.17 \u03bcs | 46.8750 | - | - | 251.84 KB | | Within | 76,627.6 \u03bcs | 1,527.91 \u03bcs | 1,759.54 \u03bcs | 7800.0000 | - | - | 32460.47 KB | | WithinBulk | 115,374.0 \u03bcs | 2,279.41 \u03bcs | 3,269.07 \u03bcs | 14333.3333 | - | - | 59488.54 KB | | WithinLike | 102,684.3 \u03bcs | 1,482.11 \u03bcs | 1,313.85 \u03bcs | 11500.0000 | 750.0000 | - | 46983.1 KB | | DefaultTargetNameBinding | 673.8 \u03bcs | 4.27 \u03bcs | 3.79 \u03bcs | 38.0859 | - | - | 156.25 KB | | CustomTargetNameBinding | 888.9 \u03bcs | 15.31 \u03bcs | 12.78 \u03bcs | 85.9375 | - | - | 351.56 KB | | NestedTargetNameBinding | 901.3 \u03bcs | 9.04 \u03bcs | 8.01 \u03bcs | 85.9375 | - | - | 351.56 KB |","title":"Results v0.21.0"},{"location":"scenarios/benchmark/results-v0.22.0/","text":"BenchmarkDotNet = v0.12.1, OS=Windows 10.0.19042 Intel Core i7-1065G7 CPU 1.30GHz, 1 CPU, 8 logical and 4 physical cores .NET Core SDK = 3.1.403 [Host] : .NET Core 3.1.9 (CoreCLR 4.700.20.47201, CoreFX 4.700.20.47203), X64 RyuJIT DefaultJob : .NET Core 3.1.9 (CoreCLR 4.700.20.47201, CoreFX 4.700.20.47203), X64 RyuJIT | Method | Mean | Error | StdDev | Gen 0 | Gen 1 | Gen 2 | Allocated | |------------------------- |-------------:|------------:|------------:|-----------:|---------:|------:|------------:| | Invoke | 40,804.1 \u03bcs | 656.89 \u03bcs | 614.45 \u03bcs | 3916.6667 | 500.0000 | - | 16124.02 KB | | InvokeIf | 42,768.8 \u03bcs | 843.79 \u03bcs | 704.61 \u03bcs | 4461.5385 | 76.9231 | - | 18374.92 KB | | InvokeType | 40,487.0 \u03bcs | 609.33 \u03bcs | 1,034.69 \u03bcs | 3923.0769 | 538.4615 | - | 16124.02 KB | | InvokeSummary | 40,403.1 \u03bcs | 806.53 \u03bcs | 714.97 \u03bcs | 3923.0769 | 538.4615 | - | 16124.26 KB | | Assert | 41,551.0 \u03bcs | 684.23 \u03bcs | 640.03 \u03bcs | 4000.0000 | 153.8462 | - | 16538.36 KB | | Get | 10,180.9 \u03bcs | 402.29 \u03bcs | 1,186.17 \u03bcs | 46.8750 | - | - | 231.12 KB | | GetHelp | 9,941.1 \u03bcs | 409.65 \u03bcs | 1,207.87 \u03bcs | 46.8750 | - | - | 229.52 KB | | Within | 75,818.3 \u03bcs | 1,504.74 \u03bcs | 2,297.90 \u03bcs | 7800.0000 | 600.0000 | - | 32468.28 KB | | WithinBulk | 112,731.0 \u03bcs | 1,239.66 \u03bcs | 1,035.17 \u03bcs | 14333.3333 | 666.6667 | - | 59496.35 KB | | WithinLike | 101,227.7 \u03bcs | 1,990.03 \u03bcs | 2,854.05 \u03bcs | 11333.3333 | - | - | 46623.62 KB | | DefaultTargetNameBinding | 654.3 \u03bcs | 10.46 \u03bcs | 9.78 \u03bcs | 38.0859 | - | - | 156.25 KB | | CustomTargetNameBinding | 854.3 \u03bcs | 16.30 \u03bcs | 15.25 \u03bcs | 85.9375 | - | - | 351.56 KB | | NestedTargetNameBinding | 945.7 \u03bcs | 18.78 \u03bcs | 19.29 \u03bcs | 85.9375 | - | - | 351.57 KB | | AssertHasFieldValue | 1,036.2 \u03bcs | 13.63 \u03bcs | 12.08 \u03bcs | 121.0938 | - | - | 500 KB |","title":"Results v0.22.0"},{"location":"scenarios/benchmark/results-v0.3.0/","text":"BenchmarkDotNet = v0.11.3, OS=Windows 10.0.17763.195 (1809/October2018Update/Redstone5) Intel Core i7-6600U CPU 2.60GHz (Skylake), 1 CPU, 4 logical and 2 physical cores .NET Core SDK = 2.2.100 [Host] : .NET Core 2.1.6 (CoreCLR 4.6.27019.06, CoreFX 4.6.27019.05), 64bit RyuJIT DefaultJob : .NET Core 2.1.6 (CoreCLR 4.6.27019.06, CoreFX 4.6.27019.05), 64bit RyuJIT | Method | Mean | Error | StdDev | Gen 0/1k Op | Gen 1/1k Op | Gen 2/1k Op | Allocated Memory/Op | |-------------- |-----------:|----------:|----------:|------------:|------------:|------------:|--------------------:| | Invoke | 117.257 ms | 2.1959 ms | 2.1567 ms | 8400.0000 | 400.0000 | - | 17355.83 KB | | InvokeIf | 128.418 ms | 3.0122 ms | 3.8095 ms | 9750.0000 | 500.0000 | - | 20301.73 KB | | InvokeSummary | 116.479 ms | 1.9241 ms | 1.7998 ms | 8400.0000 | - | - | 17301.03 KB | | Get | 8.921 ms | 0.0864 ms | 0.0766 ms | 93.7500 | - | - | 203.82 KB |","title":"Results v0.3.0"},{"location":"scenarios/benchmark/results-v1.0.1/","text":"BenchmarkDotNet = v0.12.1, OS=Windows 10.0.19042 Intel Core i7-1065G7 CPU 1.30GHz, 1 CPU, 8 logical and 4 physical cores .NET Core SDK = 5.0.102 [Host] : .NET Core 3.1.11 (CoreCLR 4.700.20.56602, CoreFX 4.700.20.56604), X64 RyuJIT DefaultJob : .NET Core 3.1.11 (CoreCLR 4.700.20.56602, CoreFX 4.700.20.56604), X64 RyuJIT | Method | Mean | Error | StdDev | Median | Gen 0 | Gen 1 | Gen 2 | Allocated | |------------------------- |-------------:|------------:|------------:|-------------:|-----------:|---------:|------:|------------:| | Invoke | 39,343.5 \u03bcs | 781.08 \u03bcs | 835.75 \u03bcs | 39,287.2 \u03bcs | 3923.0769 | 538.4615 | - | 16124.02 KB | | InvokeIf | 41,264.0 \u03bcs | 545.97 \u03bcs | 483.99 \u03bcs | 41,148.4 \u03bcs | 4461.5385 | 76.9231 | - | 18374.92 KB | | InvokeType | 39,514.4 \u03bcs | 755.90 \u03bcs | 670.09 \u03bcs | 39,343.8 \u03bcs | 3923.0769 | 538.4615 | - | 16124.02 KB | | InvokeSummary | 39,251.4 \u03bcs | 605.30 \u03bcs | 566.20 \u03bcs | 39,143.5 \u03bcs | 3916.6667 | 500.0000 | - | 16124.26 KB | | Assert | 40,662.2 \u03bcs | 776.24 \u03bcs | 688.12 \u03bcs | 40,589.9 \u03bcs | 4000.0000 | 333.3333 | - | 16538.53 KB | | Get | 8,570.8 \u03bcs | 429.97 \u03bcs | 1,267.78 \u03bcs | 8,872.7 \u03bcs | 46.8750 | - | - | 231.12 KB | | GetHelp | 9,235.4 \u03bcs | 295.56 \u03bcs | 871.45 \u03bcs | 9,238.7 \u03bcs | 46.8750 | - | - | 229.52 KB | | Within | 75,171.4 \u03bcs | 744.98 \u03bcs | 660.41 \u03bcs | 75,223.5 \u03bcs | 7750.0000 | 750.0000 | - | 32468.28 KB | | WithinBulk | 110,726.9 \u03bcs | 2,142.74 \u03bcs | 2,200.44 \u03bcs | 109,801.1 \u03bcs | 14500.0000 | 500.0000 | - | 59496.51 KB | | WithinLike | 101,989.2 \u03bcs | 2,007.91 \u03bcs | 4,056.09 \u03bcs | 100,288.9 \u03bcs | 11250.0000 | - | - | 46623.25 KB | | DefaultTargetNameBinding | 626.0 \u03bcs | 11.49 \u03bcs | 10.75 \u03bcs | 622.9 \u03bcs | 38.0859 | - | - | 156.25 KB | | CustomTargetNameBinding | 796.3 \u03bcs | 7.48 \u03bcs | 7.00 \u03bcs | 797.0 \u03bcs | 85.9375 | - | - | 351.56 KB | | NestedTargetNameBinding | 806.1 \u03bcs | 12.12 \u03bcs | 10.12 \u03bcs | 805.3 \u03bcs | 85.9375 | - | - | 351.56 KB | | AssertHasFieldValue | 900.6 \u03bcs | 14.51 \u03bcs | 12.87 \u03bcs | 901.2 \u03bcs | 122.0703 | - | - | 500 KB |","title":"Results v1.0.1"},{"location":"scenarios/benchmark/results-v1.1.0/","text":"BenchmarkDotNet = v0.12.1, OS=Windows 10.0.19042 Intel Core i7-1065G7 CPU 1.30GHz, 1 CPU, 8 logical and 4 physical cores .NET Core SDK = 5.0.103 [Host] : .NET Core 3.1.12 (CoreCLR 4.700.21.6504, CoreFX 4.700.21.6905), X64 RyuJIT DefaultJob : .NET Core 3.1.12 (CoreCLR 4.700.21.6504, CoreFX 4.700.21.6905), X64 RyuJIT | Method | Mean | Error | StdDev | Gen 0 | Gen 1 | Gen 2 | Allocated | |------------------------- |-------------:|------------:|------------:|-----------:|---------:|------:|------------:| | Invoke | 40,327.3 \u03bcs | 801.24 \u03bcs | 1,013.31 \u03bcs | 3923.0769 | 538.4615 | - | 16124.02 KB | | InvokeIf | 42,943.9 \u03bcs | 849.72 \u03bcs | 1,396.11 \u03bcs | 4461.5385 | 76.9231 | - | 18374.92 KB | | InvokeType | 40,880.7 \u03bcs | 783.51 \u03bcs | 1,452.28 \u03bcs | 3900.0000 | - | - | 16149.45 KB | | InvokeSummary | 39,101.4 \u03bcs | 431.56 \u03bcs | 336.93 \u03bcs | 3916.6667 | 500.0000 | - | 16124.26 KB | | Assert | 41,917.1 \u03bcs | 831.37 \u03bcs | 1,192.33 \u03bcs | 4076.9231 | 461.5385 | - | 16780.81 KB | | Get | 9,643.0 \u03bcs | 428.32 \u03bcs | 1,262.91 \u03bcs | 54.6875 | 7.8125 | - | 231.12 KB | | GetHelp | 9,271.5 \u03bcs | 372.94 \u03bcs | 1,099.63 \u03bcs | 46.8750 | - | - | 229.52 KB | | Within | 76,020.5 \u03bcs | 954.22 \u03bcs | 744.99 \u03bcs | 7800.0000 | 600.0000 | - | 32468.65 KB | | WithinBulk | 112,135.7 \u03bcs | 2,189.72 \u03bcs | 2,342.97 \u03bcs | 14500.0000 | 500.0000 | - | 59499.77 KB | | WithinLike | 101,928.4 \u03bcs | 1,952.97 \u03bcs | 2,398.43 \u03bcs | 11333.3333 | - | - | 46623.57 KB | | DefaultTargetNameBinding | 655.6 \u03bcs | 13.11 \u03bcs | 25.87 \u03bcs | 38.0859 | - | - | 156.25 KB | | CustomTargetNameBinding | 822.1 \u03bcs | 16.06 \u03bcs | 19.11 \u03bcs | 85.9375 | - | - | 351.56 KB | | NestedTargetNameBinding | 878.9 \u03bcs | 16.63 \u03bcs | 17.08 \u03bcs | 85.9375 | - | - | 351.56 KB | | AssertHasFieldValue | 923.2 \u03bcs | 17.81 \u03bcs | 19.05 \u03bcs | 122.0703 | 0.9766 | - | 500.26 KB |","title":"Results v1.1.0"},{"location":"scenarios/benchmark/results-v1.10.0/","text":"BenchmarkDotNet = v0.13.1, OS=Windows 10.0.22000 Intel Core i7-1065G7 CPU 1.30GHz, 1 CPU, 8 logical and 4 physical cores .NET SDK = 5.0.404 [Host] : .NET Core 3.1.22 (CoreCLR 4.700.21.56803, CoreFX 4.700.21.57101), X64 RyuJIT DefaultJob : .NET Core 3.1.22 (CoreCLR 4.700.21.56803, CoreFX 4.700.21.57101), X64 RyuJIT | Method | Mean | Error | StdDev | Gen 0 | Gen 1 | Allocated | |------------------------- |-------------:|------------:|------------:|-----------:|----------:|----------:| | Invoke | 50,742.5 \u03bcs | 908.47 \u03bcs | 709.27 \u03bcs | 4100.0000 | 400.0000 | 17,758 KB | | InvokeIf | 53,048.6 \u03bcs | 698.34 \u03bcs | 619.06 \u03bcs | 4500.0000 | 200.0000 | 20,008 KB | | InvokeType | 50,575.6 \u03bcs | 794.27 \u03bcs | 663.25 \u03bcs | 4000.0000 | 200.0000 | 17,760 KB | | InvokeSummary | 50,449.0 \u03bcs | 698.80 \u03bcs | 619.47 \u03bcs | 4100.0000 | 400.0000 | 17,758 KB | | Assert | 52,152.6 \u03bcs | 765.95 \u03bcs | 678.99 \u03bcs | 4200.0000 | 300.0000 | 18,462 KB | | Get | 5,793.8 \u03bcs | 86.70 \u03bcs | 81.10 \u03bcs | 78.1250 | - | 364 KB | | GetHelp | 5,799.6 \u03bcs | 76.72 \u03bcs | 71.77 \u03bcs | 85.9375 | 7.8125 | 364 KB | | Within | 89,538.2 \u03bcs | 1,754.26 \u03bcs | 1,555.11 \u03bcs | 8000.0000 | 1000.0000 | 34,102 KB | | WithinBulk | 128,126.9 \u03bcs | 1,928.80 \u03bcs | 1,709.83 \u03bcs | 14666.6667 | 1333.3333 | 61,131 KB | | WithinLike | 112,174.1 \u03bcs | 1,132.30 \u03bcs | 1,003.76 \u03bcs | 11666.6667 | 1666.6667 | 48,258 KB | | DefaultTargetNameBinding | 695.6 \u03bcs | 13.57 \u03bcs | 14.52 \u03bcs | 38.0859 | - | 156 KB | | CustomTargetNameBinding | 851.0 \u03bcs | 10.35 \u03bcs | 8.64 \u03bcs | 85.9375 | - | 352 KB | | NestedTargetNameBinding | 961.5 \u03bcs | 17.83 \u03bcs | 15.80 \u03bcs | 85.9375 | - | 352 KB | | AssertHasFieldValue | 3,033.5 \u03bcs | 60.15 \u03bcs | 66.85 \u03bcs | 253.9063 | 7.8125 | 1,040 KB |","title":"Results v1.10.0"},{"location":"scenarios/benchmark/results-v1.11.0/","text":"BenchmarkDotNet = v0.13.1, OS=Windows 10.0.22000 Intel Core i7-1065G7 CPU 1.30GHz, 1 CPU, 8 logical and 4 physical cores .NET SDK = 5.0.404 [Host] : .NET Core 3.1.22 (CoreCLR 4.700.21.56803, CoreFX 4.700.21.57101), X64 RyuJIT DefaultJob : .NET Core 3.1.22 (CoreCLR 4.700.21.56803, CoreFX 4.700.21.57101), X64 RyuJIT | Method | Mean | Error | StdDev | Gen 0 | Gen 1 | Allocated | |------------------------- |-------------:|------------:|------------:|-----------:|----------:|----------:| | Invoke | 50,529.4 \u03bcs | 1,006.40 \u03bcs | 941.38 \u03bcs | 4000.0000 | 444.4444 | 17,758 KB | | InvokeIf | 51,974.4 \u03bcs | 667.26 \u03bcs | 591.51 \u03bcs | 4500.0000 | 200.0000 | 20,008 KB | | InvokeType | 49,901.2 \u03bcs | 679.83 \u03bcs | 567.69 \u03bcs | 4000.0000 | 363.6364 | 17,758 KB | | InvokeSummary | 51,198.9 \u03bcs | 862.22 \u03bcs | 922.57 \u03bcs | 4000.0000 | 363.6364 | 17,758 KB | | Assert | 52,136.6 \u03bcs | 588.93 \u03bcs | 550.88 \u03bcs | 4100.0000 | 300.0000 | 18,461 KB | | Get | 5,710.0 \u03bcs | 111.69 \u03bcs | 104.47 \u03bcs | 85.9375 | 7.8125 | 364 KB | | GetHelp | 5,777.4 \u03bcs | 97.83 \u03bcs | 91.51 \u03bcs | 85.9375 | 7.8125 | 364 KB | | Within | 88,106.3 \u03bcs | 1,752.66 \u03bcs | 1,799.86 \u03bcs | 8000.0000 | 1000.0000 | 34,102 KB | | WithinBulk | 125,319.9 \u03bcs | 2,303.80 \u03bcs | 2,154.98 \u03bcs | 14666.6667 | 1000.0000 | 61,133 KB | | WithinLike | 115,376.3 \u03bcs | 1,866.04 \u03bcs | 1,654.20 \u03bcs | 11666.6667 | 1666.6667 | 48,258 KB | | DefaultTargetNameBinding | 669.5 \u03bcs | 6.52 \u03bcs | 6.10 \u03bcs | 38.0859 | - | 156 KB | | CustomTargetNameBinding | 837.6 \u03bcs | 6.70 \u03bcs | 6.27 \u03bcs | 85.9375 | - | 352 KB | | NestedTargetNameBinding | 854.1 \u03bcs | 9.50 \u03bcs | 7.42 \u03bcs | 85.9375 | - | 352 KB | | AssertHasFieldValue | 2,967.0 \u03bcs | 38.88 \u03bcs | 34.47 \u03bcs | 253.9063 | 7.8125 | 1,040 KB |","title":"Results v1.11.0"},{"location":"scenarios/benchmark/results-v2.0.0/","text":"BenchmarkDotNet = v0.13.1, OS=Windows 10.0.22000 Intel Core i7-1065G7 CPU 1.30GHz, 1 CPU, 8 logical and 4 physical cores .NET SDK = 6.0.400 [Host] : .NET Core 3.1.28 (CoreCLR 4.700.22.36202, CoreFX 4.700.22.36301), X64 RyuJIT DefaultJob : .NET Core 3.1.28 (CoreCLR 4.700.22.36202, CoreFX 4.700.22.36301), X64 RyuJIT | Method | Mean | Error | StdDev | Median | Gen 0 | Gen 1 | Allocated | |------------------------- |-----------------:|----------------:|-----------------:|-----------------:|-----------:|----------:|----------:| | Invoke | 71,586,583.6 ns | 4,077,161.43 ns | 11,957,608.68 ns | 71,526,200.0 ns | 4200.0000 | 600.0000 | 17,703 KB | | InvokeIf | 59,661,136.5 ns | 1,161,506.18 ns | 1,192,781.33 ns | 59,397,680.0 ns | 4400.0000 | 400.0000 | 19,954 KB | | InvokeType | 55,089,186.0 ns | 1,045,769.22 ns | 1,989,684.63 ns | 54,242,620.0 ns | 4300.0000 | 500.0000 | 17,703 KB | | InvokeSummary | 55,371,580.7 ns | 1,271,559.50 ns | 3,586,456.14 ns | 53,815,745.0 ns | 4300.0000 | 500.0000 | 17,704 KB | | Assert | 56,146,053.8 ns | 1,122,221.08 ns | 3,053,085.20 ns | 54,841,105.0 ns | 4500.0000 | 600.0000 | 18,407 KB | | Get | 5,701,341.2 ns | 110,332.76 ns | 158,235.95 ns | 5,665,673.8 ns | 78.1250 | 7.8125 | 365 KB | | GetHelp | 5,750,066.9 ns | 113,595.72 ns | 170,024.73 ns | 5,720,298.0 ns | 85.9375 | 7.8125 | 366 KB | | Within | 99,151,338.5 ns | 2,136,858.10 ns | 6,165,324.21 ns | 97,015,516.7 ns | 8333.3333 | 1333.3333 | 34,142 KB | | WithinBulk | 147,062,385.7 ns | 2,633,709.47 ns | 2,334,714.85 ns | 146,838,450.0 ns | 14000.0000 | 3000.0000 | 61,169 KB | | WithinLike | 120,988,346.7 ns | 2,099,294.17 ns | 1,963,681.06 ns | 120,963,000.0 ns | 11666.6667 | 1666.6667 | 48,297 KB | | DefaultTargetNameBinding | 731,969.9 ns | 13,918.54 ns | 36,422.40 ns | 714,067.8 ns | 38.0859 | - | 156 KB | | CustomTargetNameBinding | 1,052,297.9 ns | 44,284.38 ns | 125,627.41 ns | 1,022,416.2 ns | 85.9375 | - | 352 KB | | NestedTargetNameBinding | 916,580.7 ns | 24,378.48 ns | 71,497.85 ns | 903,449.3 ns | 85.9375 | - | 352 KB | | AssertHasFieldValue | 3,082,706.1 ns | 61,644.86 ns | 68,518.10 ns | 3,058,487.1 ns | 234.3750 | - | 962 KB | | PathTokenize | 846.6 ns | 16.52 ns | 23.69 ns | 842.4 ns | 0.2632 | - | 1 KB | | PathExpressionBuild | 548.3 ns | 10.14 ns | 11.68 ns | 547.1 ns | 0.3500 | - | 1 KB | | PathExpressionGet | 356,089.5 ns | 7,027.54 ns | 11,348.18 ns | 351,085.5 ns | 17.0898 | - | 70 KB |","title":"Results v2.0.0"},{"location":"scenarios/containers/container-execution/","text":"Using PSRule from a Container # Depending on your development or CI/CD process for your environment you may desire to use PSRules to validate your Infrastructure as Code (IaC) from a container. This document shows how you can use a simple container based on the mcr.microsoft.com/powershell image from Microsoft. In this tutorial we are going to use a simple Ubuntu based PowerShell image to validate an ARM template. We will do this by creating a dockerfile to describe and create a container image that we can then run. When we run the container we will use a volume mount to share our ARM template and test code for the container to then execute the PSRule for Azure against our ARM template and output the results. Creating the image # Creating an image ready to run PSRules first requires a dockerfile. The below example will use the latest PowerShell image released and install the PSRule and PSRule.Rules.Azure modules. Dockerfile # Copyright (c) Microsoft Corporation. # Licensed under the MIT License. FROM mcr.microsoft.com/powershell:7.2-ubuntu-22.04 SHELL [ \"pwsh\" , \"-command\" ] RUN Install-Module -Name 'PSRule' , 'PSRule.Rules.Azure' -Force The below docker command can be used to create the image locally. docker build - -tag psrule : latest . Note While fine for an example, it is common to always reference a container by a version number and not the latest tag. Using the latest tag may lead to unexpected behavior as version changes occur. Create your test script # Create a new directory and add a new file named validate-files.ps1 . This file will run the PSRule test for us on our new container image. Add the below code to the file. # Copyright (c) Microsoft Corporation. # Licensed under the MIT License. <# .SYNOPSIS Create a PSRule AzRuleTemplate data file and run the PSRule.Rules.Azure module rules against the output. #> Get-AzRuleTemplateLink \"$PSScriptRoot/template\" | Export-AzRuleTemplateData -OutputPath \"$PSScriptRoot/out\" Assert-PSRule -InputPath \"$PSScriptRoot/out/\" -Module 'PSRule.Rules.Azure' -As Summary Also, within the new directory add another directory named template . Add any ARM template you would like to test in this directory. For a starting point you can get a template from Azure Quickstart Templates. Your directory should now look like the below. - Directory |--> validate-files.ps1 |--> template |--> ARM template... Run PSRules in the container # Now we are ready to go! Run the below docker command to test the ARM template. docker run -it - -rm -v $PWD /:/ src psrule : latest pwsh -file / src / validate-files . ps1 This command runs the container and the PSRule tests by mounting the directory to the /src path and then executing the validate-files.ps1 script. Note The volume mount option expects your current working directory to be the new directory created. You can change this to an absolute or relative path if desired. Clean up # When you are ready to clean up the container image you can do so with the below command. docker image rm psrule","title":"Using PSRule from a Container"},{"location":"scenarios/containers/container-execution/#using-psrule-from-a-container","text":"Depending on your development or CI/CD process for your environment you may desire to use PSRules to validate your Infrastructure as Code (IaC) from a container. This document shows how you can use a simple container based on the mcr.microsoft.com/powershell image from Microsoft. In this tutorial we are going to use a simple Ubuntu based PowerShell image to validate an ARM template. We will do this by creating a dockerfile to describe and create a container image that we can then run. When we run the container we will use a volume mount to share our ARM template and test code for the container to then execute the PSRule for Azure against our ARM template and output the results.","title":"Using PSRule from a Container"},{"location":"scenarios/containers/container-execution/#creating-the-image","text":"Creating an image ready to run PSRules first requires a dockerfile. The below example will use the latest PowerShell image released and install the PSRule and PSRule.Rules.Azure modules. Dockerfile # Copyright (c) Microsoft Corporation. # Licensed under the MIT License. FROM mcr.microsoft.com/powershell:7.2-ubuntu-22.04 SHELL [ \"pwsh\" , \"-command\" ] RUN Install-Module -Name 'PSRule' , 'PSRule.Rules.Azure' -Force The below docker command can be used to create the image locally. docker build - -tag psrule : latest . Note While fine for an example, it is common to always reference a container by a version number and not the latest tag. Using the latest tag may lead to unexpected behavior as version changes occur.","title":"Creating the image"},{"location":"scenarios/containers/container-execution/#create-your-test-script","text":"Create a new directory and add a new file named validate-files.ps1 . This file will run the PSRule test for us on our new container image. Add the below code to the file. # Copyright (c) Microsoft Corporation. # Licensed under the MIT License. <# .SYNOPSIS Create a PSRule AzRuleTemplate data file and run the PSRule.Rules.Azure module rules against the output. #> Get-AzRuleTemplateLink \"$PSScriptRoot/template\" | Export-AzRuleTemplateData -OutputPath \"$PSScriptRoot/out\" Assert-PSRule -InputPath \"$PSScriptRoot/out/\" -Module 'PSRule.Rules.Azure' -As Summary Also, within the new directory add another directory named template . Add any ARM template you would like to test in this directory. For a starting point you can get a template from Azure Quickstart Templates. Your directory should now look like the below. - Directory |--> validate-files.ps1 |--> template |--> ARM template...","title":"Create your test script"},{"location":"scenarios/containers/container-execution/#run-psrules-in-the-container","text":"Now we are ready to go! Run the below docker command to test the ARM template. docker run -it - -rm -v $PWD /:/ src psrule : latest pwsh -file / src / validate-files . ps1 This command runs the container and the PSRule tests by mounting the directory to the /src path and then executing the validate-files.ps1 script. Note The volume mount option expects your current working directory to be the new directory created. You can change this to an absolute or relative path if desired.","title":"Run PSRules in the container"},{"location":"scenarios/containers/container-execution/#clean-up","text":"When you are ready to clean up the container image you can do so with the below command. docker image rm psrule","title":"Clean up"},{"location":"scenarios/kubernetes-resources/kubernetes-resources/","text":"Kubernetes resource validation example # This is an example of how PSRule can be used to validate Kubernetes resources to match an internal metadata and configuration standard. Note A pre-built module to validate Kubernetes resources already exists. This scenario demonstrates the process and features of PSRule for illustration purposes. Consider using or contributing these pre-built rule modules instead: PSRule.Rules.Kubernetes This scenario covers the following: Defining a basic rule. Configuring custom binding. Using a type precondition. Running rules using YAML input. In this scenario we will use a YAML file: resources.yaml - A Kubernetes manifest containing deployments and services. Define rules # To validate our Kubernetes resources, we need to define some rules. Rules are defined by using the Rule keyword in a file ending with the .Rule.ps1 extension. Our business rules for configuration Kubernetes resources can be defined with the following dot points: The following recommended labels will be used on all services and deployments: app.kubernetes.io/name - the name of the application/ service. app.kubernetes.io/version - the version of the service. app.kubernetes.io/component - identifies the type of component, valid options are web , api , database and gateway For web or api deployments, a minimum of two (2) replicas must be used. Deployments must use container images with a specific version tag, and not latest . Deployments must declare minimum and maximum memory/ CPU resources. In the example below: We use metadata.Name directly after the Rule keyword to name the rule definition. Each rule must be named uniquely. The # Synopsis: comment is used to add additional metadata interpreted by PSRule. One or more conditions are defined within the curly braces { } . The rule definition is saved within a file named kubernetes.Rule.ps1 . # Synopsis: Must have the app.kubernetes.io/name label Rule 'metadata.Name' { # Rule conditions go here } Check that the label exists # In the next step, we define one or more conditions. Conditions can be: Any valid PowerShell that returns a true (pass) when the condition is met or false (fail) when the condition is not met. More than one condition can be defined, if any condition returns false then the whole rule fails. PSRule includes several convenience keywords such as AllOf , AnyOf , Exists , Match , TypeOf and Within that make conditions faster to define, easier to understand and troubleshoot. However, use of these keywords is optional. In the example below: We use the Exists keyword to check that the resource has the app.kubernetes.io/name label set. By default, PSRule will step through nested properties separated by a . . i.e. labels is a property of metadata . Kubernetes supports and recommends label namespaces, which often use . in their name. PSRule supports this by enclosing the field name ( app.kubernetes.io/name ) in apostrophes ( ' ) so that app.kubernetes.io/name is checked instead of app . # Synopsis: Must have the app.kubernetes.io/name label Rule 'metadata.Name' { Exists \"metadata.labels.'app.kubernetes.io/name'\" } We have also defined something similar for the version and component labels. In the example below: Double apostrophes ( '' ) are used to enclose app.kubernetes.io/name because the field name uses ' at the start and end of the string instead of \" in the previous example. The Within keyword is used to validate that the app.kubernetes.io/component only uses one of four (4) allowed values. # Synopsis: Must have the app.kubernetes.io/version label Rule 'metadata.Version' { Exists 'metadata.labels.''app.kubernetes.io/version''' } # Synopsis: Must have the app.kubernetes.io/component label Rule 'metadata.Component' { Exists 'metadata.labels.''app.kubernetes.io/component''' Within 'metadata.labels.''app.kubernetes.io/component''' 'web' , 'api' , 'database' , 'gateway' -CaseSensitive } Use custom binding # Before processing rules, PSRule binds TargetName and TargetType properties to the pipeline object. These properties are used for filtering and displaying results. The default properties that PSRule binds are different from how Kubernetes resources are structured. Kubernetes uses: metadata.name to store the name of a resource. kind to store the type of resource. The default bindings can be updated by providing custom property names or a custom script. To change binding property names set the Binding.TargetName and Binding.TargetType configuration options. The following example shows how to set the options using a YAML configuration file: TargetName is bound to metadata.name TargetType is bound to kind binding : targetName : - metadata.name targetType : - kind These options can be set in the file .\\ps-rule.yaml to be automatically loaded at when PSRule cmdlets are called. To set these configuration options either edit the file manually or use the following command. # Set options in ps-rule.yaml Set-PSRuleOption -TargetName 'metadata.Name' -TargetType 'kind' ; Alternatively, these options can be set at runtime using the hashtable syntax. # Save options to a variable $option = New-PSRuleOption -TargetName 'metadata.Name' -TargetType 'kind' ; These options will be passed to Invoke-PSRule using the -Option parameter in a later step. Define preconditions # Currently the metadata.Name rule defined in a previous step will be executed for any type of object. Kubernetes has many types of built-in resource such as Services , Deployments , Namespaces , Pods and ClusterRoles . By defining a precondition, we can ensure that the rule is only processed for Services or Deployments to match our business rules. PSRule supports two types of preconditions, either type ( -Type ) or script block ( -If ). Type preconditions are one or more type names that PSRule compares to the TargetType binding, where: One of the type names names equal TargetType the rule will be processed. None of the type names equal TargetType the rule be skipped. Script block preconditions is a PowerShell script block that returns true or false , where: True - Continue processing the rule. False - Skip processing the rule. Preconditions are evaluated once per rule for each object. In the example below: We update our metadata.Name rule to use the -Type parameter to specify a type precondition of either Deployment or Service . In a previous step, TypeName was bound to the kind property which will be Deployment or Service for these resource types. # Synopsis: Must have the app.kubernetes.io/name label Rule 'metadata.Name' -Type 'Deployment' , 'Service' { Exists \"metadata.labels.'app.kubernetes.io/name'\" } Using a type precondition satisfies our business rules and will deliver faster performance then using a script block. An example using a script block precondition is also shown below. # Synopsis: Must have the app.kubernetes.io/name label Rule 'metadata.Name' -If { $TargetObject . kind -eq 'Deployment' -or $TargetObject . kind -eq 'Service' } { Exists \"metadata.labels.'app.kubernetes.io/name'\" } Complete remaining rules # The remaining rule definitions from our defined business rules are included below. Each follows a similar pattern and builds on the previous sections. In the example below: The built-in variable $TargetObject is used to get the current pipeline object. Built-in keywords like Exists automatically default to $TargetObject , but can be piped alternative input as shown in the rule definition named deployment.ResourcesSet . # Synopsis: Deployments use a minimum of 2 replicas Rule 'deployment.HasMinimumReplicas' -Type 'Deployment' { Exists 'spec.replicas' $TargetObject . spec . replicas -ge 2 } # Synopsis: Deployments use specific tags Rule 'deployment.NotLatestImage' -Type 'Deployment' { foreach ( $container in $TargetObject . spec . template . spec . containers ) { $container . image -like '*:*' -and $container . image -notlike '*:latest' } } # Synopsis: Resource requirements are set for each container Rule 'deployment.ResourcesSet' -Type 'Deployment' { foreach ( $container in $TargetObject . spec . template . spec . containers ) { $container | Exists 'resources.requests.cpu' $container | Exists 'resources.requests.memory' $container | Exists 'resources.limits.cpu' $container | Exists 'resources.limits.memory' } } Execute rules # With some rules defined, the next step is to execute them. For this example, we'll use Invoke-PSRule to get the result for each rule. The Test-PSRuleTarget cmdlet can be used if only a true or false is required. In our example we are using the YAML format to store Kubernetes resources. PSRule has built-in support for YAML so we can import these files directly from disk or process output from a command such as kubectl . In the examples below: The -InputPath parameter is used to load objects from disk as YAML. YAML is automatically detected based on the .yaml file extension. Alternatively the -Foramt Yaml parameter can be used. Binding parameters are read from ps-rule.yaml in the current working path. Alternatively the -Option parameter could be used to specify an alternative file path. kubectl is called with the -o yaml to output resources as YAML. kubectl is piped to Out-String to convert the multi-line output to a single string. The -Format parameter informs PSRule that the string is YAML and it should convert the string into structured objects. The -ObjectPath parameter is used with the output from kubectl . This is required because the output from kubectl is a collection of resources instead of individual resources. Specifically -ObjectPath items gets the resources from the items property of the output. # Validate resources from file Invoke-PSRule -InputPath resources . yaml ; # Validate resources directly from kubectl output kubectl get services -o yaml | Out-String | Invoke-PSRule -Format Yaml -ObjectPath items ; For this example, we limited the output to failed results with the following command: # Validate resources from file Invoke-PSRule -Path docs / scenarios / kubernetes-resources -InputPath docs / scenarios / kubernetes-resources / resources . yaml -Option docs / scenarios / kubernetes-resources / ps-rule . yaml -Outcome Fail ; The resulting output is: TargetName: app1-cache RuleName Outcome Recommendation -------- ------- -------------- deployment.HasMinimumReplicas Fail Deployments use a minimum of 2 replicas deployment.NotLatestImage Fail Deployments use specific tags deployment.ResourcesSet Fail Resource requirements are set for each container TargetName: app1-cache-service RuleName Outcome Recommendation -------- ------- -------------- metadata.Name Fail Must have the app.kubernetes.io/name label metadata.Version Fail Must have the app.kubernetes.io/version label metadata.Component Fail Must have the app.kubernetes.io/component label TargetName: app1-ui RuleName Outcome Recommendation -------- ------- -------------- metadata.Version Fail Must have the app.kubernetes.io/version label More information # kubernetes.Rule.ps1 - Example rules for validating Kubernetes resources. resources.yaml - An example Kubernetes manifest. ps-rule.yaml - PSRule options configuration file.","title":"Kubernetes resource validation example"},{"location":"scenarios/kubernetes-resources/kubernetes-resources/#kubernetes-resource-validation-example","text":"This is an example of how PSRule can be used to validate Kubernetes resources to match an internal metadata and configuration standard. Note A pre-built module to validate Kubernetes resources already exists. This scenario demonstrates the process and features of PSRule for illustration purposes. Consider using or contributing these pre-built rule modules instead: PSRule.Rules.Kubernetes This scenario covers the following: Defining a basic rule. Configuring custom binding. Using a type precondition. Running rules using YAML input. In this scenario we will use a YAML file: resources.yaml - A Kubernetes manifest containing deployments and services.","title":"Kubernetes resource validation example"},{"location":"scenarios/kubernetes-resources/kubernetes-resources/#define-rules","text":"To validate our Kubernetes resources, we need to define some rules. Rules are defined by using the Rule keyword in a file ending with the .Rule.ps1 extension. Our business rules for configuration Kubernetes resources can be defined with the following dot points: The following recommended labels will be used on all services and deployments: app.kubernetes.io/name - the name of the application/ service. app.kubernetes.io/version - the version of the service. app.kubernetes.io/component - identifies the type of component, valid options are web , api , database and gateway For web or api deployments, a minimum of two (2) replicas must be used. Deployments must use container images with a specific version tag, and not latest . Deployments must declare minimum and maximum memory/ CPU resources. In the example below: We use metadata.Name directly after the Rule keyword to name the rule definition. Each rule must be named uniquely. The # Synopsis: comment is used to add additional metadata interpreted by PSRule. One or more conditions are defined within the curly braces { } . The rule definition is saved within a file named kubernetes.Rule.ps1 . # Synopsis: Must have the app.kubernetes.io/name label Rule 'metadata.Name' { # Rule conditions go here }","title":"Define rules"},{"location":"scenarios/kubernetes-resources/kubernetes-resources/#check-that-the-label-exists","text":"In the next step, we define one or more conditions. Conditions can be: Any valid PowerShell that returns a true (pass) when the condition is met or false (fail) when the condition is not met. More than one condition can be defined, if any condition returns false then the whole rule fails. PSRule includes several convenience keywords such as AllOf , AnyOf , Exists , Match , TypeOf and Within that make conditions faster to define, easier to understand and troubleshoot. However, use of these keywords is optional. In the example below: We use the Exists keyword to check that the resource has the app.kubernetes.io/name label set. By default, PSRule will step through nested properties separated by a . . i.e. labels is a property of metadata . Kubernetes supports and recommends label namespaces, which often use . in their name. PSRule supports this by enclosing the field name ( app.kubernetes.io/name ) in apostrophes ( ' ) so that app.kubernetes.io/name is checked instead of app . # Synopsis: Must have the app.kubernetes.io/name label Rule 'metadata.Name' { Exists \"metadata.labels.'app.kubernetes.io/name'\" } We have also defined something similar for the version and component labels. In the example below: Double apostrophes ( '' ) are used to enclose app.kubernetes.io/name because the field name uses ' at the start and end of the string instead of \" in the previous example. The Within keyword is used to validate that the app.kubernetes.io/component only uses one of four (4) allowed values. # Synopsis: Must have the app.kubernetes.io/version label Rule 'metadata.Version' { Exists 'metadata.labels.''app.kubernetes.io/version''' } # Synopsis: Must have the app.kubernetes.io/component label Rule 'metadata.Component' { Exists 'metadata.labels.''app.kubernetes.io/component''' Within 'metadata.labels.''app.kubernetes.io/component''' 'web' , 'api' , 'database' , 'gateway' -CaseSensitive }","title":"Check that the label exists"},{"location":"scenarios/kubernetes-resources/kubernetes-resources/#use-custom-binding","text":"Before processing rules, PSRule binds TargetName and TargetType properties to the pipeline object. These properties are used for filtering and displaying results. The default properties that PSRule binds are different from how Kubernetes resources are structured. Kubernetes uses: metadata.name to store the name of a resource. kind to store the type of resource. The default bindings can be updated by providing custom property names or a custom script. To change binding property names set the Binding.TargetName and Binding.TargetType configuration options. The following example shows how to set the options using a YAML configuration file: TargetName is bound to metadata.name TargetType is bound to kind binding : targetName : - metadata.name targetType : - kind These options can be set in the file .\\ps-rule.yaml to be automatically loaded at when PSRule cmdlets are called. To set these configuration options either edit the file manually or use the following command. # Set options in ps-rule.yaml Set-PSRuleOption -TargetName 'metadata.Name' -TargetType 'kind' ; Alternatively, these options can be set at runtime using the hashtable syntax. # Save options to a variable $option = New-PSRuleOption -TargetName 'metadata.Name' -TargetType 'kind' ; These options will be passed to Invoke-PSRule using the -Option parameter in a later step.","title":"Use custom binding"},{"location":"scenarios/kubernetes-resources/kubernetes-resources/#define-preconditions","text":"Currently the metadata.Name rule defined in a previous step will be executed for any type of object. Kubernetes has many types of built-in resource such as Services , Deployments , Namespaces , Pods and ClusterRoles . By defining a precondition, we can ensure that the rule is only processed for Services or Deployments to match our business rules. PSRule supports two types of preconditions, either type ( -Type ) or script block ( -If ). Type preconditions are one or more type names that PSRule compares to the TargetType binding, where: One of the type names names equal TargetType the rule will be processed. None of the type names equal TargetType the rule be skipped. Script block preconditions is a PowerShell script block that returns true or false , where: True - Continue processing the rule. False - Skip processing the rule. Preconditions are evaluated once per rule for each object. In the example below: We update our metadata.Name rule to use the -Type parameter to specify a type precondition of either Deployment or Service . In a previous step, TypeName was bound to the kind property which will be Deployment or Service for these resource types. # Synopsis: Must have the app.kubernetes.io/name label Rule 'metadata.Name' -Type 'Deployment' , 'Service' { Exists \"metadata.labels.'app.kubernetes.io/name'\" } Using a type precondition satisfies our business rules and will deliver faster performance then using a script block. An example using a script block precondition is also shown below. # Synopsis: Must have the app.kubernetes.io/name label Rule 'metadata.Name' -If { $TargetObject . kind -eq 'Deployment' -or $TargetObject . kind -eq 'Service' } { Exists \"metadata.labels.'app.kubernetes.io/name'\" }","title":"Define preconditions"},{"location":"scenarios/kubernetes-resources/kubernetes-resources/#complete-remaining-rules","text":"The remaining rule definitions from our defined business rules are included below. Each follows a similar pattern and builds on the previous sections. In the example below: The built-in variable $TargetObject is used to get the current pipeline object. Built-in keywords like Exists automatically default to $TargetObject , but can be piped alternative input as shown in the rule definition named deployment.ResourcesSet . # Synopsis: Deployments use a minimum of 2 replicas Rule 'deployment.HasMinimumReplicas' -Type 'Deployment' { Exists 'spec.replicas' $TargetObject . spec . replicas -ge 2 } # Synopsis: Deployments use specific tags Rule 'deployment.NotLatestImage' -Type 'Deployment' { foreach ( $container in $TargetObject . spec . template . spec . containers ) { $container . image -like '*:*' -and $container . image -notlike '*:latest' } } # Synopsis: Resource requirements are set for each container Rule 'deployment.ResourcesSet' -Type 'Deployment' { foreach ( $container in $TargetObject . spec . template . spec . containers ) { $container | Exists 'resources.requests.cpu' $container | Exists 'resources.requests.memory' $container | Exists 'resources.limits.cpu' $container | Exists 'resources.limits.memory' } }","title":"Complete remaining rules"},{"location":"scenarios/kubernetes-resources/kubernetes-resources/#execute-rules","text":"With some rules defined, the next step is to execute them. For this example, we'll use Invoke-PSRule to get the result for each rule. The Test-PSRuleTarget cmdlet can be used if only a true or false is required. In our example we are using the YAML format to store Kubernetes resources. PSRule has built-in support for YAML so we can import these files directly from disk or process output from a command such as kubectl . In the examples below: The -InputPath parameter is used to load objects from disk as YAML. YAML is automatically detected based on the .yaml file extension. Alternatively the -Foramt Yaml parameter can be used. Binding parameters are read from ps-rule.yaml in the current working path. Alternatively the -Option parameter could be used to specify an alternative file path. kubectl is called with the -o yaml to output resources as YAML. kubectl is piped to Out-String to convert the multi-line output to a single string. The -Format parameter informs PSRule that the string is YAML and it should convert the string into structured objects. The -ObjectPath parameter is used with the output from kubectl . This is required because the output from kubectl is a collection of resources instead of individual resources. Specifically -ObjectPath items gets the resources from the items property of the output. # Validate resources from file Invoke-PSRule -InputPath resources . yaml ; # Validate resources directly from kubectl output kubectl get services -o yaml | Out-String | Invoke-PSRule -Format Yaml -ObjectPath items ; For this example, we limited the output to failed results with the following command: # Validate resources from file Invoke-PSRule -Path docs / scenarios / kubernetes-resources -InputPath docs / scenarios / kubernetes-resources / resources . yaml -Option docs / scenarios / kubernetes-resources / ps-rule . yaml -Outcome Fail ; The resulting output is: TargetName: app1-cache RuleName Outcome Recommendation -------- ------- -------------- deployment.HasMinimumReplicas Fail Deployments use a minimum of 2 replicas deployment.NotLatestImage Fail Deployments use specific tags deployment.ResourcesSet Fail Resource requirements are set for each container TargetName: app1-cache-service RuleName Outcome Recommendation -------- ------- -------------- metadata.Name Fail Must have the app.kubernetes.io/name label metadata.Version Fail Must have the app.kubernetes.io/version label metadata.Component Fail Must have the app.kubernetes.io/component label TargetName: app1-ui RuleName Outcome Recommendation -------- ------- -------------- metadata.Version Fail Must have the app.kubernetes.io/version label","title":"Execute rules"},{"location":"scenarios/kubernetes-resources/kubernetes-resources/#more-information","text":"kubernetes.Rule.ps1 - Example rules for validating Kubernetes resources. resources.yaml - An example Kubernetes manifest. ps-rule.yaml - PSRule options configuration file.","title":"More information"},{"location":"scenarios/validation-pipeline/validation-pipeline/","text":"Using within continuous integration # PSRule supports several features that make it easy to a continuous integration (CI) pipeline. When added to a pipeline, PSRule can validate files, template and objects dynamically. This scenario covers the following: Installing within a CI pipeline. Validating objects. Formatting output. Failing the pipeline. Generating NUnit output. Additional options. Installing within a CI pipeline # Typically, PSRule is not pre-installed on CI worker nodes and must be installed. If your CI pipeline runs on a persistent virtual machine that you control, consider pre-installing PSRule. The following examples focus on installing PSRule dynamically during execution of the pipeline. Which is suitable for cloud-based CI worker nodes. To install PSRule within a CI pipeline execute the Install-Module PowerShell cmdlet. In the example below: When installing modules on Windows, modules will be installed into Program Files by default, which requires administrator permissions. Depending on your environment, the CI worker process may not have administrative permissions. Instead we can install PSRule for the current context running the CI pipeline by using the -Scope CurrentUser parameter. By default, this cmdlet will install the module from the PowerShell Gallery which is not trusted by default. Since a CI pipeline is not interactive, use the -Force switch to suppress the confirmation prompt. Install-Module -Name PSRule -Scope CurrentUser -Force ; In some cases, installing NuGet and PowerShellGet may be required to connect to the PowerShell Gallery. The NuGet package provider can be installed using the Install-PackageProvider PowerShell cmdlet. Install-PackageProvider -Name NuGet -Scope CurrentUser -Force ; Install-Module PowerShellGet -MinimumVersion '2.2.1' -Scope CurrentUser -Force -AllowClobber ; The example below includes both steps together with checks: if ( $Null -eq ( Get-PackageProvider -Name NuGet -ErrorAction SilentlyContinue )) { Install-PackageProvider -Name NuGet -Scope CurrentUser -Force ; } if ( $Null -eq ( Get-InstalledModule -Name PowerShellGet -MinimumVersion '2.2.1' -ErrorAction Ignore )) { Install-Module PowerShellGet -MinimumVersion '2.2.1' -Scope CurrentUser -Force -AllowClobber ; } if ( $Null -eq ( Get-InstalledModule -Name PSRule -MinimumVersion '2.1.0' -ErrorAction SilentlyContinue )) { Install-Module -Name PSRule -Scope CurrentUser -MinimumVersion '2.1.0' -Force ; } See the change log for the latest version. Validating objects # To validate objects use Invoke-PSRule , Assert-PSRule or Test-PSRuleTarget . In a CI pipeline, Assert-PSRule is recommended. Assert-PSRule outputs preformatted results ideal for use within a CI pipeline. For rules within the same source control repository, put rules in the .ps-rule directory. A directory .ps-rule in the repository root, is used by convention. In the following example, objects are validated against rules from the ./.ps-rule/ directory: $items | Assert-PSRule -Path './.ps-rule/' Example output: -> ObjectFromFile.psd1 : System.IO.FileInfo [PASS] File.Header [PASS] File.Encoding [WARN] Target object 'ObjectFromFile.yaml' has not been processed because no matching rules were found. [WARN] Target object 'ObjectFromNestedFile.yaml' has not been processed because no matching rules were found. [WARN] Target object 'Baseline.Rule.yaml' has not been processed because no matching rules were found. -> FromFile.Rule.ps1 : System.IO.FileInfo [FAIL] File.Header [PASS] File.Encoding In the next example, objects from file are validated against pre-defined rules from a module: Assert-PSRule -InputPath .\\ resources -*. json -Module PSRule . Rules . Azure ; Formatting output # When executing a CI pipeline, feedback on any validation failures is important. The Assert-PSRule cmdlet provides easy to read formatted output instead of PowerShell objects. Additionally, Assert-PSRule supports styling formatted output for Azure Pipelines and GitHub Actions. Use the -Style AzurePipelines or -Style GitHubActions parameter to style output. For example: $items | Assert-PSRule -Path './.ps-rule/' -Style AzurePipelines ; Failing the pipeline # When using PSRule within a CI pipeline, a failed rule should stop the pipeline. When using Assert-PSRule if any rules fail, an error will be generated. Assert-PSRule : One or more rules reported failure. At line:1 char:10 + $items | Assert-PSRule -Path ./.ps-rule/ + ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ + CategoryInfo : InvalidData: (:) [Assert-PSRule], FailPipelineException + FullyQualifiedErrorId : PSRule.Fail,Assert-PSRule A single PowerShell error is typically enough to stop a CI pipeline. If you are using a different configuration additionally -ErrorAction Stop can be used. For example: $items | Assert-PSRule -Path './.ps-rule/' -ErrorAction Stop ; Using -ErrorAction Stop will stop the current script and return an exit code of 1. To continue running the current script but return an exit code, use: try { $items | Assert-PSRule -Path './.ps-rule/' -ErrorAction Stop ; } catch { $Host . SetShouldExit ( 1 ); } Generating NUnit output # NUnit is a popular unit test framework for .NET. NUnit generates a test report format that is widely interpreted by CI systems. While PSRule does not use NUnit directly, it support outputting validation results in the NUnit3 format. Using a common format allows integration with any system that supports the NUnit3 for publishing test results. To generate an NUnit report: Use the -OutputFormat NUnit3 parameter. Use the -OutputPath parameter to specify the path of the report file to write. $items | Assert-PSRule -Path './.ps-rule/' -OutputFormat NUnit3 -OutputPath reports / rule-report . xml ; The output path will be created if it does not exist. Publishing NUnit report with Azure DevOps # With Azure DevOps, an NUnit report can be published using Publish Test Results task . An example YAML snippet is included below: # PSRule results - task : PublishTestResults@2 displayName : 'Publish PSRule results' inputs : testRunTitle : 'PSRule' testRunner : NUnit testResultsFiles : 'reports/rule-report.xml' mergeTestResults : true publishRunAttachments : true condition : succeededOrFailed() Complete example # Putting each of these steps together. Install dependencies # # Install dependencies for connecting to PowerShell Gallery if ( $Null -eq ( Get-PackageProvider -Name NuGet -ErrorAction SilentlyContinue )) { Install-PackageProvider -Name NuGet -Force -Scope CurrentUser ; } if ( $Null -eq ( Get-InstalledModule -Name PowerShellGet -MinimumVersion '2.2.1' -ErrorAction SilentlyContinue )) { Install-Module PowerShellGet -MinimumVersion '2.2.1' -Scope CurrentUser -Force -AllowClobber ; } Validate files # # Install PSRule module if ( $Null -eq ( Get-InstalledModule -Name PSRule -MinimumVersion '2.1.0' -ErrorAction SilentlyContinue )) { Install-Module -Name PSRule -Scope CurrentUser -MinimumVersion '2.1.0' -Force ; } # Validate files $assertParams = @{ Path = './.ps-rule/' Style = 'AzurePipelines' OutputFormat = 'NUnit3' OutputPath = 'reports/rule-report.xml' } $items = Get-ChildItem -Recurse -Path .\\ src \\,.\\ tests \\ -Include *. ps1 ,*. psd1 ,*. psm1 ,*. yaml ; $items | Assert-PSRule $assertParams -ErrorAction Stop ; Azure DevOps Pipeline # steps : # Install dependencies - powershell : ./pipeline-deps.ps1 displayName : 'Install dependencies' # Validate templates - powershell : ./validate-files.ps1 displayName : 'Validate files' # Publish pipeline results - task : PublishTestResults@2 displayName : 'Publish PSRule results' inputs : testRunTitle : 'PSRule' testRunner : NUnit testResultsFiles : 'reports/rule-report.xml' mergeTestResults : true publishRunAttachments : true condition : succeededOrFailed() Additional options # Using Invoke-Build # Invoke-Build is a build automation cmdlet that can be installed from the PowerShell Gallery by installing the InvokeBuild module. Within Invoke-Build, each build process is broken into tasks. The following example shows an example of using PSRule with Invoke-Build tasks. # Synopsis: Install PSRule task PSRule { if ( $Null -eq ( Get-InstalledModule -Name PSRule -MinimumVersion '2.1.0' -ErrorAction SilentlyContinue )) { Install-Module -Name PSRule -Scope CurrentUser -MinimumVersion '2.1.0' -Force ; } } # Synopsis: Validate files task ValidateFiles PSRule , { $assertParams = @{ Path = './.ps-rule/' Style = 'AzurePipelines' OutputFormat = 'NUnit3' OutputPath = 'reports/rule-report.xml' } $items = Get-ChildItem -Recurse -Path .\\ src \\,.\\ tests \\ -Include *. ps1 ,*. psd1 ,*. psm1 ,*. yaml ; $items | Assert-PSRule @assertParams -ErrorAction Stop ; } # Synopsis: Run all build tasks task Build ValidateFiles Invoke-Build Build ; Calling from Pester # Pester is a unit test framework for PowerShell that can be installed from the PowerShell Gallery. Typically, Pester unit tests are built for a particular pipeline. PSRule can complement Pester unit tests by providing dynamic and sharable rules that are easy to reuse. By using -If or -Type pre-conditions, rules can dynamically provide validation for a range of use cases. When calling PSRule from Pester use Invoke-PSRule instead of Assert-PSRule . Invoke-PSRule returns validation result objects that can be tested by Pester Should conditions. Additionally, the Logging.RuleFail option can be included to generate an error message for each failing rule. For example: Describe 'Azure' { Context 'Resource templates' { It 'Use content rules' { $invokeParams = @{ Path = './.ps-rule/' OutputFormat = 'NUnit3' OutputPath = 'reports/rule-report.xml' } $items = Get-ChildItem -Recurse -Path .\\ src \\,.\\ tests \\ -Include *. ps1 ,*. psd1 ,*. psm1 ,*. yaml ; Invoke-PSRule @invokeParams -Outcome Fail , Error | Should -BeNullOrEmpty ; } } } More information # pipeline-deps.ps1 - Example script installing pipeline dependencies. file.Rule.ps1 - Example rules for validating script files. validate-files.ps1 - Example script for running files validation. azure-pipelines.yaml - An example Azure DevOps Pipeline.","title":"Using within continuous integration"},{"location":"scenarios/validation-pipeline/validation-pipeline/#using-within-continuous-integration","text":"PSRule supports several features that make it easy to a continuous integration (CI) pipeline. When added to a pipeline, PSRule can validate files, template and objects dynamically. This scenario covers the following: Installing within a CI pipeline. Validating objects. Formatting output. Failing the pipeline. Generating NUnit output. Additional options.","title":"Using within continuous integration"},{"location":"scenarios/validation-pipeline/validation-pipeline/#installing-within-a-ci-pipeline","text":"Typically, PSRule is not pre-installed on CI worker nodes and must be installed. If your CI pipeline runs on a persistent virtual machine that you control, consider pre-installing PSRule. The following examples focus on installing PSRule dynamically during execution of the pipeline. Which is suitable for cloud-based CI worker nodes. To install PSRule within a CI pipeline execute the Install-Module PowerShell cmdlet. In the example below: When installing modules on Windows, modules will be installed into Program Files by default, which requires administrator permissions. Depending on your environment, the CI worker process may not have administrative permissions. Instead we can install PSRule for the current context running the CI pipeline by using the -Scope CurrentUser parameter. By default, this cmdlet will install the module from the PowerShell Gallery which is not trusted by default. Since a CI pipeline is not interactive, use the -Force switch to suppress the confirmation prompt. Install-Module -Name PSRule -Scope CurrentUser -Force ; In some cases, installing NuGet and PowerShellGet may be required to connect to the PowerShell Gallery. The NuGet package provider can be installed using the Install-PackageProvider PowerShell cmdlet. Install-PackageProvider -Name NuGet -Scope CurrentUser -Force ; Install-Module PowerShellGet -MinimumVersion '2.2.1' -Scope CurrentUser -Force -AllowClobber ; The example below includes both steps together with checks: if ( $Null -eq ( Get-PackageProvider -Name NuGet -ErrorAction SilentlyContinue )) { Install-PackageProvider -Name NuGet -Scope CurrentUser -Force ; } if ( $Null -eq ( Get-InstalledModule -Name PowerShellGet -MinimumVersion '2.2.1' -ErrorAction Ignore )) { Install-Module PowerShellGet -MinimumVersion '2.2.1' -Scope CurrentUser -Force -AllowClobber ; } if ( $Null -eq ( Get-InstalledModule -Name PSRule -MinimumVersion '2.1.0' -ErrorAction SilentlyContinue )) { Install-Module -Name PSRule -Scope CurrentUser -MinimumVersion '2.1.0' -Force ; } See the change log for the latest version.","title":"Installing within a CI pipeline"},{"location":"scenarios/validation-pipeline/validation-pipeline/#validating-objects","text":"To validate objects use Invoke-PSRule , Assert-PSRule or Test-PSRuleTarget . In a CI pipeline, Assert-PSRule is recommended. Assert-PSRule outputs preformatted results ideal for use within a CI pipeline. For rules within the same source control repository, put rules in the .ps-rule directory. A directory .ps-rule in the repository root, is used by convention. In the following example, objects are validated against rules from the ./.ps-rule/ directory: $items | Assert-PSRule -Path './.ps-rule/' Example output: -> ObjectFromFile.psd1 : System.IO.FileInfo [PASS] File.Header [PASS] File.Encoding [WARN] Target object 'ObjectFromFile.yaml' has not been processed because no matching rules were found. [WARN] Target object 'ObjectFromNestedFile.yaml' has not been processed because no matching rules were found. [WARN] Target object 'Baseline.Rule.yaml' has not been processed because no matching rules were found. -> FromFile.Rule.ps1 : System.IO.FileInfo [FAIL] File.Header [PASS] File.Encoding In the next example, objects from file are validated against pre-defined rules from a module: Assert-PSRule -InputPath .\\ resources -*. json -Module PSRule . Rules . Azure ;","title":"Validating objects"},{"location":"scenarios/validation-pipeline/validation-pipeline/#formatting-output","text":"When executing a CI pipeline, feedback on any validation failures is important. The Assert-PSRule cmdlet provides easy to read formatted output instead of PowerShell objects. Additionally, Assert-PSRule supports styling formatted output for Azure Pipelines and GitHub Actions. Use the -Style AzurePipelines or -Style GitHubActions parameter to style output. For example: $items | Assert-PSRule -Path './.ps-rule/' -Style AzurePipelines ;","title":"Formatting output"},{"location":"scenarios/validation-pipeline/validation-pipeline/#failing-the-pipeline","text":"When using PSRule within a CI pipeline, a failed rule should stop the pipeline. When using Assert-PSRule if any rules fail, an error will be generated. Assert-PSRule : One or more rules reported failure. At line:1 char:10 + $items | Assert-PSRule -Path ./.ps-rule/ + ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ + CategoryInfo : InvalidData: (:) [Assert-PSRule], FailPipelineException + FullyQualifiedErrorId : PSRule.Fail,Assert-PSRule A single PowerShell error is typically enough to stop a CI pipeline. If you are using a different configuration additionally -ErrorAction Stop can be used. For example: $items | Assert-PSRule -Path './.ps-rule/' -ErrorAction Stop ; Using -ErrorAction Stop will stop the current script and return an exit code of 1. To continue running the current script but return an exit code, use: try { $items | Assert-PSRule -Path './.ps-rule/' -ErrorAction Stop ; } catch { $Host . SetShouldExit ( 1 ); }","title":"Failing the pipeline"},{"location":"scenarios/validation-pipeline/validation-pipeline/#generating-nunit-output","text":"NUnit is a popular unit test framework for .NET. NUnit generates a test report format that is widely interpreted by CI systems. While PSRule does not use NUnit directly, it support outputting validation results in the NUnit3 format. Using a common format allows integration with any system that supports the NUnit3 for publishing test results. To generate an NUnit report: Use the -OutputFormat NUnit3 parameter. Use the -OutputPath parameter to specify the path of the report file to write. $items | Assert-PSRule -Path './.ps-rule/' -OutputFormat NUnit3 -OutputPath reports / rule-report . xml ; The output path will be created if it does not exist.","title":"Generating NUnit output"},{"location":"scenarios/validation-pipeline/validation-pipeline/#publishing-nunit-report-with-azure-devops","text":"With Azure DevOps, an NUnit report can be published using Publish Test Results task . An example YAML snippet is included below: # PSRule results - task : PublishTestResults@2 displayName : 'Publish PSRule results' inputs : testRunTitle : 'PSRule' testRunner : NUnit testResultsFiles : 'reports/rule-report.xml' mergeTestResults : true publishRunAttachments : true condition : succeededOrFailed()","title":"Publishing NUnit report with Azure DevOps"},{"location":"scenarios/validation-pipeline/validation-pipeline/#complete-example","text":"Putting each of these steps together.","title":"Complete example"},{"location":"scenarios/validation-pipeline/validation-pipeline/#install-dependencies","text":"# Install dependencies for connecting to PowerShell Gallery if ( $Null -eq ( Get-PackageProvider -Name NuGet -ErrorAction SilentlyContinue )) { Install-PackageProvider -Name NuGet -Force -Scope CurrentUser ; } if ( $Null -eq ( Get-InstalledModule -Name PowerShellGet -MinimumVersion '2.2.1' -ErrorAction SilentlyContinue )) { Install-Module PowerShellGet -MinimumVersion '2.2.1' -Scope CurrentUser -Force -AllowClobber ; }","title":"Install dependencies"},{"location":"scenarios/validation-pipeline/validation-pipeline/#validate-files","text":"# Install PSRule module if ( $Null -eq ( Get-InstalledModule -Name PSRule -MinimumVersion '2.1.0' -ErrorAction SilentlyContinue )) { Install-Module -Name PSRule -Scope CurrentUser -MinimumVersion '2.1.0' -Force ; } # Validate files $assertParams = @{ Path = './.ps-rule/' Style = 'AzurePipelines' OutputFormat = 'NUnit3' OutputPath = 'reports/rule-report.xml' } $items = Get-ChildItem -Recurse -Path .\\ src \\,.\\ tests \\ -Include *. ps1 ,*. psd1 ,*. psm1 ,*. yaml ; $items | Assert-PSRule $assertParams -ErrorAction Stop ;","title":"Validate files"},{"location":"scenarios/validation-pipeline/validation-pipeline/#azure-devops-pipeline","text":"steps : # Install dependencies - powershell : ./pipeline-deps.ps1 displayName : 'Install dependencies' # Validate templates - powershell : ./validate-files.ps1 displayName : 'Validate files' # Publish pipeline results - task : PublishTestResults@2 displayName : 'Publish PSRule results' inputs : testRunTitle : 'PSRule' testRunner : NUnit testResultsFiles : 'reports/rule-report.xml' mergeTestResults : true publishRunAttachments : true condition : succeededOrFailed()","title":"Azure DevOps Pipeline"},{"location":"scenarios/validation-pipeline/validation-pipeline/#additional-options","text":"","title":"Additional options"},{"location":"scenarios/validation-pipeline/validation-pipeline/#using-invoke-build","text":"Invoke-Build is a build automation cmdlet that can be installed from the PowerShell Gallery by installing the InvokeBuild module. Within Invoke-Build, each build process is broken into tasks. The following example shows an example of using PSRule with Invoke-Build tasks. # Synopsis: Install PSRule task PSRule { if ( $Null -eq ( Get-InstalledModule -Name PSRule -MinimumVersion '2.1.0' -ErrorAction SilentlyContinue )) { Install-Module -Name PSRule -Scope CurrentUser -MinimumVersion '2.1.0' -Force ; } } # Synopsis: Validate files task ValidateFiles PSRule , { $assertParams = @{ Path = './.ps-rule/' Style = 'AzurePipelines' OutputFormat = 'NUnit3' OutputPath = 'reports/rule-report.xml' } $items = Get-ChildItem -Recurse -Path .\\ src \\,.\\ tests \\ -Include *. ps1 ,*. psd1 ,*. psm1 ,*. yaml ; $items | Assert-PSRule @assertParams -ErrorAction Stop ; } # Synopsis: Run all build tasks task Build ValidateFiles Invoke-Build Build ;","title":"Using Invoke-Build"},{"location":"scenarios/validation-pipeline/validation-pipeline/#calling-from-pester","text":"Pester is a unit test framework for PowerShell that can be installed from the PowerShell Gallery. Typically, Pester unit tests are built for a particular pipeline. PSRule can complement Pester unit tests by providing dynamic and sharable rules that are easy to reuse. By using -If or -Type pre-conditions, rules can dynamically provide validation for a range of use cases. When calling PSRule from Pester use Invoke-PSRule instead of Assert-PSRule . Invoke-PSRule returns validation result objects that can be tested by Pester Should conditions. Additionally, the Logging.RuleFail option can be included to generate an error message for each failing rule. For example: Describe 'Azure' { Context 'Resource templates' { It 'Use content rules' { $invokeParams = @{ Path = './.ps-rule/' OutputFormat = 'NUnit3' OutputPath = 'reports/rule-report.xml' } $items = Get-ChildItem -Recurse -Path .\\ src \\,.\\ tests \\ -Include *. ps1 ,*. psd1 ,*. psm1 ,*. yaml ; Invoke-PSRule @invokeParams -Outcome Fail , Error | Should -BeNullOrEmpty ; } } }","title":"Calling from Pester"},{"location":"scenarios/validation-pipeline/validation-pipeline/#more-information","text":"pipeline-deps.ps1 - Example script installing pipeline dependencies. file.Rule.ps1 - Example rules for validating script files. validate-files.ps1 - Example script for running files validation. azure-pipelines.yaml - An example Azure DevOps Pipeline.","title":"More information"},{"location":"specs/design-spec/","text":"PSRule design specification (draft) # This document is intended as a working technical specification for PSRule. What is PSRule? # PSRule is an engine, shipped as a PowerShell module designed to validate infrastructure as code (IaC). Additionally, PSRule can validate any PowerShell object, allowing almost any custom scenario to be supported. PSRule natively supports common infrastructure code artifacts with the following file formats: YAML ( .yaml or .yml ). JSON ( .json ). PowerShell Data Files ( .psd1 ). Markdown front matter ( .md or .markdown ). While some infrastructure as code languages implement their own custom language, many support output into a standard artifact format. i.e. terraform show -json Project objectives # Extensible : Provide an execution environment (tools and language) to validate infrastructure code. Handling of common concerns such as input/ output/ reporting should be handled by the engine. Language must be flexible enough to support a wide range of use cases. DevOps : Validation should support and enhance DevOps workflows by providing fast feedback in pull requests. Allow quality gates to be implemented between environments such development, test, and production. Cross-platform : A wide range of platforms can be used to author and deploy infrastructure code. PSRule must support rule validation and authoring on Linux, MacOS, and Windows. Runs in a Linux container. For continuous integration (CI) systems that do not support PowerShell, run in a container. Reusable : Validation should plug and play, reusable across teams and organizations. Any reusable validation will have exceptions. Rules must be able to be disabled where they are not applicable. Language specification # PSRule is rooted in PowerShell. This provides significant benefits and flexibility including: Reuses existing skills within Microsoft and customers who already know how to author PowerShell scripts. Builds on existing PowerShell community; allowing existing integrations and cmdlets to be used. PowerShell already has an established model for distributing packages (modules). This includes options for trust and hosting (publicly or privately). To ensure these benefits remain, the following must be true: Rules can be written using standard PowerShell operators and conventions. Minimal knowledge of PSRule should be required to author rules. Rules validate an object graph. Whether an object originates from a YAML or JSON file should be abstract. Future cases # PowerShell offers complete flexibility to build simple to complex rules. However, rule authors may be unfamiliar with PowerShell. Authoring rules in YAML or JSON with a defined schema will allow additional options for basic rules. Concepts # Rule definitions # Rule definitions or rules are defined using PowerShell. Rules can be created in a PowerShell script file with the .Rule.ps1 extension. Rule files can be created and used individually or bundled as a module. Each rule: Implements a test for one or more conditions against an object. When all conditions return true the rule passes, if not the rule fails. Is evaluated by executing the rule within a sandbox that provides context to each rule. Such as the deserialized object being processed and configuration. Can specify preconditions which determine if a rule should be evaluated based on the object being processed. Rules only run against the objects they are designed to test. For example: Rule 'NameOfRule' { # <Rule conditions> } # Synopsis: Configure storage accounts to only accept encrypted traffic i.e. HTTPS/SMB Rule 'StorageAccounts.UseHttps' -Type 'Microsoft.Storage/storageAccounts' { $TargetObject . Properties . supportsHttpsTrafficOnly -eq $True } PSRule engine # Distributed as a PowerShell module, all source code is included within this repository. This included cmdlets and an execution sandbox where rules are evaluated. PSRule is designed to be self contained, requiring only PowerShell to run. By itself PSRule doesn't implement any specific rules. Custom rules can be defined and evaluated from PowerShell script files. Reusable rules can be distributed using PowerShell modules. Use PowerShellGet to install modules from public and private sources. PSRule extends PowerShell with domain specific language (DSL) keywords, cmdlets, and automatic variables. These language features are only available within the sandbox. Stubs are exported from PSRule module to provide command completion during authoring. In additional to rules, a number of resources can be used within PSRule. Resources are defined in YAML files with the .Rule.yaml file extension. You can create one or many resource within a single .Rule.yaml file. PSRule supports the following resources: Baseline - A reusable group of rules and configuration defaults for a given scenario. Selector - A reusable filter to determine which objects a rule should be run against. A special ModuleConfig resource can also be defined to configure defaults for a module. Keywords and variables # TBA Baselines # A baseline is a resource defined in YAML that determines which rules to run for a given scenario. One or more baselines can be included in a .Rule.yaml file. Baselines can be created individually or bundled in a module. Common use cases where baselines are helpful include: Separation of rules or features in development. For infrastructure code or rules early in their lifecycle, a recommend practice may not be fully ratified. Baselines allow rules to be distributed but not executed by default. Progressive adoption. If validation has been added for a new use case, it may not be possible to adopt all rules at once. Baselines act as checkpoints to allow validation of a subset of rules. Execution # Execution within PSRule occurs within a pipeline. The PSRule pipeline is similar to PowerShell and contains a begin , process , and end stage. Begin : TBA Process : TBA End : TBA Three execution pipelines exist, Invoke , Assert , or Test . Differences between each of these pipeline is minimal and mostly deals with how output is presented. Invoke : Returns output as pipeline objects so they can be natively processed by PowerShell code. Assert : Returns output as styled text to provide readable results within a CI pipeline. Test : Returns true or false based on pass or fail of each object. Use this option to use filter objects from a PowerShell pipeline. Execution sandbox # The execution sandbox is implemented using PowerShell runspaces. Runspaces are a PowerShell feature which enable partial isolation within a PowerShell process. PSRule uses two discrete runspaces: In the parent runspace where PSRule is called using Invoke-PSRule , Assert-PSRule , or Test-PSRule . The parent runspace is responsible for all input and output. The sandbox runspace is where rules execute. PSRule keywords and automatic variables are implemented in the sandbox. Flow control within the PSRule pipeline maintains context for each object as it is processed by rules. Input and output are proxied between the two discrete runspaces to maintain runspace separation. This separation allows rules to be executed without polluting the state of the parent runspace. Rule evaluation # TBA Configuration # PSRule has built-in support for configuration of the engine and rules. Configuration can be set by: Configuring the default ps-rule.yaml file. Setting at runtime by passing a -Option parameter to PSRule cmdlets. Engine options # Configuration of the PSRule engine is referred to as options. Each option changes the default that PSRule uses during execution. The supported options that can be configured for PSRule are described in the about_PSRule_Options topic. Rule configuration # Separately, rules can optionally define configuration that can skip or change the rule conditions. Rule configuration is a key/ value pair. Integration # TBA","title":"PSRule design specification (draft)"},{"location":"specs/design-spec/#psrule-design-specification-draft","text":"This document is intended as a working technical specification for PSRule.","title":"PSRule design specification (draft)"},{"location":"specs/design-spec/#what-is-psrule","text":"PSRule is an engine, shipped as a PowerShell module designed to validate infrastructure as code (IaC). Additionally, PSRule can validate any PowerShell object, allowing almost any custom scenario to be supported. PSRule natively supports common infrastructure code artifacts with the following file formats: YAML ( .yaml or .yml ). JSON ( .json ). PowerShell Data Files ( .psd1 ). Markdown front matter ( .md or .markdown ). While some infrastructure as code languages implement their own custom language, many support output into a standard artifact format. i.e. terraform show -json","title":"What is PSRule?"},{"location":"specs/design-spec/#project-objectives","text":"Extensible : Provide an execution environment (tools and language) to validate infrastructure code. Handling of common concerns such as input/ output/ reporting should be handled by the engine. Language must be flexible enough to support a wide range of use cases. DevOps : Validation should support and enhance DevOps workflows by providing fast feedback in pull requests. Allow quality gates to be implemented between environments such development, test, and production. Cross-platform : A wide range of platforms can be used to author and deploy infrastructure code. PSRule must support rule validation and authoring on Linux, MacOS, and Windows. Runs in a Linux container. For continuous integration (CI) systems that do not support PowerShell, run in a container. Reusable : Validation should plug and play, reusable across teams and organizations. Any reusable validation will have exceptions. Rules must be able to be disabled where they are not applicable.","title":"Project objectives"},{"location":"specs/design-spec/#language-specification","text":"PSRule is rooted in PowerShell. This provides significant benefits and flexibility including: Reuses existing skills within Microsoft and customers who already know how to author PowerShell scripts. Builds on existing PowerShell community; allowing existing integrations and cmdlets to be used. PowerShell already has an established model for distributing packages (modules). This includes options for trust and hosting (publicly or privately). To ensure these benefits remain, the following must be true: Rules can be written using standard PowerShell operators and conventions. Minimal knowledge of PSRule should be required to author rules. Rules validate an object graph. Whether an object originates from a YAML or JSON file should be abstract.","title":"Language specification"},{"location":"specs/design-spec/#future-cases","text":"PowerShell offers complete flexibility to build simple to complex rules. However, rule authors may be unfamiliar with PowerShell. Authoring rules in YAML or JSON with a defined schema will allow additional options for basic rules.","title":"Future cases"},{"location":"specs/design-spec/#concepts","text":"","title":"Concepts"},{"location":"specs/design-spec/#rule-definitions","text":"Rule definitions or rules are defined using PowerShell. Rules can be created in a PowerShell script file with the .Rule.ps1 extension. Rule files can be created and used individually or bundled as a module. Each rule: Implements a test for one or more conditions against an object. When all conditions return true the rule passes, if not the rule fails. Is evaluated by executing the rule within a sandbox that provides context to each rule. Such as the deserialized object being processed and configuration. Can specify preconditions which determine if a rule should be evaluated based on the object being processed. Rules only run against the objects they are designed to test. For example: Rule 'NameOfRule' { # <Rule conditions> } # Synopsis: Configure storage accounts to only accept encrypted traffic i.e. HTTPS/SMB Rule 'StorageAccounts.UseHttps' -Type 'Microsoft.Storage/storageAccounts' { $TargetObject . Properties . supportsHttpsTrafficOnly -eq $True }","title":"Rule definitions"},{"location":"specs/design-spec/#psrule-engine","text":"Distributed as a PowerShell module, all source code is included within this repository. This included cmdlets and an execution sandbox where rules are evaluated. PSRule is designed to be self contained, requiring only PowerShell to run. By itself PSRule doesn't implement any specific rules. Custom rules can be defined and evaluated from PowerShell script files. Reusable rules can be distributed using PowerShell modules. Use PowerShellGet to install modules from public and private sources. PSRule extends PowerShell with domain specific language (DSL) keywords, cmdlets, and automatic variables. These language features are only available within the sandbox. Stubs are exported from PSRule module to provide command completion during authoring. In additional to rules, a number of resources can be used within PSRule. Resources are defined in YAML files with the .Rule.yaml file extension. You can create one or many resource within a single .Rule.yaml file. PSRule supports the following resources: Baseline - A reusable group of rules and configuration defaults for a given scenario. Selector - A reusable filter to determine which objects a rule should be run against. A special ModuleConfig resource can also be defined to configure defaults for a module.","title":"PSRule engine"},{"location":"specs/design-spec/#keywords-and-variables","text":"TBA","title":"Keywords and variables"},{"location":"specs/design-spec/#baselines","text":"A baseline is a resource defined in YAML that determines which rules to run for a given scenario. One or more baselines can be included in a .Rule.yaml file. Baselines can be created individually or bundled in a module. Common use cases where baselines are helpful include: Separation of rules or features in development. For infrastructure code or rules early in their lifecycle, a recommend practice may not be fully ratified. Baselines allow rules to be distributed but not executed by default. Progressive adoption. If validation has been added for a new use case, it may not be possible to adopt all rules at once. Baselines act as checkpoints to allow validation of a subset of rules.","title":"Baselines"},{"location":"specs/design-spec/#execution","text":"Execution within PSRule occurs within a pipeline. The PSRule pipeline is similar to PowerShell and contains a begin , process , and end stage. Begin : TBA Process : TBA End : TBA Three execution pipelines exist, Invoke , Assert , or Test . Differences between each of these pipeline is minimal and mostly deals with how output is presented. Invoke : Returns output as pipeline objects so they can be natively processed by PowerShell code. Assert : Returns output as styled text to provide readable results within a CI pipeline. Test : Returns true or false based on pass or fail of each object. Use this option to use filter objects from a PowerShell pipeline.","title":"Execution"},{"location":"specs/design-spec/#execution-sandbox","text":"The execution sandbox is implemented using PowerShell runspaces. Runspaces are a PowerShell feature which enable partial isolation within a PowerShell process. PSRule uses two discrete runspaces: In the parent runspace where PSRule is called using Invoke-PSRule , Assert-PSRule , or Test-PSRule . The parent runspace is responsible for all input and output. The sandbox runspace is where rules execute. PSRule keywords and automatic variables are implemented in the sandbox. Flow control within the PSRule pipeline maintains context for each object as it is processed by rules. Input and output are proxied between the two discrete runspaces to maintain runspace separation. This separation allows rules to be executed without polluting the state of the parent runspace.","title":"Execution sandbox"},{"location":"specs/design-spec/#rule-evaluation","text":"TBA","title":"Rule evaluation"},{"location":"specs/design-spec/#configuration","text":"PSRule has built-in support for configuration of the engine and rules. Configuration can be set by: Configuring the default ps-rule.yaml file. Setting at runtime by passing a -Option parameter to PSRule cmdlets.","title":"Configuration"},{"location":"specs/design-spec/#engine-options","text":"Configuration of the PSRule engine is referred to as options. Each option changes the default that PSRule uses during execution. The supported options that can be configured for PSRule are described in the about_PSRule_Options topic.","title":"Engine options"},{"location":"specs/design-spec/#rule-configuration","text":"Separately, rules can optionally define configuration that can skip or change the rule conditions. Rule configuration is a key/ value pair.","title":"Rule configuration"},{"location":"specs/design-spec/#integration","text":"TBA","title":"Integration"},{"location":"specs/function-spec/","text":"PSRule function expressions spec (draft) # This is a spec for implementing function expressions in PSRule v2. Synopsis # Functions are available to handle complex conditions within YAML and JSON expressions. Schema driven # While functions allow handing for complex use cases, they should still remain schema driven. A schema driven design allows auto-completion and validation during authoring in a broad set of tools. Syntax # Functions can be used within YAML and JSON expressions by using the $ object property. For example: --- # Synopsis: An expression function example. apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : Yaml.Fn.Example1 spec : if : value : $ : substring : path : name length : 3 equals : abc","title":"PSRule function expressions spec (draft)"},{"location":"specs/function-spec/#psrule-function-expressions-spec-draft","text":"This is a spec for implementing function expressions in PSRule v2.","title":"PSRule function expressions spec (draft)"},{"location":"specs/function-spec/#synopsis","text":"Functions are available to handle complex conditions within YAML and JSON expressions.","title":"Synopsis"},{"location":"specs/function-spec/#schema-driven","text":"While functions allow handing for complex use cases, they should still remain schema driven. A schema driven design allows auto-completion and validation during authoring in a broad set of tools.","title":"Schema driven"},{"location":"specs/function-spec/#syntax","text":"Functions can be used within YAML and JSON expressions by using the $ object property. For example: --- # Synopsis: An expression function example. apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : Yaml.Fn.Example1 spec : if : value : $ : substring : path : name length : 3 equals : abc","title":"Syntax"}]}