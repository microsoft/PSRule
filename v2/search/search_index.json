{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"CHANGELOG-v0/","text":"Change log # See upgrade notes for helpful information when upgrading from previous versions. Attention PSRule v0 is a prior release. Please upgrade to the latest version. v0.22.0 # What's changed since v0.21.0: Engine features: Added HasFields assertion helper to check all fields exist. #578 Updated HasField to check if any of the specified fields exist. #578 General improvements: Input format detection now includes .jsonc and .markdown file extensions. #575 Improved support for cross module rule dependencies. #248 Rule dependencies are now automatically imported. Bug fixes: Fixed handling for null or empty arrays with StartsWith , Contains , EndsWith , In , and NotIn . #579 What's changed since pre-release v0.22.0-B2010014: No additional changes. v0.22.0-B2010014 (pre-release) # What's changed since v0.21.0: Engine features: Added HasFields assertion helper to check all fields exist. #578 Updated HasField to check if any of the specified fields exist. #578 General improvements: Input format detection now includes .jsonc and .markdown file extensions. #575 Improved support for cross module rule dependencies. #248 Rule dependencies are now automatically imported. Bug fixes: Fixed handling for null or empty arrays with StartsWith , Contains , EndsWith , In , and NotIn . #579 v0.21.0 # What's changed since v0.20.0: Engine features: Added support for formatting results as markdown. #474 Use -OutputFormat Markdown or configure Output.Format to output markdown. To format as either detail or summary, use the -As parameter or configure Output.As . Added character case assertion helpers IsLower , and IsUpper . #555 IsLower checks that all letters in a field value are lowercase. IsUpper checks that all letters in a field value are uppercase. General improvements: Numerical strings can be converted with numeric assertion helpers. #550 Added outcome Output.Outcome as a configurable option. #552 Added help links and default snippets to schemas. #561 Improved rule error reporting by including rule and source location. #565 Engineering: Bump Manatee.Json from 13.0.2 to 13.0.3. #563 Bug fixes: Fixed NUnit report reasons should be escaped in markdown. #471 Fixed reporting of error when rule error is handled. #564 Additionally rules can use -ErrorAction Ignore to ignore non-exception errors. Fixed first exception stops other rules from being processed. #566 What's changed since pre-release v0.21.0-B2010010: No additional changes. v0.21.0-B2010010 (pre-release) # What's changed since pre-release v0.21.0-B2010003: General improvements: Improved rule error reporting by including rule and source location. #565 v0.21.0-B2010003 (pre-release) # What's changed since pre-release v0.21.0-B2009016: General improvements: Added help links and default snippets to schemas. #561 Engineering: Bump Manatee.Json from 13.0.2 to 13.0.3. #563 Bug fixes: Fixed reporting of error when rule error is handled. #564 Additionally rules can use -ErrorAction Ignore to ignore non-exception errors. Fixed first exception stops other rules from being processed. #566 v0.21.0-B2009016 (pre-release) # What's changed since pre-release v0.21.0-B2009006: Engine features: Added character case assertion helpers IsLower , and IsUpper . #555 IsLower checks that all letters in a field value are lowercase. IsUpper checks that all letters in a field value are uppercase. Bug fixes: Fixed NUnit report reasons should be escaped in markdown. #471 v0.21.0-B2009006 (pre-release) # What's changed since v0.20.0: Engine features: Added support for formatting results as markdown. #474 Use -OutputFormat Markdown or configure Output.Format to output markdown. To format as either detail or summary, use the -As parameter or configure Output.As . General improvements: Numerical strings can be converted with numeric assertion helpers. #550 Added outcome Output.Outcome as a configurable option. #552 v0.20.0 # What's changed since v0.19.0: Engine features: Added support for scanning repository files. #524 Added File input type ( -InputType File ) to scan for files without deserializing them. Added Input.PathIgnore option to ignore files. When using the File input type path specs in .gitignore are ignored. Added Get-PSRuleTarget cmdlet to read input files and return raw objects. #525 This cmdlet can be used to troubleshoot PSRule input issues. Baselines can now be flagged as obsolete. #499 Set the metadata.annotations.obsolete property to true to flag a baseline as obsolete. When an obsolete baseline is used, a warning will be generated. Added file assertion helpers FileHeader , and FilePath . #534 FileHeader checks for a comment header in the file. FilePath checks that a file path (optionally with suffixes) exist. General improvements: Added automatic binding for Rule object. #542 Engineering: Warn when deprecated $Rule properties are used. #536 #545 First usage of deprecated property generates a warning. Rule using deprecated property is flagged in debug output. Bump YamlDotNet dependency to v8.1.2. #439 Bug fixes: Fixed out of bounds exception when empty markdown documentation is used. #516 What's changed since pre-release v0.20.0-B2009013: Bug fixes: Fixed excessive obsolete property warnings. #545 v0.20.0-B2009013 (pre-release) # What's changed since pre-release v0.20.0-B2009007: General improvements: Added automatic binding for Rule object. #542 Bug fixes: Fixed InputFileInfo Type property causes downstream binding issues. #541 v0.20.0-B2009007 (pre-release) # What's changed since pre-release v0.20.0-B2008010: Engine features: Added file assertion helpers FileHeader , and FilePath . #534 FileHeader checks for a comment header in the file. FilePath checks that a file path (optionally with suffixes) exist. Engineering: Warn when deprecated $Rule properties are used. #536 Bug fixes: Fixed out of bounds exception when empty markdown documentation is used. #516 Fixed lines breaks in RepositoryInfo target name with git ref. #538 v0.20.0-B2008010 (pre-release) # What's changed since pre-release v0.20.0-B2008002: Engine features: Baselines can now be flagged as obsolete. #499 Set the metadata.annotations.obsolete property to true to flag a baseline as obsolete. When an obsolete baseline is used, a warning will be generated. Engineering: Bump YamlDotNet dependency to v8.1.2. #439 v0.20.0-B2008002 (pre-release) # What's changed since v0.19.0: Engine features: Added support for scanning repository files. #524 Added File input type ( -InputType File ) to scan for files without deserializing them. Added Input.PathIgnore option to ignore files. When using the File input type path specs in .gitignore are ignored. Added Get-PSRuleTarget cmdlet to read input files and return raw objects. #525 This cmdlet can be used to troubleshoot PSRule input issues. v0.19.0 # What's changed since v0.18.1: Engine features: Added Reason method to assertion results. #500 This new method, streamlines setting custom reasons particularly with formatted strings. The Reason method replaces any previously set reasons with a custom string. Optional arguments can be provided to be included in string formatting. Improvements to assertion methods. Added regular expression assertion helpers Match , and NotMatch . #502 Added collection assertion helpers In , and NotIn . #501 Added module version constraints. #498 The module versions that PSRule uses can be constrained. Bug fixes: Fixed styling for no rule files warning with Assert-PSRule . #484 Fixed actual value in reason for numeric comparison assertion method. #505 What's changed since pre-release v0.19.0-B2007030: No additional changes. v0.19.0-B2007030 (pre-release) # Bug fixes: Fixed Assert.In unable to compare PSObject wrapped array items. #512 v0.19.0-B2007023 (pre-release) # Engine features: Added Reason method to assertion results. #500 This new method, streamlines setting custom reasons particularly with formatted strings. The Reason method replaces any previously set reasons with a custom string. Optional arguments can be provided to be included in string formatting. Improvements to assertion methods. Added regular expression assertion helpers Match , and NotMatch . #502 Added collection assertion helpers In , and NotIn . #501 Added module version constraints. #498 The module versions that PSRule uses can be constrained. Bug fixes: Fixed styling for no rule files warning with Assert-PSRule . #484 Fixed actual value in reason for numeric comparison assertion method. #505 v0.18.1 # What's changed since v0.18.0: Bug fixes: Fixed unable to read properties for .NET DynamicObject . #491 Fixed read of JSON input format with null array item. #490 Fixed Csv output format with summary for Invoke-PSRule . #486 v0.19.0-B2006027 (pre-release) # Bug fixes: Fixed unable to read properties for .NET DynamicObject . #491 Fixed read of JSON input format with null array item. #490 v0.19.0-B2006018 (pre-release) # Bug fixes: Fixed Csv output format with summary for Invoke-PSRule . #486 v0.18.0 # What's changed since v0.17.0: General improvements: Improved Assert-PSRule output formatting. #472 Added recommendation and reasons for AzurePipelines and GitHubActions styles. Summary line is has been updated to include synopsis instead of reasons. Bug fixes: Fixed binding with ModuleConfig . #468 Fixed recommendation output with client style. #467 What's changed since pre-release v0.18.0-B2005015: No additional changes. v0.18.0-B2005015 (pre-release) # General improvements: Improved Assert-PSRule output formatting. #472 Added recommendation and reasons for AzurePipelines and GitHubActions styles. Summary line is has been updated to include synopsis instead of reasons. Bug fixes: Fixed binding with ModuleConfig . #468 Fixed recommendation output with client style. #467 v0.17.0 # What's changed since v0.16.0: General improvements: Improved Assert-PSRule output formatting. Added recommendation and reasons for Client and Plain styles. #456 Added support for configuration of default module options. #459 binding and configuration options can be set to a default value. Updated New-PSRuleOption parameter sets and help based on updates to module config. Added support for module fallback culture. #441 Bug fixes: Fixed resource schema to include useQualifiedName and nameSeparator option. #458 What's changed since pre-release v0.17.0-B2005010: No additional changes. v0.17.0-B2005010 (pre-release) # General improvements: Improved Assert-PSRule output formatting. Added recommendation and reasons for Client and Plain styles. #456 Added support for configuration of default module options. #459 binding and configuration options can be set to a default value. Updated New-PSRuleOption parameter sets and help based on updates to module config. Added support for module fallback culture. #441 Bug fixes: Fixed resource schema to include useQualifiedName and nameSeparator option. #458 v0.16.0 # What's changed since v0.15.0: General improvements: Added configuration option Output.Culture for setting culture. #442 Improved handling of fields to allow the input object to be referenced with . . #437 Bug fixes: Fixed numeric comparison assertion with non-int types. #436 Fixed output culture option ignored. #449 What's changed since pre-release v0.16.0-B2003027: No additional changes. v0.16.0-B2003027 (pre-release) # Bug fixes: Fixed output culture option ignored. #449 v0.16.0-B2003022 (pre-release) # General improvements: Added configuration option Output.Culture for setting culture. #442 Improved handling of fields to allow the input object to be referenced with . . #437 Bug fixes: Fixed numeric comparison assertion with non-int types. #436 v0.15.0 # What's changed since v0.14.0: Engine features: Added -ResultVariable to store results from Assert-PSRule into a variable. #412 General improvements: Added recommendation to failure message of NUnit results. #421 Bug fixes: Fixed handling of v in field value with $Assert.Version . #429 Fixed handling of warning action preference with Assert-PSRule . #428 Fixed parent culture unwind with POSIX. #414 Fixed output of warning with Assert-PSRule . #417 Fixed NUnit report to include a failure element when reason is not specified. #420 What's changed since pre-release v0.15.0-B2002031: No additional changes. v0.15.0-B2002031 (pre-release) # Fixed handling of v in field value with $Assert.Version . #429 Fixed handling of warning action preference with Assert-PSRule . #428 v0.15.0-B2002019 (pre-release) # Added -ResultVariable to store results from Assert-PSRule into a variable. #412 v0.15.0-B2002012 (pre-release) # Fixed output of warning with Assert-PSRule . #417 Fixed NUnit report to include a failure element when reason is not specified. #420 Added recommendation to failure message of NUnit results. #421 v0.15.0-B2002005 (pre-release) # Fixed parent culture unwind with POSIX. #414 v0.14.0 # What's changed since v0.13.0: Engine features: Added support for qualified target names. #395 Added options Binding.UseQualifiedName and Binding.NameSeparator . See about_PSRule_Options for details. Added assertion method HasJsonSchema to check if a JSON schema is referenced. #398 See about_PSRule_Assert for usage details. Added file content helper for reading objects from files. #399 The method GetContent of $PSRule can be used to read files as objects. See about_PSRule_Variables for usage details. General improvements: Improved reporting on runtime errors in rule blocks. #239 Improved NUnit results to include a failure message based on reported reasons. #404 Bug fixes: Fixed wide formatting of rules with Get-PSRule . #407 Fixed TargetName hash serialization for base types. #406 Fixed output not generated with Assert-PSRule and Stop. #405 Fixed NUnit results incorrectly reporting that the test had not executed. #403 What's changed since pre-release v0.14.0-B2002003: No additional changes v0.14.0-B2002003 (pre-release) # Fixed wide formatting of rules with Get-PSRule . #407 Fixed TargetName hash serialization for base types. #406 Fixed output not generated with Assert-PSRule and Stop. #405 Fixed NUnit results incorrectly reporting that the test had not executed. #403 Improved NUnit results to include a failure message based on reported reasons. #404 Improved reporting on runtime errors in rule blocks. #239 v0.14.0-B2001020 (pre-release) # Added support for qualified target names. #395 Added options Binding.UseQualifiedName and Binding.NameSeparator . See about_PSRule_Options for details. Added assertion method HasJsonSchema to check if a JSON schema is referenced. #398 See about_PSRule_Assert for usage details. Added file content helper for reading objects from files. #399 The method GetContent of $PSRule can be used to read files as objects. See about_PSRule_Variables for usage details. v0.13.0 # What's changed since v0.12.0: Engine features: Improvements to rule help and documentation. #382 #316 Added links and notes sections to help. Added -Full switch to Get-PSRuleHelp to display links and notes sections. Added support for using a parent culture in rule help. Rule help will use parent culture when a more specific culture is not available. Added input format for reading PowerShell data .psd1 files. #368 PowerShellData has been added to Input.Format . See about_PSRule_Options for details. Added custom rule data to results. #322 $PSRule.Data can be used to set custom data during rule execution that is included in output. See about_PSRule_Variables for usage details. Improvements to assertion methods. #386 #374 #387 #344 #353 #357 Added support for assertion methods to be used within script pre-conditions. Added numeric comparison assertion helpers Greater , GreaterOrEqual , Less and LessOrEqual . Added semantic version assertion helper Version . Added string affix assertion helpers StartsWith , EndsWith and Contains . See about_PSRule_Assert for usage details. Improvements to output logging and formatting for Assert-PSRule . Formatting now includes errors and warnings using style. Added PSRule banner with module information. Added rule success summary. General improvements: Added aliases for -OutputFormat ( -o ) and -Module ( -m ) parameters. #384 Added WithReason to append/ replace reasons from assertion result. #354 Added configuration helper for strings arrays. #363 Bug fixes: Fixed JSON de-serialization fails with single object. #379 Fixed stack overflow when parsing malformed JSON. #380 What's changed since pre-release v0.13.0-B2001013: No additional changes. v0.13.0-B2001013 (pre-release) # Fixed JSON de-serialization fails with single object. #379 Fixed stack overflow when parsing malformed JSON. #380 Added rule documentation links and notes to help. #382 Added -Full switch to Get-PSRuleHelp to display links and notes sections. Added aliases for -OutputFormat ( -o ) and -Module ( -m ) parameters. #384 Improved numeric comparison assertion helpers to support strings. #387 Methods Greater , GreaterOrEqual , Less and LessOrEqual now also check string length. Added support for assertion methods to be used within script pre-conditions. #386 v0.13.0-B1912043 (pre-release) # Added input format for reading PowerShell data .psd1 files. #368 PowerShellData has been added to Input.Format . See about_PSRule_Options for details. Added numeric comparison assertion helpers. #374 Added methods Greater , GreaterOrEqual , Less and LessOrEqual . See about_PSRule_Assert for usage details. v0.13.0-B1912027 (pre-release) # Added configuration helper for strings arrays. #363 Added support for using a parent culture in rule help. #316 Rule help will use parent culture when a more specific culture is not available. Added custom rule data to results. #322 $PSRule.Data can be used to set custom data during rule execution that is included in output. See about_PSRule_Variables for usage details. v0.13.0-B1912012 (pre-release) # Improves output logging and formatting for Assert-PSRule. #357 Formatting now includes errors and warnings using style. Added PSRule banner with module information. Added rule success summary. v0.13.0-B1912005 (pre-release) # Added semantic version assertion helper Version . #344 Added string affix assertion helpers. #353 Added methods StartsWith , EndsWith and Contains . See about_PSRule_Assert for usage details. Added WithReason to append/ replace reasons from assertion result. #354 v0.12.0 # What's changed since v0.11.0: Engine features: Added -All option to Exists keyword. #331 Added custom field binding. #321 Added new option Binding.Field available in baselines to configure binding. General improvements: Added filtering for rules against a baseline with Get-PSRule . #345 Added parameter alias -f for -InputPath . #340 -f was added to Invoke-PSRule , Assert-PSRule and Test-PSRuleTarget cmdlets. Important change : Added $PSRule generic context variable. #341 Deprecated TargetName , TargetType and TargetObject properties on $Rule . Use TargetName , TargetType and TargetObject on $PSRule instead. Properties TargetName , TargetType and TargetObject on $Rule will be removed in the future. Going forward $Rule will only contain properties that relate to the current rule context. Bug fixes: Fixed key has already been added for default baseline. #349 Fixed multiple value tag filtering. #346 Fixed TargetType fall back to type name. #339 Fixed NUnit serialization issue for unprocessed rules. #332 What's changed since pre-release v0.12.0-B1912007: Fixed key has already been added for default baseline. #349 v0.12.0-B1912007 (pre-release) # Fixed multiple value tag filtering. #346 Added filtering for rules against a baseline with Get-PSRule . #345 v0.12.0-B1912002 (pre-release) # Fixed TargetType fall back to type name. #339 Added custom field binding. #321 Added new option Binding.Field available in baselines to configure binding. Added parameter alias -f for -InputPath . #340 -f was added to Invoke-PSRule , Assert-PSRule and Test-PSRuleTarget cmdlets. Important change : Added $PSRule generic context variable. #341 Deprecated TargetName , TargetType and TargetObject properties on $Rule . Use TargetName , TargetType and TargetObject on $PSRule instead. Properties TargetName , TargetType and TargetObject on $Rule will be removed in the future. Going forward $Rule will only contain properties that relate to the current rule context. v0.12.0-B1911013 (pre-release) # Fixed NUnit serialization issue for unprocessed rules. #332 Added -All option to Exists keyword. #331 v0.11.0 # What's changed since v0.10.0: General improvements: Added -TargetType parameter to filter input objects by target type. #176 This parameter applies to Invoke-PSRule , Assert-PSRule and Test-PSRuleTarget . Bug fixes: Fixed null reference exception when bound property is null. #323 Fixed missing Markdown input format in options schema. #315 Breaking change : Unprocessed object results are not returned from Test-PSRuleTarget by default. #318 Previously unprocessed objects returned $True , now unprocessed objects return no result. Use -Outcome All to return $True for unprocessed objects the same as <= v0.10.0. What's changed since pre-release v0.11.0-B1911002: No additional changes. v0.11.0-B1911002 (pre-release) # Fixed null reference exception when bound property is null. #323 v0.11.0-B1910014 (pre-release) # Fixed missing Markdown input format in options schema. #315 Added -TargetType parameter to filter input objects by target type. #176 This parameter applies to Invoke-PSRule , Assert-PSRule and Test-PSRuleTarget . Breaking change : Unprocessed object results are not returned from Test-PSRuleTarget by default. #318 Previously unprocessed objects returned $True , now unprocessed objects return no result. Use -Outcome All to return $True for unprocessed objects the same as <= v0.10.0. v0.10.0 # What's changed since v0.9.0: General improvements: Added source note properties to input objects read from disk with -InputPath . #302 Engine features: Added assertion helper for checking field default value. #289 Added dependency DependsOn information to results from Get-PSRule . #210 To include dependencies that would normally be filtered out use -IncludeDependencies . Added input format for reading markdown front matter. #301 Markdown front matter is deserialized and evaluated as an object. Added Assert-PSRule cmdlet to improve integration into CI processes. #290 Added Output.Style option to support output in the following styles: Client/ Plain - Output returns easy to read log of rule pass/ fail. Azure Pipelines - Report rule failures as errors collected by Azure Pipelines. GitHub Actions - Reports rule failures as errors collected by GitHub Actions. Bug fixes: Fix Get-PSRuleHelp -Online in constrained language mode. #296 Breaking change : Removed previously deprecated alias Hint for Recommend . #165 Use the Recommend keyword instead. What's changed since pre-release v0.10.0-B1910036: No additional changes. v0.10.0-B1910036 (pre-release) # Added dependency DependsOn information to results from Get-PSRule . #210 To include dependencies that would normally be filtered out use -IncludeDependencies . Added input format for reading markdown front matter. #301 Markdown front matter is deserialized and evaluated as an object. Added source note properties to input objects read from disk with -InputPath . #302 Breaking change : Removed previously deprecated alias Hint for Recommend . #165 Use the Recommend keyword instead. v0.10.0-B1910025 (pre-release) # Fix Get-PSRuleHelp -Online in constrained language mode. #296 Added Assert-PSRule cmdlet to improve integration into CI processes. #290 Added Output.Style option to support output in the following styles: Client/ Plain - Output returns easy to read log of rule pass/ fail. Azure Pipelines - Report rule failures as errors collected by Azure Pipelines. GitHub Actions - Reports rule failures as errors collected by GitHub Actions. v0.10.0-B1910011 (pre-release) # Added assertion helper for checking field default value. #289 v0.9.0 # What's changed since v0.8.0: General improvements: Improve feedback of parsing errors. #185 Updated Get-PSRuleHelp to include help within the current path by default. #197 Engine features: Added support for a wildcard match using the Within keyword. #272 Added rule info display name. #276 Added support for matching an array of tag values. #282 Added named baselines. Now baselines are a separate resource that can be individually used. Baselines can be packaged within module. Modules can specify a default baseline in module manifest. Target binding options ( Binding ) are now part of baselines. See about_PSRule_Baseline for more information. Bug fixes: Fix can not serialize nested System.IO.DirectoryInfo property. #281 Fix ModuleName not displayed in Get-PSRuleHelp list. #275 Fix outcome reported when error or exception is raised. #211 Breaking change : Baseline improvements, fundamentally changes how baselines work. #274 Previously, baselines were specified as workspace options. The previous baseline options property has been renamed to rule . The previous configuration property is now a top level option. What's changed since pre-release v0.9.0-B190905: No additional changes v0.9.0-B190905 (pre-release) # Added support for matching an array of tag values. #282 Updated Get-PSRuleHelp to include help within the current path by default. #197 Fix can not serialize nested System.IO.DirectoryInfo property. #281 Fix export of Like parameter for Within keyword. #279 Breaking change : Added named baselines. This changes how baselines work. #274 Previously, baselines were specified as workspace options. Now, baselines are a separate resource that can be individually used. Additionally: Baselines can be packaged within module. Modules can specify a default baseline in module manifest. Target binding options ( Binding ) are now part of baselines. The previous baseline options property has been renamed to rule . The previous configuration property is now a top level option. See about_PSRule_Baseline for more information. v0.9.0-B190819 (pre-release) # Added support for a wildcard match using the Within keyword. #272 Added rule info display name. #276 Fix ModuleName not displayed in Get-PSRuleHelp list. #275 v0.9.0-B190810 (pre-release) # Improve feedback of parsing errors. #185 Fix outcome reported when error or exception is raised. #211 v0.8.0 # What's changed since v0.7.0: General improvements: PSRule options are now displayed as YAML instead of a complex object. #233 Add detection for improper keyword use. #203 Automatically load rule modules. #218 Added support for debug messages and Write-Debug in rule definitions. #146 Added Logging.LimitDebug and Logging.LimitVerbose options to limit logging to named scopes. #235 Engine features: Added per object reason for failing rules. #200 Keywords Exists , Match , Within and TypeOf automatically add a reason when they fail. Custom reason can be set for keywords Exists , Match , Within and TypeOf with -Reason . Added Reason keyword to add to reason for custom logic. Added wide output display for Invoke-PSRule which include the reason why rule failed. To use wide output use the -OutputFormat Wide parameter. Renamed -Message parameter to -Text on the Recommend keyword. The -Message is an alias of -Text and will be deprecated in the future. Added assertion helper $Assert for extensibility. #250 Add built-in assertions for HasField , HasFieldValue and NullOrEmpty . Add JSON schema assertion method JsonSchema . #42 Bug fixes: Fix rule synopsis comment capture. #214 Fix YAML options file discovery issue in dotted directory. #232 Fix comparison of wrapped types and null with Within . #237 Breaking change : Use rule references consistent with cmdlet fully qualified syntax. #217 Rule names have to be unique within the current execution path or within a module. Previously rule names only had to be unique within a single file. Previously the filename.rule.ps1/RuleName was required to reference rules across files. This is no longer required because rule names are unique. You can reference a rule from a loaded module by using the syntax ModuleName\\RuleName . What's changed since pre-release v0.8.0-B190806: Fix export of assertion helper variable $Assert . #262 v0.8.0-B190806 (pre-release) # Fix module reloading with different versions. #254 Fix not finding rules in current path by default. #256 Fix rule synopsis comment capture. #214 v0.8.0-B190742 (pre-release) # Fix inconsistent handling of $PWD . #249 Add detection for improper keyword use. #203 Automatically load rule modules. #218 Added assertion helper $Assert for extensibility. #250 Add built-in assertions for HasField , HasFieldValue and NullOrEmpty . Add JSON schema assertion method JsonSchema . #42 Breaking change : Use rule references consistent with cmdlet fully qualified syntax. #217 Rule names have to be unique within the current execution path or within a module. Previously rule names only had to be unique within a single file. Previously the filename.rule.ps1/RuleName was required to reference rules across files. This is no longer required because rule names are unique. You can reference a rule from a loaded module by using the syntax ModuleName\\RuleName . v0.8.0-B190716 (pre-release) # Added per object reason for failing rules. #200 The keywords Exists , Match , Within and TypeOf automatically add a reason when they fail. Added -Reason parameter to Exists , Match , Within and TypeOf keywords to allow a custom reason to be set. Added Reason keyword to add to reason for custom logic. Added wide output display for Invoke-PSRule which include the reason why rule failed. To use wide output use the -OutputFormat Wide parameter. Renamed -Message parameter to -Text on the Recommend keyword. The -Message is an alias of -Text and will be deprecated in the future. v0.8.0-B190708 (pre-release) # Fix YAML options file discovery issue in dotted directory. #232 Fix comparison of wrapped types and null with Within . #237 PSRule options are now displayed as YAML instead of a complex object. #233 Added support for debug messages and Write-Debug in rule definitions. #146 Added Logging.LimitDebug and Logging.LimitVerbose options to limit logging to named scopes. #235 v0.7.0 # What's changed since v0.6.0: Fix reading nested arrays from JSON input. #223 Fix comparison of non-string types with Within . #226 Fix circular rule dependency issue. #190 Fix rule DependsOn parameter allows null. #191 Fix error message when attempting to use the rule keyword in a rule definition. #189 Fix TargetName binding when TargetName or Name property is null. #202 Fix handling of non-boolean results in rules. Rule is failed with more specific error message. #187 #224 Include .ps1 files that are specified directly with -Path , instead of only .Rule.ps1 files. #182 Improved warning message displayed when no Rule.ps1 files are founds. Added support for Invoke-PSRule to return CSV formatted results. #169 To generate CSV results use the -OutputFormat Csv parameter. Added Output.Path option to allow output to be saved directly to file. Added Output.Encoding option configure encoding used to write to file. By default, UTF-8 encoding without BOM is used. Invoke-PSRule cmdlet also provides a parameter -OutputPath to write results to file. Reordered cmdlet parameters to improve usage of frequently used parameters. #175 -Module parameter will tab-complete with imported rule modules. Added culture support for PowerShell informational messages. #158 A new $LocalizedData variable can be used within rule definitions. Added -Not switch to Within and Match keywords to allow negative comparison. #208 Improve discovery of rule tags. #209 Add wide format -OutputFormat Wide to Get-PSRule to allow output of rule tags. Breaking change : Changed rule filtering by tag to be case-insensitive. #204 Previously tag value was case-sensitive, however this is confusing since PowerShell is case-insensitive by default. Breaking change : Rule time is recorded in milliseconds instead of seconds. #192 What's changed since pre-release v0.7.0-B190664: No additional changes. v0.7.0-B190664 (pre-release) # Fix reading nested arrays from JSON input. #223 Fix comparison of non-string types with Within . #226 Improve handling of null rule result. #224 v0.7.0-B190652 (pre-release) # Fix TargetName binding when TargetName or Name property is null. #202 Add culture support for PowerShell informational messages. #158 A new $LocalizedData variable can be used within rule definitions. Add -Not switch to Within and Match keywords to allow negative comparison. #208 Improve discovery of rule tags. #209 Add wide format -OutputFormat Wide to Get-PSRule to allow output of rule tags. Breaking change : Change rule filtering by tag to be case-insensitive. #204 Previously tag value was case-sensitive, however this is confusing since PowerShell is case-insensitive by default. v0.7.0-B190633 (pre-release) # Fix circular rule dependency issue. #190 Fix rule DependsOn parameter allows null. #191 Fix error message when attempting to use the rule keyword in a rule definition. #189 Breaking change : Rule time is recorded in milliseconds instead of seconds. #192 v0.7.0-B190624 (pre-release) # Fix handling of non-boolean results in rules. Rule is failed with more specific error message. #187 Include .ps1 files that are specified directly with -Path , instead of only .rule.ps1 files. #182 Improved warning message displayed when no Rule.ps1 files are founds. v0.7.0-B190613 (pre-release) # Added support for Invoke-PSRule to return CSV formatted results. #169 To generate CSV results use the -OutputFormat Csv parameter. Added Output.Path option to allow output to be saved directly to file. Added Output.Encoding option configure encoding used to write to file. By default, UTF-8 encoding without BOM is used. Invoke-PSRule cmdlet also provides a parameter -OutputPath to write results to file. Reordered cmdlet parameters to improve usage of frequently used parameters. #175 -Module parameter will tab-complete with imported rule modules. v0.6.0 # What's changed since v0.5.0: Fix operation is not supported on this platform failure. #152 Fix FullName cannot be found on this object error. #149 Fix discovery of rules within paths that contain spaces fails. #168 Added rule documentation, which allows additional rule information to be stored in markdown files. #157 Rule documentation also adds culture support. #18 Rule documentation can be accessed like help with the Get-PSRuleHelp cmdlet. Added annotations, which are non-indexed metadata stored in rule documentation. #148 Annotations can contain a link to online version of the documentation. #147 Important change : Changed Hint keyword to Recommend to align with rule documentation. #165 Use of Hint keyword is deprecated and will be removed in a future release. Currently Hint is aliased to Recommend for compatibility. Breaking change : Changed rule properties to align with rule documentation. #164 Rule Synopsis , is a brief summary of the rule and Description is a detailed purpose of the rule. Description: metadata keyword used in comment help is now Synopsis: , use of Description: will set synopsis. Description metadata keyword is deprecated and will be removed in a future update. Output property Message on rule results is now Recommendation . What's changed since pre-release v0.6.0-B190627: Fix discovery of rules within paths that contain spaces fails. #168 Fix exporting of Recommend keyword and Hint alias. #171 v0.6.0-B190627 (pre-release) # Important change : Changed Hint keyword to Recommend to align with rule documentation. #165 Use of Hint keyword is deprecated and will be removed in a future release. Currently Hint is aliased to Recommend for compatibility. Breaking change : Changed rule properties to align with rule documentation. #164 Rule Synopsis , is a brief summary of the rule and Description is a detailed purpose of the rule. Description: metadata keyword used in comment help is now Synopsis: , use of Description: will set synopsis. Description metadata keyword is deprecated and will be removed in a future update. Output property Message on rule results is now Recommendation . v0.6.0-B190614 (pre-release) # Added rule documentation, which allows additional rule information to be stored in markdown files. #157 Rule documentation also adds culture support. #18 Rule documentation can be accessed like help with the Get-PSRuleHelp cmdlet. Added annotations, which are non-indexed metadata stored in rule documentation. #148 Annotations can contain a link to online version of the documentation. #147 v0.6.0-B190514 (pre-release) # Fix operation is not supported on this platform failure. #152 Fix FullName cannot be found on this object error. #149 v0.5.0 # What's changed since v0.4.0: Fix PSRule options schema usage of additionalProperties. #136 Fix null reference exception when traversing null field. #123 Fix missing help topics for options and variables. #125 Improved handling of default YAML options file. #137 Added support for Invoke-PSRule to return NUnit3 formatted results. #129 To generate NUnit3 results use the -OutputFormat NUnit3 parameter. Added Set-PSRuleOption cmdlet to configure YAML options file. #135 Added parameters to New-PSRuleOption to configure common options. #134 Additional parameters are an alternative to using a -Option hashtable. What's changed since pre-release v0.5.0-B190423: Fix schema conformance of -OutputFormat NUnit3 to NUnit report schema. #141 Fix PSRule options schema usage of additionalProperties. #136 v0.5.0-B190423 (pre-release) # Added support for Invoke-PSRule to return NUnit3 formatted results. #129 To generate NUnit3 results use the -OutputFormat NUnit3 parameter. Added Set-PSRuleOption cmdlet to configure YAML options file. #135 Added parameters to New-PSRuleOption to configure common options. #134 Additional parameters are an alternative to using a -Option hashtable. Improved handling of default YAML options file. #137 v0.5.0-B190405 (pre-release) # Fix null reference exception when traversing null field. #123 Fix missing help topics for options and variables. #125 v0.4.0 # What's changed since v0.3.0: Fix incorrect JSON de-serialization. #109 #111 Added support for using -InputPath instead of using -InputObject to handle serialized objects. #106 -Format is automatically detected for .yaml , .yml and .json file extensions. Added -OutputFormat parameter to serialize output from Invoke-PSRule as YAML or JSON. #29 Added support for logging pass or fail outcomes to a data stream such as Error, Warning or Information. #97 Breaking change : Deprecated usage of the -TargetName parameter on the Hint keyword has been removed. #81 What's changed since pre-release v0.4.0-B190328: No additional changes. v0.4.0-B190328 (pre-release) # Fix summary is not correctly serialized with JSON or YAML output format. #116 Fix missing properties on serialized YAML output. #115 Fix incorrect property name case of YAML serialized results. #114 v0.4.0-B190320 (pre-release) # Fix incorrect JSON de-serialization of nested arrays. #109 Fix incorrect JSON de-serialization of non-object arrays. #111 v0.4.0-B190311 (pre-release) # Added support for using -InputPath instead of using -InputObject to handle serialized objects. #106 -Format is automatically detected for .yaml , .yml and .json file extensions. Added -OutputFormat parameter to serialize output from Invoke-PSRule . #29 Added support for logging pass or fail outcomes to a data stream such as Error, Warning or Information. #97 Breaking change : Deprecated usage of the -TargetName parameter on the Hint keyword has been removed. #81 v0.3.0 # What's changed since v0.2.0: Added support for pipelining with Exists , Within , Match and TypeOf keywords #90 Added support for packaging rules in modules #16 Import objects from YAML or JSON format #75 Added support for input de-serialization from FileInfo objects #95 Support nested TargetObjects #77 Export variables to improve authoring experience #83 Binding improvements: Added object type binding and dynamic filtering for rules #82 Added support for indexed and quoted field names #86 Added support for case-sensitive binding operations #87 Binding ignores case by default. Set option Binding.CaseSensitive to true to enable case-sensitivity. Support TargetName binding of nested properties #71 Added online help links to keywords #72 Added schema for PSRule options #74 Important change : The -TargetName parameter of the Hint keyword has been deprecated #81 -TargetName parameter not longer sets the pipeline object TargetName and generates a warning instead. The -TargetName will be completely removed in v0.4.0 , at which time using the parameter will generate an error. Breaking change : Changed parameter alias for -Path from -f to -p #99 What's changed since pre-release v0.3.0-B190231: Added support for input de-serialization from FileInfo objects #95 Breaking change : Changed parameter alias for -Path from -f to -p #99 v0.3.0-B190231 (pre-release) # Added support for pipelining with Exists , Within , Match and TypeOf keywords #90 Fix empty YAML object causes format de-serialize to fail #92 v0.3.0-B190224 (pre-release) # Export variables to improve authoring experience #83 Added support for packaging rules in modules #16 Added support for indexed and quoted field names #86 Added object type binding and dynamic filtering for rules #82 Added support for case-sensitive binding operations #87 Binding ignores case by default. Set option Binding.CaseSensitive to true to enable case-sensitivity. Important change : The -TargetName parameter of the Hint keyword has been deprecated #81 -TargetName parameter not longer sets the pipeline object TargetName and generates a warning instead. The -TargetName will be completely removed in v0.4.0 , at which time using the parameter will generate an error. v0.3.0-B190208 (pre-release) # Added online help links to keywords #72 Added schema for PSRule options #74 Import objects from YAML or JSON format #75 Support TargetName binding of nested properties #71 Support nested TargetObjects #77 v0.2.0 # What's changed since v0.1.0: Added support for cross-platform environments (Windows, Linux and macOS) #49 Added support for nested field names with Exists , Within and Match keywords #60 Added support for rule configuration using baselines #17 Use rule description when hint message not set #61 Allow objects to be suppressed by TargetName for individual rules #13 Allow binding of TargetName to custom property #44 Custom functions can be used to bind TargetName #44 Objects that are unable to bind a TargetName will use a SHA1 object hash for TargetName #44 Added Test-PSRuleTarget command to return an overall $True or $False after evaluating rules for an object #30 Improve reporting of inconclusive results and objects that are not processed by any rule #46 Inconclusive results and objects not processed will return a warning by default. Fix propagation of informational messages to host from rule scripts and definitions #48 Fix Get-PSRule generates exception when no .rule.ps1 scripts exist in path #53 Fix LocalizedData.PathNotFound warning when no .rule.ps1 scripts exist in path #54 What's changed since pre-release v0.2.0-B190121: No additional changes. v0.2.0-B190121 (pre-release) # Added support for nested field names with Exists , Within and Match keywords #60 Added support for rule configuration using baselines #17 Use rule description when hint message not set #61 v0.2.0-B190113 (pre-release) # Fix Get-PSRule generates exception when no .rule.ps1 scripts exist in path #53 Fix LocalizedData.PathNotFound warning when no .rule.ps1 scripts exist in path #54 Breaking change : Renamed Test-PSRule cmdlet to Test-PSRuleTarget which aligns more closely to the verb-noun naming standard #57 v0.2.0-B190105 (pre-release) # Allow objects to be suppressed by TargetName for individual rules #13 Allow binding of TargetName to custom property #44 Custom functions can be used to bind TargetName #44 Objects that are unable to bind a TargetName will use a SHA1 object hash for TargetName #44 Added Test-PSRule command to return an overall $True or $False after evaluating rules for an object #30 Improve reporting of inconclusive results and objects that are not processed by any rule #46 Inconclusive results and objects not processed will return a warning by default. Fix propagation of informational messages to host from rule scripts and definitions #48 Added support for cross-platform environments (Windows, Linux and macOS) #49 v0.1.0 # Initial release What's changed since pre-release v0.1.0-B181235: Fix outcome filtering of summary results #33 Fix target object counter in verbose logging #35 Fix hashtable keys should be handled as fields #36 v0.1.0-B181235 (pre-release) # RuleId and RuleName are now independent. Rules are created with a name, and the RuleId is generated based on rule name and file name Rules with the same name can exist and be cross linked with DependsOn, as long a the script file name is different Added -Not to Exists keyword Improved verbose logging of Exists , AllOf , AnyOf keywords and core engine Breaking change : Renamed outcome filtering parameters to align to type name and increase clarity Invoke-PSRule has a -Outcome parameter instead of -Status -Outcome supports values of Pass , Fail , Error , None , Processed and All v0.1.0-B181222 (pre-release) # Added rule tags to results to enable grouping and sorting #14 Added support to check for rule tag existence. Use * for tag value on -Tag parameter with Invoke-PSRule and Get-PSRule Added option to report rule summary using -As parameter of Invoke-PSRule #12 v0.1.0-B181212 (pre-release) # Initial pre-release.","title":"v0"},{"location":"CHANGELOG-v0/#change-log","text":"See upgrade notes for helpful information when upgrading from previous versions. Attention PSRule v0 is a prior release. Please upgrade to the latest version.","title":"Change log"},{"location":"CHANGELOG-v0/#v0220","text":"What's changed since v0.21.0: Engine features: Added HasFields assertion helper to check all fields exist. #578 Updated HasField to check if any of the specified fields exist. #578 General improvements: Input format detection now includes .jsonc and .markdown file extensions. #575 Improved support for cross module rule dependencies. #248 Rule dependencies are now automatically imported. Bug fixes: Fixed handling for null or empty arrays with StartsWith , Contains , EndsWith , In , and NotIn . #579 What's changed since pre-release v0.22.0-B2010014: No additional changes.","title":"v0.22.0"},{"location":"CHANGELOG-v0/#v0220-b2010014-pre-release","text":"What's changed since v0.21.0: Engine features: Added HasFields assertion helper to check all fields exist. #578 Updated HasField to check if any of the specified fields exist. #578 General improvements: Input format detection now includes .jsonc and .markdown file extensions. #575 Improved support for cross module rule dependencies. #248 Rule dependencies are now automatically imported. Bug fixes: Fixed handling for null or empty arrays with StartsWith , Contains , EndsWith , In , and NotIn . #579","title":"v0.22.0-B2010014 (pre-release)"},{"location":"CHANGELOG-v0/#v0210","text":"What's changed since v0.20.0: Engine features: Added support for formatting results as markdown. #474 Use -OutputFormat Markdown or configure Output.Format to output markdown. To format as either detail or summary, use the -As parameter or configure Output.As . Added character case assertion helpers IsLower , and IsUpper . #555 IsLower checks that all letters in a field value are lowercase. IsUpper checks that all letters in a field value are uppercase. General improvements: Numerical strings can be converted with numeric assertion helpers. #550 Added outcome Output.Outcome as a configurable option. #552 Added help links and default snippets to schemas. #561 Improved rule error reporting by including rule and source location. #565 Engineering: Bump Manatee.Json from 13.0.2 to 13.0.3. #563 Bug fixes: Fixed NUnit report reasons should be escaped in markdown. #471 Fixed reporting of error when rule error is handled. #564 Additionally rules can use -ErrorAction Ignore to ignore non-exception errors. Fixed first exception stops other rules from being processed. #566 What's changed since pre-release v0.21.0-B2010010: No additional changes.","title":"v0.21.0"},{"location":"CHANGELOG-v0/#v0210-b2010010-pre-release","text":"What's changed since pre-release v0.21.0-B2010003: General improvements: Improved rule error reporting by including rule and source location. #565","title":"v0.21.0-B2010010 (pre-release)"},{"location":"CHANGELOG-v0/#v0210-b2010003-pre-release","text":"What's changed since pre-release v0.21.0-B2009016: General improvements: Added help links and default snippets to schemas. #561 Engineering: Bump Manatee.Json from 13.0.2 to 13.0.3. #563 Bug fixes: Fixed reporting of error when rule error is handled. #564 Additionally rules can use -ErrorAction Ignore to ignore non-exception errors. Fixed first exception stops other rules from being processed. #566","title":"v0.21.0-B2010003 (pre-release)"},{"location":"CHANGELOG-v0/#v0210-b2009016-pre-release","text":"What's changed since pre-release v0.21.0-B2009006: Engine features: Added character case assertion helpers IsLower , and IsUpper . #555 IsLower checks that all letters in a field value are lowercase. IsUpper checks that all letters in a field value are uppercase. Bug fixes: Fixed NUnit report reasons should be escaped in markdown. #471","title":"v0.21.0-B2009016 (pre-release)"},{"location":"CHANGELOG-v0/#v0210-b2009006-pre-release","text":"What's changed since v0.20.0: Engine features: Added support for formatting results as markdown. #474 Use -OutputFormat Markdown or configure Output.Format to output markdown. To format as either detail or summary, use the -As parameter or configure Output.As . General improvements: Numerical strings can be converted with numeric assertion helpers. #550 Added outcome Output.Outcome as a configurable option. #552","title":"v0.21.0-B2009006 (pre-release)"},{"location":"CHANGELOG-v0/#v0200","text":"What's changed since v0.19.0: Engine features: Added support for scanning repository files. #524 Added File input type ( -InputType File ) to scan for files without deserializing them. Added Input.PathIgnore option to ignore files. When using the File input type path specs in .gitignore are ignored. Added Get-PSRuleTarget cmdlet to read input files and return raw objects. #525 This cmdlet can be used to troubleshoot PSRule input issues. Baselines can now be flagged as obsolete. #499 Set the metadata.annotations.obsolete property to true to flag a baseline as obsolete. When an obsolete baseline is used, a warning will be generated. Added file assertion helpers FileHeader , and FilePath . #534 FileHeader checks for a comment header in the file. FilePath checks that a file path (optionally with suffixes) exist. General improvements: Added automatic binding for Rule object. #542 Engineering: Warn when deprecated $Rule properties are used. #536 #545 First usage of deprecated property generates a warning. Rule using deprecated property is flagged in debug output. Bump YamlDotNet dependency to v8.1.2. #439 Bug fixes: Fixed out of bounds exception when empty markdown documentation is used. #516 What's changed since pre-release v0.20.0-B2009013: Bug fixes: Fixed excessive obsolete property warnings. #545","title":"v0.20.0"},{"location":"CHANGELOG-v0/#v0200-b2009013-pre-release","text":"What's changed since pre-release v0.20.0-B2009007: General improvements: Added automatic binding for Rule object. #542 Bug fixes: Fixed InputFileInfo Type property causes downstream binding issues. #541","title":"v0.20.0-B2009013 (pre-release)"},{"location":"CHANGELOG-v0/#v0200-b2009007-pre-release","text":"What's changed since pre-release v0.20.0-B2008010: Engine features: Added file assertion helpers FileHeader , and FilePath . #534 FileHeader checks for a comment header in the file. FilePath checks that a file path (optionally with suffixes) exist. Engineering: Warn when deprecated $Rule properties are used. #536 Bug fixes: Fixed out of bounds exception when empty markdown documentation is used. #516 Fixed lines breaks in RepositoryInfo target name with git ref. #538","title":"v0.20.0-B2009007 (pre-release)"},{"location":"CHANGELOG-v0/#v0200-b2008010-pre-release","text":"What's changed since pre-release v0.20.0-B2008002: Engine features: Baselines can now be flagged as obsolete. #499 Set the metadata.annotations.obsolete property to true to flag a baseline as obsolete. When an obsolete baseline is used, a warning will be generated. Engineering: Bump YamlDotNet dependency to v8.1.2. #439","title":"v0.20.0-B2008010 (pre-release)"},{"location":"CHANGELOG-v0/#v0200-b2008002-pre-release","text":"What's changed since v0.19.0: Engine features: Added support for scanning repository files. #524 Added File input type ( -InputType File ) to scan for files without deserializing them. Added Input.PathIgnore option to ignore files. When using the File input type path specs in .gitignore are ignored. Added Get-PSRuleTarget cmdlet to read input files and return raw objects. #525 This cmdlet can be used to troubleshoot PSRule input issues.","title":"v0.20.0-B2008002 (pre-release)"},{"location":"CHANGELOG-v0/#v0190","text":"What's changed since v0.18.1: Engine features: Added Reason method to assertion results. #500 This new method, streamlines setting custom reasons particularly with formatted strings. The Reason method replaces any previously set reasons with a custom string. Optional arguments can be provided to be included in string formatting. Improvements to assertion methods. Added regular expression assertion helpers Match , and NotMatch . #502 Added collection assertion helpers In , and NotIn . #501 Added module version constraints. #498 The module versions that PSRule uses can be constrained. Bug fixes: Fixed styling for no rule files warning with Assert-PSRule . #484 Fixed actual value in reason for numeric comparison assertion method. #505 What's changed since pre-release v0.19.0-B2007030: No additional changes.","title":"v0.19.0"},{"location":"CHANGELOG-v0/#v0190-b2007030-pre-release","text":"Bug fixes: Fixed Assert.In unable to compare PSObject wrapped array items. #512","title":"v0.19.0-B2007030 (pre-release)"},{"location":"CHANGELOG-v0/#v0190-b2007023-pre-release","text":"Engine features: Added Reason method to assertion results. #500 This new method, streamlines setting custom reasons particularly with formatted strings. The Reason method replaces any previously set reasons with a custom string. Optional arguments can be provided to be included in string formatting. Improvements to assertion methods. Added regular expression assertion helpers Match , and NotMatch . #502 Added collection assertion helpers In , and NotIn . #501 Added module version constraints. #498 The module versions that PSRule uses can be constrained. Bug fixes: Fixed styling for no rule files warning with Assert-PSRule . #484 Fixed actual value in reason for numeric comparison assertion method. #505","title":"v0.19.0-B2007023 (pre-release)"},{"location":"CHANGELOG-v0/#v0181","text":"What's changed since v0.18.0: Bug fixes: Fixed unable to read properties for .NET DynamicObject . #491 Fixed read of JSON input format with null array item. #490 Fixed Csv output format with summary for Invoke-PSRule . #486","title":"v0.18.1"},{"location":"CHANGELOG-v0/#v0190-b2006027-pre-release","text":"Bug fixes: Fixed unable to read properties for .NET DynamicObject . #491 Fixed read of JSON input format with null array item. #490","title":"v0.19.0-B2006027 (pre-release)"},{"location":"CHANGELOG-v0/#v0190-b2006018-pre-release","text":"Bug fixes: Fixed Csv output format with summary for Invoke-PSRule . #486","title":"v0.19.0-B2006018 (pre-release)"},{"location":"CHANGELOG-v0/#v0180","text":"What's changed since v0.17.0: General improvements: Improved Assert-PSRule output formatting. #472 Added recommendation and reasons for AzurePipelines and GitHubActions styles. Summary line is has been updated to include synopsis instead of reasons. Bug fixes: Fixed binding with ModuleConfig . #468 Fixed recommendation output with client style. #467 What's changed since pre-release v0.18.0-B2005015: No additional changes.","title":"v0.18.0"},{"location":"CHANGELOG-v0/#v0180-b2005015-pre-release","text":"General improvements: Improved Assert-PSRule output formatting. #472 Added recommendation and reasons for AzurePipelines and GitHubActions styles. Summary line is has been updated to include synopsis instead of reasons. Bug fixes: Fixed binding with ModuleConfig . #468 Fixed recommendation output with client style. #467","title":"v0.18.0-B2005015 (pre-release)"},{"location":"CHANGELOG-v0/#v0170","text":"What's changed since v0.16.0: General improvements: Improved Assert-PSRule output formatting. Added recommendation and reasons for Client and Plain styles. #456 Added support for configuration of default module options. #459 binding and configuration options can be set to a default value. Updated New-PSRuleOption parameter sets and help based on updates to module config. Added support for module fallback culture. #441 Bug fixes: Fixed resource schema to include useQualifiedName and nameSeparator option. #458 What's changed since pre-release v0.17.0-B2005010: No additional changes.","title":"v0.17.0"},{"location":"CHANGELOG-v0/#v0170-b2005010-pre-release","text":"General improvements: Improved Assert-PSRule output formatting. Added recommendation and reasons for Client and Plain styles. #456 Added support for configuration of default module options. #459 binding and configuration options can be set to a default value. Updated New-PSRuleOption parameter sets and help based on updates to module config. Added support for module fallback culture. #441 Bug fixes: Fixed resource schema to include useQualifiedName and nameSeparator option. #458","title":"v0.17.0-B2005010 (pre-release)"},{"location":"CHANGELOG-v0/#v0160","text":"What's changed since v0.15.0: General improvements: Added configuration option Output.Culture for setting culture. #442 Improved handling of fields to allow the input object to be referenced with . . #437 Bug fixes: Fixed numeric comparison assertion with non-int types. #436 Fixed output culture option ignored. #449 What's changed since pre-release v0.16.0-B2003027: No additional changes.","title":"v0.16.0"},{"location":"CHANGELOG-v0/#v0160-b2003027-pre-release","text":"Bug fixes: Fixed output culture option ignored. #449","title":"v0.16.0-B2003027 (pre-release)"},{"location":"CHANGELOG-v0/#v0160-b2003022-pre-release","text":"General improvements: Added configuration option Output.Culture for setting culture. #442 Improved handling of fields to allow the input object to be referenced with . . #437 Bug fixes: Fixed numeric comparison assertion with non-int types. #436","title":"v0.16.0-B2003022 (pre-release)"},{"location":"CHANGELOG-v0/#v0150","text":"What's changed since v0.14.0: Engine features: Added -ResultVariable to store results from Assert-PSRule into a variable. #412 General improvements: Added recommendation to failure message of NUnit results. #421 Bug fixes: Fixed handling of v in field value with $Assert.Version . #429 Fixed handling of warning action preference with Assert-PSRule . #428 Fixed parent culture unwind with POSIX. #414 Fixed output of warning with Assert-PSRule . #417 Fixed NUnit report to include a failure element when reason is not specified. #420 What's changed since pre-release v0.15.0-B2002031: No additional changes.","title":"v0.15.0"},{"location":"CHANGELOG-v0/#v0150-b2002031-pre-release","text":"Fixed handling of v in field value with $Assert.Version . #429 Fixed handling of warning action preference with Assert-PSRule . #428","title":"v0.15.0-B2002031 (pre-release)"},{"location":"CHANGELOG-v0/#v0150-b2002019-pre-release","text":"Added -ResultVariable to store results from Assert-PSRule into a variable. #412","title":"v0.15.0-B2002019 (pre-release)"},{"location":"CHANGELOG-v0/#v0150-b2002012-pre-release","text":"Fixed output of warning with Assert-PSRule . #417 Fixed NUnit report to include a failure element when reason is not specified. #420 Added recommendation to failure message of NUnit results. #421","title":"v0.15.0-B2002012 (pre-release)"},{"location":"CHANGELOG-v0/#v0150-b2002005-pre-release","text":"Fixed parent culture unwind with POSIX. #414","title":"v0.15.0-B2002005 (pre-release)"},{"location":"CHANGELOG-v0/#v0140","text":"What's changed since v0.13.0: Engine features: Added support for qualified target names. #395 Added options Binding.UseQualifiedName and Binding.NameSeparator . See about_PSRule_Options for details. Added assertion method HasJsonSchema to check if a JSON schema is referenced. #398 See about_PSRule_Assert for usage details. Added file content helper for reading objects from files. #399 The method GetContent of $PSRule can be used to read files as objects. See about_PSRule_Variables for usage details. General improvements: Improved reporting on runtime errors in rule blocks. #239 Improved NUnit results to include a failure message based on reported reasons. #404 Bug fixes: Fixed wide formatting of rules with Get-PSRule . #407 Fixed TargetName hash serialization for base types. #406 Fixed output not generated with Assert-PSRule and Stop. #405 Fixed NUnit results incorrectly reporting that the test had not executed. #403 What's changed since pre-release v0.14.0-B2002003: No additional changes","title":"v0.14.0"},{"location":"CHANGELOG-v0/#v0140-b2002003-pre-release","text":"Fixed wide formatting of rules with Get-PSRule . #407 Fixed TargetName hash serialization for base types. #406 Fixed output not generated with Assert-PSRule and Stop. #405 Fixed NUnit results incorrectly reporting that the test had not executed. #403 Improved NUnit results to include a failure message based on reported reasons. #404 Improved reporting on runtime errors in rule blocks. #239","title":"v0.14.0-B2002003 (pre-release)"},{"location":"CHANGELOG-v0/#v0140-b2001020-pre-release","text":"Added support for qualified target names. #395 Added options Binding.UseQualifiedName and Binding.NameSeparator . See about_PSRule_Options for details. Added assertion method HasJsonSchema to check if a JSON schema is referenced. #398 See about_PSRule_Assert for usage details. Added file content helper for reading objects from files. #399 The method GetContent of $PSRule can be used to read files as objects. See about_PSRule_Variables for usage details.","title":"v0.14.0-B2001020 (pre-release)"},{"location":"CHANGELOG-v0/#v0130","text":"What's changed since v0.12.0: Engine features: Improvements to rule help and documentation. #382 #316 Added links and notes sections to help. Added -Full switch to Get-PSRuleHelp to display links and notes sections. Added support for using a parent culture in rule help. Rule help will use parent culture when a more specific culture is not available. Added input format for reading PowerShell data .psd1 files. #368 PowerShellData has been added to Input.Format . See about_PSRule_Options for details. Added custom rule data to results. #322 $PSRule.Data can be used to set custom data during rule execution that is included in output. See about_PSRule_Variables for usage details. Improvements to assertion methods. #386 #374 #387 #344 #353 #357 Added support for assertion methods to be used within script pre-conditions. Added numeric comparison assertion helpers Greater , GreaterOrEqual , Less and LessOrEqual . Added semantic version assertion helper Version . Added string affix assertion helpers StartsWith , EndsWith and Contains . See about_PSRule_Assert for usage details. Improvements to output logging and formatting for Assert-PSRule . Formatting now includes errors and warnings using style. Added PSRule banner with module information. Added rule success summary. General improvements: Added aliases for -OutputFormat ( -o ) and -Module ( -m ) parameters. #384 Added WithReason to append/ replace reasons from assertion result. #354 Added configuration helper for strings arrays. #363 Bug fixes: Fixed JSON de-serialization fails with single object. #379 Fixed stack overflow when parsing malformed JSON. #380 What's changed since pre-release v0.13.0-B2001013: No additional changes.","title":"v0.13.0"},{"location":"CHANGELOG-v0/#v0130-b2001013-pre-release","text":"Fixed JSON de-serialization fails with single object. #379 Fixed stack overflow when parsing malformed JSON. #380 Added rule documentation links and notes to help. #382 Added -Full switch to Get-PSRuleHelp to display links and notes sections. Added aliases for -OutputFormat ( -o ) and -Module ( -m ) parameters. #384 Improved numeric comparison assertion helpers to support strings. #387 Methods Greater , GreaterOrEqual , Less and LessOrEqual now also check string length. Added support for assertion methods to be used within script pre-conditions. #386","title":"v0.13.0-B2001013 (pre-release)"},{"location":"CHANGELOG-v0/#v0130-b1912043-pre-release","text":"Added input format for reading PowerShell data .psd1 files. #368 PowerShellData has been added to Input.Format . See about_PSRule_Options for details. Added numeric comparison assertion helpers. #374 Added methods Greater , GreaterOrEqual , Less and LessOrEqual . See about_PSRule_Assert for usage details.","title":"v0.13.0-B1912043 (pre-release)"},{"location":"CHANGELOG-v0/#v0130-b1912027-pre-release","text":"Added configuration helper for strings arrays. #363 Added support for using a parent culture in rule help. #316 Rule help will use parent culture when a more specific culture is not available. Added custom rule data to results. #322 $PSRule.Data can be used to set custom data during rule execution that is included in output. See about_PSRule_Variables for usage details.","title":"v0.13.0-B1912027 (pre-release)"},{"location":"CHANGELOG-v0/#v0130-b1912012-pre-release","text":"Improves output logging and formatting for Assert-PSRule. #357 Formatting now includes errors and warnings using style. Added PSRule banner with module information. Added rule success summary.","title":"v0.13.0-B1912012 (pre-release)"},{"location":"CHANGELOG-v0/#v0130-b1912005-pre-release","text":"Added semantic version assertion helper Version . #344 Added string affix assertion helpers. #353 Added methods StartsWith , EndsWith and Contains . See about_PSRule_Assert for usage details. Added WithReason to append/ replace reasons from assertion result. #354","title":"v0.13.0-B1912005 (pre-release)"},{"location":"CHANGELOG-v0/#v0120","text":"What's changed since v0.11.0: Engine features: Added -All option to Exists keyword. #331 Added custom field binding. #321 Added new option Binding.Field available in baselines to configure binding. General improvements: Added filtering for rules against a baseline with Get-PSRule . #345 Added parameter alias -f for -InputPath . #340 -f was added to Invoke-PSRule , Assert-PSRule and Test-PSRuleTarget cmdlets. Important change : Added $PSRule generic context variable. #341 Deprecated TargetName , TargetType and TargetObject properties on $Rule . Use TargetName , TargetType and TargetObject on $PSRule instead. Properties TargetName , TargetType and TargetObject on $Rule will be removed in the future. Going forward $Rule will only contain properties that relate to the current rule context. Bug fixes: Fixed key has already been added for default baseline. #349 Fixed multiple value tag filtering. #346 Fixed TargetType fall back to type name. #339 Fixed NUnit serialization issue for unprocessed rules. #332 What's changed since pre-release v0.12.0-B1912007: Fixed key has already been added for default baseline. #349","title":"v0.12.0"},{"location":"CHANGELOG-v0/#v0120-b1912007-pre-release","text":"Fixed multiple value tag filtering. #346 Added filtering for rules against a baseline with Get-PSRule . #345","title":"v0.12.0-B1912007 (pre-release)"},{"location":"CHANGELOG-v0/#v0120-b1912002-pre-release","text":"Fixed TargetType fall back to type name. #339 Added custom field binding. #321 Added new option Binding.Field available in baselines to configure binding. Added parameter alias -f for -InputPath . #340 -f was added to Invoke-PSRule , Assert-PSRule and Test-PSRuleTarget cmdlets. Important change : Added $PSRule generic context variable. #341 Deprecated TargetName , TargetType and TargetObject properties on $Rule . Use TargetName , TargetType and TargetObject on $PSRule instead. Properties TargetName , TargetType and TargetObject on $Rule will be removed in the future. Going forward $Rule will only contain properties that relate to the current rule context.","title":"v0.12.0-B1912002 (pre-release)"},{"location":"CHANGELOG-v0/#v0120-b1911013-pre-release","text":"Fixed NUnit serialization issue for unprocessed rules. #332 Added -All option to Exists keyword. #331","title":"v0.12.0-B1911013 (pre-release)"},{"location":"CHANGELOG-v0/#v0110","text":"What's changed since v0.10.0: General improvements: Added -TargetType parameter to filter input objects by target type. #176 This parameter applies to Invoke-PSRule , Assert-PSRule and Test-PSRuleTarget . Bug fixes: Fixed null reference exception when bound property is null. #323 Fixed missing Markdown input format in options schema. #315 Breaking change : Unprocessed object results are not returned from Test-PSRuleTarget by default. #318 Previously unprocessed objects returned $True , now unprocessed objects return no result. Use -Outcome All to return $True for unprocessed objects the same as <= v0.10.0. What's changed since pre-release v0.11.0-B1911002: No additional changes.","title":"v0.11.0"},{"location":"CHANGELOG-v0/#v0110-b1911002-pre-release","text":"Fixed null reference exception when bound property is null. #323","title":"v0.11.0-B1911002 (pre-release)"},{"location":"CHANGELOG-v0/#v0110-b1910014-pre-release","text":"Fixed missing Markdown input format in options schema. #315 Added -TargetType parameter to filter input objects by target type. #176 This parameter applies to Invoke-PSRule , Assert-PSRule and Test-PSRuleTarget . Breaking change : Unprocessed object results are not returned from Test-PSRuleTarget by default. #318 Previously unprocessed objects returned $True , now unprocessed objects return no result. Use -Outcome All to return $True for unprocessed objects the same as <= v0.10.0.","title":"v0.11.0-B1910014 (pre-release)"},{"location":"CHANGELOG-v0/#v0100","text":"What's changed since v0.9.0: General improvements: Added source note properties to input objects read from disk with -InputPath . #302 Engine features: Added assertion helper for checking field default value. #289 Added dependency DependsOn information to results from Get-PSRule . #210 To include dependencies that would normally be filtered out use -IncludeDependencies . Added input format for reading markdown front matter. #301 Markdown front matter is deserialized and evaluated as an object. Added Assert-PSRule cmdlet to improve integration into CI processes. #290 Added Output.Style option to support output in the following styles: Client/ Plain - Output returns easy to read log of rule pass/ fail. Azure Pipelines - Report rule failures as errors collected by Azure Pipelines. GitHub Actions - Reports rule failures as errors collected by GitHub Actions. Bug fixes: Fix Get-PSRuleHelp -Online in constrained language mode. #296 Breaking change : Removed previously deprecated alias Hint for Recommend . #165 Use the Recommend keyword instead. What's changed since pre-release v0.10.0-B1910036: No additional changes.","title":"v0.10.0"},{"location":"CHANGELOG-v0/#v0100-b1910036-pre-release","text":"Added dependency DependsOn information to results from Get-PSRule . #210 To include dependencies that would normally be filtered out use -IncludeDependencies . Added input format for reading markdown front matter. #301 Markdown front matter is deserialized and evaluated as an object. Added source note properties to input objects read from disk with -InputPath . #302 Breaking change : Removed previously deprecated alias Hint for Recommend . #165 Use the Recommend keyword instead.","title":"v0.10.0-B1910036 (pre-release)"},{"location":"CHANGELOG-v0/#v0100-b1910025-pre-release","text":"Fix Get-PSRuleHelp -Online in constrained language mode. #296 Added Assert-PSRule cmdlet to improve integration into CI processes. #290 Added Output.Style option to support output in the following styles: Client/ Plain - Output returns easy to read log of rule pass/ fail. Azure Pipelines - Report rule failures as errors collected by Azure Pipelines. GitHub Actions - Reports rule failures as errors collected by GitHub Actions.","title":"v0.10.0-B1910025 (pre-release)"},{"location":"CHANGELOG-v0/#v0100-b1910011-pre-release","text":"Added assertion helper for checking field default value. #289","title":"v0.10.0-B1910011 (pre-release)"},{"location":"CHANGELOG-v0/#v090","text":"What's changed since v0.8.0: General improvements: Improve feedback of parsing errors. #185 Updated Get-PSRuleHelp to include help within the current path by default. #197 Engine features: Added support for a wildcard match using the Within keyword. #272 Added rule info display name. #276 Added support for matching an array of tag values. #282 Added named baselines. Now baselines are a separate resource that can be individually used. Baselines can be packaged within module. Modules can specify a default baseline in module manifest. Target binding options ( Binding ) are now part of baselines. See about_PSRule_Baseline for more information. Bug fixes: Fix can not serialize nested System.IO.DirectoryInfo property. #281 Fix ModuleName not displayed in Get-PSRuleHelp list. #275 Fix outcome reported when error or exception is raised. #211 Breaking change : Baseline improvements, fundamentally changes how baselines work. #274 Previously, baselines were specified as workspace options. The previous baseline options property has been renamed to rule . The previous configuration property is now a top level option. What's changed since pre-release v0.9.0-B190905: No additional changes","title":"v0.9.0"},{"location":"CHANGELOG-v0/#v090-b190905-pre-release","text":"Added support for matching an array of tag values. #282 Updated Get-PSRuleHelp to include help within the current path by default. #197 Fix can not serialize nested System.IO.DirectoryInfo property. #281 Fix export of Like parameter for Within keyword. #279 Breaking change : Added named baselines. This changes how baselines work. #274 Previously, baselines were specified as workspace options. Now, baselines are a separate resource that can be individually used. Additionally: Baselines can be packaged within module. Modules can specify a default baseline in module manifest. Target binding options ( Binding ) are now part of baselines. The previous baseline options property has been renamed to rule . The previous configuration property is now a top level option. See about_PSRule_Baseline for more information.","title":"v0.9.0-B190905 (pre-release)"},{"location":"CHANGELOG-v0/#v090-b190819-pre-release","text":"Added support for a wildcard match using the Within keyword. #272 Added rule info display name. #276 Fix ModuleName not displayed in Get-PSRuleHelp list. #275","title":"v0.9.0-B190819 (pre-release)"},{"location":"CHANGELOG-v0/#v090-b190810-pre-release","text":"Improve feedback of parsing errors. #185 Fix outcome reported when error or exception is raised. #211","title":"v0.9.0-B190810 (pre-release)"},{"location":"CHANGELOG-v0/#v080","text":"What's changed since v0.7.0: General improvements: PSRule options are now displayed as YAML instead of a complex object. #233 Add detection for improper keyword use. #203 Automatically load rule modules. #218 Added support for debug messages and Write-Debug in rule definitions. #146 Added Logging.LimitDebug and Logging.LimitVerbose options to limit logging to named scopes. #235 Engine features: Added per object reason for failing rules. #200 Keywords Exists , Match , Within and TypeOf automatically add a reason when they fail. Custom reason can be set for keywords Exists , Match , Within and TypeOf with -Reason . Added Reason keyword to add to reason for custom logic. Added wide output display for Invoke-PSRule which include the reason why rule failed. To use wide output use the -OutputFormat Wide parameter. Renamed -Message parameter to -Text on the Recommend keyword. The -Message is an alias of -Text and will be deprecated in the future. Added assertion helper $Assert for extensibility. #250 Add built-in assertions for HasField , HasFieldValue and NullOrEmpty . Add JSON schema assertion method JsonSchema . #42 Bug fixes: Fix rule synopsis comment capture. #214 Fix YAML options file discovery issue in dotted directory. #232 Fix comparison of wrapped types and null with Within . #237 Breaking change : Use rule references consistent with cmdlet fully qualified syntax. #217 Rule names have to be unique within the current execution path or within a module. Previously rule names only had to be unique within a single file. Previously the filename.rule.ps1/RuleName was required to reference rules across files. This is no longer required because rule names are unique. You can reference a rule from a loaded module by using the syntax ModuleName\\RuleName . What's changed since pre-release v0.8.0-B190806: Fix export of assertion helper variable $Assert . #262","title":"v0.8.0"},{"location":"CHANGELOG-v0/#v080-b190806-pre-release","text":"Fix module reloading with different versions. #254 Fix not finding rules in current path by default. #256 Fix rule synopsis comment capture. #214","title":"v0.8.0-B190806 (pre-release)"},{"location":"CHANGELOG-v0/#v080-b190742-pre-release","text":"Fix inconsistent handling of $PWD . #249 Add detection for improper keyword use. #203 Automatically load rule modules. #218 Added assertion helper $Assert for extensibility. #250 Add built-in assertions for HasField , HasFieldValue and NullOrEmpty . Add JSON schema assertion method JsonSchema . #42 Breaking change : Use rule references consistent with cmdlet fully qualified syntax. #217 Rule names have to be unique within the current execution path or within a module. Previously rule names only had to be unique within a single file. Previously the filename.rule.ps1/RuleName was required to reference rules across files. This is no longer required because rule names are unique. You can reference a rule from a loaded module by using the syntax ModuleName\\RuleName .","title":"v0.8.0-B190742 (pre-release)"},{"location":"CHANGELOG-v0/#v080-b190716-pre-release","text":"Added per object reason for failing rules. #200 The keywords Exists , Match , Within and TypeOf automatically add a reason when they fail. Added -Reason parameter to Exists , Match , Within and TypeOf keywords to allow a custom reason to be set. Added Reason keyword to add to reason for custom logic. Added wide output display for Invoke-PSRule which include the reason why rule failed. To use wide output use the -OutputFormat Wide parameter. Renamed -Message parameter to -Text on the Recommend keyword. The -Message is an alias of -Text and will be deprecated in the future.","title":"v0.8.0-B190716 (pre-release)"},{"location":"CHANGELOG-v0/#v080-b190708-pre-release","text":"Fix YAML options file discovery issue in dotted directory. #232 Fix comparison of wrapped types and null with Within . #237 PSRule options are now displayed as YAML instead of a complex object. #233 Added support for debug messages and Write-Debug in rule definitions. #146 Added Logging.LimitDebug and Logging.LimitVerbose options to limit logging to named scopes. #235","title":"v0.8.0-B190708 (pre-release)"},{"location":"CHANGELOG-v0/#v070","text":"What's changed since v0.6.0: Fix reading nested arrays from JSON input. #223 Fix comparison of non-string types with Within . #226 Fix circular rule dependency issue. #190 Fix rule DependsOn parameter allows null. #191 Fix error message when attempting to use the rule keyword in a rule definition. #189 Fix TargetName binding when TargetName or Name property is null. #202 Fix handling of non-boolean results in rules. Rule is failed with more specific error message. #187 #224 Include .ps1 files that are specified directly with -Path , instead of only .Rule.ps1 files. #182 Improved warning message displayed when no Rule.ps1 files are founds. Added support for Invoke-PSRule to return CSV formatted results. #169 To generate CSV results use the -OutputFormat Csv parameter. Added Output.Path option to allow output to be saved directly to file. Added Output.Encoding option configure encoding used to write to file. By default, UTF-8 encoding without BOM is used. Invoke-PSRule cmdlet also provides a parameter -OutputPath to write results to file. Reordered cmdlet parameters to improve usage of frequently used parameters. #175 -Module parameter will tab-complete with imported rule modules. Added culture support for PowerShell informational messages. #158 A new $LocalizedData variable can be used within rule definitions. Added -Not switch to Within and Match keywords to allow negative comparison. #208 Improve discovery of rule tags. #209 Add wide format -OutputFormat Wide to Get-PSRule to allow output of rule tags. Breaking change : Changed rule filtering by tag to be case-insensitive. #204 Previously tag value was case-sensitive, however this is confusing since PowerShell is case-insensitive by default. Breaking change : Rule time is recorded in milliseconds instead of seconds. #192 What's changed since pre-release v0.7.0-B190664: No additional changes.","title":"v0.7.0"},{"location":"CHANGELOG-v0/#v070-b190664-pre-release","text":"Fix reading nested arrays from JSON input. #223 Fix comparison of non-string types with Within . #226 Improve handling of null rule result. #224","title":"v0.7.0-B190664 (pre-release)"},{"location":"CHANGELOG-v0/#v070-b190652-pre-release","text":"Fix TargetName binding when TargetName or Name property is null. #202 Add culture support for PowerShell informational messages. #158 A new $LocalizedData variable can be used within rule definitions. Add -Not switch to Within and Match keywords to allow negative comparison. #208 Improve discovery of rule tags. #209 Add wide format -OutputFormat Wide to Get-PSRule to allow output of rule tags. Breaking change : Change rule filtering by tag to be case-insensitive. #204 Previously tag value was case-sensitive, however this is confusing since PowerShell is case-insensitive by default.","title":"v0.7.0-B190652 (pre-release)"},{"location":"CHANGELOG-v0/#v070-b190633-pre-release","text":"Fix circular rule dependency issue. #190 Fix rule DependsOn parameter allows null. #191 Fix error message when attempting to use the rule keyword in a rule definition. #189 Breaking change : Rule time is recorded in milliseconds instead of seconds. #192","title":"v0.7.0-B190633 (pre-release)"},{"location":"CHANGELOG-v0/#v070-b190624-pre-release","text":"Fix handling of non-boolean results in rules. Rule is failed with more specific error message. #187 Include .ps1 files that are specified directly with -Path , instead of only .rule.ps1 files. #182 Improved warning message displayed when no Rule.ps1 files are founds.","title":"v0.7.0-B190624 (pre-release)"},{"location":"CHANGELOG-v0/#v070-b190613-pre-release","text":"Added support for Invoke-PSRule to return CSV formatted results. #169 To generate CSV results use the -OutputFormat Csv parameter. Added Output.Path option to allow output to be saved directly to file. Added Output.Encoding option configure encoding used to write to file. By default, UTF-8 encoding without BOM is used. Invoke-PSRule cmdlet also provides a parameter -OutputPath to write results to file. Reordered cmdlet parameters to improve usage of frequently used parameters. #175 -Module parameter will tab-complete with imported rule modules.","title":"v0.7.0-B190613 (pre-release)"},{"location":"CHANGELOG-v0/#v060","text":"What's changed since v0.5.0: Fix operation is not supported on this platform failure. #152 Fix FullName cannot be found on this object error. #149 Fix discovery of rules within paths that contain spaces fails. #168 Added rule documentation, which allows additional rule information to be stored in markdown files. #157 Rule documentation also adds culture support. #18 Rule documentation can be accessed like help with the Get-PSRuleHelp cmdlet. Added annotations, which are non-indexed metadata stored in rule documentation. #148 Annotations can contain a link to online version of the documentation. #147 Important change : Changed Hint keyword to Recommend to align with rule documentation. #165 Use of Hint keyword is deprecated and will be removed in a future release. Currently Hint is aliased to Recommend for compatibility. Breaking change : Changed rule properties to align with rule documentation. #164 Rule Synopsis , is a brief summary of the rule and Description is a detailed purpose of the rule. Description: metadata keyword used in comment help is now Synopsis: , use of Description: will set synopsis. Description metadata keyword is deprecated and will be removed in a future update. Output property Message on rule results is now Recommendation . What's changed since pre-release v0.6.0-B190627: Fix discovery of rules within paths that contain spaces fails. #168 Fix exporting of Recommend keyword and Hint alias. #171","title":"v0.6.0"},{"location":"CHANGELOG-v0/#v060-b190627-pre-release","text":"Important change : Changed Hint keyword to Recommend to align with rule documentation. #165 Use of Hint keyword is deprecated and will be removed in a future release. Currently Hint is aliased to Recommend for compatibility. Breaking change : Changed rule properties to align with rule documentation. #164 Rule Synopsis , is a brief summary of the rule and Description is a detailed purpose of the rule. Description: metadata keyword used in comment help is now Synopsis: , use of Description: will set synopsis. Description metadata keyword is deprecated and will be removed in a future update. Output property Message on rule results is now Recommendation .","title":"v0.6.0-B190627 (pre-release)"},{"location":"CHANGELOG-v0/#v060-b190614-pre-release","text":"Added rule documentation, which allows additional rule information to be stored in markdown files. #157 Rule documentation also adds culture support. #18 Rule documentation can be accessed like help with the Get-PSRuleHelp cmdlet. Added annotations, which are non-indexed metadata stored in rule documentation. #148 Annotations can contain a link to online version of the documentation. #147","title":"v0.6.0-B190614 (pre-release)"},{"location":"CHANGELOG-v0/#v060-b190514-pre-release","text":"Fix operation is not supported on this platform failure. #152 Fix FullName cannot be found on this object error. #149","title":"v0.6.0-B190514 (pre-release)"},{"location":"CHANGELOG-v0/#v050","text":"What's changed since v0.4.0: Fix PSRule options schema usage of additionalProperties. #136 Fix null reference exception when traversing null field. #123 Fix missing help topics for options and variables. #125 Improved handling of default YAML options file. #137 Added support for Invoke-PSRule to return NUnit3 formatted results. #129 To generate NUnit3 results use the -OutputFormat NUnit3 parameter. Added Set-PSRuleOption cmdlet to configure YAML options file. #135 Added parameters to New-PSRuleOption to configure common options. #134 Additional parameters are an alternative to using a -Option hashtable. What's changed since pre-release v0.5.0-B190423: Fix schema conformance of -OutputFormat NUnit3 to NUnit report schema. #141 Fix PSRule options schema usage of additionalProperties. #136","title":"v0.5.0"},{"location":"CHANGELOG-v0/#v050-b190423-pre-release","text":"Added support for Invoke-PSRule to return NUnit3 formatted results. #129 To generate NUnit3 results use the -OutputFormat NUnit3 parameter. Added Set-PSRuleOption cmdlet to configure YAML options file. #135 Added parameters to New-PSRuleOption to configure common options. #134 Additional parameters are an alternative to using a -Option hashtable. Improved handling of default YAML options file. #137","title":"v0.5.0-B190423 (pre-release)"},{"location":"CHANGELOG-v0/#v050-b190405-pre-release","text":"Fix null reference exception when traversing null field. #123 Fix missing help topics for options and variables. #125","title":"v0.5.0-B190405 (pre-release)"},{"location":"CHANGELOG-v0/#v040","text":"What's changed since v0.3.0: Fix incorrect JSON de-serialization. #109 #111 Added support for using -InputPath instead of using -InputObject to handle serialized objects. #106 -Format is automatically detected for .yaml , .yml and .json file extensions. Added -OutputFormat parameter to serialize output from Invoke-PSRule as YAML or JSON. #29 Added support for logging pass or fail outcomes to a data stream such as Error, Warning or Information. #97 Breaking change : Deprecated usage of the -TargetName parameter on the Hint keyword has been removed. #81 What's changed since pre-release v0.4.0-B190328: No additional changes.","title":"v0.4.0"},{"location":"CHANGELOG-v0/#v040-b190328-pre-release","text":"Fix summary is not correctly serialized with JSON or YAML output format. #116 Fix missing properties on serialized YAML output. #115 Fix incorrect property name case of YAML serialized results. #114","title":"v0.4.0-B190328 (pre-release)"},{"location":"CHANGELOG-v0/#v040-b190320-pre-release","text":"Fix incorrect JSON de-serialization of nested arrays. #109 Fix incorrect JSON de-serialization of non-object arrays. #111","title":"v0.4.0-B190320 (pre-release)"},{"location":"CHANGELOG-v0/#v040-b190311-pre-release","text":"Added support for using -InputPath instead of using -InputObject to handle serialized objects. #106 -Format is automatically detected for .yaml , .yml and .json file extensions. Added -OutputFormat parameter to serialize output from Invoke-PSRule . #29 Added support for logging pass or fail outcomes to a data stream such as Error, Warning or Information. #97 Breaking change : Deprecated usage of the -TargetName parameter on the Hint keyword has been removed. #81","title":"v0.4.0-B190311 (pre-release)"},{"location":"CHANGELOG-v0/#v030","text":"What's changed since v0.2.0: Added support for pipelining with Exists , Within , Match and TypeOf keywords #90 Added support for packaging rules in modules #16 Import objects from YAML or JSON format #75 Added support for input de-serialization from FileInfo objects #95 Support nested TargetObjects #77 Export variables to improve authoring experience #83 Binding improvements: Added object type binding and dynamic filtering for rules #82 Added support for indexed and quoted field names #86 Added support for case-sensitive binding operations #87 Binding ignores case by default. Set option Binding.CaseSensitive to true to enable case-sensitivity. Support TargetName binding of nested properties #71 Added online help links to keywords #72 Added schema for PSRule options #74 Important change : The -TargetName parameter of the Hint keyword has been deprecated #81 -TargetName parameter not longer sets the pipeline object TargetName and generates a warning instead. The -TargetName will be completely removed in v0.4.0 , at which time using the parameter will generate an error. Breaking change : Changed parameter alias for -Path from -f to -p #99 What's changed since pre-release v0.3.0-B190231: Added support for input de-serialization from FileInfo objects #95 Breaking change : Changed parameter alias for -Path from -f to -p #99","title":"v0.3.0"},{"location":"CHANGELOG-v0/#v030-b190231-pre-release","text":"Added support for pipelining with Exists , Within , Match and TypeOf keywords #90 Fix empty YAML object causes format de-serialize to fail #92","title":"v0.3.0-B190231 (pre-release)"},{"location":"CHANGELOG-v0/#v030-b190224-pre-release","text":"Export variables to improve authoring experience #83 Added support for packaging rules in modules #16 Added support for indexed and quoted field names #86 Added object type binding and dynamic filtering for rules #82 Added support for case-sensitive binding operations #87 Binding ignores case by default. Set option Binding.CaseSensitive to true to enable case-sensitivity. Important change : The -TargetName parameter of the Hint keyword has been deprecated #81 -TargetName parameter not longer sets the pipeline object TargetName and generates a warning instead. The -TargetName will be completely removed in v0.4.0 , at which time using the parameter will generate an error.","title":"v0.3.0-B190224 (pre-release)"},{"location":"CHANGELOG-v0/#v030-b190208-pre-release","text":"Added online help links to keywords #72 Added schema for PSRule options #74 Import objects from YAML or JSON format #75 Support TargetName binding of nested properties #71 Support nested TargetObjects #77","title":"v0.3.0-B190208 (pre-release)"},{"location":"CHANGELOG-v0/#v020","text":"What's changed since v0.1.0: Added support for cross-platform environments (Windows, Linux and macOS) #49 Added support for nested field names with Exists , Within and Match keywords #60 Added support for rule configuration using baselines #17 Use rule description when hint message not set #61 Allow objects to be suppressed by TargetName for individual rules #13 Allow binding of TargetName to custom property #44 Custom functions can be used to bind TargetName #44 Objects that are unable to bind a TargetName will use a SHA1 object hash for TargetName #44 Added Test-PSRuleTarget command to return an overall $True or $False after evaluating rules for an object #30 Improve reporting of inconclusive results and objects that are not processed by any rule #46 Inconclusive results and objects not processed will return a warning by default. Fix propagation of informational messages to host from rule scripts and definitions #48 Fix Get-PSRule generates exception when no .rule.ps1 scripts exist in path #53 Fix LocalizedData.PathNotFound warning when no .rule.ps1 scripts exist in path #54 What's changed since pre-release v0.2.0-B190121: No additional changes.","title":"v0.2.0"},{"location":"CHANGELOG-v0/#v020-b190121-pre-release","text":"Added support for nested field names with Exists , Within and Match keywords #60 Added support for rule configuration using baselines #17 Use rule description when hint message not set #61","title":"v0.2.0-B190121 (pre-release)"},{"location":"CHANGELOG-v0/#v020-b190113-pre-release","text":"Fix Get-PSRule generates exception when no .rule.ps1 scripts exist in path #53 Fix LocalizedData.PathNotFound warning when no .rule.ps1 scripts exist in path #54 Breaking change : Renamed Test-PSRule cmdlet to Test-PSRuleTarget which aligns more closely to the verb-noun naming standard #57","title":"v0.2.0-B190113 (pre-release)"},{"location":"CHANGELOG-v0/#v020-b190105-pre-release","text":"Allow objects to be suppressed by TargetName for individual rules #13 Allow binding of TargetName to custom property #44 Custom functions can be used to bind TargetName #44 Objects that are unable to bind a TargetName will use a SHA1 object hash for TargetName #44 Added Test-PSRule command to return an overall $True or $False after evaluating rules for an object #30 Improve reporting of inconclusive results and objects that are not processed by any rule #46 Inconclusive results and objects not processed will return a warning by default. Fix propagation of informational messages to host from rule scripts and definitions #48 Added support for cross-platform environments (Windows, Linux and macOS) #49","title":"v0.2.0-B190105 (pre-release)"},{"location":"CHANGELOG-v0/#v010","text":"Initial release What's changed since pre-release v0.1.0-B181235: Fix outcome filtering of summary results #33 Fix target object counter in verbose logging #35 Fix hashtable keys should be handled as fields #36","title":"v0.1.0"},{"location":"CHANGELOG-v0/#v010-b181235-pre-release","text":"RuleId and RuleName are now independent. Rules are created with a name, and the RuleId is generated based on rule name and file name Rules with the same name can exist and be cross linked with DependsOn, as long a the script file name is different Added -Not to Exists keyword Improved verbose logging of Exists , AllOf , AnyOf keywords and core engine Breaking change : Renamed outcome filtering parameters to align to type name and increase clarity Invoke-PSRule has a -Outcome parameter instead of -Status -Outcome supports values of Pass , Fail , Error , None , Processed and All","title":"v0.1.0-B181235 (pre-release)"},{"location":"CHANGELOG-v0/#v010-b181222-pre-release","text":"Added rule tags to results to enable grouping and sorting #14 Added support to check for rule tag existence. Use * for tag value on -Tag parameter with Invoke-PSRule and Get-PSRule Added option to report rule summary using -As parameter of Invoke-PSRule #12","title":"v0.1.0-B181222 (pre-release)"},{"location":"CHANGELOG-v0/#v010-b181212-pre-release","text":"Initial pre-release.","title":"v0.1.0-B181212 (pre-release)"},{"location":"CHANGELOG-v1/","text":"Change log # See upgrade notes for helpful information when upgrading from previous versions. Important notes : YAML resources will require an apiVersion from PSRule v2. #648 Setting the default module baseline requires a module configuration from PSRule v2. #809 Info The next release of PSRule is currently in preview. For more information see v2 release notes. Please check out our upgrade notes to get prepared for the next release. v1.11.0 # What's changed since v1.10.0: General improvements: Added version expression to check semantic version constraints. #861 See about_PSRule_Expressions for details. Added hasDefault expression to check field default value. #870 See about_PSRule_Expressions for details. Bug fixes: Fixed GetReason() not returning results for a failed assertion. #874 What's changed since pre-release v1.11.0-B2112016: No additional changes. v1.11.0-B2112016 (pre-release) # What's changed since v1.10.0: General improvements: Added version expression to check semantic version constraints. #861 See about_PSRule_Expressions for details. Added hasDefault expression to check field default value. #870 See about_PSRule_Expressions for details. Bug fixes: Fixed GetReason() not returning results for a failed assertion. #874 v1.10.0 # What's changed since v1.9.0: General improvements: Added JSON support for reading rules and selectors from pipeline. #857 Added HasSchema expression to check the schema of an object. #860 See about_PSRule_Expressions for details. Engineering: Bump Microsoft.SourceLink.GitHub to 1.1.1. #856 Bug fixes: Fixed $Assert.HasJsonSchema accepts empty value. #859 Fixed module configuration is not loaded when case does not match. #864 What's changed since pre-release v1.10.0-B2112002: No additional changes. v1.10.0-B2112002 (pre-release) # What's changed since pre-release v1.10.0-B2111024: Bug fixes: Fixed module configuration is not loaded when case does not match. #864 v1.10.0-B2111024 (pre-release) # What's changed since v1.9.0: General improvements: Added JSON support for reading rules and selectors from pipeline. #857 Added HasSchema expression to check the schema of an object. #860 See about_PSRule_Expressions for details. Engineering: Bump Microsoft.SourceLink.GitHub to 1.1.1. #856 Bug fixes: Fixed $Assert.HasJsonSchema accepts empty value. #859 v1.9.0 # What's changed since v1.8.0: General improvements: Added improvements to YAML output for Get-PSRuleBaseline . #829 Added -Initialize convention block. #826 Use this block to perform any initialization that is required before any rules are run. This block is only run once instead of -Begin which is run once per object. See about_PSRule_Conventions for details. Allow lifetime services to be used. #827 Use $PSRule.AddService and $PSRule.GetService to add a service. Services allows a singleton instance to be used and shared across multiple rules. PSRule will automatically dispose the service when all rules have run. See about_PSRule_Variables for details. Added Export-PSRuleBaseline cmdlet to export baseline. #622 Added JSON output format for Baseline cmdlets. #839 Allow downstream issues to be consumed. #843 Objects can be flagged with issues that have been generated externally. See about_PSRule_Assert for details. Migrated default baseline to module configuration. #809 This enables configuration of the default baseline for a module with a module configuration. This depreciate configuring the default baseline within the module manifest. Modules using manifest configuration will start warning from v1.9.0. See about_PSRule_Options for details. Added JSON support to read baselines from pipeline. #845 Engineering: Bump System.Drawing.Common dependency to v6.0.0. #848 Bug fixes: Fixed convention execution is out of order. #835 What's changed since pre-release v1.9.0-B2111024: Engineering: Bump Microsoft.CodeAnalysis.NetAnalyzers to v6.0.0. #851 v1.9.0-B2111024 (pre-release) # What's changed since pre-release v1.9.0-B2111009: General improvements: Allow downstream issues to be consumed. #843 Objects can be flagged with issues that have been generated externally. See about_PSRule_Assert for details. Migrated default baseline to module configuration. #809 This enables configuration of the default baseline for a module with a module configuration. This depreciate configuring the default baseline within the module manifest. Modules using manifest configuration will start warning from v1.9.0. See about_PSRule_Options for details. Added JSON support to read baselines from pipeline. #845 Engineering: Bump System.Drawing.Common dependency to v6.0.0. #848 v1.9.0-B2111009 (pre-release) # What's changed since pre-release v1.9.0-B2110027: General improvements: Added JSON output format for Baseline cmdlets. #839 Bug fixes: Fixed convention execution is out of order. #835 v1.9.0-B2110027 (pre-release) # What's changed since pre-release v1.9.0-B2110015: General improvements: Added Export-PSRuleBaseline cmdlet to export baseline. #622 v1.9.0-B2110015 (pre-release) # What's changed since v1.8.0: General improvements: Added improvements to YAML output for Get-PSRuleBaseline . #829 Added -Initialize convention block. #826 Use this block to perform any initialization that is required before any rules are run. This block is only run once instead of -Begin which is run once per object. See about_PSRule_Conventions for details. Allow lifetime services to be used. #827 Use $PSRule.AddService and $PSRule.GetService to add a service. Services allows a singleton instance to be used and shared across multiple rules. PSRule will automatically dispose the service when all rules have run. See about_PSRule_Variables for details. v1.8.0 # What's changed since v1.7.2: General improvements: Added YAML output format support for Get-PSRuleBaseline . #326 Added YAML/JSON output format support for Get-PSRule . #128 Added Output.JsonIndent option for JSON output format. #817 Added assertion helpers and expressions for improving intersection checks. #795 Added Count to determine of the field has a specific number of elements. Added SetOf to determine if a collection is another collection. Added Subset to determine if a collection is includes another collection. See about_PSRule_Assert and about_PSRule_Expressions for details. Added support for conditional reason messages with ReasonIf . #804 See about_PSRule_Assert for details. Added support for type and name expression properties. #810 Use type to compare the bound type of the current object. Use name to compare the bound name of the current object. See about_PSRule_Expressions for details. Engineering: Migration of Pester v4 tests to Pester v5. #478 What's changed since pre-release v1.8.0-B2110030: No additional changes. v1.8.0-B2110030 (pre-release) # What's changed since pre-release v1.8.0-B2110020: General improvements: Added Output.JsonIndent option for JSON output format. #817 v1.8.0-B2110020 (pre-release) # What's changed since pre-release v1.8.0-B2110006: General improvements: Added YAML/JSON output format support for Get-PSRule . #128 Engineering: Migration of Pester v4 tests to Pester v5. #478 v1.8.0-B2110006 (pre-release) # What's changed since pre-release v1.8.0-B2109022: General improvements: Added YAML output format support for Get-PSRuleBaseline . #326 v1.8.0-B2109022 (pre-release) # What's changed since pre-release v1.8.0-B2109015: General improvements: Added support for conditional reason messages with ReasonIf . #804 See about_PSRule_Assert for details. Added support for type and name expression properties. #810 Use type to compare the bound type of the current object. Use name to compare the bound name of the current object. See about_PSRule_Expressions for details. v1.8.0-B2109015 (pre-release) # What's changed since v1.7.2: General improvements: Added assertion helpers and expressions for improving intersection checks. #795 Added Count to determine of the field has a specific number of elements. Added SetOf to determine if a collection is another collection. Added Subset to determine if a collection is includes another collection. See about_PSRule_Assert and about_PSRule_Expressions for details. v1.7.2 # What's changed since v1.7.1: Bug fixes: Fixed Get-PSRuleBaseline does not return any results from module. #801 v1.7.1 # What's changed since v1.7.0: Bug fixes: Fixed ResourceTags does not contain a method named ToHashtable. #798 v1.7.0 # What's changed since v1.6.0: Engine features: Added support for generating badges from rule results. #623 Standard or custom badges can be generated using a convention and the badge API. See about_PSRule_Badges for details. General improvements: Rule results now include a run ID or each run. #774 Run ID is returned in Assert-PSRule output at the end of each run by default. By default a unique runId is generated when the rule is run. The Output.Footer option was added to configure the output footer. See about_PSRule_Options for details. Automatically exclude common repository files from input files. #721 Added Input.IgnoreRepositoryCommon option to change default behavior. See about_PSRule_Options for details. Added aggregation assertion methods for AnyOf and AllOf . #776 See about_PSRule_Assert for details. Allow baselines to include local rules. #756 The Rule.IncludeLocal option was automatically include local/ standalone rules not in a module. This option is useful when you want to include local rules not included in a baseline. See about_PSRule_Options for details. Bug fixes: Fixed configuration array deserializes as dictionary from YAML options. #779 What's changed since pre-release v1.7.0-B2109002: No additional changes. v1.7.0-B2109002 (pre-release) # What's changed since pre-release v1.7.0-B2108032: General improvements: Allow baselines to include local rules. #756 The Rule.IncludeLocal option was automatically include local/ standalone rules not in a module. This option is useful when you want to include local rules not included in a baseline. See about_PSRule_Options for details. v1.7.0-B2108032 (pre-release) # What's changed since pre-release v1.7.0-B2108021: Engine features: Added support for generating badges from rule results. #623 Standard or custom badges can be generated using a convention and the badge API. See about_PSRule_Badges for details. General improvements: Rule results now include a run ID or each run. #774 Run ID is returned in Assert-PSRule output at the end of each run by default. By default a unique runId is generated when the rule is run. The Output.Footer option was added to configure the output footer. See about_PSRule_Options for details. v1.7.0-B2108021 (pre-release) # What's changed since pre-release v1.7.0-B2108016: Bug fixes: Fixed configuration array deserializes as dictionary from YAML options. #779 v1.7.0-B2108016 (pre-release) # What's changed since v1.6.0: General improvements: Automatically exclude common repository files from input files. #721 Added Input.IgnoreRepositoryCommon option to change default behavior. See about_PSRule_Options for details. Added aggregation assertion methods for AnyOf and AllOf . #776 See about_PSRule_Assert for details. v1.6.1 # What's changed since v1.6.0: Bug fixes: Fixed configuration array deserializes as dictionary from YAML options. #779 v1.6.0 # What's changed since v1.5.0: Engine features: Added support for YAML rules. #603 YAML rules evaluate an expression tree and return a result for each object. YAML provides an additional option for defining rules in addition to PowerShell script rules. Type and selector pre-conditions are supported. See about_PSRule_Rules for details. General improvements: Added support for object source location in validation. #757 Default rule source location .ps-rule/ is automatically included. #742 Added Include.Path and Include.Module options to automatically include rule sources. See about_PSRule_Options for details. Bug fixes: Fixed target binding across multiple scopes. #762 What's changed since pre-release v1.6.0-B2108009: No additional changes. v1.6.0-B2108009 (pre-release) # What's changed since pre-release v1.6.0-B2108003: Engine features: Added support for YAML rules. #603 YAML rules evaluate an expression tree and return a result for each object. YAML provides an additional option for defining rules in addition to PowerShell script rules. Type and selector pre-conditions are supported. See about_PSRule_Rules for details. v1.6.0-B2108003 (pre-release) # What's changed since pre-release v1.6.0-B2107008: Bug fixes: Fixed target binding across multiple scopes. #762 v1.6.0-B2107008 (pre-release) # What's changed since v1.5.0: General improvements: Added support for object source location in validation. #757 Default rule source location .ps-rule/ is automatically included. #742 Added Include.Path and Include.Module options to automatically include rule sources. See about_PSRule_Options for details. v1.5.0 # What's changed since v1.4.0: General improvements: Added string selector conditions. #747 Use startWith , contains , and endsWith to check for a sub-string. Use isString , isLower , and isUpper to check for string type and casing. See about_PSRule_Selectors for details. Engineering: Bump YamlDotNet dependency to 11.2.1. #740 Bug fixes: Fixed options schema should allow spacing after @pre . #743 Fixed match selector expression passing on missing field. #745 What's changed since pre-release v1.5.0-B2107009: No additional changes. v1.5.0-B2107009 (pre-release) # What's changed since pre-release v1.5.0-B2106006: General improvements: Added string selector conditions. #747 Use startWith , contains , and endsWith to check for a sub-string. Use isString , isLower , and isUpper to check for string type and casing. See about_PSRule_Selectors for details. Engineering: Bump YamlDotNet dependency to 11.2.1. #740 Bug fixes: Fixed options schema should allow spacing after @pre . #743 Fixed match selector expression passing on missing field. #745 v1.5.0-B2106006 (pre-release) # What's changed since v1.4.0: Engineering: Bump YamlDotNet dependency to 11.2.0. #736 v1.4.0 # What's changed since v1.3.0: General improvements: PSRule banner can be configured in output when using Assert-PSRule . #708 Input source location of objects are included in results. Input source location of objects from JSON and YAML input files are read automatically. #624 Input source location of objects from the pipeline are read from properties. #729 Assert output improvements: Added support for Visual Studio Code with VisualStudioCode style. #731 Updated output format provides support for problem matchers in task output. Automatically detect output style from environment variables. #732 Assert-PSRule now defaults to Detect instead of Client . See about_PSRule_Options for details. Improved support for version constraints by: Constraints can include prerelease versions of other matching versions. #714 Constraints support using a @prerelease or @pre to include prerelease versions. #717 Constraint sets allow multiple constraints to be joined together. #715 See about_PSRule_Assert for details. Bug fixes: Fixed prerelease constraint handling for prerelease versions. #712 Fixed null reference in convention for nested exceptions. #725 What's changed since pre-release v1.4.0-B2105041: No additional changes. v1.4.0-B2105041 (pre-release) # What's changed since pre-release v1.4.0-B2105032: General improvements: Source location of objects from the pipeline are read from properties. #729 Assert output improvements: Added support for Visual Studio Code with VisualStudioCode style. #731 Updated output format provides support for problem matchers in task output. Automatically detect output style from environment variables. #732 Assert-PSRule now defaults to Detect instead of Client . See about_PSRule_Options for details. v1.4.0-B2105032 (pre-release) # What's changed since pre-release v1.4.0-B2105019: Bug fixes: Fixed null reference in convention for nested exceptions. #725 v1.4.0-B2105019 (pre-release) # What's changed since pre-release v1.4.0-B2105004: General improvements: Source location of objects are included in results. Source location of objects from JSON and YAML input files are read automatically. #624 Improved support for version constraints by: Constraints can include prerelease versions of other matching versions. #714 Constraints support using a @prerelease or @pre to include prerelease versions. #717 Constraint sets allow multiple constraints to be joined together. #715 See about_PSRule_Assert for details. Bug fixes: Fixed prerelease constraint handling for prerelease versions. #712 v1.4.0-B2105004 (pre-release) # What's changed since v1.3.0: General improvements: PSRule banner can be configured in output when using Assert-PSRule . #708 v1.3.0 # What's changed since v1.2.0: Engine features: Options can be configured with environment variables. #691 See about_PSRule_Options for details. General improvements: Exclude .git sub-directory by default for recursive scans. #697 Added Input.IgnoreGitPath option to configure inclusion of .git path. See about_PSRule_Options for details. Added file path assertion helpers. #679 Added WithinPath to check the file path field is within a specified path. Added NotWithinPath to check the file path field is not within a specified path See about_PSRule_Assert for details. Added DateTime type assertion helper. #680 Added IsDateTime to check of object field is [DateTime] . See about_PSRule_Assert for details. Improved numeric comparison assertion helpers to compare [DateTime] fields. #685 Less , LessOrEqual , Greater , and GreaterOrEqual compare the number of days from the current time. See about_PSRule_Assert for details. Improved handling of field names for objects implementing IList , IEnumerable , and index properties. #692 Engineering: Bump YamlDotNet dependency to 11.1.1. #690 Bug fixes: Fixed expected DocumentEnd got SequenceEnd. #698 What's changed since pre-release v1.3.0-B2105004: No additional changes. v1.3.0-B2105004 (pre-release) # What's changed since pre-release v1.3.0-B2104042: Engine features: Options can be configured with environment variables. #691 See about_PSRule_Options for details. General improvements: Exclude .git sub-directory by default for recursive scans. #697 Added Input.IgnoreGitPath option to configure inclusion of .git path. See about_PSRule_Options for details. v1.3.0-B2104042 (pre-release) # What's changed since pre-release v1.3.0-B2104030: Bug fixes: Fixed expected DocumentEnd got SequenceEnd. #698 v1.3.0-B2104030 (pre-release) # What's changed since pre-release v1.3.0-B2104021: General improvements: Improved handling of field names for objects implementing IList , IEnumerable , and index properties. #692 Engineering: Bump YamlDotNet dependency to 11.1.1. #690 v1.3.0-B2104021 (pre-release) # What's changed since v1.2.0: General improvements: Added file path assertion helpers. #679 Added WithinPath to check the file path field is within a specified path. Added NotWithinPath to check the file path field is not within a specified path See about_PSRule_Assert for details. Added DateTime type assertion helper. #680 Added IsDateTime to check of object field is [DateTime] . See about_PSRule_Assert for details. Improved numeric comparison assertion helpers to compare [DateTime] fields. #685 Less , LessOrEqual , Greater , and GreaterOrEqual compare the number of days from the current time. See about_PSRule_Assert for details. v1.2.0 # What's changed since v1.1.0: Engine features: Added support for extensibility with conventions. #650 Conventions provide an extensibility point within PSRule to execute actions within the pipeline. A convention can expose Begin , Process , and End blocks. In additional to within rules $PSRule.Data can be accessed from Begin and Process blocks. See about_PSRule_Conventions for details. Added support for object expansion with conventions. #661 Use the $PSRule.Import method to import child source objects into the pipeline. See about_PSRule_Variables for details. Added support for complex pre-conditions with selectors. #649 See about_PSRule_Selectors for details. General improvements: Added support for preferring automatic binding over custom binding configurations. #670 Added the Binding.PreferTargetInfo option to prefer target info specified by the object. See about_PSRule_Options for details. Added strong apiVersion to resource types. #647 Resource schemas now support an apiVersion field. The apiVersion field is optional but recommended. Resources without a apiVersion field will not be supported from PSRule v2. Added warning to flag baseline without apiVersion set. Added support for detecting files headers from additional file extensions using FileHeader . #664 Added .bicep , .csx , .jsx , .groovy , .java , .json , .jsonc , .scala , .rb , .bat , .cmd . Added support for Jenkinsfile and Dockerfile without an extension. See about_PSRule_Assert for details. Added support for automatic type binding with files that do not have a file extension. #665 Bug fixes: Fixed dependent rule execution is skipped for consequent input objects. #657 What's changed since pre-release v1.2.0-B2103043: No additional changes. v1.2.0-B2103043 (pre-release) # What's changed since pre-release v1.2.0-B2103031: Engine features: Added support for complex pre-conditions with selectors. #649 General improvements: Added support for preferring automatic binding over custom binding configurations. #670 Added the Binding.PreferTargetInfo option to prefer target info specified by the object. See about_PSRule_Options for details. Added strong apiVersion to resource types. #647 Resource schemas now support an apiVersion field. The apiVersion field is optional but recommended. Resources without a apiVersion field will not be supported from PSRule v2. Added warning to flag baseline without apiVersion set. v1.2.0-B2103031 (pre-release) # What's changed since pre-release v1.2.0-B2103023: General improvements: Added support for detecting files headers from additional file extensions. #664 Added .bicep , .csx , .jsx , .groovy , .java , .json , .jsonc , .scala , .rb , .bat , .cmd . Added support for Jenkinsfile and Dockerfile without an extension. See about_PSRule_Assert for details. Added support for automatic type binding with files that do not have a file extension. #665 v1.2.0-B2103023 (pre-release) # What's changed since pre-release v1.2.0-B2103016: Engine features: Added support for object expansion with conventions. #661 Use the $PSRule.Import method to import child source objects into the pipeline. See about_PSRule_Variables for details. v1.2.0-B2103016 (pre-release) # What's changed since pre-release v1.2.0-B2103008: Bug fixes: Fixed dependent rule execution is skipped for consequent input objects. #657 v1.2.0-B2103008 (pre-release) # What's changed since v1.1.0: Engine features: Added support for extensibility with conventions. #650 Conventions provide an extensibility point within PSRule to execute actions within the pipeline. A convention can expose Begin , Process , and End blocks. In additional to within rules $PSRule.Data can be accessed from Begin and Process blocks. See about_PSRule_Conventions for details. v1.1.0 # What's changed since v1.0.3: Engine features: Added assertion helpers. #640 Added NotHasField to check object does not have any of the specified fields. Added Null to check field value is null. Added NotNull to check field value is not null. See about_PSRule_Assert for details. Added type assertion helpers. #635 Added IsNumeric to check field value is a numeric types. Added IsInteger to check field value is an integer types. Added IsBoolean to check field value is a boolean. Added IsArray to check field value is an array. Added IsString to check field value is a string. Added TypeOf to check field value is a specified type. See about_PSRule_Assert for details. Added content helpers. #637 Added $PSRule.GetContentFirstOrDefault to get content and return the first object. Added $PSRule.GetContentField to get the field from content objects. See about_PSRule_Variables for details. General improvements: Updated HasJsonSchema assertion helper. #636 The URI scheme can optionally be ignored for http:// or https:// URIs. The fragment # is ignored. See about_PSRule_Assert for details. Added support for -Outcome and -As to produce filtered output from Assert-PSRule . #643 Configure Output.As with Summary to produce summarized results per object. Configure Output.Outcome to limit output to Fail or Error . See Assert-PSRule for details. What's changed since pre-release v1.1.0-B2102029: No additional changes. v1.1.0-B2102029 (pre-release) # What's changed since pre-release v1.1.0-B2102024: General improvements: Added support for -Outcome and -As to produce filtered output from Assert-PSRule . #643 Configure Output.As with Summary to produce summarized results per object. Configure Output.Outcome to limit output to Fail or Error . See Assert-PSRule for details. v1.1.0-B2102024 (pre-release) # What's changed since pre-release v1.1.0-B2102019: Engine features: Added assertion helpers. #640 Added NotHasField to check object does not have any of the specified fields. Added Null to check field value is null. Added NotNull to check field value is not null. See about_PSRule_Assert for details. v1.1.0-B2102019 (pre-release) # What's changed since v1.0.3: Engine features: Added type assertion helpers. #635 Added IsNumeric to check field value is a numeric types. Added IsInteger to check field value is an integer types. Added IsBoolean to check field value is a boolean. Added IsArray to check field value is an array. Added IsString to check field value is a string. Added TypeOf to check field value is a specified type. See about_PSRule_Assert for details. Added content helpers. #637 Added $PSRule.GetContentFirstOrDefault to get content and return the first object. Added $PSRule.GetContentField to get the field from content objects. See about_PSRule_Variables for details. General improvements: Updated HasJsonSchema assertion helper. #636 The URI scheme can optionally be ignored for http:// or https:// URIs. The fragment # is ignored. See about_PSRule_Assert for details. v1.0.3 # What's changed since v1.0.2: Bug fixes: Fixed reason reported fields for HasField and HasFields assertion helpers. #632 v1.0.2 # What's changed since v1.0.1: Engineering: Bump Manatee.Json dependency to 13.0.5. #619 Bug fixes: Fixed GetContent processing of InputFileInfo . #625 Fixed null reference of rule reason with wide output. #626 Fixed markdown help handling of inline code blocks with [ . #627 Fixed markdown help inclusion of fenced code blocks in notes and description. #628 v1.0.1 # What's changed since v1.0.0: Bug fixes: Fixed module source key has already been added. #608 v1.0.0 # What's changed since v0.22.0: General improvements: Added rule help link in failed Assert-PSRule output. #595 Engineering: Breaking change : Removed deprecated $Rule properties. #495 Bump Manatee.Json dependency to 13.0.4. #591 What's changed since pre-release v1.0.0-B2011028: No additional changes. v1.0.0-B2011028 (pre-release) # What's changed since v0.22.0: General improvements: Added rule help link in failed Assert-PSRule output. #595 Engineering: Breaking change : Removed deprecated $Rule properties. #495 Bump Manatee.Json dependency to 13.0.4. #591","title":"v1"},{"location":"CHANGELOG-v1/#change-log","text":"See upgrade notes for helpful information when upgrading from previous versions. Important notes : YAML resources will require an apiVersion from PSRule v2. #648 Setting the default module baseline requires a module configuration from PSRule v2. #809 Info The next release of PSRule is currently in preview. For more information see v2 release notes. Please check out our upgrade notes to get prepared for the next release.","title":"Change log"},{"location":"CHANGELOG-v1/#v1110","text":"What's changed since v1.10.0: General improvements: Added version expression to check semantic version constraints. #861 See about_PSRule_Expressions for details. Added hasDefault expression to check field default value. #870 See about_PSRule_Expressions for details. Bug fixes: Fixed GetReason() not returning results for a failed assertion. #874 What's changed since pre-release v1.11.0-B2112016: No additional changes.","title":"v1.11.0"},{"location":"CHANGELOG-v1/#v1110-b2112016-pre-release","text":"What's changed since v1.10.0: General improvements: Added version expression to check semantic version constraints. #861 See about_PSRule_Expressions for details. Added hasDefault expression to check field default value. #870 See about_PSRule_Expressions for details. Bug fixes: Fixed GetReason() not returning results for a failed assertion. #874","title":"v1.11.0-B2112016 (pre-release)"},{"location":"CHANGELOG-v1/#v1100","text":"What's changed since v1.9.0: General improvements: Added JSON support for reading rules and selectors from pipeline. #857 Added HasSchema expression to check the schema of an object. #860 See about_PSRule_Expressions for details. Engineering: Bump Microsoft.SourceLink.GitHub to 1.1.1. #856 Bug fixes: Fixed $Assert.HasJsonSchema accepts empty value. #859 Fixed module configuration is not loaded when case does not match. #864 What's changed since pre-release v1.10.0-B2112002: No additional changes.","title":"v1.10.0"},{"location":"CHANGELOG-v1/#v1100-b2112002-pre-release","text":"What's changed since pre-release v1.10.0-B2111024: Bug fixes: Fixed module configuration is not loaded when case does not match. #864","title":"v1.10.0-B2112002 (pre-release)"},{"location":"CHANGELOG-v1/#v1100-b2111024-pre-release","text":"What's changed since v1.9.0: General improvements: Added JSON support for reading rules and selectors from pipeline. #857 Added HasSchema expression to check the schema of an object. #860 See about_PSRule_Expressions for details. Engineering: Bump Microsoft.SourceLink.GitHub to 1.1.1. #856 Bug fixes: Fixed $Assert.HasJsonSchema accepts empty value. #859","title":"v1.10.0-B2111024 (pre-release)"},{"location":"CHANGELOG-v1/#v190","text":"What's changed since v1.8.0: General improvements: Added improvements to YAML output for Get-PSRuleBaseline . #829 Added -Initialize convention block. #826 Use this block to perform any initialization that is required before any rules are run. This block is only run once instead of -Begin which is run once per object. See about_PSRule_Conventions for details. Allow lifetime services to be used. #827 Use $PSRule.AddService and $PSRule.GetService to add a service. Services allows a singleton instance to be used and shared across multiple rules. PSRule will automatically dispose the service when all rules have run. See about_PSRule_Variables for details. Added Export-PSRuleBaseline cmdlet to export baseline. #622 Added JSON output format for Baseline cmdlets. #839 Allow downstream issues to be consumed. #843 Objects can be flagged with issues that have been generated externally. See about_PSRule_Assert for details. Migrated default baseline to module configuration. #809 This enables configuration of the default baseline for a module with a module configuration. This depreciate configuring the default baseline within the module manifest. Modules using manifest configuration will start warning from v1.9.0. See about_PSRule_Options for details. Added JSON support to read baselines from pipeline. #845 Engineering: Bump System.Drawing.Common dependency to v6.0.0. #848 Bug fixes: Fixed convention execution is out of order. #835 What's changed since pre-release v1.9.0-B2111024: Engineering: Bump Microsoft.CodeAnalysis.NetAnalyzers to v6.0.0. #851","title":"v1.9.0"},{"location":"CHANGELOG-v1/#v190-b2111024-pre-release","text":"What's changed since pre-release v1.9.0-B2111009: General improvements: Allow downstream issues to be consumed. #843 Objects can be flagged with issues that have been generated externally. See about_PSRule_Assert for details. Migrated default baseline to module configuration. #809 This enables configuration of the default baseline for a module with a module configuration. This depreciate configuring the default baseline within the module manifest. Modules using manifest configuration will start warning from v1.9.0. See about_PSRule_Options for details. Added JSON support to read baselines from pipeline. #845 Engineering: Bump System.Drawing.Common dependency to v6.0.0. #848","title":"v1.9.0-B2111024 (pre-release)"},{"location":"CHANGELOG-v1/#v190-b2111009-pre-release","text":"What's changed since pre-release v1.9.0-B2110027: General improvements: Added JSON output format for Baseline cmdlets. #839 Bug fixes: Fixed convention execution is out of order. #835","title":"v1.9.0-B2111009 (pre-release)"},{"location":"CHANGELOG-v1/#v190-b2110027-pre-release","text":"What's changed since pre-release v1.9.0-B2110015: General improvements: Added Export-PSRuleBaseline cmdlet to export baseline. #622","title":"v1.9.0-B2110027 (pre-release)"},{"location":"CHANGELOG-v1/#v190-b2110015-pre-release","text":"What's changed since v1.8.0: General improvements: Added improvements to YAML output for Get-PSRuleBaseline . #829 Added -Initialize convention block. #826 Use this block to perform any initialization that is required before any rules are run. This block is only run once instead of -Begin which is run once per object. See about_PSRule_Conventions for details. Allow lifetime services to be used. #827 Use $PSRule.AddService and $PSRule.GetService to add a service. Services allows a singleton instance to be used and shared across multiple rules. PSRule will automatically dispose the service when all rules have run. See about_PSRule_Variables for details.","title":"v1.9.0-B2110015 (pre-release)"},{"location":"CHANGELOG-v1/#v180","text":"What's changed since v1.7.2: General improvements: Added YAML output format support for Get-PSRuleBaseline . #326 Added YAML/JSON output format support for Get-PSRule . #128 Added Output.JsonIndent option for JSON output format. #817 Added assertion helpers and expressions for improving intersection checks. #795 Added Count to determine of the field has a specific number of elements. Added SetOf to determine if a collection is another collection. Added Subset to determine if a collection is includes another collection. See about_PSRule_Assert and about_PSRule_Expressions for details. Added support for conditional reason messages with ReasonIf . #804 See about_PSRule_Assert for details. Added support for type and name expression properties. #810 Use type to compare the bound type of the current object. Use name to compare the bound name of the current object. See about_PSRule_Expressions for details. Engineering: Migration of Pester v4 tests to Pester v5. #478 What's changed since pre-release v1.8.0-B2110030: No additional changes.","title":"v1.8.0"},{"location":"CHANGELOG-v1/#v180-b2110030-pre-release","text":"What's changed since pre-release v1.8.0-B2110020: General improvements: Added Output.JsonIndent option for JSON output format. #817","title":"v1.8.0-B2110030 (pre-release)"},{"location":"CHANGELOG-v1/#v180-b2110020-pre-release","text":"What's changed since pre-release v1.8.0-B2110006: General improvements: Added YAML/JSON output format support for Get-PSRule . #128 Engineering: Migration of Pester v4 tests to Pester v5. #478","title":"v1.8.0-B2110020 (pre-release)"},{"location":"CHANGELOG-v1/#v180-b2110006-pre-release","text":"What's changed since pre-release v1.8.0-B2109022: General improvements: Added YAML output format support for Get-PSRuleBaseline . #326","title":"v1.8.0-B2110006 (pre-release)"},{"location":"CHANGELOG-v1/#v180-b2109022-pre-release","text":"What's changed since pre-release v1.8.0-B2109015: General improvements: Added support for conditional reason messages with ReasonIf . #804 See about_PSRule_Assert for details. Added support for type and name expression properties. #810 Use type to compare the bound type of the current object. Use name to compare the bound name of the current object. See about_PSRule_Expressions for details.","title":"v1.8.0-B2109022 (pre-release)"},{"location":"CHANGELOG-v1/#v180-b2109015-pre-release","text":"What's changed since v1.7.2: General improvements: Added assertion helpers and expressions for improving intersection checks. #795 Added Count to determine of the field has a specific number of elements. Added SetOf to determine if a collection is another collection. Added Subset to determine if a collection is includes another collection. See about_PSRule_Assert and about_PSRule_Expressions for details.","title":"v1.8.0-B2109015 (pre-release)"},{"location":"CHANGELOG-v1/#v172","text":"What's changed since v1.7.1: Bug fixes: Fixed Get-PSRuleBaseline does not return any results from module. #801","title":"v1.7.2"},{"location":"CHANGELOG-v1/#v171","text":"What's changed since v1.7.0: Bug fixes: Fixed ResourceTags does not contain a method named ToHashtable. #798","title":"v1.7.1"},{"location":"CHANGELOG-v1/#v170","text":"What's changed since v1.6.0: Engine features: Added support for generating badges from rule results. #623 Standard or custom badges can be generated using a convention and the badge API. See about_PSRule_Badges for details. General improvements: Rule results now include a run ID or each run. #774 Run ID is returned in Assert-PSRule output at the end of each run by default. By default a unique runId is generated when the rule is run. The Output.Footer option was added to configure the output footer. See about_PSRule_Options for details. Automatically exclude common repository files from input files. #721 Added Input.IgnoreRepositoryCommon option to change default behavior. See about_PSRule_Options for details. Added aggregation assertion methods for AnyOf and AllOf . #776 See about_PSRule_Assert for details. Allow baselines to include local rules. #756 The Rule.IncludeLocal option was automatically include local/ standalone rules not in a module. This option is useful when you want to include local rules not included in a baseline. See about_PSRule_Options for details. Bug fixes: Fixed configuration array deserializes as dictionary from YAML options. #779 What's changed since pre-release v1.7.0-B2109002: No additional changes.","title":"v1.7.0"},{"location":"CHANGELOG-v1/#v170-b2109002-pre-release","text":"What's changed since pre-release v1.7.0-B2108032: General improvements: Allow baselines to include local rules. #756 The Rule.IncludeLocal option was automatically include local/ standalone rules not in a module. This option is useful when you want to include local rules not included in a baseline. See about_PSRule_Options for details.","title":"v1.7.0-B2109002 (pre-release)"},{"location":"CHANGELOG-v1/#v170-b2108032-pre-release","text":"What's changed since pre-release v1.7.0-B2108021: Engine features: Added support for generating badges from rule results. #623 Standard or custom badges can be generated using a convention and the badge API. See about_PSRule_Badges for details. General improvements: Rule results now include a run ID or each run. #774 Run ID is returned in Assert-PSRule output at the end of each run by default. By default a unique runId is generated when the rule is run. The Output.Footer option was added to configure the output footer. See about_PSRule_Options for details.","title":"v1.7.0-B2108032 (pre-release)"},{"location":"CHANGELOG-v1/#v170-b2108021-pre-release","text":"What's changed since pre-release v1.7.0-B2108016: Bug fixes: Fixed configuration array deserializes as dictionary from YAML options. #779","title":"v1.7.0-B2108021 (pre-release)"},{"location":"CHANGELOG-v1/#v170-b2108016-pre-release","text":"What's changed since v1.6.0: General improvements: Automatically exclude common repository files from input files. #721 Added Input.IgnoreRepositoryCommon option to change default behavior. See about_PSRule_Options for details. Added aggregation assertion methods for AnyOf and AllOf . #776 See about_PSRule_Assert for details.","title":"v1.7.0-B2108016 (pre-release)"},{"location":"CHANGELOG-v1/#v161","text":"What's changed since v1.6.0: Bug fixes: Fixed configuration array deserializes as dictionary from YAML options. #779","title":"v1.6.1"},{"location":"CHANGELOG-v1/#v160","text":"What's changed since v1.5.0: Engine features: Added support for YAML rules. #603 YAML rules evaluate an expression tree and return a result for each object. YAML provides an additional option for defining rules in addition to PowerShell script rules. Type and selector pre-conditions are supported. See about_PSRule_Rules for details. General improvements: Added support for object source location in validation. #757 Default rule source location .ps-rule/ is automatically included. #742 Added Include.Path and Include.Module options to automatically include rule sources. See about_PSRule_Options for details. Bug fixes: Fixed target binding across multiple scopes. #762 What's changed since pre-release v1.6.0-B2108009: No additional changes.","title":"v1.6.0"},{"location":"CHANGELOG-v1/#v160-b2108009-pre-release","text":"What's changed since pre-release v1.6.0-B2108003: Engine features: Added support for YAML rules. #603 YAML rules evaluate an expression tree and return a result for each object. YAML provides an additional option for defining rules in addition to PowerShell script rules. Type and selector pre-conditions are supported. See about_PSRule_Rules for details.","title":"v1.6.0-B2108009 (pre-release)"},{"location":"CHANGELOG-v1/#v160-b2108003-pre-release","text":"What's changed since pre-release v1.6.0-B2107008: Bug fixes: Fixed target binding across multiple scopes. #762","title":"v1.6.0-B2108003 (pre-release)"},{"location":"CHANGELOG-v1/#v160-b2107008-pre-release","text":"What's changed since v1.5.0: General improvements: Added support for object source location in validation. #757 Default rule source location .ps-rule/ is automatically included. #742 Added Include.Path and Include.Module options to automatically include rule sources. See about_PSRule_Options for details.","title":"v1.6.0-B2107008 (pre-release)"},{"location":"CHANGELOG-v1/#v150","text":"What's changed since v1.4.0: General improvements: Added string selector conditions. #747 Use startWith , contains , and endsWith to check for a sub-string. Use isString , isLower , and isUpper to check for string type and casing. See about_PSRule_Selectors for details. Engineering: Bump YamlDotNet dependency to 11.2.1. #740 Bug fixes: Fixed options schema should allow spacing after @pre . #743 Fixed match selector expression passing on missing field. #745 What's changed since pre-release v1.5.0-B2107009: No additional changes.","title":"v1.5.0"},{"location":"CHANGELOG-v1/#v150-b2107009-pre-release","text":"What's changed since pre-release v1.5.0-B2106006: General improvements: Added string selector conditions. #747 Use startWith , contains , and endsWith to check for a sub-string. Use isString , isLower , and isUpper to check for string type and casing. See about_PSRule_Selectors for details. Engineering: Bump YamlDotNet dependency to 11.2.1. #740 Bug fixes: Fixed options schema should allow spacing after @pre . #743 Fixed match selector expression passing on missing field. #745","title":"v1.5.0-B2107009 (pre-release)"},{"location":"CHANGELOG-v1/#v150-b2106006-pre-release","text":"What's changed since v1.4.0: Engineering: Bump YamlDotNet dependency to 11.2.0. #736","title":"v1.5.0-B2106006 (pre-release)"},{"location":"CHANGELOG-v1/#v140","text":"What's changed since v1.3.0: General improvements: PSRule banner can be configured in output when using Assert-PSRule . #708 Input source location of objects are included in results. Input source location of objects from JSON and YAML input files are read automatically. #624 Input source location of objects from the pipeline are read from properties. #729 Assert output improvements: Added support for Visual Studio Code with VisualStudioCode style. #731 Updated output format provides support for problem matchers in task output. Automatically detect output style from environment variables. #732 Assert-PSRule now defaults to Detect instead of Client . See about_PSRule_Options for details. Improved support for version constraints by: Constraints can include prerelease versions of other matching versions. #714 Constraints support using a @prerelease or @pre to include prerelease versions. #717 Constraint sets allow multiple constraints to be joined together. #715 See about_PSRule_Assert for details. Bug fixes: Fixed prerelease constraint handling for prerelease versions. #712 Fixed null reference in convention for nested exceptions. #725 What's changed since pre-release v1.4.0-B2105041: No additional changes.","title":"v1.4.0"},{"location":"CHANGELOG-v1/#v140-b2105041-pre-release","text":"What's changed since pre-release v1.4.0-B2105032: General improvements: Source location of objects from the pipeline are read from properties. #729 Assert output improvements: Added support for Visual Studio Code with VisualStudioCode style. #731 Updated output format provides support for problem matchers in task output. Automatically detect output style from environment variables. #732 Assert-PSRule now defaults to Detect instead of Client . See about_PSRule_Options for details.","title":"v1.4.0-B2105041 (pre-release)"},{"location":"CHANGELOG-v1/#v140-b2105032-pre-release","text":"What's changed since pre-release v1.4.0-B2105019: Bug fixes: Fixed null reference in convention for nested exceptions. #725","title":"v1.4.0-B2105032 (pre-release)"},{"location":"CHANGELOG-v1/#v140-b2105019-pre-release","text":"What's changed since pre-release v1.4.0-B2105004: General improvements: Source location of objects are included in results. Source location of objects from JSON and YAML input files are read automatically. #624 Improved support for version constraints by: Constraints can include prerelease versions of other matching versions. #714 Constraints support using a @prerelease or @pre to include prerelease versions. #717 Constraint sets allow multiple constraints to be joined together. #715 See about_PSRule_Assert for details. Bug fixes: Fixed prerelease constraint handling for prerelease versions. #712","title":"v1.4.0-B2105019 (pre-release)"},{"location":"CHANGELOG-v1/#v140-b2105004-pre-release","text":"What's changed since v1.3.0: General improvements: PSRule banner can be configured in output when using Assert-PSRule . #708","title":"v1.4.0-B2105004 (pre-release)"},{"location":"CHANGELOG-v1/#v130","text":"What's changed since v1.2.0: Engine features: Options can be configured with environment variables. #691 See about_PSRule_Options for details. General improvements: Exclude .git sub-directory by default for recursive scans. #697 Added Input.IgnoreGitPath option to configure inclusion of .git path. See about_PSRule_Options for details. Added file path assertion helpers. #679 Added WithinPath to check the file path field is within a specified path. Added NotWithinPath to check the file path field is not within a specified path See about_PSRule_Assert for details. Added DateTime type assertion helper. #680 Added IsDateTime to check of object field is [DateTime] . See about_PSRule_Assert for details. Improved numeric comparison assertion helpers to compare [DateTime] fields. #685 Less , LessOrEqual , Greater , and GreaterOrEqual compare the number of days from the current time. See about_PSRule_Assert for details. Improved handling of field names for objects implementing IList , IEnumerable , and index properties. #692 Engineering: Bump YamlDotNet dependency to 11.1.1. #690 Bug fixes: Fixed expected DocumentEnd got SequenceEnd. #698 What's changed since pre-release v1.3.0-B2105004: No additional changes.","title":"v1.3.0"},{"location":"CHANGELOG-v1/#v130-b2105004-pre-release","text":"What's changed since pre-release v1.3.0-B2104042: Engine features: Options can be configured with environment variables. #691 See about_PSRule_Options for details. General improvements: Exclude .git sub-directory by default for recursive scans. #697 Added Input.IgnoreGitPath option to configure inclusion of .git path. See about_PSRule_Options for details.","title":"v1.3.0-B2105004 (pre-release)"},{"location":"CHANGELOG-v1/#v130-b2104042-pre-release","text":"What's changed since pre-release v1.3.0-B2104030: Bug fixes: Fixed expected DocumentEnd got SequenceEnd. #698","title":"v1.3.0-B2104042 (pre-release)"},{"location":"CHANGELOG-v1/#v130-b2104030-pre-release","text":"What's changed since pre-release v1.3.0-B2104021: General improvements: Improved handling of field names for objects implementing IList , IEnumerable , and index properties. #692 Engineering: Bump YamlDotNet dependency to 11.1.1. #690","title":"v1.3.0-B2104030 (pre-release)"},{"location":"CHANGELOG-v1/#v130-b2104021-pre-release","text":"What's changed since v1.2.0: General improvements: Added file path assertion helpers. #679 Added WithinPath to check the file path field is within a specified path. Added NotWithinPath to check the file path field is not within a specified path See about_PSRule_Assert for details. Added DateTime type assertion helper. #680 Added IsDateTime to check of object field is [DateTime] . See about_PSRule_Assert for details. Improved numeric comparison assertion helpers to compare [DateTime] fields. #685 Less , LessOrEqual , Greater , and GreaterOrEqual compare the number of days from the current time. See about_PSRule_Assert for details.","title":"v1.3.0-B2104021 (pre-release)"},{"location":"CHANGELOG-v1/#v120","text":"What's changed since v1.1.0: Engine features: Added support for extensibility with conventions. #650 Conventions provide an extensibility point within PSRule to execute actions within the pipeline. A convention can expose Begin , Process , and End blocks. In additional to within rules $PSRule.Data can be accessed from Begin and Process blocks. See about_PSRule_Conventions for details. Added support for object expansion with conventions. #661 Use the $PSRule.Import method to import child source objects into the pipeline. See about_PSRule_Variables for details. Added support for complex pre-conditions with selectors. #649 See about_PSRule_Selectors for details. General improvements: Added support for preferring automatic binding over custom binding configurations. #670 Added the Binding.PreferTargetInfo option to prefer target info specified by the object. See about_PSRule_Options for details. Added strong apiVersion to resource types. #647 Resource schemas now support an apiVersion field. The apiVersion field is optional but recommended. Resources without a apiVersion field will not be supported from PSRule v2. Added warning to flag baseline without apiVersion set. Added support for detecting files headers from additional file extensions using FileHeader . #664 Added .bicep , .csx , .jsx , .groovy , .java , .json , .jsonc , .scala , .rb , .bat , .cmd . Added support for Jenkinsfile and Dockerfile without an extension. See about_PSRule_Assert for details. Added support for automatic type binding with files that do not have a file extension. #665 Bug fixes: Fixed dependent rule execution is skipped for consequent input objects. #657 What's changed since pre-release v1.2.0-B2103043: No additional changes.","title":"v1.2.0"},{"location":"CHANGELOG-v1/#v120-b2103043-pre-release","text":"What's changed since pre-release v1.2.0-B2103031: Engine features: Added support for complex pre-conditions with selectors. #649 General improvements: Added support for preferring automatic binding over custom binding configurations. #670 Added the Binding.PreferTargetInfo option to prefer target info specified by the object. See about_PSRule_Options for details. Added strong apiVersion to resource types. #647 Resource schemas now support an apiVersion field. The apiVersion field is optional but recommended. Resources without a apiVersion field will not be supported from PSRule v2. Added warning to flag baseline without apiVersion set.","title":"v1.2.0-B2103043 (pre-release)"},{"location":"CHANGELOG-v1/#v120-b2103031-pre-release","text":"What's changed since pre-release v1.2.0-B2103023: General improvements: Added support for detecting files headers from additional file extensions. #664 Added .bicep , .csx , .jsx , .groovy , .java , .json , .jsonc , .scala , .rb , .bat , .cmd . Added support for Jenkinsfile and Dockerfile without an extension. See about_PSRule_Assert for details. Added support for automatic type binding with files that do not have a file extension. #665","title":"v1.2.0-B2103031 (pre-release)"},{"location":"CHANGELOG-v1/#v120-b2103023-pre-release","text":"What's changed since pre-release v1.2.0-B2103016: Engine features: Added support for object expansion with conventions. #661 Use the $PSRule.Import method to import child source objects into the pipeline. See about_PSRule_Variables for details.","title":"v1.2.0-B2103023 (pre-release)"},{"location":"CHANGELOG-v1/#v120-b2103016-pre-release","text":"What's changed since pre-release v1.2.0-B2103008: Bug fixes: Fixed dependent rule execution is skipped for consequent input objects. #657","title":"v1.2.0-B2103016 (pre-release)"},{"location":"CHANGELOG-v1/#v120-b2103008-pre-release","text":"What's changed since v1.1.0: Engine features: Added support for extensibility with conventions. #650 Conventions provide an extensibility point within PSRule to execute actions within the pipeline. A convention can expose Begin , Process , and End blocks. In additional to within rules $PSRule.Data can be accessed from Begin and Process blocks. See about_PSRule_Conventions for details.","title":"v1.2.0-B2103008 (pre-release)"},{"location":"CHANGELOG-v1/#v110","text":"What's changed since v1.0.3: Engine features: Added assertion helpers. #640 Added NotHasField to check object does not have any of the specified fields. Added Null to check field value is null. Added NotNull to check field value is not null. See about_PSRule_Assert for details. Added type assertion helpers. #635 Added IsNumeric to check field value is a numeric types. Added IsInteger to check field value is an integer types. Added IsBoolean to check field value is a boolean. Added IsArray to check field value is an array. Added IsString to check field value is a string. Added TypeOf to check field value is a specified type. See about_PSRule_Assert for details. Added content helpers. #637 Added $PSRule.GetContentFirstOrDefault to get content and return the first object. Added $PSRule.GetContentField to get the field from content objects. See about_PSRule_Variables for details. General improvements: Updated HasJsonSchema assertion helper. #636 The URI scheme can optionally be ignored for http:// or https:// URIs. The fragment # is ignored. See about_PSRule_Assert for details. Added support for -Outcome and -As to produce filtered output from Assert-PSRule . #643 Configure Output.As with Summary to produce summarized results per object. Configure Output.Outcome to limit output to Fail or Error . See Assert-PSRule for details. What's changed since pre-release v1.1.0-B2102029: No additional changes.","title":"v1.1.0"},{"location":"CHANGELOG-v1/#v110-b2102029-pre-release","text":"What's changed since pre-release v1.1.0-B2102024: General improvements: Added support for -Outcome and -As to produce filtered output from Assert-PSRule . #643 Configure Output.As with Summary to produce summarized results per object. Configure Output.Outcome to limit output to Fail or Error . See Assert-PSRule for details.","title":"v1.1.0-B2102029 (pre-release)"},{"location":"CHANGELOG-v1/#v110-b2102024-pre-release","text":"What's changed since pre-release v1.1.0-B2102019: Engine features: Added assertion helpers. #640 Added NotHasField to check object does not have any of the specified fields. Added Null to check field value is null. Added NotNull to check field value is not null. See about_PSRule_Assert for details.","title":"v1.1.0-B2102024 (pre-release)"},{"location":"CHANGELOG-v1/#v110-b2102019-pre-release","text":"What's changed since v1.0.3: Engine features: Added type assertion helpers. #635 Added IsNumeric to check field value is a numeric types. Added IsInteger to check field value is an integer types. Added IsBoolean to check field value is a boolean. Added IsArray to check field value is an array. Added IsString to check field value is a string. Added TypeOf to check field value is a specified type. See about_PSRule_Assert for details. Added content helpers. #637 Added $PSRule.GetContentFirstOrDefault to get content and return the first object. Added $PSRule.GetContentField to get the field from content objects. See about_PSRule_Variables for details. General improvements: Updated HasJsonSchema assertion helper. #636 The URI scheme can optionally be ignored for http:// or https:// URIs. The fragment # is ignored. See about_PSRule_Assert for details.","title":"v1.1.0-B2102019 (pre-release)"},{"location":"CHANGELOG-v1/#v103","text":"What's changed since v1.0.2: Bug fixes: Fixed reason reported fields for HasField and HasFields assertion helpers. #632","title":"v1.0.3"},{"location":"CHANGELOG-v1/#v102","text":"What's changed since v1.0.1: Engineering: Bump Manatee.Json dependency to 13.0.5. #619 Bug fixes: Fixed GetContent processing of InputFileInfo . #625 Fixed null reference of rule reason with wide output. #626 Fixed markdown help handling of inline code blocks with [ . #627 Fixed markdown help inclusion of fenced code blocks in notes and description. #628","title":"v1.0.2"},{"location":"CHANGELOG-v1/#v101","text":"What's changed since v1.0.0: Bug fixes: Fixed module source key has already been added. #608","title":"v1.0.1"},{"location":"CHANGELOG-v1/#v100","text":"What's changed since v0.22.0: General improvements: Added rule help link in failed Assert-PSRule output. #595 Engineering: Breaking change : Removed deprecated $Rule properties. #495 Bump Manatee.Json dependency to 13.0.4. #591 What's changed since pre-release v1.0.0-B2011028: No additional changes.","title":"v1.0.0"},{"location":"CHANGELOG-v1/#v100-b2011028-pre-release","text":"What's changed since v0.22.0: General improvements: Added rule help link in failed Assert-PSRule output. #595 Engineering: Breaking change : Removed deprecated $Rule properties. #495 Bump Manatee.Json dependency to 13.0.4. #591","title":"v1.0.0-B2011028 (pre-release)"},{"location":"CHANGELOG-v2/","text":"Change log # See upgrade notes for helpful information when upgrading from previous versions. Important notes : YAML resources will require an apiVersion from PSRule v2. #648 Setting the default module baseline requires a module configuration from PSRule v2. #809 Unreleased # v2.0.0-B2201135 (pre-release) # What's changed since pre-release v2.0.0-B2201117: Engineering: Breaking change: Prefer module sources over loose files. #610 Module sources are discovered before loose files. Warning is shown for duplicate rule names, and exception is thrown for duplicate rule Ids. See upgrade notes for details. Added more tests for JSON resources. #929 Bug fixes: Fixed empty suppression group rules property applies to no rules. #931 Fixed object reference for suppression group will rule not defined. #932 v2.0.0-B2201117 (pre-release) # What's changed since pre-release v2.0.0-B2201093: General improvements: Add option to disable invariant culture warning. #899 Added Execution.InvariantCultureWarning option. See about_PSRule_Options for details. v2.0.0-B2201093 (pre-release) # What's changed since pre-release v2.0.0-B2201075: New features: Add support for suppression groups. #793 New SuppressionGroup resource has been included. See about_PSRule_SuppressionGroups for details. v2.0.0-B2201075 (pre-release) # What's changed since pre-release v2.0.0-B2201054: General improvements: Added support for rule aliases. #792 Aliases allow rules to be references by an alternative name. When renaming rules, add a rule alias to avoid breaking references to the old rule name. To specify an alias use the -Alias parameter or alias metadata property in YAML or JSON. Added support for stable identifiers with rule refs. #881 A rule ref may be optionally be used to reference a rule. Rule refs should be: stable, not changing between releases; opaque, as opposed to being a human-readable string. Stable and opaque refs ease web lookup and to help to avoid language difficulties. To specify a rule ref use the -Ref parameter or ref metadata property in YAML or JSON. Bug fixes: Fixed object path handling with dash. #902 v2.0.0-B2201054 (pre-release) # What's changed since v1.11.0: General improvements: Added support for object path expressions. #808 #693 Inspired by JSONPath, object path expressions can be used to access nested objects. Array members can be filtered and enumerated using object path expressions. Object path expressions can be used in YAML, JSON, and PowerShell rules and selectors. See about_PSRule_Assert for details. Improve tracking of suppressed objects. #794 Added Execution.SuppressedRuleWarning option to output warning for suppressed rules. Engineering: Breaking change: Removal of deprecated default baseline from module manifest. #755 Set the default module baseline using module configuration. See upgrade notes for details. Breaking change: Require apiVersion on YAML and JSON to be specified. #648 Resources should use github.com/microsoft/PSRule/v1 as the apiVersion . Resources that do not specify an apiVersion will be ignored. See upgrade notes for details.","title":"v2 (preview)"},{"location":"CHANGELOG-v2/#change-log","text":"See upgrade notes for helpful information when upgrading from previous versions. Important notes : YAML resources will require an apiVersion from PSRule v2. #648 Setting the default module baseline requires a module configuration from PSRule v2. #809","title":"Change log"},{"location":"CHANGELOG-v2/#unreleased","text":"","title":"Unreleased"},{"location":"CHANGELOG-v2/#v200-b2201135-pre-release","text":"What's changed since pre-release v2.0.0-B2201117: Engineering: Breaking change: Prefer module sources over loose files. #610 Module sources are discovered before loose files. Warning is shown for duplicate rule names, and exception is thrown for duplicate rule Ids. See upgrade notes for details. Added more tests for JSON resources. #929 Bug fixes: Fixed empty suppression group rules property applies to no rules. #931 Fixed object reference for suppression group will rule not defined. #932","title":"v2.0.0-B2201135 (pre-release)"},{"location":"CHANGELOG-v2/#v200-b2201117-pre-release","text":"What's changed since pre-release v2.0.0-B2201093: General improvements: Add option to disable invariant culture warning. #899 Added Execution.InvariantCultureWarning option. See about_PSRule_Options for details.","title":"v2.0.0-B2201117 (pre-release)"},{"location":"CHANGELOG-v2/#v200-b2201093-pre-release","text":"What's changed since pre-release v2.0.0-B2201075: New features: Add support for suppression groups. #793 New SuppressionGroup resource has been included. See about_PSRule_SuppressionGroups for details.","title":"v2.0.0-B2201093 (pre-release)"},{"location":"CHANGELOG-v2/#v200-b2201075-pre-release","text":"What's changed since pre-release v2.0.0-B2201054: General improvements: Added support for rule aliases. #792 Aliases allow rules to be references by an alternative name. When renaming rules, add a rule alias to avoid breaking references to the old rule name. To specify an alias use the -Alias parameter or alias metadata property in YAML or JSON. Added support for stable identifiers with rule refs. #881 A rule ref may be optionally be used to reference a rule. Rule refs should be: stable, not changing between releases; opaque, as opposed to being a human-readable string. Stable and opaque refs ease web lookup and to help to avoid language difficulties. To specify a rule ref use the -Ref parameter or ref metadata property in YAML or JSON. Bug fixes: Fixed object path handling with dash. #902","title":"v2.0.0-B2201075 (pre-release)"},{"location":"CHANGELOG-v2/#v200-b2201054-pre-release","text":"What's changed since v1.11.0: General improvements: Added support for object path expressions. #808 #693 Inspired by JSONPath, object path expressions can be used to access nested objects. Array members can be filtered and enumerated using object path expressions. Object path expressions can be used in YAML, JSON, and PowerShell rules and selectors. See about_PSRule_Assert for details. Improve tracking of suppressed objects. #794 Added Execution.SuppressedRuleWarning option to output warning for suppressed rules. Engineering: Breaking change: Removal of deprecated default baseline from module manifest. #755 Set the default module baseline using module configuration. See upgrade notes for details. Breaking change: Require apiVersion on YAML and JSON to be specified. #648 Resources should use github.com/microsoft/PSRule/v1 as the apiVersion . Resources that do not specify an apiVersion will be ignored. See upgrade notes for details.","title":"v2.0.0-B2201054 (pre-release)"},{"location":"about/","text":"What is PSRule? # PSRule is a rules engine geared towards testing Infrastructure as Code ( IaC ). Rules you write or import perform static analysis on IaC artifacts such as: templates, manifests, pipelines, and workflows. Why use PSRule? # PSRule aims to provide a rich experience for building and running static analysis tests on IaC . While this has some similarities to traditional testing frameworks it extends on the following: Reuse and share \u2014 existing pre-built rules, configure, or write your own. Incremental adoption \u2014 with baselines allows you to keep moving forward. Handle exceptions \u2014 and keep exceptions auditable in git history. Documentation \u2014 provides recommendations and examples instead of just pass or fail.","title":"About"},{"location":"about/#what-is-psrule","text":"PSRule is a rules engine geared towards testing Infrastructure as Code ( IaC ). Rules you write or import perform static analysis on IaC artifacts such as: templates, manifests, pipelines, and workflows.","title":"What is PSRule?"},{"location":"about/#why-use-psrule","text":"PSRule aims to provide a rich experience for building and running static analysis tests on IaC . While this has some similarities to traditional testing frameworks it extends on the following: Reuse and share \u2014 existing pre-built rules, configure, or write your own. Incremental adoption \u2014 with baselines allows you to keep moving forward. Handle exceptions \u2014 and keep exceptions auditable in git history. Documentation \u2014 provides recommendations and examples instead of just pass or fail.","title":"Why use PSRule?"},{"location":"addon-modules/","text":"Additional modules # Pre-built rules # The following modules contain pre-built rules that can be plugged into your pipeline. Module Description Version / downloads PSRule.Rules.Azure A suite of rules to validate Azure resources and infrastructure as code (IaC) using PSRule. PSRule.Rules.Kubernetes A suite of rules to validate Kubernetes resources using PSRule. PSRule.Rules.CAF A suite of rules to validate Azure resources against the Cloud Adoption Framework (CAF) using PSRule. PSRule.Rules.GitHub A suite of rules to validate GitHub repositories using PSRule. PSRule.Rules.MSFT.OSS A suite of rules to validate repositories against Microsoft Open Source Software (OSS) requirements.","title":"Additional modules"},{"location":"addon-modules/#additional-modules","text":"","title":"Additional modules"},{"location":"addon-modules/#pre-built-rules","text":"The following modules contain pre-built rules that can be plugged into your pipeline. Module Description Version / downloads PSRule.Rules.Azure A suite of rules to validate Azure resources and infrastructure as code (IaC) using PSRule. PSRule.Rules.Kubernetes A suite of rules to validate Kubernetes resources using PSRule. PSRule.Rules.CAF A suite of rules to validate Azure resources against the Cloud Adoption Framework (CAF) using PSRule. PSRule.Rules.GitHub A suite of rules to validate GitHub repositories using PSRule. PSRule.Rules.MSFT.OSS A suite of rules to validate repositories against Microsoft Open Source Software (OSS) requirements.","title":"Pre-built rules"},{"location":"creating-your-pipeline/","text":"Creating your pipeline # You can use PSRule to test Infrastructure as Code (IaC) artifacts throughout their lifecycle. By using validation within a continuous integration (CI) pipeline, any issues provide fast feedback. Within the root directory of your IaC repository: GitHub Actions Azure Pipelines Create a new GitHub Actions workflow by creating .github/workflows/analyze-arm.yaml . name : Analyze templates on : - pull_request jobs : analyze_arm : name : Analyze templates runs-on : ubuntu-latest steps : - name : Checkout uses : actions/checkout@v2 # Analyze Azure resources using PSRule for Azure - name : Analyze Azure template files uses : Microsoft/ps-rule@v1.12.0 with : modules : 'PSRule.Rules.Azure' Create a new Azure DevOps YAML pipeline by creating .azure-pipelines/analyze-arm.yaml . steps : # Analyze Azure resources using PSRule for Azure - task : ps-rule-assert@1 displayName : Analyze Azure template files inputs : inputType : repository modules : 'PSRule.Rules.Azure' This will automatically install compatible versions of all dependencies. Configuration # Configuration options for PSRule are set within the ps-rule.yaml file. Ignoring rules # To prevent a rule executing you can either: Exclude \u2014 The rule is not executed for any resource. Suppress \u2014 The rule is not executed for a specific resource by name. To exclude a rule, set Rule.Exclude option within the ps-rule.yaml file. Docs rule : exclude : # Ignore the following rules for all resources - Azure.VM.UseHybridUseBenefit - Azure.VM.Standalone To suppress a rule, set Suppression option within the ps-rule.yaml file. Docs suppression : Azure.AKS.AuthorizedIPs : # Exclude the following externally managed AKS clusters - aks-cluster-prod-eus-001 Azure.Storage.SoftDelete : # Exclude the following non-production storage accounts - storagedeveus6jo36t - storagedeveus1df278 Tip Use comments within ps-rule.yaml to describe the reason why rules are excluded or suppressed. Meaningful comments help during peer review within a Pull Request (PR). Also consider including a date if the exclusions or suppressions are temporary.","title":"Creating your pipeline"},{"location":"creating-your-pipeline/#creating-your-pipeline","text":"You can use PSRule to test Infrastructure as Code (IaC) artifacts throughout their lifecycle. By using validation within a continuous integration (CI) pipeline, any issues provide fast feedback. Within the root directory of your IaC repository: GitHub Actions Azure Pipelines Create a new GitHub Actions workflow by creating .github/workflows/analyze-arm.yaml . name : Analyze templates on : - pull_request jobs : analyze_arm : name : Analyze templates runs-on : ubuntu-latest steps : - name : Checkout uses : actions/checkout@v2 # Analyze Azure resources using PSRule for Azure - name : Analyze Azure template files uses : Microsoft/ps-rule@v1.12.0 with : modules : 'PSRule.Rules.Azure' Create a new Azure DevOps YAML pipeline by creating .azure-pipelines/analyze-arm.yaml . steps : # Analyze Azure resources using PSRule for Azure - task : ps-rule-assert@1 displayName : Analyze Azure template files inputs : inputType : repository modules : 'PSRule.Rules.Azure' This will automatically install compatible versions of all dependencies.","title":"Creating your pipeline"},{"location":"creating-your-pipeline/#configuration","text":"Configuration options for PSRule are set within the ps-rule.yaml file.","title":"Configuration"},{"location":"creating-your-pipeline/#ignoring-rules","text":"To prevent a rule executing you can either: Exclude \u2014 The rule is not executed for any resource. Suppress \u2014 The rule is not executed for a specific resource by name. To exclude a rule, set Rule.Exclude option within the ps-rule.yaml file. Docs rule : exclude : # Ignore the following rules for all resources - Azure.VM.UseHybridUseBenefit - Azure.VM.Standalone To suppress a rule, set Suppression option within the ps-rule.yaml file. Docs suppression : Azure.AKS.AuthorizedIPs : # Exclude the following externally managed AKS clusters - aks-cluster-prod-eus-001 Azure.Storage.SoftDelete : # Exclude the following non-production storage accounts - storagedeveus6jo36t - storagedeveus1df278 Tip Use comments within ps-rule.yaml to describe the reason why rules are excluded or suppressed. Meaningful comments help during peer review within a Pull Request (PR). Also consider including a date if the exclusions or suppressions are temporary.","title":"Ignoring rules"},{"location":"deprecations/","text":"Deprecations # Deprecations for v3 # Rule output object # Several properties of the rule object have been renamed to improve consistency with other objects. Previously rules returned by Get-PSRule returned a rule object which included the following properties: RuleId RuleName Description These have been replaced with the following properties: Id instead of RuleId . Name instead of RuleName . Synopsis instead of Description . From v3 these properties will be removed. These changes do not affect normal usage of PSRule. Supporting scripts that directly use the old names may not work correctly until you update these names. Deprecations for v2 # Default baseline by module manifest # When packaging baselines in a module, you may want to specify a default baseline. PSRule v1.9.0 added support for setting the default baseline in a module configuration. Previously a default baseline could be set by specifying the baseline in the module manifest. From v1.9.0 this is deprecated and will be removed from v2 . For details on how to migrate to the new default baseline option, continue reading the upgrade notes . Resources without an API version # When creating YAML and JSON resources you define a resource by specifying the apiVersion and kind . To allow new schema versions for resources to be introduced in the future, an apiVersion was introduced. For backwards compatibility, resources without an apiVersion deprecated but supported. From v2 resources without an apiVersion will be ignored. For details on how to add an apiVersion to a resource, continue reading the upgrade notes .","title":"Deprecations"},{"location":"deprecations/#deprecations","text":"","title":"Deprecations"},{"location":"deprecations/#deprecations-for-v3","text":"","title":"Deprecations for v3"},{"location":"deprecations/#rule-output-object","text":"Several properties of the rule object have been renamed to improve consistency with other objects. Previously rules returned by Get-PSRule returned a rule object which included the following properties: RuleId RuleName Description These have been replaced with the following properties: Id instead of RuleId . Name instead of RuleName . Synopsis instead of Description . From v3 these properties will be removed. These changes do not affect normal usage of PSRule. Supporting scripts that directly use the old names may not work correctly until you update these names.","title":"Rule output object"},{"location":"deprecations/#deprecations-for-v2","text":"","title":"Deprecations for v2"},{"location":"deprecations/#default-baseline-by-module-manifest","text":"When packaging baselines in a module, you may want to specify a default baseline. PSRule v1.9.0 added support for setting the default baseline in a module configuration. Previously a default baseline could be set by specifying the baseline in the module manifest. From v1.9.0 this is deprecated and will be removed from v2 . For details on how to migrate to the new default baseline option, continue reading the upgrade notes .","title":"Default baseline by module manifest"},{"location":"deprecations/#resources-without-an-api-version","text":"When creating YAML and JSON resources you define a resource by specifying the apiVersion and kind . To allow new schema versions for resources to be introduced in the future, an apiVersion was introduced. For backwards compatibility, resources without an apiVersion deprecated but supported. From v2 resources without an apiVersion will be ignored. For details on how to add an apiVersion to a resource, continue reading the upgrade notes .","title":"Resources without an API version"},{"location":"faq/","text":"Frequently Asked Questions (FAQ) # How is PSRule different to Pester? # PSRule is a framework for testing infrastructure as code ( IaC ) and objects using rules. Rules can be written in PowerShell, YAML, or JSON. Some features include: Objects - PowerShell objects can be validated on the pipeline or imported. Objects can be imported directly from JSON , YAML , or .psd1 . Each object is automatically bound to a target type for use with pre-conditions. Rule results are orientated to validating an object. Built-in assertions , automatically traverse object properties. Pre-conditions - Rules understand which objects they apply to. Objects are bound to a type as they are processed using object properties. Dissimilar objects can be processed quickly. Objects that match no rules are flagged with a warning by default. Packaging - Rules can be reused between projects and optionally packaged into a module. Portable rules, configuration, baselines, and documentation allow greater reuse and distribution. Documentation with detailed guidance or next steps can be included. Standalone or rules from modules can be combined together with -Module and -Path . Configuration - Configuration of rules is handled by PSRule. Rules can be configured at runtime, from YAML configuration, or environment variables. Baselines can be used to pair rules and configuration for a specific scenario. Exceptions - Exceptions to a rule can be ignored for a single object using suppression . Exclusion can be used additionally to ignore a rule entirely. These features make PSRule ideal for validating: Infrastructure as code, including: Kubernetes manifests. Azure Resource Manager (ARM) templates. Configuration files. Pipeline files. Deployments or configurations against a baseline. If you want to test PowerShell code, consider using Pester, we do! What pre-built modules are available for PSRule? # PSRule rules modules can be found on the PowerShell Gallery using the tag PSRule-rules . How do I configure PSRule? # PSRule and rules can be configured by: Parameter - PSRule can be configured at runtime by passing the -Option parameter to cmdlets. Options file - Options stored in YAML are load configuration from file. The default ps-rule.yaml option file is read automatically from the current working path by default. When checking into source control, store this file in the root directory of the repository. Environment variables - Configuration can be specified using environment variables. For example: # With cmdlet $option = New-PSRuleOption -OutputAs Summary -OutputCulture 'en-AU' -NotProcessedWarning $False -Configuration @{ CUSTOM_VALUE = 'example' } $items | Assert-PSRule -Option $option # With hashtable $items | Assert-PSRule -Option @{ 'Output.As' = 'Summary' 'Output.Culture' = 'en-AU' 'Execution.NotProcessedWarning' = $False 'Configuration.CUSTOM_VALUE' = 'Example' } # With YAML output : as : Summary culture : [ 'en-AU' ] execution : notProcessedWarning : false configuration : CUSTOM_VALUE : Example # With environment variable in bash export PSRULE_EXECUTION_NOTPROCESSEDWARNING = false export PSRULE_OUTPUT_AS = Summary export PSRULE_OUTPUT_CULTURE = en-AU export PSRULE_CONFIGURATION_CUSTOM_VALUE = Example For a list of configuration options and usage see about_PSRule_Options . How do I ignore a rule? # To prevent a rule executing you can either: Exclude the rule - The rule is not executed for any object. Suppress the rule - The rule is not executed for a specific object by name. To exclude a rule use the Rule.Exclude option. To do this in YAML, add the following to the ps-rule.yaml options file. # YAML: Using the rule/exclude property rule : exclude : - 'My.FirstRule' # The name of the first rule to exclude. - 'My.SecondRule' # The name of the second rule to exclude. To suppress a rule use the Suppression option. To do this in YAML, add the following to the ps-rule.yaml options file. # YAML: Using the suppression property suppression : My.FirstRule : # The name of the rule being suppressed - TestObject1 # The name of the first object to suppress - TestObject3 # The name of the second object to suppress My.SecondRule : # An additional rule to suppress - TestObject2 The name of the object is reported by PSRule in output results. See about_PSRule_Options for additional usage for both of these options. How do I layer on custom rules on top of an existing module? # PSRule allows rules from modules and standalone (loose) rules to be run together. To run rules from a standalone path use: # Note: .ps-rule/ is a standard path to include standalone rules. # With input from the pipeline $items | Assert-PSRule -Path '.ps-rule/' # With input from file Assert-PSRule -Path '.ps-rule/' -InputPath 'src/' To run rules from an installed module use: # With input from the pipeline $items | Assert-PSRule -Module 'PSRule.Rules.Azure' # With input from file Assert-PSRule -Module 'PSRule.Rules.Azure' -InputPath 'src/' Combining both: Assert-PSRule -Module 'PSRule.Rules.Azure' , 'PSRule.Rules.CAF' -Path '.ps-rule/' -InputPath 'src/' Why should I use PSRule keywords and assertions? # Except for the Rule keyword, using the built-in language features are optional. The built-in keywords and assertions accelerate rule creation. They do this by providing a condition and a set of reasons in a single command. Reasons are also optional; however, they provide additional context as to why the rule failed. Alternatively, you can provide your own reasons to complement standard PowerShell with the Reason keyword.","title":"FAQ"},{"location":"faq/#frequently-asked-questions-faq","text":"","title":"Frequently Asked Questions (FAQ)"},{"location":"faq/#how-is-psrule-different-to-pester","text":"PSRule is a framework for testing infrastructure as code ( IaC ) and objects using rules. Rules can be written in PowerShell, YAML, or JSON. Some features include: Objects - PowerShell objects can be validated on the pipeline or imported. Objects can be imported directly from JSON , YAML , or .psd1 . Each object is automatically bound to a target type for use with pre-conditions. Rule results are orientated to validating an object. Built-in assertions , automatically traverse object properties. Pre-conditions - Rules understand which objects they apply to. Objects are bound to a type as they are processed using object properties. Dissimilar objects can be processed quickly. Objects that match no rules are flagged with a warning by default. Packaging - Rules can be reused between projects and optionally packaged into a module. Portable rules, configuration, baselines, and documentation allow greater reuse and distribution. Documentation with detailed guidance or next steps can be included. Standalone or rules from modules can be combined together with -Module and -Path . Configuration - Configuration of rules is handled by PSRule. Rules can be configured at runtime, from YAML configuration, or environment variables. Baselines can be used to pair rules and configuration for a specific scenario. Exceptions - Exceptions to a rule can be ignored for a single object using suppression . Exclusion can be used additionally to ignore a rule entirely. These features make PSRule ideal for validating: Infrastructure as code, including: Kubernetes manifests. Azure Resource Manager (ARM) templates. Configuration files. Pipeline files. Deployments or configurations against a baseline. If you want to test PowerShell code, consider using Pester, we do!","title":"How is PSRule different to Pester?"},{"location":"faq/#what-pre-built-modules-are-available-for-psrule","text":"PSRule rules modules can be found on the PowerShell Gallery using the tag PSRule-rules .","title":"What pre-built modules are available for PSRule?"},{"location":"faq/#how-do-i-configure-psrule","text":"PSRule and rules can be configured by: Parameter - PSRule can be configured at runtime by passing the -Option parameter to cmdlets. Options file - Options stored in YAML are load configuration from file. The default ps-rule.yaml option file is read automatically from the current working path by default. When checking into source control, store this file in the root directory of the repository. Environment variables - Configuration can be specified using environment variables. For example: # With cmdlet $option = New-PSRuleOption -OutputAs Summary -OutputCulture 'en-AU' -NotProcessedWarning $False -Configuration @{ CUSTOM_VALUE = 'example' } $items | Assert-PSRule -Option $option # With hashtable $items | Assert-PSRule -Option @{ 'Output.As' = 'Summary' 'Output.Culture' = 'en-AU' 'Execution.NotProcessedWarning' = $False 'Configuration.CUSTOM_VALUE' = 'Example' } # With YAML output : as : Summary culture : [ 'en-AU' ] execution : notProcessedWarning : false configuration : CUSTOM_VALUE : Example # With environment variable in bash export PSRULE_EXECUTION_NOTPROCESSEDWARNING = false export PSRULE_OUTPUT_AS = Summary export PSRULE_OUTPUT_CULTURE = en-AU export PSRULE_CONFIGURATION_CUSTOM_VALUE = Example For a list of configuration options and usage see about_PSRule_Options .","title":"How do I configure PSRule?"},{"location":"faq/#how-do-i-ignore-a-rule","text":"To prevent a rule executing you can either: Exclude the rule - The rule is not executed for any object. Suppress the rule - The rule is not executed for a specific object by name. To exclude a rule use the Rule.Exclude option. To do this in YAML, add the following to the ps-rule.yaml options file. # YAML: Using the rule/exclude property rule : exclude : - 'My.FirstRule' # The name of the first rule to exclude. - 'My.SecondRule' # The name of the second rule to exclude. To suppress a rule use the Suppression option. To do this in YAML, add the following to the ps-rule.yaml options file. # YAML: Using the suppression property suppression : My.FirstRule : # The name of the rule being suppressed - TestObject1 # The name of the first object to suppress - TestObject3 # The name of the second object to suppress My.SecondRule : # An additional rule to suppress - TestObject2 The name of the object is reported by PSRule in output results. See about_PSRule_Options for additional usage for both of these options.","title":"How do I ignore a rule?"},{"location":"faq/#how-do-i-layer-on-custom-rules-on-top-of-an-existing-module","text":"PSRule allows rules from modules and standalone (loose) rules to be run together. To run rules from a standalone path use: # Note: .ps-rule/ is a standard path to include standalone rules. # With input from the pipeline $items | Assert-PSRule -Path '.ps-rule/' # With input from file Assert-PSRule -Path '.ps-rule/' -InputPath 'src/' To run rules from an installed module use: # With input from the pipeline $items | Assert-PSRule -Module 'PSRule.Rules.Azure' # With input from file Assert-PSRule -Module 'PSRule.Rules.Azure' -InputPath 'src/' Combining both: Assert-PSRule -Module 'PSRule.Rules.Azure' , 'PSRule.Rules.CAF' -Path '.ps-rule/' -InputPath 'src/'","title":"How do I layer on custom rules on top of an existing module?"},{"location":"faq/#why-should-i-use-psrule-keywords-and-assertions","text":"Except for the Rule keyword, using the built-in language features are optional. The built-in keywords and assertions accelerate rule creation. They do this by providing a condition and a set of reasons in a single command. Reasons are also optional; however, they provide additional context as to why the rule failed. Alternatively, you can provide your own reasons to complement standard PowerShell with the Reason keyword.","title":"Why should I use PSRule keywords and assertions?"},{"location":"features/","text":"Features # DevOps # PSRule allows you to quickly plug-in Infrastructure as Code ( IaC ) controls into your DevOps pipeline. Shift-left \u2014 Identify configuration issues and provide fast feedback in PRs . Quality gates \u2014 Implement quality gates between environments such as dev, test, and prod. Monitor continuously \u2014 Perform ongoing checks for configuration optimization opportunities. Run on MacOS, Linux, and Windows or anywere PowerShell is supported. Native support for popular continuous integration ( CI ) systems includes: GitHub Actions - Trigger tests for GitHub repositories using workflows. Azure Pipelines - Use tasks to run tests in Azure DevOps YAML or Classic pipelines and releases. Extensible # Import pre-built rules or define your own using YAML, JSON, or PowerShell format. Regardless of the format you choose, any combination of YAML, JSON, or PowerShell rules can be used together. YAML \u2014 Use a popular, easy to read, and learn IaC format. With YAML, you can quickly build out common rules with minimal effort and no scripting experience. JSON \u2014 Is ubiquitous used by many tools. While this format is typically harder to read then YAML it is easy to automate. You may prefer to use this format if you are generating rules with automation. PowerShell \u2014 Is a flexiable scripting language. If you or your team already can write a basic PowerShell script, you can already define a rule. PowerShell allows you to tap into a large world-wide community of PowerShell users. Use existing cmdlets to help you build out rules quickly. Rules can be authored using any text editor, but we provide a native extension for Visual Studio Code. Use the extension to quickly author rules or run tests locally before you commit your IaC . Reusable # Typically unit tests in traditional testing frameworks are written for a specific case. This makes it hard invest in tests that are not easily reusable between projects. Several features of PSRule make it eaiser to reuse and share rules across teams or organizations. The following built-in features improve portability: Modular \u2014 Rules can be packages up into a standard PowerShell module then distributed. Private \u2014 Modules can be published privately on a network share or NuGet feed. Public \u2014 Distribute rules globally using the PowerShell Gallery. Configuration \u2014 PSRule and rules can be configured. Baselines \u2014 An artifact containing rules and configuration for a scenario. Suppression \u2014 Allows you to handle and keep exceptions auditable in git history. Approval \u2014 Use code owners and branch policy concepts to control changes. Documentation \u2014 Provide guidance on how to resolve detected issues. Quick - Use a one liner to quickly add a hint or reference on rules you build. Detailed - Support for markdown allows you to provide detailed detailed guidance to resolve issues.","title":"Features"},{"location":"features/#features","text":"","title":"Features"},{"location":"features/#devops","text":"PSRule allows you to quickly plug-in Infrastructure as Code ( IaC ) controls into your DevOps pipeline. Shift-left \u2014 Identify configuration issues and provide fast feedback in PRs . Quality gates \u2014 Implement quality gates between environments such as dev, test, and prod. Monitor continuously \u2014 Perform ongoing checks for configuration optimization opportunities. Run on MacOS, Linux, and Windows or anywere PowerShell is supported. Native support for popular continuous integration ( CI ) systems includes: GitHub Actions - Trigger tests for GitHub repositories using workflows. Azure Pipelines - Use tasks to run tests in Azure DevOps YAML or Classic pipelines and releases.","title":"DevOps"},{"location":"features/#extensible","text":"Import pre-built rules or define your own using YAML, JSON, or PowerShell format. Regardless of the format you choose, any combination of YAML, JSON, or PowerShell rules can be used together. YAML \u2014 Use a popular, easy to read, and learn IaC format. With YAML, you can quickly build out common rules with minimal effort and no scripting experience. JSON \u2014 Is ubiquitous used by many tools. While this format is typically harder to read then YAML it is easy to automate. You may prefer to use this format if you are generating rules with automation. PowerShell \u2014 Is a flexiable scripting language. If you or your team already can write a basic PowerShell script, you can already define a rule. PowerShell allows you to tap into a large world-wide community of PowerShell users. Use existing cmdlets to help you build out rules quickly. Rules can be authored using any text editor, but we provide a native extension for Visual Studio Code. Use the extension to quickly author rules or run tests locally before you commit your IaC .","title":"Extensible"},{"location":"features/#reusable","text":"Typically unit tests in traditional testing frameworks are written for a specific case. This makes it hard invest in tests that are not easily reusable between projects. Several features of PSRule make it eaiser to reuse and share rules across teams or organizations. The following built-in features improve portability: Modular \u2014 Rules can be packages up into a standard PowerShell module then distributed. Private \u2014 Modules can be published privately on a network share or NuGet feed. Public \u2014 Distribute rules globally using the PowerShell Gallery. Configuration \u2014 PSRule and rules can be configured. Baselines \u2014 An artifact containing rules and configuration for a scenario. Suppression \u2014 Allows you to handle and keep exceptions auditable in git history. Approval \u2014 Use code owners and branch policy concepts to control changes. Documentation \u2014 Provide guidance on how to resolve detected issues. Quick - Use a one liner to quickly add a hint or reference on rules you build. Detailed - Support for markdown allows you to provide detailed detailed guidance to resolve issues.","title":"Reusable"},{"location":"install-instructions/","text":"Installation # PSRule supports running within continuous integration ( CI ) systems or locally. It is shipped as a PowerShell module which makes it easy to install and distribute updates. Tip PSRule provides native integration to popular CI systems such as GitHub Actions and Azure Pipelines. If you are using a different CI system you can use the local install to run on MacOS, Linux, and Windows worker nodes. With GitHub Actions # GitHub Action Install and use PSRule with GitHub Actions by referencing the Microsoft/ps-rule action. - name : Analyze Azure template files uses : Microsoft/ps-rule@v1.10.0 This will automatically install compatible versions of all dependencies. With Azure Pipelines # Extension Install and use PSRule with Azure Pipeline by using extension tasks. Install the extension from the marketplace, then use the ps-rule-assert task in pipeline steps. - task : ps-rule-assert@1 displayName : Analyze Azure template files inputs : inputType : repository This will automatically install compatible versions of all dependencies. Installing locally # PSRule can be installed locally from the PowerShell Gallery using PowerShell. You can also use this option to install on CI workers that are not natively supported. The following platforms are supported: Windows PowerShell 5.1 with .NET Framework 4.7.2 or greater. PowerShell 7.1 or greater on MacOS, Linux, and Windows. Installing PowerShell # PowerShell 7.x can be installed on MacOS, Linux, and Windows but is not installed by default. For a list of platforms that PowerShell 7.1 is supported on and install instructions see Get PowerShell . Getting the modules # Module PSRule can be installed or updated from the PowerShell Gallery. Use the following command line examples from a PowerShell terminal to install or update PSRule. For the current user For all users To install PSRule for the current user use: Install-Module -Name 'PSRule' -Repository PSGallery -Scope CurrentUser To update PSRule for the current user use: Update-Module -Name 'PSRule' -Repository PSGallery -Scope CurrentUser To install PSRule for all users (requires admin/ root permissions) use: Install-Module -Name 'PSRule' -Repository PSGallery -Scope AllUsers To update PSRule for all users (requires admin/ root permissions) use: Update-Module -Name 'PSRule' -Repository PSGallery -Scope AllUsers Pre-release versions # To use a pre-release version of PSRule add the -AllowPrerelease switch when calling Install-Module , Update-Module , or Save-Module cmdlets. Tip To install pre-release module versions, the latest version of PowerShellGet may be required. # Install the latest PowerShellGet version Install-Module -Name PowerShellGet -Repository PSGallery -Scope CurrentUser -Force Building from source # Source PSRule is provided as open source on GitHub. To build PSRule from source code: Clone the GitHub repository . Run ./build.ps1 from a PowerShell terminal in the cloned path. This build script will compile the module and documentation then output the result into out/modules/PSRule . Development dependencies # The following PowerShell modules will be automatically install if the required versions are not present: PlatyPS Pester PSScriptAnalyzer PowerShellGet PackageManagement InvokeBuild These additional modules are only required for building PSRule. Additionally .NET Core SDK v3.1 is required. .NET Core will not be automatically downloaded and installed. To download and install the latest SDK see Download .NET Core 3.1 . Limited access networks # If you are on a network that does not permit Internet access to the PowerShell Gallery, download the required PowerShell modules on an alternative device that has access. PowerShell provides the Save-Module cmdlet that can be run from a PowerShell terminal to do this. The following command lines can be used to download the required modules using a PowerShell terminal. After downloading the modules, copy the module directories to devices with restricted Internet access. Runtime modules Development modules To save PSRule for offline use: Save-Module -Name 'PSRule' -Path '.\\modules' This will save PSRule into the modules sub-directory. To save PSRule development module dependencies for offline use: $modules = @( 'PlatyPS' , 'Pester' , 'PSScriptAnalyzer' , 'PowerShellGet' , 'PackageManagement' , 'InvokeBuild' ) Save-Module -Name $modules -Repository PSGallery -Path '.\\modules' ; This will save required developments dependencies into the modules sub-directory.","title":"Installation"},{"location":"install-instructions/#installation","text":"PSRule supports running within continuous integration ( CI ) systems or locally. It is shipped as a PowerShell module which makes it easy to install and distribute updates. Tip PSRule provides native integration to popular CI systems such as GitHub Actions and Azure Pipelines. If you are using a different CI system you can use the local install to run on MacOS, Linux, and Windows worker nodes.","title":"Installation"},{"location":"install-instructions/#with-github-actions","text":"GitHub Action Install and use PSRule with GitHub Actions by referencing the Microsoft/ps-rule action. - name : Analyze Azure template files uses : Microsoft/ps-rule@v1.10.0 This will automatically install compatible versions of all dependencies.","title":"With GitHub Actions"},{"location":"install-instructions/#with-azure-pipelines","text":"Extension Install and use PSRule with Azure Pipeline by using extension tasks. Install the extension from the marketplace, then use the ps-rule-assert task in pipeline steps. - task : ps-rule-assert@1 displayName : Analyze Azure template files inputs : inputType : repository This will automatically install compatible versions of all dependencies.","title":"With Azure Pipelines"},{"location":"install-instructions/#installing-locally","text":"PSRule can be installed locally from the PowerShell Gallery using PowerShell. You can also use this option to install on CI workers that are not natively supported. The following platforms are supported: Windows PowerShell 5.1 with .NET Framework 4.7.2 or greater. PowerShell 7.1 or greater on MacOS, Linux, and Windows.","title":"Installing locally"},{"location":"install-instructions/#installing-powershell","text":"PowerShell 7.x can be installed on MacOS, Linux, and Windows but is not installed by default. For a list of platforms that PowerShell 7.1 is supported on and install instructions see Get PowerShell .","title":"Installing PowerShell"},{"location":"install-instructions/#getting-the-modules","text":"Module PSRule can be installed or updated from the PowerShell Gallery. Use the following command line examples from a PowerShell terminal to install or update PSRule. For the current user For all users To install PSRule for the current user use: Install-Module -Name 'PSRule' -Repository PSGallery -Scope CurrentUser To update PSRule for the current user use: Update-Module -Name 'PSRule' -Repository PSGallery -Scope CurrentUser To install PSRule for all users (requires admin/ root permissions) use: Install-Module -Name 'PSRule' -Repository PSGallery -Scope AllUsers To update PSRule for all users (requires admin/ root permissions) use: Update-Module -Name 'PSRule' -Repository PSGallery -Scope AllUsers","title":"Getting the modules"},{"location":"install-instructions/#pre-release-versions","text":"To use a pre-release version of PSRule add the -AllowPrerelease switch when calling Install-Module , Update-Module , or Save-Module cmdlets. Tip To install pre-release module versions, the latest version of PowerShellGet may be required. # Install the latest PowerShellGet version Install-Module -Name PowerShellGet -Repository PSGallery -Scope CurrentUser -Force","title":"Pre-release versions"},{"location":"install-instructions/#building-from-source","text":"Source PSRule is provided as open source on GitHub. To build PSRule from source code: Clone the GitHub repository . Run ./build.ps1 from a PowerShell terminal in the cloned path. This build script will compile the module and documentation then output the result into out/modules/PSRule .","title":"Building from source"},{"location":"install-instructions/#development-dependencies","text":"The following PowerShell modules will be automatically install if the required versions are not present: PlatyPS Pester PSScriptAnalyzer PowerShellGet PackageManagement InvokeBuild These additional modules are only required for building PSRule. Additionally .NET Core SDK v3.1 is required. .NET Core will not be automatically downloaded and installed. To download and install the latest SDK see Download .NET Core 3.1 .","title":"Development dependencies"},{"location":"install-instructions/#limited-access-networks","text":"If you are on a network that does not permit Internet access to the PowerShell Gallery, download the required PowerShell modules on an alternative device that has access. PowerShell provides the Save-Module cmdlet that can be run from a PowerShell terminal to do this. The following command lines can be used to download the required modules using a PowerShell terminal. After downloading the modules, copy the module directories to devices with restricted Internet access. Runtime modules Development modules To save PSRule for offline use: Save-Module -Name 'PSRule' -Path '.\\modules' This will save PSRule into the modules sub-directory. To save PSRule development module dependencies for offline use: $modules = @( 'PlatyPS' , 'Pester' , 'PSScriptAnalyzer' , 'PowerShellGet' , 'PackageManagement' , 'InvokeBuild' ) Save-Module -Name $modules -Repository PSGallery -Path '.\\modules' ; This will save required developments dependencies into the modules sub-directory.","title":"Limited access networks"},{"location":"license-contributing/","text":"License and contributing # PSRule is licensed with an MIT License , which means it's free to use and modify. But please check out the details. We open source at Microsoft. In addition to our team, we hope you will think about contributing too. Here is how you can get started: Report issues. Upvote existing issues that are important to you. Improve documentation. Contribute code.","title":"License and contributing"},{"location":"license-contributing/#license-and-contributing","text":"PSRule is licensed with an MIT License , which means it's free to use and modify. But please check out the details. We open source at Microsoft. In addition to our team, we hope you will think about contributing too. Here is how you can get started: Report issues. Upvote existing issues that are important to you. Improve documentation. Contribute code.","title":"License and contributing"},{"location":"support/","text":"Support # This project uses GitHub Issues to track bugs and feature requests. Please search the existing issues before filing new issues to avoid duplicates. For new issues, file your bug or feature request as a new issue . For help, discussion, and support questions about using this project, join or start a discussion . Microsoft Support Policy # Support for this project/ product is limited to the resources listed above.","title":"Support"},{"location":"support/#support","text":"This project uses GitHub Issues to track bugs and feature requests. Please search the existing issues before filing new issues to avoid duplicates. For new issues, file your bug or feature request as a new issue . For help, discussion, and support questions about using this project, join or start a discussion .","title":"Support"},{"location":"support/#microsoft-support-policy","text":"Support for this project/ product is limited to the resources listed above.","title":"Microsoft Support Policy"},{"location":"upgrade-notes/","text":"Upgrade notes # This document contains notes to help upgrade from previous versions of PSRule. Upgrading to v2.0.0 # PSRule v2.0.0 is a planned future release. It's not yet available, but you can take these steps to proactively prepare for the release. Setting default module baseline # When packaging rules in a module, you can set the default baseline. The default baseline from the module will be automatically used unless overridden. Prior to v1.9.0 the default baseline was set by configuring the module manifest .psd1 file. From v1.9.0 the default baseline can be configured by within a module configuration. Using module configuration is the recommended method. Setting the default baseline from module manifest and has been removed from v2.0.0 . A module configuration can be defined in YAML. Example --- # Synopsis: Example module configuration for Enterprise.Rules module. apiVersion : github.com/microsoft/PSRule/v1 kind : ModuleConfig metadata : name : Enterprise.Rules spec : rule : baseline : Enterprise.Default Setting resource API version # When creating YAML and JSON resources you define a resource by specifying the apiVersion and kind . An apiVersion was added as a requirement from v1.2.0 . For compatibility resources without an apiVersion were supported however deprecated for removal in v2.0.0 . This has now been removed from v2.0.0 . When defining resource specify an apiVersion . Currently this must be set to github.com/microsoft/PSRule/v1 . YAML JSON --- # Synopsis: An example rule to require TLS. apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'Local.YAML.RequireTLS' spec : condition : field : 'configure.supportsHttpsTrafficOnly' equals : true [ { // Sy n opsis : A n example rule t o require TLS. \"apiVersion\" : \"github.com/microsoft/PSRule/v1\" , \"kind\" : \"Rule\" , \"metadata\" : { \"name\" : \"Local.JSON.RequireTLS\" }, \"spec\" : { \"condition\" : { \"field\" : \"configure.supportsHttpsTrafficOnly\" , \"equals\" : true } } } ] Change in source file discovery for Get-PSRuleHelp # Previously in PSRule v1.11.0 and prior versions, rules would show up twice when running Get-PSRuleHelp in the context of a module and in the same working directory of the module. This behavior has no been removed from v2.0.0 . Module files are now preferred over loose files, and rules are only shown once in the output. Any duplicate rule names from loose files are outputted as a warning instead. The old behavior: Name ModuleName Synopsis ---- ---------- -------- M1 . Rule1 This is the default M1 . Rule2 This is the default M1 . Rule1 TestModule Synopsis en-AU . M1 . Rule2 TestModule This is the default The new behavior: WARNING : A rule with the same name 'M1.Rule1' already exists . WARNING : A rule with the same name 'M1.Rule2' already exists . Name ModuleName Synopsis ---- ---------- -------- M1 . Rule1 TestModule Synopsis en-AU . M1 . Rule2 TestModule This is the default Upgrading to v1.4.0 # Follow these notes to upgrade to PSRule v1.4.0 from previous versions. Change in default output styles # Previously in PSRule v1.3.0 and prior the default style when using Assert-PSRule was Client . From v1.4.0 PSRule now defaults to Detect . The Detect output style falls back to Client however may detect one of the following styles instead: AzurePipelines - Output is written for integration Azure Pipelines. GitHubActions - Output is written for integration GitHub Actions. VisualStudioCode - Output is written for integration with Visual Studio Code. Detect uses the following logic: If the TF_BUILD environment variable is set to true , AzurePipelines will be used. If the GITHUB_ACTIONS environment variable is set to true , GitHubActions will be used. If the TERM_PROGRAM environment variable is set to vscode , VisualStudioCode will be used. Use Client . To force usage of the Client output style set the Output.Style option. For example: # YAML: Using the output/style property output : style : Client # Bash: Using environment variable export PSRULE_OUTPUT_STYLE = Client # GitHub Actions: Using environment variable env : PSRULE_OUTPUT_STYLE : Client # Azure Pipelines: Using environment variable variables : - name : PSRULE_OUTPUT_STYLE value : Client Upgrading to v1.0.0 # Follow these notes to upgrade to PSRule v1.0.0 from previous versions. Replaced $Rule target properties # Previously in PSRule v0.22.0 and prior the $Rule automatic variable had the following properties: TargetName TargetType TargetObject For example: Rule 'Rule1' { $Rule . TargetName -eq 'Name1' ; $Rule . TargetType -eq '.json' ; $Rule . TargetObject . someProperty -eq 1 ; } In v1.0.0 these properties have been removed after being deprecated in v0.12.0 . These properties are instead available on the $PSRule variable. Rules referencing the deprecated properties of $Rule must be updated. For example: Rule 'Rule1' { $PSRule . TargetName -eq 'Name1' ; $PSRule . TargetType -eq '.json' ; $PSRule . TargetObject . someProperty -eq 1 ; }","title":"Upgrade notes"},{"location":"upgrade-notes/#upgrade-notes","text":"This document contains notes to help upgrade from previous versions of PSRule.","title":"Upgrade notes"},{"location":"upgrade-notes/#upgrading-to-v200","text":"PSRule v2.0.0 is a planned future release. It's not yet available, but you can take these steps to proactively prepare for the release.","title":"Upgrading to v2.0.0"},{"location":"upgrade-notes/#setting-default-module-baseline","text":"When packaging rules in a module, you can set the default baseline. The default baseline from the module will be automatically used unless overridden. Prior to v1.9.0 the default baseline was set by configuring the module manifest .psd1 file. From v1.9.0 the default baseline can be configured by within a module configuration. Using module configuration is the recommended method. Setting the default baseline from module manifest and has been removed from v2.0.0 . A module configuration can be defined in YAML. Example --- # Synopsis: Example module configuration for Enterprise.Rules module. apiVersion : github.com/microsoft/PSRule/v1 kind : ModuleConfig metadata : name : Enterprise.Rules spec : rule : baseline : Enterprise.Default","title":"Setting default module baseline"},{"location":"upgrade-notes/#setting-resource-api-version","text":"When creating YAML and JSON resources you define a resource by specifying the apiVersion and kind . An apiVersion was added as a requirement from v1.2.0 . For compatibility resources without an apiVersion were supported however deprecated for removal in v2.0.0 . This has now been removed from v2.0.0 . When defining resource specify an apiVersion . Currently this must be set to github.com/microsoft/PSRule/v1 . YAML JSON --- # Synopsis: An example rule to require TLS. apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'Local.YAML.RequireTLS' spec : condition : field : 'configure.supportsHttpsTrafficOnly' equals : true [ { // Sy n opsis : A n example rule t o require TLS. \"apiVersion\" : \"github.com/microsoft/PSRule/v1\" , \"kind\" : \"Rule\" , \"metadata\" : { \"name\" : \"Local.JSON.RequireTLS\" }, \"spec\" : { \"condition\" : { \"field\" : \"configure.supportsHttpsTrafficOnly\" , \"equals\" : true } } } ]","title":"Setting resource API version"},{"location":"upgrade-notes/#change-in-source-file-discovery-for-get-psrulehelp","text":"Previously in PSRule v1.11.0 and prior versions, rules would show up twice when running Get-PSRuleHelp in the context of a module and in the same working directory of the module. This behavior has no been removed from v2.0.0 . Module files are now preferred over loose files, and rules are only shown once in the output. Any duplicate rule names from loose files are outputted as a warning instead. The old behavior: Name ModuleName Synopsis ---- ---------- -------- M1 . Rule1 This is the default M1 . Rule2 This is the default M1 . Rule1 TestModule Synopsis en-AU . M1 . Rule2 TestModule This is the default The new behavior: WARNING : A rule with the same name 'M1.Rule1' already exists . WARNING : A rule with the same name 'M1.Rule2' already exists . Name ModuleName Synopsis ---- ---------- -------- M1 . Rule1 TestModule Synopsis en-AU . M1 . Rule2 TestModule This is the default","title":"Change in source file discovery for Get-PSRuleHelp"},{"location":"upgrade-notes/#upgrading-to-v140","text":"Follow these notes to upgrade to PSRule v1.4.0 from previous versions.","title":"Upgrading to v1.4.0"},{"location":"upgrade-notes/#change-in-default-output-styles","text":"Previously in PSRule v1.3.0 and prior the default style when using Assert-PSRule was Client . From v1.4.0 PSRule now defaults to Detect . The Detect output style falls back to Client however may detect one of the following styles instead: AzurePipelines - Output is written for integration Azure Pipelines. GitHubActions - Output is written for integration GitHub Actions. VisualStudioCode - Output is written for integration with Visual Studio Code. Detect uses the following logic: If the TF_BUILD environment variable is set to true , AzurePipelines will be used. If the GITHUB_ACTIONS environment variable is set to true , GitHubActions will be used. If the TERM_PROGRAM environment variable is set to vscode , VisualStudioCode will be used. Use Client . To force usage of the Client output style set the Output.Style option. For example: # YAML: Using the output/style property output : style : Client # Bash: Using environment variable export PSRULE_OUTPUT_STYLE = Client # GitHub Actions: Using environment variable env : PSRULE_OUTPUT_STYLE : Client # Azure Pipelines: Using environment variable variables : - name : PSRULE_OUTPUT_STYLE value : Client","title":"Change in default output styles"},{"location":"upgrade-notes/#upgrading-to-v100","text":"Follow these notes to upgrade to PSRule v1.0.0 from previous versions.","title":"Upgrading to v1.0.0"},{"location":"upgrade-notes/#replaced-rule-target-properties","text":"Previously in PSRule v0.22.0 and prior the $Rule automatic variable had the following properties: TargetName TargetType TargetObject For example: Rule 'Rule1' { $Rule . TargetName -eq 'Name1' ; $Rule . TargetType -eq '.json' ; $Rule . TargetObject . someProperty -eq 1 ; } In v1.0.0 these properties have been removed after being deprecated in v0.12.0 . These properties are instead available on the $PSRule variable. Rules referencing the deprecated properties of $Rule must be updated. For example: Rule 'Rule1' { $PSRule . TargetName -eq 'Name1' ; $PSRule . TargetType -eq '.json' ; $PSRule . TargetObject . someProperty -eq 1 ; }","title":"Replaced $Rule target properties"},{"location":"validating-locally/","text":"Validating locally # While preparing infrastructure code artifacts, Azure resources can be validated locally. PSRule can be installed locally on MacOS, Linux, and Windows for local validation. Tip If you haven't already, follow the instructions on installing locally before continuing. With Visual Studio Code # Extension An extension for Visual Studio Code is available for an integrated experience using PSRule for Azure. The Visual Studio Code extension includes a built-in PSRule: Run analysis task. To learn about tasks in Visual Studio Code see Integrate with External Tools via Tasks . To use PSRule for Azure with the built-in PSRule: Run analysis task, insert the following into .vscode/tasks.json . { \"type\" : \"PSRule\" , \"problemMatcher\" : [ \"$PSRule\" ], \"label\" : \"PSRule: Run analysis\" , \"modules\" : [ \"PSRule.Rules.Azure\" ], \"presentation\" : { \"clear\" : true , \"panel\" : \"dedicated\" } } Example A complete .vscode/tasks.json might look like the following: { \"version\" : \"2.0.0\" , \"tasks\" : [ { \"type\" : \"PSRule\" , \"problemMatcher\" : [ \"$PSRule\" ], \"label\" : \"PSRule: Run analysis\" , \"modules\" : [ \"PSRule.Rules.Azure\" ], \"presentation\" : { \"clear\" : true , \"panel\" : \"dedicated\" } } ] }","title":"Validating locally"},{"location":"validating-locally/#validating-locally","text":"While preparing infrastructure code artifacts, Azure resources can be validated locally. PSRule can be installed locally on MacOS, Linux, and Windows for local validation. Tip If you haven't already, follow the instructions on installing locally before continuing.","title":"Validating locally"},{"location":"validating-locally/#with-visual-studio-code","text":"Extension An extension for Visual Studio Code is available for an integrated experience using PSRule for Azure. The Visual Studio Code extension includes a built-in PSRule: Run analysis task. To learn about tasks in Visual Studio Code see Integrate with External Tools via Tasks . To use PSRule for Azure with the built-in PSRule: Run analysis task, insert the following into .vscode/tasks.json . { \"type\" : \"PSRule\" , \"problemMatcher\" : [ \"$PSRule\" ], \"label\" : \"PSRule: Run analysis\" , \"modules\" : [ \"PSRule.Rules.Azure\" ], \"presentation\" : { \"clear\" : true , \"panel\" : \"dedicated\" } } Example A complete .vscode/tasks.json might look like the following: { \"version\" : \"2.0.0\" , \"tasks\" : [ { \"type\" : \"PSRule\" , \"problemMatcher\" : [ \"$PSRule\" ], \"label\" : \"PSRule: Run analysis\" , \"modules\" : [ \"PSRule.Rules.Azure\" ], \"presentation\" : { \"clear\" : true , \"panel\" : \"dedicated\" } } ] }","title":"With Visual Studio Code"},{"location":"authoring/packaging-rules/","text":"Packaging rules in a module # PSRule supports distribution of rules within modules. Using a module, rules can be published and installed using standard PowerShell cmdlets. You should consider packaging rules into a module to: Version rules. PowerShell modules support semantic versioning (semver). Reuse rules across projects, pipelines or teams. Publish rules to external consumers via the PowerShell Gallery. This scenario covers the following: Creating a module manifest Including rules and baselines Defining a module configuration Including documentation Creating a module manifest # When creating a PowerShell module, a module manifest is an optional file that stores module metadata. Module manifests use the .psd1 file extension. When packaging rules in a module, a module manifest is required for PSRule discover the module. Creating the manifest file # A module manifest can be created from PowerShell using the New-ModuleManifest cmdlet. Additionally, Visual Studio Code and many other tools also include snippets for creating a module manifest. For example: # Create a directory for the module md ./ Enterprise . Rules ; # Create the manifest New-ModuleManifest -Path ./ Enterprise . Rules / Enterprise . Rules . psd1 -Tags 'PSRule-rules' ; The example above creates a module manifest for a module named Enterprise.Rules tagged with PSRule-rules . The use of the PSRule-rules tag is explained in the following section. Setting module tags # When PSRule cmdlets are used with the -Module parameter, PSRule discovers rule modules. If the module is already imported, that module is used. If the module is not imported, PSRule will import the highest version of the module automatically. For a module to be discovered by PSRule, tag the module with PSRule-rules . To tag modules, find the Tags section the PSData hashtable in the module manifest and add PSRule-rules . An updated module manifest may look like this: # Private data to pass to the module specified in RootModule/ModuleToProcess. This may also contain a PSData hashtable with additional module metadata used by PowerShell. PrivateData = @{ PSData = @{ # Tags applied to this module. These help with module discovery in online galleries. Tags = @( 'PSRule-rules' ) } } Including rules and baselines # Rules and baselines can be included anywhere within the module directory structure. Such as in the root directory of the module or in a nested sub-directory. By convention, consider including rules and baselines within a rules sub-directory within the module. For example: Enterprise.Rules/ rules/ Baseline.Rule.yaml Config.Rule.yaml Standards.Rule.ps1 Enterprise.Rules.psd1 File names # For PSRule to find rules included in a module, rule file names must end with the .Rule.ps1 suffix. We recommend using the exact case .Rule.ps1 . This is because some file systems are case-sensitive. For example, on Linux Standards.rule.ps1 would be ignored by PSRule. Similarly, when including baselines within a module use the .Rule.yaml suffix. Defining a module configuration # A module configuration that sets options defaults and can be optionally packaged with a module. To set a module configuration, define a ModuleConfig resource within an included .Rule.yaml file. A module configuration .Rule.yaml file must be distributed within the module directory structure. PSRule only supports a single ModuleConfig resource. The name of the ModuleConfig must match the name of the module. Additional ModuleConfig resources or with an alternative name are ignored. PSRule does not support module configurations distributed outside of a module. Example --- # Synopsis: Example module configuration for Enterprise.Rules module. apiVersion : github.com/microsoft/PSRule/v1 kind : ModuleConfig metadata : name : Enterprise.Rules spec : binding : targetName : - ResourceName - FullName - name targetType : - ResourceType - type - Extension field : resourceId : [ 'ResourceId' ] subscriptionId : [ 'SubscriptionId' ] resourceGroupName : [ 'ResourceGroupName' ] rule : baseline : Enterprise.Default The following options are allowed within a ModuleConfig : Binding.Field Binding.IgnoreCase Binding.NameSeparator Binding.PreferTargetInfo Binding.TargetName Binding.TargetType Binding.UseQualifiedName Configuration Output.Culture Rule.Baseline Setting a default baseline # Optionally, baselines can be included in rule modules. If a baseline contains configuration or binding options then setting a default baseline is often desirable. When a default baseline is set, PSRule will use the named baseline automatically when processing rules from that module. This feature removes the need for users to specify it manually. To set a default baseline, set the Rule.Baseline property of the ModuleConfig resource. Example --- # Synopsis: Example module configuration for Enterprise.Rules module. apiVersion : github.com/microsoft/PSRule/v1 kind : ModuleConfig metadata : name : Enterprise.Rules spec : binding : targetName : - ResourceName - FullName - name targetType : - ResourceType - type - Extension field : resourceId : [ 'ResourceId' ] subscriptionId : [ 'SubscriptionId' ] resourceGroupName : [ 'ResourceGroupName' ] rule : baseline : Enterprise.Default This examples set the default baseline to Enterprise.Default . The default baseline must be included in file ending with .Rule.yaml within the module directory structure. Including documentation # PSRule supports write and packaging rule modules with markdown documentation. Markdown documentation is automatically interpreted by PSRule and included in output. When including markdown, files are copied into a directory structure based on the target culture. For example, store documentation targeted to the culture en-US in a directory named en-US . Similarly, documentation for cultures such as en-AU , en-GB and fr-FR would be in separate directories. If a directory for the exact culture en-US doesn't exist, PSRule will attempt to find the parent culture. For example, documentation would be read from a directory named en . When naming directories for their culture, use exact case. This is because some file systems are case-sensitive. For example on Linux en-us would not match. For example: Enterprise.Rules/ en/ Org.Az.Storage.UseHttps.md Org.Az.Resource.Tagging.md en-US/ Org.Az.Storage.UseHttps.md fr-FR/ Org.Az.Storage.UseHttps.md rules/ Baseline.Rule.yaml Config.Rule.yaml Standards.Rule.ps1 Enterprise.Rules.psd1 More information # Enterprise.Rules.psd1 - An example module manifest. Baseline.Rule.yaml - An example baseline. Config.Rule.yaml - An example module configuration.","title":"Packaging rules in a module"},{"location":"authoring/packaging-rules/#packaging-rules-in-a-module","text":"PSRule supports distribution of rules within modules. Using a module, rules can be published and installed using standard PowerShell cmdlets. You should consider packaging rules into a module to: Version rules. PowerShell modules support semantic versioning (semver). Reuse rules across projects, pipelines or teams. Publish rules to external consumers via the PowerShell Gallery. This scenario covers the following: Creating a module manifest Including rules and baselines Defining a module configuration Including documentation","title":"Packaging rules in a module"},{"location":"authoring/packaging-rules/#creating-a-module-manifest","text":"When creating a PowerShell module, a module manifest is an optional file that stores module metadata. Module manifests use the .psd1 file extension. When packaging rules in a module, a module manifest is required for PSRule discover the module.","title":"Creating a module manifest"},{"location":"authoring/packaging-rules/#creating-the-manifest-file","text":"A module manifest can be created from PowerShell using the New-ModuleManifest cmdlet. Additionally, Visual Studio Code and many other tools also include snippets for creating a module manifest. For example: # Create a directory for the module md ./ Enterprise . Rules ; # Create the manifest New-ModuleManifest -Path ./ Enterprise . Rules / Enterprise . Rules . psd1 -Tags 'PSRule-rules' ; The example above creates a module manifest for a module named Enterprise.Rules tagged with PSRule-rules . The use of the PSRule-rules tag is explained in the following section.","title":"Creating the manifest file"},{"location":"authoring/packaging-rules/#setting-module-tags","text":"When PSRule cmdlets are used with the -Module parameter, PSRule discovers rule modules. If the module is already imported, that module is used. If the module is not imported, PSRule will import the highest version of the module automatically. For a module to be discovered by PSRule, tag the module with PSRule-rules . To tag modules, find the Tags section the PSData hashtable in the module manifest and add PSRule-rules . An updated module manifest may look like this: # Private data to pass to the module specified in RootModule/ModuleToProcess. This may also contain a PSData hashtable with additional module metadata used by PowerShell. PrivateData = @{ PSData = @{ # Tags applied to this module. These help with module discovery in online galleries. Tags = @( 'PSRule-rules' ) } }","title":"Setting module tags"},{"location":"authoring/packaging-rules/#including-rules-and-baselines","text":"Rules and baselines can be included anywhere within the module directory structure. Such as in the root directory of the module or in a nested sub-directory. By convention, consider including rules and baselines within a rules sub-directory within the module. For example: Enterprise.Rules/ rules/ Baseline.Rule.yaml Config.Rule.yaml Standards.Rule.ps1 Enterprise.Rules.psd1","title":"Including rules and baselines"},{"location":"authoring/packaging-rules/#file-names","text":"For PSRule to find rules included in a module, rule file names must end with the .Rule.ps1 suffix. We recommend using the exact case .Rule.ps1 . This is because some file systems are case-sensitive. For example, on Linux Standards.rule.ps1 would be ignored by PSRule. Similarly, when including baselines within a module use the .Rule.yaml suffix.","title":"File names"},{"location":"authoring/packaging-rules/#defining-a-module-configuration","text":"A module configuration that sets options defaults and can be optionally packaged with a module. To set a module configuration, define a ModuleConfig resource within an included .Rule.yaml file. A module configuration .Rule.yaml file must be distributed within the module directory structure. PSRule only supports a single ModuleConfig resource. The name of the ModuleConfig must match the name of the module. Additional ModuleConfig resources or with an alternative name are ignored. PSRule does not support module configurations distributed outside of a module. Example --- # Synopsis: Example module configuration for Enterprise.Rules module. apiVersion : github.com/microsoft/PSRule/v1 kind : ModuleConfig metadata : name : Enterprise.Rules spec : binding : targetName : - ResourceName - FullName - name targetType : - ResourceType - type - Extension field : resourceId : [ 'ResourceId' ] subscriptionId : [ 'SubscriptionId' ] resourceGroupName : [ 'ResourceGroupName' ] rule : baseline : Enterprise.Default The following options are allowed within a ModuleConfig : Binding.Field Binding.IgnoreCase Binding.NameSeparator Binding.PreferTargetInfo Binding.TargetName Binding.TargetType Binding.UseQualifiedName Configuration Output.Culture Rule.Baseline","title":"Defining a module configuration"},{"location":"authoring/packaging-rules/#setting-a-default-baseline","text":"Optionally, baselines can be included in rule modules. If a baseline contains configuration or binding options then setting a default baseline is often desirable. When a default baseline is set, PSRule will use the named baseline automatically when processing rules from that module. This feature removes the need for users to specify it manually. To set a default baseline, set the Rule.Baseline property of the ModuleConfig resource. Example --- # Synopsis: Example module configuration for Enterprise.Rules module. apiVersion : github.com/microsoft/PSRule/v1 kind : ModuleConfig metadata : name : Enterprise.Rules spec : binding : targetName : - ResourceName - FullName - name targetType : - ResourceType - type - Extension field : resourceId : [ 'ResourceId' ] subscriptionId : [ 'SubscriptionId' ] resourceGroupName : [ 'ResourceGroupName' ] rule : baseline : Enterprise.Default This examples set the default baseline to Enterprise.Default . The default baseline must be included in file ending with .Rule.yaml within the module directory structure.","title":"Setting a default baseline"},{"location":"authoring/packaging-rules/#including-documentation","text":"PSRule supports write and packaging rule modules with markdown documentation. Markdown documentation is automatically interpreted by PSRule and included in output. When including markdown, files are copied into a directory structure based on the target culture. For example, store documentation targeted to the culture en-US in a directory named en-US . Similarly, documentation for cultures such as en-AU , en-GB and fr-FR would be in separate directories. If a directory for the exact culture en-US doesn't exist, PSRule will attempt to find the parent culture. For example, documentation would be read from a directory named en . When naming directories for their culture, use exact case. This is because some file systems are case-sensitive. For example on Linux en-us would not match. For example: Enterprise.Rules/ en/ Org.Az.Storage.UseHttps.md Org.Az.Resource.Tagging.md en-US/ Org.Az.Storage.UseHttps.md fr-FR/ Org.Az.Storage.UseHttps.md rules/ Baseline.Rule.yaml Config.Rule.yaml Standards.Rule.ps1 Enterprise.Rules.psd1","title":"Including documentation"},{"location":"authoring/packaging-rules/#more-information","text":"Enterprise.Rules.psd1 - An example module manifest. Baseline.Rule.yaml - An example baseline. Config.Rule.yaml - An example module configuration.","title":"More information"},{"location":"authoring/storing-rules/","text":"Storing and naming rules # Rules are stored in one or more files and each file can contain one or many rules. Additionally, rules can be grouped into a module and distributed. Abstract This topic covers recommendations for naming and storing rules. Using a standard file path # Rules can be standalone or packaged within a module. Standalone rules are ideal for a single project such as an Infrastructure as Code (IaC) repository. To reuse rules across multiple projects consider packaging these as a module. The instructions for packaging rules in a module can be found here: Packaging rules in a module To store standalone rules we recommend that you: Use .ps-rule/ \u2014 Create a sub-directory called .ps-rule in the root of your repository. Use all lower-case in the sub-directory name. Put any custom rules within this sub-directory. Use files ending with .Rule.* \u2014 PSRule uses a file naming convention to discover rules. Use one of the following depending on the file format you are using: YAML - .Rule.yaml . JSON - .Rule.jsonc or .Rule.json . PowerShell - .Rule.ps1 . Note Build pipelines are often case-sensitive or run on Linux-based systems. Using the casing rule above reduces confusion latter when you configure continuous integration (CI). Naming rules # When running PSRule, rule names must be unique. For example, PSRule for Azure uses the name prefix of Azure. for rules included in the module. Example The following names are examples of rules included within PSRule for Azure: Azure.AKS.Version Azure.AKS.AuthorizedIPs Azure.SQL.MinTLS When naming custom rules we recommend that you: Use a standard prefix \u2014 You can use the Local. or Org. prefix for standalone rules. Alternatively choose a short prefix that identifies your organization. Use dotted notation \u2014 Use dots to separate rule name. Use a maximum length of 35 characters \u2014 The default view of Invoke-PSRule truncates longer names. PSRule supports longer rule names however if Invoke-PSRule is called directly consider using Format-List .","title":"Storing and naming rules"},{"location":"authoring/storing-rules/#storing-and-naming-rules","text":"Rules are stored in one or more files and each file can contain one or many rules. Additionally, rules can be grouped into a module and distributed. Abstract This topic covers recommendations for naming and storing rules.","title":"Storing and naming rules"},{"location":"authoring/storing-rules/#using-a-standard-file-path","text":"Rules can be standalone or packaged within a module. Standalone rules are ideal for a single project such as an Infrastructure as Code (IaC) repository. To reuse rules across multiple projects consider packaging these as a module. The instructions for packaging rules in a module can be found here: Packaging rules in a module To store standalone rules we recommend that you: Use .ps-rule/ \u2014 Create a sub-directory called .ps-rule in the root of your repository. Use all lower-case in the sub-directory name. Put any custom rules within this sub-directory. Use files ending with .Rule.* \u2014 PSRule uses a file naming convention to discover rules. Use one of the following depending on the file format you are using: YAML - .Rule.yaml . JSON - .Rule.jsonc or .Rule.json . PowerShell - .Rule.ps1 . Note Build pipelines are often case-sensitive or run on Linux-based systems. Using the casing rule above reduces confusion latter when you configure continuous integration (CI).","title":"Using a standard file path"},{"location":"authoring/storing-rules/#naming-rules","text":"When running PSRule, rule names must be unique. For example, PSRule for Azure uses the name prefix of Azure. for rules included in the module. Example The following names are examples of rules included within PSRule for Azure: Azure.AKS.Version Azure.AKS.AuthorizedIPs Azure.SQL.MinTLS When naming custom rules we recommend that you: Use a standard prefix \u2014 You can use the Local. or Org. prefix for standalone rules. Alternatively choose a short prefix that identifies your organization. Use dotted notation \u2014 Use dots to separate rule name. Use a maximum length of 35 characters \u2014 The default view of Invoke-PSRule truncates longer names. PSRule supports longer rule names however if Invoke-PSRule is called directly consider using Format-List .","title":"Naming rules"},{"location":"authoring/writing-rule-help/","text":"Writing rule help # PSRule has built-in support for help. Documentation can optionally be added for each rule to provide detailed information or remediation steps. This scenario covers the following: Using inline help Writing markdown documentation Localizing documentation files Using inline help # When authoring rules in PowerShell, PSRule provides the following syntax features: Comment metadata. Recommend keyword. Reason keyword. These features are each describe in detail in the following sections. Comment metadata # Comment metadata can be included directly above a rule block by using the syntax # Synopsis: <text> . This is only supported for populating a rule synopsis. For example: # Synopsis: Must have the app.kubernetes.io/name label Rule 'metadata.Name' -Type 'Deployment' , 'Service' { Exists \"metadata.labels.'app.kubernetes.io/name'\" } This example above would set the synopsis to Must have the app.kubernetes.io/name label . Including comment metadata improves authoring by indicating the rules purpose. Only a single line is supported. A rule synopsis is displayed when using Get-PSRule and Get-PSRuleHelp . The synopsis can not break over multiple lines. The key limitation of only using comment metadata is that it can not be localized for multiple languages. Consider using comment metadata and also using markdown documentation for a multi-language experience. Recommend keyword # The Recommend keyword sets the recommendation for a rule. Use the keyword with a text recommendation at the top of your rule body. Using the Recommend keyword is recommended for rules that are not packaged in a module. When packaging rules in a module consider using markdown help instead. For example: # Synopsis: Must have the app.kubernetes.io/name label Rule 'metadata.Name' -Type 'Deployment' , 'Service' { Recommend 'Consider setting the recommended label ''app.kubernetes.io/name'' on deployment and service resources.' Exists \"metadata.labels.'app.kubernetes.io/name'\" } A rule recommendation is displayed when using Invoke-PSRule or Get-PSRuleHelp . Only use the Recommend keyword once to set the recommendation text and avoid formatting with variables. Recommendations are cached the first time they are used. Supplying a unique recommendation within a rule based on conditions/ logic is not supported. To return a custom unique reason for why the rule failed, use the Reason keyword. Localized recommendations can set by using the $LocalizedData . For example: # Synopsis: Must have the app.kubernetes.io/name label Rule 'metadata.Name' -Type 'Deployment' , 'Service' { Recommend $LocalizedData . RecommendNameLabel Exists \"metadata.labels.'app.kubernetes.io/name'\" } Reason keyword # The Reason keyword sets the reason the rule failed when using Invoke-PSRule and Assert-PSRule . The reason is only included in detailed output if the rule did not pass. If the rule passed, then reason is empty it returned output. Reasons are not included in the default view when using Invoke-PSRule . Use -OutputFormat Wide to display reason messages. To set a reason use the Reason keyword followed by the reason. For example: # Synopsis: Must have the app.kubernetes.io/name label Rule 'metadata.Name' -Type 'Deployment' , 'Service' { Recommend $LocalizedData . RecommendNameLabel Exists \"metadata.labels.'app.kubernetes.io/name'\" Reason 'The standard name label is not set.' } The Reason keyword can be used multiple times within conditional logic to return a list of reasons the rule failed. Additionally the reason messages can be localized by using the $LocalizedData variable. For example: # Synopsis: Must have the app.kubernetes.io/name label Rule 'metadata.Name' -Type 'Deployment' , 'Service' { Recommend $LocalizedData . RecommendNameLabel Exists \"metadata.labels.'app.kubernetes.io/name'\" # $LocalizedData.ReasonLabelMissing is set to 'The standard {0} label is not set.'. Reason ( $LocalizedData . ReasonLabelMissing -f 'name' ) } Writing markdown documentation # In addition to inline help, documentation can be written in markdown to provide online and offline help. Extended documentation is generally easier to author using markdown. Additionally markdown documentation is easily localized. Markdown documentation is authored by creating one or more .md files, one for each rule. PSRule uses a naming convention with a file name the same as the rule to match rule to markdown. For example, metadata.Name.md would be used for a rule named metadata.Name . We recommend matching the rule name case exactly when naming markdown files. This is because some file systems are case-sensitive. For example on Linux Metadata.Name.md would not match. Within each markdown file a number of predefined sections are automatically interpreted by PSRule. While it is possible to have additional sections, they will be ignored by the help system. The basic structure of markdown help is as follows: --- {{ Annotations }} --- # {{ Name of rule }} {{ A brief summary of the rule }} ## Description {{ A detailed description of the rule }} ## Recommendation {{ A detailed explanation of the steps required to pass the rule }} ## Notes {{ Additional information or configuration options }} ## Links {{ Links to external references }} The PSRule Visual Studio Code extension includes snippets for writing markdown documentation. Annotations # The annotation front matter at the top of the markdown document, is a set of key value pairs. Front matter follows YAML conventions and must start on the first line of the markdown document. A --- on a separate line indicates the start and end of the front matter block. Within the front matter block, all key value pairs are treated as annotations by PSRule. Annotations are optional metadata that are associated with the rule. Any annotations associated with a rule are included in output. Some examples of annotations include; severity , category , author . Annotations differ from tags in two key ways: Annotations are localized, and can have a different value for different languages; tags are not. Tags are indexed and can be used to filter rules; annotations have no affect on rule filtering. The following reserved annotation exists: online version - A URL to the online version of the document, used by Get-PSRuleHelp -Online . --- online version: https://github.com/microsoft/PSRule/blob/main/docs/scenarios/rule-docs/rule-docs.md --- The front matter start and end --- are not required and can be removed if no annotations are defined. Display name # The document title, indicated by a level one heading # is the display name of the rule. The rule display name is shown when using Get-PSRuleHelp and is included in output. Specify the display name on a single line. Wrapping the display name across multiple lines is not supported. For example: # Use recommended name label Synopsis section # The synopsis section is indicated by the heading `. Any text following the heading is interpreted by PSRule and included in output. The synopsis is displayed when using Get-PSRule and Get-PSRuleHelp` cmdlets. The synopsis is intended to be a brief description of the rule, over a single line. A good synopsis should convey the purpose of the rule. A more verbose description can be included in the description section. For example: Deployments and services must use the app.kubernetes.io/name label. Description section # The description section is indicated by the heading ## Description . Any text following the heading is interpreted by PSRule and included in output. The description is displayed when using the Get-PSRuleHelp cmdlet. The description is intended to be a verbose description of the rule. If your rule documentation needs to include background information include it here. PSRule supports semantic line breaks, and will automatically run together lines into a single paragraph. Use a blank line to separate paragraphs. For example: ## Description Kubernetes defines a common set of labels that are recommended for tool interoperability. These labels should be used to consistently apply standard metadata. The `app.kubernetes.io/name` label should be used to specify the name of the application. Recommendation section # The recommendation section is indicated by the heading ## Recommendation . Any text following the heading is interpreted by PSRule and included in output. The recommendation is displayed when using the Invoke-PSRule and Get-PSRuleHelp cmdlets. The recommendation is intended to identify corrective actions that can be taken to address any failures. Avoid using URLs within the recommendations. Use the links section to include references to external sources. PSRule supports semantic line breaks, and will automatically run together lines into a single paragraph. Use a blank line to separate paragraphs. For example: ## Recommendation Consider setting the recommended label `app.kubernetes.io/name` on deployment and service resources. Notes section # The notes section is indicated by the heading ## Notes . Any text following the heading is interpreted by PSRule and included in pipeline output. Notes are excluded when formatting output as YAML and JSON. To view any included notes use the Get-PSRuleHelp cmdlet with the -Full switch. Use notes to include additional information such configuration options. PSRule supports semantic line breaks, and will automatically run together lines into a single paragraph. Use a blank line to separate paragraphs. For example: ## Notes The Kubernetes recommended labels include: - `app.kubernetes.io/name` - `app.kubernetes.io/instance` - `app.kubernetes.io/version` - `app.kubernetes.io/component` - `app.kubernetes.io/part-of` - `app.kubernetes.io/managed-by` Links section # The links section is indicated by the heading ## Links . Any markdown links following the heading are interpreted by PSRule and included in pipeline output. Links are excluded when formatting output as YAML and JSON. To view any included links use the Get-PSRuleHelp cmdlet with the -Full switch. Use links to reference external sources with a URL. To specify links, use the markdown syntax [display name](url) . Include each link on a separate line. To improve display in web rendered markdown, use a list of links by prefixing the line with - . Additional text such as See additional information: is useful for web rendered views, but ignored by PSRule. For example: ## Links - [Recommended Labels](https://kubernetes.io/docs/concepts/overview/working-with-objects/common-labels/) Localizing documentation files # When distributing rules, you may need to provide rule help in different languages. PSRule builds on the culture system in PowerShell. Using cultures # A directory structure is used to identify the markdown documentation that should be used for each culture. To get a list of cultures in PowerShell the use cmdlet Get-Culture -ListAvailable . For example, store documentation targeted to the culture en-US in a directory named en-US . Similarly, documentation for cultures such as en-AU , en-GB and fr-FR would be in separate directories. If a directory for the exact culture en-US doesn't exist, PSRule will attempt to find the parent culture. For example, documentation would be read from a directory named en . When naming directories for their culture, use exact case. This is because some file systems are case-sensitive. For example on Linux en-us would not match. Culture directory search path # The path that PSRule looks for a culture directory in varies depending on how the rule is redistributed. Rules can be redistributed individually (loose) or included in a module. The following logic is used to locate the culture directory. If the rules are loose, PSRule will search for the culture directory in the same subdirectory as the .Rule.ps1 file. When rules are included in a module, PSRule will search for the culture directory in the same subdirectory as the module manifest .psd1 file. For example, loose file structure: .ps-rule/ en/ metadata.Name.md en-US/ metadata.Name.md fr-FR/ metadata.Name.md kubernetes.Rule.ps1 Module file structure: Kubernetes.Rules/ en/ metadata.Name.md en-US/ metadata.Name.md fr-FR/ metadata.Name.md rules/ kubernetes.Rule.ps1 Kubernetes.Rules.psd1 More information # kubernetes.Rule.ps1 - An example rule for validating name label. metadata.Name - An example markdown documentation file.","title":"Writing rule help"},{"location":"authoring/writing-rule-help/#writing-rule-help","text":"PSRule has built-in support for help. Documentation can optionally be added for each rule to provide detailed information or remediation steps. This scenario covers the following: Using inline help Writing markdown documentation Localizing documentation files","title":"Writing rule help"},{"location":"authoring/writing-rule-help/#using-inline-help","text":"When authoring rules in PowerShell, PSRule provides the following syntax features: Comment metadata. Recommend keyword. Reason keyword. These features are each describe in detail in the following sections.","title":"Using inline help"},{"location":"authoring/writing-rule-help/#comment-metadata","text":"Comment metadata can be included directly above a rule block by using the syntax # Synopsis: <text> . This is only supported for populating a rule synopsis. For example: # Synopsis: Must have the app.kubernetes.io/name label Rule 'metadata.Name' -Type 'Deployment' , 'Service' { Exists \"metadata.labels.'app.kubernetes.io/name'\" } This example above would set the synopsis to Must have the app.kubernetes.io/name label . Including comment metadata improves authoring by indicating the rules purpose. Only a single line is supported. A rule synopsis is displayed when using Get-PSRule and Get-PSRuleHelp . The synopsis can not break over multiple lines. The key limitation of only using comment metadata is that it can not be localized for multiple languages. Consider using comment metadata and also using markdown documentation for a multi-language experience.","title":"Comment metadata"},{"location":"authoring/writing-rule-help/#recommend-keyword","text":"The Recommend keyword sets the recommendation for a rule. Use the keyword with a text recommendation at the top of your rule body. Using the Recommend keyword is recommended for rules that are not packaged in a module. When packaging rules in a module consider using markdown help instead. For example: # Synopsis: Must have the app.kubernetes.io/name label Rule 'metadata.Name' -Type 'Deployment' , 'Service' { Recommend 'Consider setting the recommended label ''app.kubernetes.io/name'' on deployment and service resources.' Exists \"metadata.labels.'app.kubernetes.io/name'\" } A rule recommendation is displayed when using Invoke-PSRule or Get-PSRuleHelp . Only use the Recommend keyword once to set the recommendation text and avoid formatting with variables. Recommendations are cached the first time they are used. Supplying a unique recommendation within a rule based on conditions/ logic is not supported. To return a custom unique reason for why the rule failed, use the Reason keyword. Localized recommendations can set by using the $LocalizedData . For example: # Synopsis: Must have the app.kubernetes.io/name label Rule 'metadata.Name' -Type 'Deployment' , 'Service' { Recommend $LocalizedData . RecommendNameLabel Exists \"metadata.labels.'app.kubernetes.io/name'\" }","title":"Recommend keyword"},{"location":"authoring/writing-rule-help/#reason-keyword","text":"The Reason keyword sets the reason the rule failed when using Invoke-PSRule and Assert-PSRule . The reason is only included in detailed output if the rule did not pass. If the rule passed, then reason is empty it returned output. Reasons are not included in the default view when using Invoke-PSRule . Use -OutputFormat Wide to display reason messages. To set a reason use the Reason keyword followed by the reason. For example: # Synopsis: Must have the app.kubernetes.io/name label Rule 'metadata.Name' -Type 'Deployment' , 'Service' { Recommend $LocalizedData . RecommendNameLabel Exists \"metadata.labels.'app.kubernetes.io/name'\" Reason 'The standard name label is not set.' } The Reason keyword can be used multiple times within conditional logic to return a list of reasons the rule failed. Additionally the reason messages can be localized by using the $LocalizedData variable. For example: # Synopsis: Must have the app.kubernetes.io/name label Rule 'metadata.Name' -Type 'Deployment' , 'Service' { Recommend $LocalizedData . RecommendNameLabel Exists \"metadata.labels.'app.kubernetes.io/name'\" # $LocalizedData.ReasonLabelMissing is set to 'The standard {0} label is not set.'. Reason ( $LocalizedData . ReasonLabelMissing -f 'name' ) }","title":"Reason keyword"},{"location":"authoring/writing-rule-help/#writing-markdown-documentation","text":"In addition to inline help, documentation can be written in markdown to provide online and offline help. Extended documentation is generally easier to author using markdown. Additionally markdown documentation is easily localized. Markdown documentation is authored by creating one or more .md files, one for each rule. PSRule uses a naming convention with a file name the same as the rule to match rule to markdown. For example, metadata.Name.md would be used for a rule named metadata.Name . We recommend matching the rule name case exactly when naming markdown files. This is because some file systems are case-sensitive. For example on Linux Metadata.Name.md would not match. Within each markdown file a number of predefined sections are automatically interpreted by PSRule. While it is possible to have additional sections, they will be ignored by the help system. The basic structure of markdown help is as follows: --- {{ Annotations }} --- # {{ Name of rule }} {{ A brief summary of the rule }} ## Description {{ A detailed description of the rule }} ## Recommendation {{ A detailed explanation of the steps required to pass the rule }} ## Notes {{ Additional information or configuration options }} ## Links {{ Links to external references }} The PSRule Visual Studio Code extension includes snippets for writing markdown documentation.","title":"Writing markdown documentation"},{"location":"authoring/writing-rule-help/#annotations","text":"The annotation front matter at the top of the markdown document, is a set of key value pairs. Front matter follows YAML conventions and must start on the first line of the markdown document. A --- on a separate line indicates the start and end of the front matter block. Within the front matter block, all key value pairs are treated as annotations by PSRule. Annotations are optional metadata that are associated with the rule. Any annotations associated with a rule are included in output. Some examples of annotations include; severity , category , author . Annotations differ from tags in two key ways: Annotations are localized, and can have a different value for different languages; tags are not. Tags are indexed and can be used to filter rules; annotations have no affect on rule filtering. The following reserved annotation exists: online version - A URL to the online version of the document, used by Get-PSRuleHelp -Online . --- online version: https://github.com/microsoft/PSRule/blob/main/docs/scenarios/rule-docs/rule-docs.md --- The front matter start and end --- are not required and can be removed if no annotations are defined.","title":"Annotations"},{"location":"authoring/writing-rule-help/#display-name","text":"The document title, indicated by a level one heading # is the display name of the rule. The rule display name is shown when using Get-PSRuleHelp and is included in output. Specify the display name on a single line. Wrapping the display name across multiple lines is not supported. For example: # Use recommended name label","title":"Display name"},{"location":"authoring/writing-rule-help/#synopsis-section","text":"The synopsis section is indicated by the heading `. Any text following the heading is interpreted by PSRule and included in output. The synopsis is displayed when using Get-PSRule and Get-PSRuleHelp` cmdlets. The synopsis is intended to be a brief description of the rule, over a single line. A good synopsis should convey the purpose of the rule. A more verbose description can be included in the description section. For example: Deployments and services must use the app.kubernetes.io/name label.","title":"Synopsis section"},{"location":"authoring/writing-rule-help/#description-section","text":"The description section is indicated by the heading ## Description . Any text following the heading is interpreted by PSRule and included in output. The description is displayed when using the Get-PSRuleHelp cmdlet. The description is intended to be a verbose description of the rule. If your rule documentation needs to include background information include it here. PSRule supports semantic line breaks, and will automatically run together lines into a single paragraph. Use a blank line to separate paragraphs. For example: ## Description Kubernetes defines a common set of labels that are recommended for tool interoperability. These labels should be used to consistently apply standard metadata. The `app.kubernetes.io/name` label should be used to specify the name of the application.","title":"Description section"},{"location":"authoring/writing-rule-help/#recommendation-section","text":"The recommendation section is indicated by the heading ## Recommendation . Any text following the heading is interpreted by PSRule and included in output. The recommendation is displayed when using the Invoke-PSRule and Get-PSRuleHelp cmdlets. The recommendation is intended to identify corrective actions that can be taken to address any failures. Avoid using URLs within the recommendations. Use the links section to include references to external sources. PSRule supports semantic line breaks, and will automatically run together lines into a single paragraph. Use a blank line to separate paragraphs. For example: ## Recommendation Consider setting the recommended label `app.kubernetes.io/name` on deployment and service resources.","title":"Recommendation section"},{"location":"authoring/writing-rule-help/#notes-section","text":"The notes section is indicated by the heading ## Notes . Any text following the heading is interpreted by PSRule and included in pipeline output. Notes are excluded when formatting output as YAML and JSON. To view any included notes use the Get-PSRuleHelp cmdlet with the -Full switch. Use notes to include additional information such configuration options. PSRule supports semantic line breaks, and will automatically run together lines into a single paragraph. Use a blank line to separate paragraphs. For example: ## Notes The Kubernetes recommended labels include: - `app.kubernetes.io/name` - `app.kubernetes.io/instance` - `app.kubernetes.io/version` - `app.kubernetes.io/component` - `app.kubernetes.io/part-of` - `app.kubernetes.io/managed-by`","title":"Notes section"},{"location":"authoring/writing-rule-help/#links-section","text":"The links section is indicated by the heading ## Links . Any markdown links following the heading are interpreted by PSRule and included in pipeline output. Links are excluded when formatting output as YAML and JSON. To view any included links use the Get-PSRuleHelp cmdlet with the -Full switch. Use links to reference external sources with a URL. To specify links, use the markdown syntax [display name](url) . Include each link on a separate line. To improve display in web rendered markdown, use a list of links by prefixing the line with - . Additional text such as See additional information: is useful for web rendered views, but ignored by PSRule. For example: ## Links - [Recommended Labels](https://kubernetes.io/docs/concepts/overview/working-with-objects/common-labels/)","title":"Links section"},{"location":"authoring/writing-rule-help/#localizing-documentation-files","text":"When distributing rules, you may need to provide rule help in different languages. PSRule builds on the culture system in PowerShell.","title":"Localizing documentation files"},{"location":"authoring/writing-rule-help/#using-cultures","text":"A directory structure is used to identify the markdown documentation that should be used for each culture. To get a list of cultures in PowerShell the use cmdlet Get-Culture -ListAvailable . For example, store documentation targeted to the culture en-US in a directory named en-US . Similarly, documentation for cultures such as en-AU , en-GB and fr-FR would be in separate directories. If a directory for the exact culture en-US doesn't exist, PSRule will attempt to find the parent culture. For example, documentation would be read from a directory named en . When naming directories for their culture, use exact case. This is because some file systems are case-sensitive. For example on Linux en-us would not match.","title":"Using cultures"},{"location":"authoring/writing-rule-help/#culture-directory-search-path","text":"The path that PSRule looks for a culture directory in varies depending on how the rule is redistributed. Rules can be redistributed individually (loose) or included in a module. The following logic is used to locate the culture directory. If the rules are loose, PSRule will search for the culture directory in the same subdirectory as the .Rule.ps1 file. When rules are included in a module, PSRule will search for the culture directory in the same subdirectory as the module manifest .psd1 file. For example, loose file structure: .ps-rule/ en/ metadata.Name.md en-US/ metadata.Name.md fr-FR/ metadata.Name.md kubernetes.Rule.ps1 Module file structure: Kubernetes.Rules/ en/ metadata.Name.md en-US/ metadata.Name.md fr-FR/ metadata.Name.md rules/ kubernetes.Rule.ps1 Kubernetes.Rules.psd1","title":"Culture directory search path"},{"location":"authoring/writing-rule-help/#more-information","text":"kubernetes.Rule.ps1 - An example rule for validating name label. metadata.Name - An example markdown documentation file.","title":"More information"},{"location":"authoring/writing-rules/","text":"Writing rules # You can use PSRule to create tests for Infrastructure as Code (IaC). Each test is called a rule . PSRule allows you to write rules using YAML, JSON, or PowerShell. Regardless of the format you choose, any combination of YAML, JSON, or PowerShell rules can be used together. Abstract This topic covers how to create a rule using YAML, JSON, and PowerShell by example. This example, while fictious is indicative of common testing and validation scenarios for IaC. Sample data # To get started authoring a rule, we will be working with a sample file settings.json . This sample configuration file configures an application. For the purpose of this example, one configuration setting supportsHttpsTrafficOnly is set. This configuration setting can be either true or false . When set to true , Transport Layer Security (TLS) is enforced. When set to false , the application permits insecure communication with HTTP. Contents of settings.json Create a settings.json file in the root of your repository with the following contents. { \"type\" : \"app1\" , \"version\" : 1 , \"configure\" : { \"supportsHttpsTrafficOnly\" : false } } Define a rule # To meet the requirements of our organization we want to write a rule to: Enforce secure traffic by requiring supportsHttpsTrafficOnly to be true . Enforce use of TLS 1.2 as a minimum by requiring minTLSVersion to be 1.2 . In this section the same rule will be authored using YAML, JSON, and PowerShell. Tip To make you editing experience even better, consider installing the Visual Studio Code extension. YAML JSON PowerShell Create a .ps-rule/Local.Rule.yaml file in your repository with the following contents. --- # Synopsis: An example rule to require TLS. apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'Local.YAML.RequireTLS' spec : condition : field : 'configure.supportsHttpsTrafficOnly' equals : true Use a short Synopsis: to describe your rule in a line comment above your rule. For this to be interpreted by PSRule, only a single line is allowed. Name your rule with a unique name. The condition block determines the checks PSRule will use to test settings.json . Specifically, the object path configures.supportsHttpsTrafficOnly must exist and be set to true . Create a .ps-rule/Local.Rule.jsonc file in your repository with the following contents. [ { // Sy n opsis : A n example rule t o require TLS. \"apiVersion\" : \"github.com/microsoft/PSRule/v1\" , \"kind\" : \"Rule\" , \"metadata\" : { \"name\" : \"Local.JSON.RequireTLS\" }, \"spec\" : { \"condition\" : { \"field\" : \"configure.supportsHttpsTrafficOnly\" , \"equals\" : true } } } ] Use a short Synopsis: to describe your rule in a line comment above your rule. For this to be interpreted by PSRule, only a single line is allowed. Name your rule with a unique name. The condition block determines the checks PSRule will use to test settings.json . Specifically, the object path configures.supportsHttpsTrafficOnly must exist and be set to true . Create a .ps-rule/Local.Rule.ps1 file in your repository with the following contents. # Synopsis: An example rule to require TLS. Rule 'Local.PS.RequireTLS' { $Assert . HasFieldValue ( $TargetObject , 'configure.supportsHttpsTrafficOnly' , $True ) } Use a short Synopsis: to describe your rule in a line comment above your rule. For this to be interpreted by PSRule, only a single line is allowed. Name your rule with a unique name. The condition contained within the curly braces { } determines the checks PSRule will use to test settings.json . The $Assert.HasFieldValue method checks the object path configures.supportsHttpsTrafficOnly exists and is set to true . Tip To learn more about recommended file and naming conventions for rules, continue reading Storing and naming rules . Using multiple conditions # Each rule must have at least one condition. Additional conditions can be combined to check multiple test cases. In the example a minTLSVersion configuration setting does not exist and is not set. YAML JSON PowerShell Update .ps-rule/Local.Rule.yaml in your repository with the following contents. --- # Synopsis: An example rule to require TLS. apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'Local.YAML.RequireTLS' spec : condition : allOf : - field : 'configure.supportsHttpsTrafficOnly' equals : true - field : 'configure.minTLSVersion' equals : '1.2' Using the allOf expression requires that all conditions be true for the rule to pass. This expression allows an array of one or more conditions to be provided. Using anyOf would pass the rule if any single condition is true. Update .ps-rule/Local.Rule.jsonc in your repository with the following contents. [ { // Sy n opsis : A n example rule t o require TLS. \"apiVersion\" : \"github.com/microsoft/PSRule/v1\" , \"kind\" : \"Rule\" , \"metadata\" : { \"name\" : \"Local.JSON.RequireTLS\" }, \"spec\" : { \"condition\" : { \"allOf\" : [ { \"field\" : \"configure.supportsHttpsTrafficOnly\" , \"equals\" : true }, { \"field\" : \"configure.minTLSVersion\" , \"equals\" : \"1.2\" } ] } } } ] Using the allOf expression requires that all conditions be true for the rule to pass. This expression allows an array of one or more conditions to be provided. Using anyOf would pass the rule if any single condition is true. Update .ps-rule/Local.Rule.ps1 in your repository with the following contents. # Synopsis: An example rule to require TLS. Rule 'Local.PS.RequireTLS' { $Assert . HasFieldValue ( $TargetObject , 'configure.supportsHttpsTrafficOnly' , $True ) $Assert . HasFieldValue ( $TargetObject , 'configure.minTLSVersion' , '1.2' ) } An additional, $Assert.HasFieldValue assertion helper method can be called. The rule will pass if all of the conditions return true. Testing the rule # Assert-PSRule -f ./ settings . json","title":"Writing rules"},{"location":"authoring/writing-rules/#writing-rules","text":"You can use PSRule to create tests for Infrastructure as Code (IaC). Each test is called a rule . PSRule allows you to write rules using YAML, JSON, or PowerShell. Regardless of the format you choose, any combination of YAML, JSON, or PowerShell rules can be used together. Abstract This topic covers how to create a rule using YAML, JSON, and PowerShell by example. This example, while fictious is indicative of common testing and validation scenarios for IaC.","title":"Writing rules"},{"location":"authoring/writing-rules/#sample-data","text":"To get started authoring a rule, we will be working with a sample file settings.json . This sample configuration file configures an application. For the purpose of this example, one configuration setting supportsHttpsTrafficOnly is set. This configuration setting can be either true or false . When set to true , Transport Layer Security (TLS) is enforced. When set to false , the application permits insecure communication with HTTP. Contents of settings.json Create a settings.json file in the root of your repository with the following contents. { \"type\" : \"app1\" , \"version\" : 1 , \"configure\" : { \"supportsHttpsTrafficOnly\" : false } }","title":"Sample data"},{"location":"authoring/writing-rules/#define-a-rule","text":"To meet the requirements of our organization we want to write a rule to: Enforce secure traffic by requiring supportsHttpsTrafficOnly to be true . Enforce use of TLS 1.2 as a minimum by requiring minTLSVersion to be 1.2 . In this section the same rule will be authored using YAML, JSON, and PowerShell. Tip To make you editing experience even better, consider installing the Visual Studio Code extension. YAML JSON PowerShell Create a .ps-rule/Local.Rule.yaml file in your repository with the following contents. --- # Synopsis: An example rule to require TLS. apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'Local.YAML.RequireTLS' spec : condition : field : 'configure.supportsHttpsTrafficOnly' equals : true Use a short Synopsis: to describe your rule in a line comment above your rule. For this to be interpreted by PSRule, only a single line is allowed. Name your rule with a unique name. The condition block determines the checks PSRule will use to test settings.json . Specifically, the object path configures.supportsHttpsTrafficOnly must exist and be set to true . Create a .ps-rule/Local.Rule.jsonc file in your repository with the following contents. [ { // Sy n opsis : A n example rule t o require TLS. \"apiVersion\" : \"github.com/microsoft/PSRule/v1\" , \"kind\" : \"Rule\" , \"metadata\" : { \"name\" : \"Local.JSON.RequireTLS\" }, \"spec\" : { \"condition\" : { \"field\" : \"configure.supportsHttpsTrafficOnly\" , \"equals\" : true } } } ] Use a short Synopsis: to describe your rule in a line comment above your rule. For this to be interpreted by PSRule, only a single line is allowed. Name your rule with a unique name. The condition block determines the checks PSRule will use to test settings.json . Specifically, the object path configures.supportsHttpsTrafficOnly must exist and be set to true . Create a .ps-rule/Local.Rule.ps1 file in your repository with the following contents. # Synopsis: An example rule to require TLS. Rule 'Local.PS.RequireTLS' { $Assert . HasFieldValue ( $TargetObject , 'configure.supportsHttpsTrafficOnly' , $True ) } Use a short Synopsis: to describe your rule in a line comment above your rule. For this to be interpreted by PSRule, only a single line is allowed. Name your rule with a unique name. The condition contained within the curly braces { } determines the checks PSRule will use to test settings.json . The $Assert.HasFieldValue method checks the object path configures.supportsHttpsTrafficOnly exists and is set to true . Tip To learn more about recommended file and naming conventions for rules, continue reading Storing and naming rules .","title":"Define a rule"},{"location":"authoring/writing-rules/#using-multiple-conditions","text":"Each rule must have at least one condition. Additional conditions can be combined to check multiple test cases. In the example a minTLSVersion configuration setting does not exist and is not set. YAML JSON PowerShell Update .ps-rule/Local.Rule.yaml in your repository with the following contents. --- # Synopsis: An example rule to require TLS. apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'Local.YAML.RequireTLS' spec : condition : allOf : - field : 'configure.supportsHttpsTrafficOnly' equals : true - field : 'configure.minTLSVersion' equals : '1.2' Using the allOf expression requires that all conditions be true for the rule to pass. This expression allows an array of one or more conditions to be provided. Using anyOf would pass the rule if any single condition is true. Update .ps-rule/Local.Rule.jsonc in your repository with the following contents. [ { // Sy n opsis : A n example rule t o require TLS. \"apiVersion\" : \"github.com/microsoft/PSRule/v1\" , \"kind\" : \"Rule\" , \"metadata\" : { \"name\" : \"Local.JSON.RequireTLS\" }, \"spec\" : { \"condition\" : { \"allOf\" : [ { \"field\" : \"configure.supportsHttpsTrafficOnly\" , \"equals\" : true }, { \"field\" : \"configure.minTLSVersion\" , \"equals\" : \"1.2\" } ] } } } ] Using the allOf expression requires that all conditions be true for the rule to pass. This expression allows an array of one or more conditions to be provided. Using anyOf would pass the rule if any single condition is true. Update .ps-rule/Local.Rule.ps1 in your repository with the following contents. # Synopsis: An example rule to require TLS. Rule 'Local.PS.RequireTLS' { $Assert . HasFieldValue ( $TargetObject , 'configure.supportsHttpsTrafficOnly' , $True ) $Assert . HasFieldValue ( $TargetObject , 'configure.minTLSVersion' , '1.2' ) } An additional, $Assert.HasFieldValue assertion helper method can be called. The rule will pass if all of the conditions return true.","title":"Using multiple conditions"},{"location":"authoring/writing-rules/#testing-the-rule","text":"Assert-PSRule -f ./ settings . json","title":"Testing the rule"},{"location":"authoring/packaging-rules/Enterprise.Rules/en/Org.Az.Resource.Tagging/","text":"Use mandatory tags # Each resource must be tagged with mandatory tags. Description # Azure resources can be tagged with additional metadata. Our enterprise standard requires that the following tags are used: Environment BusinessUnit Department CostCode Recommendation # Consider tagging Azure resource with mandatory tags. Links # Use tags to organize your Azure resources and management hierarchy","title":"Use mandatory tags"},{"location":"authoring/packaging-rules/Enterprise.Rules/en/Org.Az.Resource.Tagging/#use-mandatory-tags","text":"Each resource must be tagged with mandatory tags.","title":"Use mandatory tags"},{"location":"authoring/packaging-rules/Enterprise.Rules/en/Org.Az.Resource.Tagging/#description","text":"Azure resources can be tagged with additional metadata. Our enterprise standard requires that the following tags are used: Environment BusinessUnit Department CostCode","title":"Description"},{"location":"authoring/packaging-rules/Enterprise.Rules/en/Org.Az.Resource.Tagging/#recommendation","text":"Consider tagging Azure resource with mandatory tags.","title":"Recommendation"},{"location":"authoring/packaging-rules/Enterprise.Rules/en/Org.Az.Resource.Tagging/#links","text":"Use tags to organize your Azure resources and management hierarchy","title":"Links"},{"location":"authoring/packaging-rules/Enterprise.Rules/en/Org.Az.Storage.UseHttps/","text":"Enforce encrypted Storage connections # Storage accounts should only accept encrypted connections. Description # An Azure Storage Account is configured to allow unencrypted connections. This does not indicate that unencrypted connections are being used. Unencrypted communication to storage accounts could allow disclosure of information to an untrusted party. Storage Accounts can be configured to require encrypted connections, by setting the Secure transfer required option. If secure transfer required is not enabled (the default), unencrypted and encrypted connections are permitted. When secure transfer required is enabled, attempts to connect to storage using HTTP or unencrypted SMB connections are rejected. Recommendation # Storage accounts should only accept secure traffic. Consider setting secure transfer required if there is no requirement to access storage over unencrypted connections. Also consider using Azure Policy to audit or enforce this configuration. Links # Require secure transfer in Azure Storage Sample policy for ensuring https traffic","title":"Enforce encrypted Storage connections"},{"location":"authoring/packaging-rules/Enterprise.Rules/en/Org.Az.Storage.UseHttps/#enforce-encrypted-storage-connections","text":"Storage accounts should only accept encrypted connections.","title":"Enforce encrypted Storage connections"},{"location":"authoring/packaging-rules/Enterprise.Rules/en/Org.Az.Storage.UseHttps/#description","text":"An Azure Storage Account is configured to allow unencrypted connections. This does not indicate that unencrypted connections are being used. Unencrypted communication to storage accounts could allow disclosure of information to an untrusted party. Storage Accounts can be configured to require encrypted connections, by setting the Secure transfer required option. If secure transfer required is not enabled (the default), unencrypted and encrypted connections are permitted. When secure transfer required is enabled, attempts to connect to storage using HTTP or unencrypted SMB connections are rejected.","title":"Description"},{"location":"authoring/packaging-rules/Enterprise.Rules/en/Org.Az.Storage.UseHttps/#recommendation","text":"Storage accounts should only accept secure traffic. Consider setting secure transfer required if there is no requirement to access storage over unencrypted connections. Also consider using Azure Policy to audit or enforce this configuration.","title":"Recommendation"},{"location":"authoring/packaging-rules/Enterprise.Rules/en/Org.Az.Storage.UseHttps/#links","text":"Require secure transfer in Azure Storage Sample policy for ensuring https traffic","title":"Links"},{"location":"authoring/writing-rule-help/en-US/metadata.Name/","text":"Use recommended name label # Deployments and services must use the app.kubernetes.io/name label. Description # Kubernetes defines a common set of labels that are recommended for tool interoperability. These labels should be used to consistently apply standard metadata. The app.kubernetes.io/name label should be used to specify the name of the application. Recommendation # Consider setting the recommended label app.kubernetes.io/name on deployment and service resources. Notes # The Kubernetes recommended labels include: app.kubernetes.io/name app.kubernetes.io/instance app.kubernetes.io/version app.kubernetes.io/component app.kubernetes.io/part-of app.kubernetes.io/managed-by Links # Recommended Labels","title":"Use recommended name label"},{"location":"authoring/writing-rule-help/en-US/metadata.Name/#use-recommended-name-label","text":"Deployments and services must use the app.kubernetes.io/name label.","title":"Use recommended name label"},{"location":"authoring/writing-rule-help/en-US/metadata.Name/#description","text":"Kubernetes defines a common set of labels that are recommended for tool interoperability. These labels should be used to consistently apply standard metadata. The app.kubernetes.io/name label should be used to specify the name of the application.","title":"Description"},{"location":"authoring/writing-rule-help/en-US/metadata.Name/#recommendation","text":"Consider setting the recommended label app.kubernetes.io/name on deployment and service resources.","title":"Recommendation"},{"location":"authoring/writing-rule-help/en-US/metadata.Name/#notes","text":"The Kubernetes recommended labels include: app.kubernetes.io/name app.kubernetes.io/instance app.kubernetes.io/version app.kubernetes.io/component app.kubernetes.io/part-of app.kubernetes.io/managed-by","title":"Notes"},{"location":"authoring/writing-rule-help/en-US/metadata.Name/#links","text":"Recommended Labels","title":"Links"},{"location":"commands/PSRule/en-US/Assert-PSRule/","text":"Assert-PSRule # Evaluate objects against matching rules and assert any failures. SYNTAX # Input (Default) # Assert-PSRule [-Module <String[]>] [-Format <InputFormat>] [-Baseline <BaselineOption>] [-Convention <String[]>] [-Style <OutputStyle>] [-Outcome <RuleOutcome>] [-As <ResultFormat>] [[-Path] <String[]>] [-Name <String[]>] [-Tag <Hashtable>] [-OutputPath <String>] [-OutputFormat <OutputFormat>] [-Option <PSRuleOption>] [-ObjectPath <String>] [-TargetType <String[]>] [-Culture <String[]>] -InputObject <PSObject> [-ResultVariable <String>] [-WhatIf] [-Confirm] [<CommonParameters>] InputPath # Assert-PSRule -InputPath <String[]> [-Module <String[]>] [-Format <InputFormat>] [-Baseline <BaselineOption>] [-Convention <String[]>] [-Style <OutputStyle>] [-Outcome <RuleOutcome>] [-As <ResultFormat>] [[-Path] <String[]>] [-Name <String[]>] [-Tag <Hashtable>] [-OutputPath <String>] [-OutputFormat <OutputFormat>] [-Option <PSRuleOption>] [-ObjectPath <String>] [-TargetType <String[]>] [-Culture <String[]>] [-ResultVariable <String>] [-WhatIf] [-Confirm] [<CommonParameters>] Description # Evaluate objects against matching rules and assert any failures. Objects can be specified directly from the pipeline or provided from file. The commands Invoke-PSRule and Assert-PSRule provide similar functionality, as differ as follows: Invoke-PSRule writes results as structured objects Assert-PSRule writes results as a formatted string. Examples # Example 1 # @{ Name = 'Item 1' } | Assert-PSRule ; Evaluate a simple hashtable on the pipeline against rules loaded from the current working path. Example 2 # # Define objects to validate $items = @(); $items += [PSCustomObject] @{ Name = 'Fridge' }; $items += [PSCustomObject] @{ Name = 'Apple' }; # Validate each item using rules saved in current working path $items | Assert-PSRule -Path .\\ docs \\ scenarios \\ fruit \\ -> Fridge : System.Management.Automation.PSCustomObject [FAIL] isFruit -> Apple : System.Management.Automation.PSCustomObject [PASS] isFruit Assert-PSRule : One or more rules reported failure. At line:1 char:10 + $items | Assert-PSRule -Path .\\docs\\scenarios\\fruit\\ + ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ + CategoryInfo : InvalidData: (:) [Assert-PSRule], FailPipelineException + FullyQualifiedErrorId : PSRule.Fail,Assert-PSRule Evaluate an array of objects on the pipeline against rules loaded a specified relative path. Example 3 # $items | Assert-PSRule -Module PSRule . Rules . Azure -o NUnit3 -OutputPath .\\ reports \\ results . xml Evaluate items from a pre-installed rules module PSRule.Rules.Azure. Additionally save the results as a NUnit report. Example 4 # $items | Assert-PSRule -Path .\\ docs \\ scenarios \\ fruit \\ -ResultVariable resultRecords ; Evaluate items and additionally save the results into a variable resultRecords . PARAMETERS # -InputPath # Instead of processing objects from the pipeline, import objects file the specified file paths. Type : String[] Parameter Sets : InputPath Aliases : f Required : True Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -Format # Configures the input format for when a string is passed in as a target object. When the -InputObject parameter or pipeline input is used, strings are treated as plain text by default. Set this option to either Yaml , Json , Markdown , PowerShellData to have PSRule deserialize the object. When the -InputPath parameter is used with a file path or URL. If the Detect format is used, the file extension will be used to automatically detect the format. When -InputPath is not used, Detect is the same as None . When this option is set to File PSRule scans the path and subdirectories specified by -InputPath . Files are treated as objects instead of being deserialized. Additional, PSRule uses the file extension as the object type. When files have no extension the whole file name is used. See about_PSRule_Options for details. This parameter takes precedence over the Input.Format option if set. Type : InputFormat Parameter Sets : (All) Aliases : Accepted values : None, Yaml, Json, Markdown, PowerShellData, File, Detect Required : False Position : Named Default value : Detect Accept pipeline input : False Accept wildcard characters : False -Baseline # Specifies an explicit baseline by name to use for evaluating rules. Baselines can contain filters and custom configuration that overrides the defaults. Type : BaselineOption Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -Convention # Specifies conventions by name to execute in the pipeline when processing objects. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -Culture # Specifies the culture to use for rule documentation and messages. By default, the culture of PowerShell is used. This option does not affect the culture used for the PSRule engine, which always uses the culture of PowerShell. The PowerShell cmdlet Get-Culture shows the current culture of PowerShell. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -Module # Search for rule definitions within a module. If no sources are specified by -Path , -Module , or options, the current working directory is used. Type : String[] Parameter Sets : (All) Aliases : m Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -Name # The name of a specific rule to evaluate. If this parameter is not specified all rules in search paths will be evaluated. Type : String[] Parameter Sets : (All) Aliases : n Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -ObjectPath # The name of a property to use instead of the pipeline object. If the property specified by ObjectPath is a collection or an array, then each item in evaluated separately. Type : String Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -TargetType # Filters input objects by TargetType. If specified, only objects with the specified TargetType are processed. Objects that do not match TargetType are ignored. If multiple values are specified, only one TargetType must match. This parameter is not case-sensitive. By default, all objects are processed. This parameter if set, overrides the Input.TargetType option. To change the field TargetType is bound to set the Binding.TargetType option. For details see the about_PSRule_Options help topic. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -Option # Additional options that configure execution. A PSRuleOption can be created by using the New-PSRuleOption cmdlet. Alternatively, a hashtable or path to YAML file can be specified with options. For more information on PSRule options see about_PSRule_Options. Type : PSRuleOption Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -OutputPath # Specifies the output file path to write results. Directories along the file path will automatically be created if they do not exist. Type : String Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -OutputFormat # Configures the format that output is written. This parameter has no affect when -OutputPath is not specified. The following format options are available: None - Output is presented as an object using PowerShell defaults. This is the default. Yaml - Output is serialized as YAML. Json - Output is serialized as JSON. Markdown - Output is serialized as Markdown. NUnit3 - Output is serialized as NUnit3 (XML). Csv - Output is serialized as a comma separated values (CSV). The Wide format is not applicable to Assert-PSRule . Type : OutputFormat Parameter Sets : (All) Aliases : o Accepted values : None, Yaml, Json, Markdown, NUnit3, Csv Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -Style # Configures the style that results will be presented in. The following styles are available: Client - Output is written to the host directly in green/ red to indicate outcome. Plain - Output is written as an unformatted string. This option can be redirected to a file. AzurePipelines - Output is written for integration Azure Pipelines. GitHubActions - Output is written for integration GitHub Actions. VisualStudioCode - Output is written for integration with Visual Studio Code. Detect - Output style will be detected by checking the environment variables. This is the default. Detect uses the following logic: If the TF_BUILD environment variable is set to true , AzurePipelines will be used. If the GITHUB_ACTIONS environment variable is set to true , GitHubActions will be used. If the TERM_PROGRAM environment variable is set to vscode , VisualStudioCode will be used. Use Client . Each of these styles outputs to the host. To capture output as a string redirect the information stream. For example: 6>&1 Type : OutputStyle Parameter Sets : (All) Aliases : Accepted values : Client, Plain, AzurePipelines, GitHubActions, VisualStudioCode, Detect Required : False Position : Named Default value : Client Accept pipeline input : False Accept wildcard characters : False -As # The type of results to produce. Detailed results are generated by default. The following result formats are available: Detail - Returns pass/ fail results for each rule per object. Summary - Failure or errors are shown but passing results are summarized. Type : ResultFormat Parameter Sets : (All) Aliases : Accepted values : Detail, Summary Required : False Position : Named Default value : Detail Accept pipeline input : False Accept wildcard characters : False -Outcome # Filter output to only show rule results with a specific outcome. Type : RuleOutcome Parameter Sets : (All) Aliases : Accepted values : Pass, Fail, Error, None, Processed, All Required : False Position : Named Default value : Pass, Fail, Error Accept pipeline input : False Accept wildcard characters : False -Path # One or more paths to search for rule definitions within. If no sources are specified by -Path , -Module , or options, the current working directory is used. Type : String[] Parameter Sets : (All) Aliases : p Required : False Position : 0 Default value : $PWD Accept pipeline input : False Accept wildcard characters : False -Tag # Only get rules with the specified tags set. If this parameter is not specified all rules in search paths will be returned. When more than one tag is used, all tags must match. Tags are not case sensitive. A tag value of * may be used to filter rules to any rule with the tag set, regardless of tag value. An array of tag values can be used to match a rule with either value. i.e. severity = important, critical matches rules with a category of either important or critical . Type : Hashtable Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -InputObject # The pipeline object to process rules for. Type : PSObject Parameter Sets : Input Aliases : TargetObject Required : True Position : Named Default value : None Accept pipeline input : True (ByValue) Accept wildcard characters : False -ResultVariable # Stores output result objects in the specified variable. Type : String Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -WhatIf # Shows what would happen if the cmdlet runs. The cmdlet is not run. Type : SwitchParameter Parameter Sets : (All) Aliases : wi Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -Confirm # Prompts you for confirmation before running the cmdlet. Type : SwitchParameter Parameter Sets : (All) Aliases : cf Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False CommonParameters # This cmdlet supports the common parameters: -Debug, -ErrorAction, -ErrorVariable, -InformationAction, -InformationVariable, -OutVariable, -OutBuffer, -PipelineVariable, -Verbose, -WarningAction, and -WarningVariable. For more information, see about_CommonParameters . INPUTS # System.Management.Automation.PSObject # You can pipe any object to Assert-PSRule . OUTPUTS # System.String # Notes # RELATED LINKS # Get-PSRule Invoke-PSRule Test-PSRuleTarget","title":"Assert-PSRule"},{"location":"commands/PSRule/en-US/Assert-PSRule/#assert-psrule","text":"Evaluate objects against matching rules and assert any failures.","title":"Assert-PSRule"},{"location":"commands/PSRule/en-US/Assert-PSRule/#syntax","text":"","title":"SYNTAX"},{"location":"commands/PSRule/en-US/Assert-PSRule/#input-default","text":"Assert-PSRule [-Module <String[]>] [-Format <InputFormat>] [-Baseline <BaselineOption>] [-Convention <String[]>] [-Style <OutputStyle>] [-Outcome <RuleOutcome>] [-As <ResultFormat>] [[-Path] <String[]>] [-Name <String[]>] [-Tag <Hashtable>] [-OutputPath <String>] [-OutputFormat <OutputFormat>] [-Option <PSRuleOption>] [-ObjectPath <String>] [-TargetType <String[]>] [-Culture <String[]>] -InputObject <PSObject> [-ResultVariable <String>] [-WhatIf] [-Confirm] [<CommonParameters>]","title":"Input (Default)"},{"location":"commands/PSRule/en-US/Assert-PSRule/#inputpath","text":"Assert-PSRule -InputPath <String[]> [-Module <String[]>] [-Format <InputFormat>] [-Baseline <BaselineOption>] [-Convention <String[]>] [-Style <OutputStyle>] [-Outcome <RuleOutcome>] [-As <ResultFormat>] [[-Path] <String[]>] [-Name <String[]>] [-Tag <Hashtable>] [-OutputPath <String>] [-OutputFormat <OutputFormat>] [-Option <PSRuleOption>] [-ObjectPath <String>] [-TargetType <String[]>] [-Culture <String[]>] [-ResultVariable <String>] [-WhatIf] [-Confirm] [<CommonParameters>]","title":"InputPath"},{"location":"commands/PSRule/en-US/Assert-PSRule/#description","text":"Evaluate objects against matching rules and assert any failures. Objects can be specified directly from the pipeline or provided from file. The commands Invoke-PSRule and Assert-PSRule provide similar functionality, as differ as follows: Invoke-PSRule writes results as structured objects Assert-PSRule writes results as a formatted string.","title":"Description"},{"location":"commands/PSRule/en-US/Assert-PSRule/#examples","text":"","title":"Examples"},{"location":"commands/PSRule/en-US/Assert-PSRule/#example-1","text":"@{ Name = 'Item 1' } | Assert-PSRule ; Evaluate a simple hashtable on the pipeline against rules loaded from the current working path.","title":"Example 1"},{"location":"commands/PSRule/en-US/Assert-PSRule/#example-2","text":"# Define objects to validate $items = @(); $items += [PSCustomObject] @{ Name = 'Fridge' }; $items += [PSCustomObject] @{ Name = 'Apple' }; # Validate each item using rules saved in current working path $items | Assert-PSRule -Path .\\ docs \\ scenarios \\ fruit \\ -> Fridge : System.Management.Automation.PSCustomObject [FAIL] isFruit -> Apple : System.Management.Automation.PSCustomObject [PASS] isFruit Assert-PSRule : One or more rules reported failure. At line:1 char:10 + $items | Assert-PSRule -Path .\\docs\\scenarios\\fruit\\ + ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ + CategoryInfo : InvalidData: (:) [Assert-PSRule], FailPipelineException + FullyQualifiedErrorId : PSRule.Fail,Assert-PSRule Evaluate an array of objects on the pipeline against rules loaded a specified relative path.","title":"Example 2"},{"location":"commands/PSRule/en-US/Assert-PSRule/#example-3","text":"$items | Assert-PSRule -Module PSRule . Rules . Azure -o NUnit3 -OutputPath .\\ reports \\ results . xml Evaluate items from a pre-installed rules module PSRule.Rules.Azure. Additionally save the results as a NUnit report.","title":"Example 3"},{"location":"commands/PSRule/en-US/Assert-PSRule/#example-4","text":"$items | Assert-PSRule -Path .\\ docs \\ scenarios \\ fruit \\ -ResultVariable resultRecords ; Evaluate items and additionally save the results into a variable resultRecords .","title":"Example 4"},{"location":"commands/PSRule/en-US/Assert-PSRule/#parameters","text":"","title":"PARAMETERS"},{"location":"commands/PSRule/en-US/Assert-PSRule/#-inputpath","text":"Instead of processing objects from the pipeline, import objects file the specified file paths. Type : String[] Parameter Sets : InputPath Aliases : f Required : True Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-InputPath"},{"location":"commands/PSRule/en-US/Assert-PSRule/#-format","text":"Configures the input format for when a string is passed in as a target object. When the -InputObject parameter or pipeline input is used, strings are treated as plain text by default. Set this option to either Yaml , Json , Markdown , PowerShellData to have PSRule deserialize the object. When the -InputPath parameter is used with a file path or URL. If the Detect format is used, the file extension will be used to automatically detect the format. When -InputPath is not used, Detect is the same as None . When this option is set to File PSRule scans the path and subdirectories specified by -InputPath . Files are treated as objects instead of being deserialized. Additional, PSRule uses the file extension as the object type. When files have no extension the whole file name is used. See about_PSRule_Options for details. This parameter takes precedence over the Input.Format option if set. Type : InputFormat Parameter Sets : (All) Aliases : Accepted values : None, Yaml, Json, Markdown, PowerShellData, File, Detect Required : False Position : Named Default value : Detect Accept pipeline input : False Accept wildcard characters : False","title":"-Format"},{"location":"commands/PSRule/en-US/Assert-PSRule/#-baseline","text":"Specifies an explicit baseline by name to use for evaluating rules. Baselines can contain filters and custom configuration that overrides the defaults. Type : BaselineOption Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Baseline"},{"location":"commands/PSRule/en-US/Assert-PSRule/#-convention","text":"Specifies conventions by name to execute in the pipeline when processing objects. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Convention"},{"location":"commands/PSRule/en-US/Assert-PSRule/#-culture","text":"Specifies the culture to use for rule documentation and messages. By default, the culture of PowerShell is used. This option does not affect the culture used for the PSRule engine, which always uses the culture of PowerShell. The PowerShell cmdlet Get-Culture shows the current culture of PowerShell. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Culture"},{"location":"commands/PSRule/en-US/Assert-PSRule/#-module","text":"Search for rule definitions within a module. If no sources are specified by -Path , -Module , or options, the current working directory is used. Type : String[] Parameter Sets : (All) Aliases : m Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Module"},{"location":"commands/PSRule/en-US/Assert-PSRule/#-name","text":"The name of a specific rule to evaluate. If this parameter is not specified all rules in search paths will be evaluated. Type : String[] Parameter Sets : (All) Aliases : n Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Name"},{"location":"commands/PSRule/en-US/Assert-PSRule/#-objectpath","text":"The name of a property to use instead of the pipeline object. If the property specified by ObjectPath is a collection or an array, then each item in evaluated separately. Type : String Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-ObjectPath"},{"location":"commands/PSRule/en-US/Assert-PSRule/#-targettype","text":"Filters input objects by TargetType. If specified, only objects with the specified TargetType are processed. Objects that do not match TargetType are ignored. If multiple values are specified, only one TargetType must match. This parameter is not case-sensitive. By default, all objects are processed. This parameter if set, overrides the Input.TargetType option. To change the field TargetType is bound to set the Binding.TargetType option. For details see the about_PSRule_Options help topic. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-TargetType"},{"location":"commands/PSRule/en-US/Assert-PSRule/#-option","text":"Additional options that configure execution. A PSRuleOption can be created by using the New-PSRuleOption cmdlet. Alternatively, a hashtable or path to YAML file can be specified with options. For more information on PSRule options see about_PSRule_Options. Type : PSRuleOption Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Option"},{"location":"commands/PSRule/en-US/Assert-PSRule/#-outputpath","text":"Specifies the output file path to write results. Directories along the file path will automatically be created if they do not exist. Type : String Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-OutputPath"},{"location":"commands/PSRule/en-US/Assert-PSRule/#-outputformat","text":"Configures the format that output is written. This parameter has no affect when -OutputPath is not specified. The following format options are available: None - Output is presented as an object using PowerShell defaults. This is the default. Yaml - Output is serialized as YAML. Json - Output is serialized as JSON. Markdown - Output is serialized as Markdown. NUnit3 - Output is serialized as NUnit3 (XML). Csv - Output is serialized as a comma separated values (CSV). The Wide format is not applicable to Assert-PSRule . Type : OutputFormat Parameter Sets : (All) Aliases : o Accepted values : None, Yaml, Json, Markdown, NUnit3, Csv Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-OutputFormat"},{"location":"commands/PSRule/en-US/Assert-PSRule/#-style","text":"Configures the style that results will be presented in. The following styles are available: Client - Output is written to the host directly in green/ red to indicate outcome. Plain - Output is written as an unformatted string. This option can be redirected to a file. AzurePipelines - Output is written for integration Azure Pipelines. GitHubActions - Output is written for integration GitHub Actions. VisualStudioCode - Output is written for integration with Visual Studio Code. Detect - Output style will be detected by checking the environment variables. This is the default. Detect uses the following logic: If the TF_BUILD environment variable is set to true , AzurePipelines will be used. If the GITHUB_ACTIONS environment variable is set to true , GitHubActions will be used. If the TERM_PROGRAM environment variable is set to vscode , VisualStudioCode will be used. Use Client . Each of these styles outputs to the host. To capture output as a string redirect the information stream. For example: 6>&1 Type : OutputStyle Parameter Sets : (All) Aliases : Accepted values : Client, Plain, AzurePipelines, GitHubActions, VisualStudioCode, Detect Required : False Position : Named Default value : Client Accept pipeline input : False Accept wildcard characters : False","title":"-Style"},{"location":"commands/PSRule/en-US/Assert-PSRule/#-as","text":"The type of results to produce. Detailed results are generated by default. The following result formats are available: Detail - Returns pass/ fail results for each rule per object. Summary - Failure or errors are shown but passing results are summarized. Type : ResultFormat Parameter Sets : (All) Aliases : Accepted values : Detail, Summary Required : False Position : Named Default value : Detail Accept pipeline input : False Accept wildcard characters : False","title":"-As"},{"location":"commands/PSRule/en-US/Assert-PSRule/#-outcome","text":"Filter output to only show rule results with a specific outcome. Type : RuleOutcome Parameter Sets : (All) Aliases : Accepted values : Pass, Fail, Error, None, Processed, All Required : False Position : Named Default value : Pass, Fail, Error Accept pipeline input : False Accept wildcard characters : False","title":"-Outcome"},{"location":"commands/PSRule/en-US/Assert-PSRule/#-path","text":"One or more paths to search for rule definitions within. If no sources are specified by -Path , -Module , or options, the current working directory is used. Type : String[] Parameter Sets : (All) Aliases : p Required : False Position : 0 Default value : $PWD Accept pipeline input : False Accept wildcard characters : False","title":"-Path"},{"location":"commands/PSRule/en-US/Assert-PSRule/#-tag","text":"Only get rules with the specified tags set. If this parameter is not specified all rules in search paths will be returned. When more than one tag is used, all tags must match. Tags are not case sensitive. A tag value of * may be used to filter rules to any rule with the tag set, regardless of tag value. An array of tag values can be used to match a rule with either value. i.e. severity = important, critical matches rules with a category of either important or critical . Type : Hashtable Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Tag"},{"location":"commands/PSRule/en-US/Assert-PSRule/#-inputobject","text":"The pipeline object to process rules for. Type : PSObject Parameter Sets : Input Aliases : TargetObject Required : True Position : Named Default value : None Accept pipeline input : True (ByValue) Accept wildcard characters : False","title":"-InputObject"},{"location":"commands/PSRule/en-US/Assert-PSRule/#-resultvariable","text":"Stores output result objects in the specified variable. Type : String Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-ResultVariable"},{"location":"commands/PSRule/en-US/Assert-PSRule/#-whatif","text":"Shows what would happen if the cmdlet runs. The cmdlet is not run. Type : SwitchParameter Parameter Sets : (All) Aliases : wi Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-WhatIf"},{"location":"commands/PSRule/en-US/Assert-PSRule/#-confirm","text":"Prompts you for confirmation before running the cmdlet. Type : SwitchParameter Parameter Sets : (All) Aliases : cf Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Confirm"},{"location":"commands/PSRule/en-US/Assert-PSRule/#commonparameters","text":"This cmdlet supports the common parameters: -Debug, -ErrorAction, -ErrorVariable, -InformationAction, -InformationVariable, -OutVariable, -OutBuffer, -PipelineVariable, -Verbose, -WarningAction, and -WarningVariable. For more information, see about_CommonParameters .","title":"CommonParameters"},{"location":"commands/PSRule/en-US/Assert-PSRule/#inputs","text":"","title":"INPUTS"},{"location":"commands/PSRule/en-US/Assert-PSRule/#systemmanagementautomationpsobject","text":"You can pipe any object to Assert-PSRule .","title":"System.Management.Automation.PSObject"},{"location":"commands/PSRule/en-US/Assert-PSRule/#outputs","text":"","title":"OUTPUTS"},{"location":"commands/PSRule/en-US/Assert-PSRule/#systemstring","text":"","title":"System.String"},{"location":"commands/PSRule/en-US/Assert-PSRule/#notes","text":"","title":"Notes"},{"location":"commands/PSRule/en-US/Assert-PSRule/#related-links","text":"Get-PSRule Invoke-PSRule Test-PSRuleTarget","title":"RELATED LINKS"},{"location":"commands/PSRule/en-US/Export-PSRuleBaseline/","text":"Export-PSRuleBaseline # Exports a list of baselines. SYNTAX # Export-PSRuleBaseline [[-Path] <string[]>] -OutputPath <string> [-Module <string[]>] [-Name <string[]>] [-Option <PSRuleOption>] [-Culture <string>] [-OutputFormat <OutputFormat>] [-OutputEncoding <OutputEncoding>] [-WhatIf] [-Confirm] [<CommonParameters>] Description # Exports a list of baselines to a file. Examples # Example 1 # Export-PSRuleBaseline -Module PSRule . Rules . Azure -OutputFormat Yaml -OutputPath Baseline . Rule . yml Exports list of baselines from PSRule.Rules.Azure module to file Baseline.Rule.yml in YAML output format. PARAMETERS # -Module # Search for baselines definitions within a module. If no sources are specified by -Path , -Module , or options, the current working directory is used. Type : String[] Parameter Sets : (All) Aliases : m Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -Path # One or more paths to search for baselines within. If no sources are specified by -Path , -Module , or options, the current working directory is used. Type : String[] Parameter Sets : (All) Aliases : p Required : False Position : 1 Default value : $PWD Accept pipeline input : False Accept wildcard characters : False -Name # The name of a specific baseline to list. If this parameter is not specified all baselines in search paths will be listed. Type : String[] Parameter Sets : (All) Aliases : n Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : True -Option # Additional options that configure execution. A PSRuleOption can be created by using the New-PSRuleOption cmdlet. Alternatively a hashtable or path to YAML file can be specified with options. For more information on PSRule options see about_PSRule_Options. Type : PSRuleOption Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -Culture # Specifies the culture to use for documentation and messages. By default, the culture of PowerShell is used. This option does not affect the culture used for the PSRule engine, which always uses the culture of PowerShell. The PowerShell cmdlet Get-Culture shows the current culture of PowerShell. Type : String Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -OutputFormat # Configures the format that output is presented in. The following format options are available: Yaml - Output is serialized as YAML. This is the default. Json - Output is serialized as JSON. Type : OutputFormat Parameter Sets : (All) Aliases : o Accepted values : Yaml, Json Required : False Position : Named Default value : Yaml Accept pipeline input : False Accept wildcard characters : False -OutputEncoding # Sets the option Output.Encoding . The Output.Encoding option configured the encoding used to write results to file. Type : OutputEncoding Parameter Sets : (All) Aliases : Accepted values : Default, UTF8, UTF7, Unicode, UTF32, ASCII Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -OutputPath # Sets the option Output.Path . The Output.Path option configures the output path the results are written to. Type : String Parameter Sets : (All) Aliases : Required : True Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -WhatIf # Shows what would happen if the cmdlet runs. The cmdlet is not run. Type : SwitchParameter Parameter Sets : (All) Aliases : wi Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -Confirm # Prompts you for confirmation before running the cmdlet. Type : SwitchParameter Parameter Sets : (All) Aliases : cf Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False CommonParameters # This cmdlet supports the common parameters: -Debug, -ErrorAction, -ErrorVariable, -InformationAction, -InformationVariable, -OutVariable, -OutBuffer, -PipelineVariable, -Verbose, -WarningAction, and -WarningVariable. For more information, see about_CommonParameters . INPUTS # OUTPUTS # Notes # RELATED LINKS # Get-PSRuleBaseline","title":"Export-PSRuleBaseline"},{"location":"commands/PSRule/en-US/Export-PSRuleBaseline/#export-psrulebaseline","text":"Exports a list of baselines.","title":"Export-PSRuleBaseline"},{"location":"commands/PSRule/en-US/Export-PSRuleBaseline/#syntax","text":"Export-PSRuleBaseline [[-Path] <string[]>] -OutputPath <string> [-Module <string[]>] [-Name <string[]>] [-Option <PSRuleOption>] [-Culture <string>] [-OutputFormat <OutputFormat>] [-OutputEncoding <OutputEncoding>] [-WhatIf] [-Confirm] [<CommonParameters>]","title":"SYNTAX"},{"location":"commands/PSRule/en-US/Export-PSRuleBaseline/#description","text":"Exports a list of baselines to a file.","title":"Description"},{"location":"commands/PSRule/en-US/Export-PSRuleBaseline/#examples","text":"","title":"Examples"},{"location":"commands/PSRule/en-US/Export-PSRuleBaseline/#example-1","text":"Export-PSRuleBaseline -Module PSRule . Rules . Azure -OutputFormat Yaml -OutputPath Baseline . Rule . yml Exports list of baselines from PSRule.Rules.Azure module to file Baseline.Rule.yml in YAML output format.","title":"Example 1"},{"location":"commands/PSRule/en-US/Export-PSRuleBaseline/#parameters","text":"","title":"PARAMETERS"},{"location":"commands/PSRule/en-US/Export-PSRuleBaseline/#-module","text":"Search for baselines definitions within a module. If no sources are specified by -Path , -Module , or options, the current working directory is used. Type : String[] Parameter Sets : (All) Aliases : m Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Module"},{"location":"commands/PSRule/en-US/Export-PSRuleBaseline/#-path","text":"One or more paths to search for baselines within. If no sources are specified by -Path , -Module , or options, the current working directory is used. Type : String[] Parameter Sets : (All) Aliases : p Required : False Position : 1 Default value : $PWD Accept pipeline input : False Accept wildcard characters : False","title":"-Path"},{"location":"commands/PSRule/en-US/Export-PSRuleBaseline/#-name","text":"The name of a specific baseline to list. If this parameter is not specified all baselines in search paths will be listed. Type : String[] Parameter Sets : (All) Aliases : n Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : True","title":"-Name"},{"location":"commands/PSRule/en-US/Export-PSRuleBaseline/#-option","text":"Additional options that configure execution. A PSRuleOption can be created by using the New-PSRuleOption cmdlet. Alternatively a hashtable or path to YAML file can be specified with options. For more information on PSRule options see about_PSRule_Options. Type : PSRuleOption Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Option"},{"location":"commands/PSRule/en-US/Export-PSRuleBaseline/#-culture","text":"Specifies the culture to use for documentation and messages. By default, the culture of PowerShell is used. This option does not affect the culture used for the PSRule engine, which always uses the culture of PowerShell. The PowerShell cmdlet Get-Culture shows the current culture of PowerShell. Type : String Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Culture"},{"location":"commands/PSRule/en-US/Export-PSRuleBaseline/#-outputformat","text":"Configures the format that output is presented in. The following format options are available: Yaml - Output is serialized as YAML. This is the default. Json - Output is serialized as JSON. Type : OutputFormat Parameter Sets : (All) Aliases : o Accepted values : Yaml, Json Required : False Position : Named Default value : Yaml Accept pipeline input : False Accept wildcard characters : False","title":"-OutputFormat"},{"location":"commands/PSRule/en-US/Export-PSRuleBaseline/#-outputencoding","text":"Sets the option Output.Encoding . The Output.Encoding option configured the encoding used to write results to file. Type : OutputEncoding Parameter Sets : (All) Aliases : Accepted values : Default, UTF8, UTF7, Unicode, UTF32, ASCII Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-OutputEncoding"},{"location":"commands/PSRule/en-US/Export-PSRuleBaseline/#-outputpath","text":"Sets the option Output.Path . The Output.Path option configures the output path the results are written to. Type : String Parameter Sets : (All) Aliases : Required : True Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-OutputPath"},{"location":"commands/PSRule/en-US/Export-PSRuleBaseline/#-whatif","text":"Shows what would happen if the cmdlet runs. The cmdlet is not run. Type : SwitchParameter Parameter Sets : (All) Aliases : wi Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-WhatIf"},{"location":"commands/PSRule/en-US/Export-PSRuleBaseline/#-confirm","text":"Prompts you for confirmation before running the cmdlet. Type : SwitchParameter Parameter Sets : (All) Aliases : cf Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Confirm"},{"location":"commands/PSRule/en-US/Export-PSRuleBaseline/#commonparameters","text":"This cmdlet supports the common parameters: -Debug, -ErrorAction, -ErrorVariable, -InformationAction, -InformationVariable, -OutVariable, -OutBuffer, -PipelineVariable, -Verbose, -WarningAction, and -WarningVariable. For more information, see about_CommonParameters .","title":"CommonParameters"},{"location":"commands/PSRule/en-US/Export-PSRuleBaseline/#inputs","text":"","title":"INPUTS"},{"location":"commands/PSRule/en-US/Export-PSRuleBaseline/#outputs","text":"","title":"OUTPUTS"},{"location":"commands/PSRule/en-US/Export-PSRuleBaseline/#notes","text":"","title":"Notes"},{"location":"commands/PSRule/en-US/Export-PSRuleBaseline/#related-links","text":"Get-PSRuleBaseline","title":"RELATED LINKS"},{"location":"commands/PSRule/en-US/Get-PSRule/","text":"Get-PSRule # Get a list of rule definitions. SYNTAX # Get-PSRule [-Module <String[]>] [-ListAvailable] [-OutputFormat <OutputFormat>] [-Baseline <BaselineOption>] [[-Path] <String[]>] [-Name <String[]>] [-Tag <Hashtable>] [-Option <PSRuleOption>] [-Culture <String>] [-IncludeDependencies] [<CommonParameters>] Description # Get a list of matching rule definitions within the search path. Examples # Example 1 # Get-PSRule ; RuleName ModuleName Synopsis -------- ---------- -------- isFruit An example rule Get a list of rule definitions from the current working path. Example 2 # Get-PSRule -Module PSRule . Rules . Azure ; RuleName ModuleName Synopsis -------- ---------- -------- Azure.ACR.AdminUser PSRule.Rules.Azure Use Azure AD accounts instead of using the registry adm\u2026 Azure.ACR.MinSku PSRule.Rules.Azure ACR should use the Premium or Standard SKU for producti\u2026 Azure.AKS.MinNodeCount PSRule.Rules.Azure AKS clusters should have minimum number of nodes for fa\u2026 Azure.AKS.Version PSRule.Rules.Azure AKS clusters should meet the minimum version. Azure.AKS.UseRBAC PSRule.Rules.Azure AKS cluster should use role-based access control (RBAC). Get a list of rule definitions included in the module PSRule.Rules.Azure . Example 3 # Get-PSRule -Module PSRule . Rules . Azure -OutputFormat Wide ; RuleName ModuleName Synopsis Tag -------- ---------- -------- --- Azure.ACR.AdminUser PSRule.Rules.Azure Use Azure AD accounts severity='Critical' instead of using the category='Security registry admin user. configuration' Azure.ACR.MinSku PSRule.Rules.Azure ACR should use the Premium severity='Important' or Standard SKU for category='Performance' production deployments. Azure.AKS.MinNodeCount PSRule.Rules.Azure AKS clusters should have severity='Important' minimum number of nodes for category='Reliability' failover and updates. Azure.AKS.Version PSRule.Rules.Azure AKS clusters should meet severity='Important' the minimum version. category='Operations management' Azure.AKS.UseRBAC PSRule.Rules.Azure AKS cluster should use severity='Important' role-based access control category='Security (RBAC). configuration' Get a list of rule definitions included in the module PSRule.Rules.Azure including tags with line wrapping. PARAMETERS # -Name # The name of a specific rule to list. If this parameter is not specified all rules in search paths will be listed. Type : String[] Parameter Sets : (All) Aliases : n Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -Path # One or more paths to search for rule definitions within. If no sources are specified by -Path , -Module , or options, the current working directory is used. Type : String[] Parameter Sets : (All) Aliases : p Required : False Position : 0 Default value : $PWD Accept pipeline input : False Accept wildcard characters : False -Tag # Only get rules with the specified tags set. If this parameter is not specified all rules in search paths will be returned. When more than one tag is used, all tags must match. Tags are not case sensitive. A tag value of * may be used to filter rules to any rule with the tag set, regardless of tag value. An array of tag values can be used to match a rule with either value. i.e. severity = important, critical matches rules with a category of either important or critical . Type : Hashtable Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -Option # Additional options that configure execution. A PSRuleOption can be created by using the New-PSRuleOption cmdlet. Alternatively a hashtable or path to YAML file can be specified with options. For more information on PSRule options see about_PSRule_Options. Type : PSRuleOption Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -ListAvailable # Look for modules containing rule definitions including modules that are currently not imported. This switch is used with the -Module parameter. Type : SwitchParameter Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -Module # Search for rule definitions within a module. If no sources are specified by -Path , -Module , or options, the current working directory is used. Type : String[] Parameter Sets : (All) Aliases : m Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -Culture # Specifies the culture to use for documentation and messages. By default, the culture of PowerShell is used. This option does not affect the culture used for the PSRule engine, which always uses the culture of PowerShell. The PowerShell cmdlet Get-Culture shows the current culture of PowerShell. Type : String Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -OutputFormat # Configures the format that output is presented in. The following format options are available: None - Output is presented as an object using PowerShell defaults. This is the default. Wide - Output is presented using the wide table format, which includes tags and wraps columns. Yaml - Output is serialized as YAML. Json - Output is serialized as JSON. Type : OutputFormat Parameter Sets : (All) Aliases : o Accepted values : None, Wide, Yaml, Json Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -IncludeDependencies # When this switch is specified, dependencies of the rules that meet the -Name and -Tag filters are included even if they would normally be excluded. This switch has no affect when getting an unfiltered list of rules. Type : SwitchParameter Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -Baseline # When specified, rules are filtered so that only rules that are included in the baselines are returned. Type : BaselineOption Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False CommonParameters # This cmdlet supports the common parameters: -Debug, -ErrorAction, -ErrorVariable, -InformationAction, -InformationVariable, -OutVariable, -OutBuffer, -PipelineVariable, -Verbose, -WarningAction, and -WarningVariable. For more information, see about_CommonParameters . INPUTS # None # OUTPUTS # PSRule.Definitions.Rules.IRuleV1 # Notes # RELATED LINKS # Invoke-PSRule","title":"Get-PSRule"},{"location":"commands/PSRule/en-US/Get-PSRule/#get-psrule","text":"Get a list of rule definitions.","title":"Get-PSRule"},{"location":"commands/PSRule/en-US/Get-PSRule/#syntax","text":"Get-PSRule [-Module <String[]>] [-ListAvailable] [-OutputFormat <OutputFormat>] [-Baseline <BaselineOption>] [[-Path] <String[]>] [-Name <String[]>] [-Tag <Hashtable>] [-Option <PSRuleOption>] [-Culture <String>] [-IncludeDependencies] [<CommonParameters>]","title":"SYNTAX"},{"location":"commands/PSRule/en-US/Get-PSRule/#description","text":"Get a list of matching rule definitions within the search path.","title":"Description"},{"location":"commands/PSRule/en-US/Get-PSRule/#examples","text":"","title":"Examples"},{"location":"commands/PSRule/en-US/Get-PSRule/#example-1","text":"Get-PSRule ; RuleName ModuleName Synopsis -------- ---------- -------- isFruit An example rule Get a list of rule definitions from the current working path.","title":"Example 1"},{"location":"commands/PSRule/en-US/Get-PSRule/#example-2","text":"Get-PSRule -Module PSRule . Rules . Azure ; RuleName ModuleName Synopsis -------- ---------- -------- Azure.ACR.AdminUser PSRule.Rules.Azure Use Azure AD accounts instead of using the registry adm\u2026 Azure.ACR.MinSku PSRule.Rules.Azure ACR should use the Premium or Standard SKU for producti\u2026 Azure.AKS.MinNodeCount PSRule.Rules.Azure AKS clusters should have minimum number of nodes for fa\u2026 Azure.AKS.Version PSRule.Rules.Azure AKS clusters should meet the minimum version. Azure.AKS.UseRBAC PSRule.Rules.Azure AKS cluster should use role-based access control (RBAC). Get a list of rule definitions included in the module PSRule.Rules.Azure .","title":"Example 2"},{"location":"commands/PSRule/en-US/Get-PSRule/#example-3","text":"Get-PSRule -Module PSRule . Rules . Azure -OutputFormat Wide ; RuleName ModuleName Synopsis Tag -------- ---------- -------- --- Azure.ACR.AdminUser PSRule.Rules.Azure Use Azure AD accounts severity='Critical' instead of using the category='Security registry admin user. configuration' Azure.ACR.MinSku PSRule.Rules.Azure ACR should use the Premium severity='Important' or Standard SKU for category='Performance' production deployments. Azure.AKS.MinNodeCount PSRule.Rules.Azure AKS clusters should have severity='Important' minimum number of nodes for category='Reliability' failover and updates. Azure.AKS.Version PSRule.Rules.Azure AKS clusters should meet severity='Important' the minimum version. category='Operations management' Azure.AKS.UseRBAC PSRule.Rules.Azure AKS cluster should use severity='Important' role-based access control category='Security (RBAC). configuration' Get a list of rule definitions included in the module PSRule.Rules.Azure including tags with line wrapping.","title":"Example 3"},{"location":"commands/PSRule/en-US/Get-PSRule/#parameters","text":"","title":"PARAMETERS"},{"location":"commands/PSRule/en-US/Get-PSRule/#-name","text":"The name of a specific rule to list. If this parameter is not specified all rules in search paths will be listed. Type : String[] Parameter Sets : (All) Aliases : n Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Name"},{"location":"commands/PSRule/en-US/Get-PSRule/#-path","text":"One or more paths to search for rule definitions within. If no sources are specified by -Path , -Module , or options, the current working directory is used. Type : String[] Parameter Sets : (All) Aliases : p Required : False Position : 0 Default value : $PWD Accept pipeline input : False Accept wildcard characters : False","title":"-Path"},{"location":"commands/PSRule/en-US/Get-PSRule/#-tag","text":"Only get rules with the specified tags set. If this parameter is not specified all rules in search paths will be returned. When more than one tag is used, all tags must match. Tags are not case sensitive. A tag value of * may be used to filter rules to any rule with the tag set, regardless of tag value. An array of tag values can be used to match a rule with either value. i.e. severity = important, critical matches rules with a category of either important or critical . Type : Hashtable Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Tag"},{"location":"commands/PSRule/en-US/Get-PSRule/#-option","text":"Additional options that configure execution. A PSRuleOption can be created by using the New-PSRuleOption cmdlet. Alternatively a hashtable or path to YAML file can be specified with options. For more information on PSRule options see about_PSRule_Options. Type : PSRuleOption Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Option"},{"location":"commands/PSRule/en-US/Get-PSRule/#-listavailable","text":"Look for modules containing rule definitions including modules that are currently not imported. This switch is used with the -Module parameter. Type : SwitchParameter Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-ListAvailable"},{"location":"commands/PSRule/en-US/Get-PSRule/#-module","text":"Search for rule definitions within a module. If no sources are specified by -Path , -Module , or options, the current working directory is used. Type : String[] Parameter Sets : (All) Aliases : m Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Module"},{"location":"commands/PSRule/en-US/Get-PSRule/#-culture","text":"Specifies the culture to use for documentation and messages. By default, the culture of PowerShell is used. This option does not affect the culture used for the PSRule engine, which always uses the culture of PowerShell. The PowerShell cmdlet Get-Culture shows the current culture of PowerShell. Type : String Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Culture"},{"location":"commands/PSRule/en-US/Get-PSRule/#-outputformat","text":"Configures the format that output is presented in. The following format options are available: None - Output is presented as an object using PowerShell defaults. This is the default. Wide - Output is presented using the wide table format, which includes tags and wraps columns. Yaml - Output is serialized as YAML. Json - Output is serialized as JSON. Type : OutputFormat Parameter Sets : (All) Aliases : o Accepted values : None, Wide, Yaml, Json Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-OutputFormat"},{"location":"commands/PSRule/en-US/Get-PSRule/#-includedependencies","text":"When this switch is specified, dependencies of the rules that meet the -Name and -Tag filters are included even if they would normally be excluded. This switch has no affect when getting an unfiltered list of rules. Type : SwitchParameter Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-IncludeDependencies"},{"location":"commands/PSRule/en-US/Get-PSRule/#-baseline","text":"When specified, rules are filtered so that only rules that are included in the baselines are returned. Type : BaselineOption Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Baseline"},{"location":"commands/PSRule/en-US/Get-PSRule/#commonparameters","text":"This cmdlet supports the common parameters: -Debug, -ErrorAction, -ErrorVariable, -InformationAction, -InformationVariable, -OutVariable, -OutBuffer, -PipelineVariable, -Verbose, -WarningAction, and -WarningVariable. For more information, see about_CommonParameters .","title":"CommonParameters"},{"location":"commands/PSRule/en-US/Get-PSRule/#inputs","text":"","title":"INPUTS"},{"location":"commands/PSRule/en-US/Get-PSRule/#none","text":"","title":"None"},{"location":"commands/PSRule/en-US/Get-PSRule/#outputs","text":"","title":"OUTPUTS"},{"location":"commands/PSRule/en-US/Get-PSRule/#psruledefinitionsrulesirulev1","text":"","title":"PSRule.Definitions.Rules.IRuleV1"},{"location":"commands/PSRule/en-US/Get-PSRule/#notes","text":"","title":"Notes"},{"location":"commands/PSRule/en-US/Get-PSRule/#related-links","text":"Invoke-PSRule","title":"RELATED LINKS"},{"location":"commands/PSRule/en-US/Get-PSRuleBaseline/","text":"Get-PSRuleBaseline # Get a list of baselines. SYNTAX # Get-PSRuleBaseline [-Module <String[]>] [-ListAvailable] [[-Path] <String[]>] [-Name <String[]>] [-Option <PSRuleOption>] [-Culture <String>] [-OutputFormat <OutputFormat>] [<CommonParameters>] Description # Get a list of matching baselines within the search path. Examples # Example 1 # Get-PSRuleBaseline ; Get a list of baselines from the current working path. PARAMETERS # -Module # Search for baselines definitions within a module. If no sources are specified by -Path , -Module , or options, the current working directory is used. Type : String[] Parameter Sets : (All) Aliases : m Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -ListAvailable # Look for modules containing baselines including modules that are currently not imported. This switch is used with the -Module parameter. Type : SwitchParameter Parameter Sets : (All) Aliases : Required : False Position : Named Default value : False Accept pipeline input : False Accept wildcard characters : False -Path # One or more paths to search for baselines within. If no sources are specified by -Path , -Module , or options, the current working directory is used. Type : String[] Parameter Sets : (All) Aliases : p Required : False Position : 1 Default value : $PWD Accept pipeline input : False Accept wildcard characters : False -Name # The name of a specific baseline to list. If this parameter is not specified all baselines in search paths will be listed. Type : String[] Parameter Sets : (All) Aliases : n Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -Option # Additional options that configure execution. A PSRuleOption can be created by using the New-PSRuleOption cmdlet. Alternatively a hashtable or path to YAML file can be specified with options. For more information on PSRule options see about_PSRule_Options. Type : PSRuleOption Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -Culture # Specifies the culture to use for documentation and messages. By default, the culture of PowerShell is used. This option does not affect the culture used for the PSRule engine, which always uses the culture of PowerShell. The PowerShell cmdlet Get-Culture shows the current culture of PowerShell. Type : String Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -OutputFormat # Configures the format that output is presented in. The following format options are available: None - Output is presented as an object using PowerShell defaults. This is the default. Yaml - Output is serialized as YAML. Json - Output is serialized as JSON. Type : OutputFormat Parameter Sets : (All) Aliases : o Accepted values : None, Yaml, Json Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False CommonParameters # This cmdlet supports the common parameters: -Debug, -ErrorAction, -ErrorVariable, -InformationAction, -InformationVariable, -OutVariable, -OutBuffer, -PipelineVariable, -Verbose, -WarningAction, and -WarningVariable. For more information, see about_CommonParameters . INPUTS # OUTPUTS # PSRule.Definitions.Baseline # This is the default. System.String # When you use -OutputFormat Yaml or -OutputFormat Json . Notes # RELATED LINKS # Get-PSRule","title":"Get-PSRuleBaseline"},{"location":"commands/PSRule/en-US/Get-PSRuleBaseline/#get-psrulebaseline","text":"Get a list of baselines.","title":"Get-PSRuleBaseline"},{"location":"commands/PSRule/en-US/Get-PSRuleBaseline/#syntax","text":"Get-PSRuleBaseline [-Module <String[]>] [-ListAvailable] [[-Path] <String[]>] [-Name <String[]>] [-Option <PSRuleOption>] [-Culture <String>] [-OutputFormat <OutputFormat>] [<CommonParameters>]","title":"SYNTAX"},{"location":"commands/PSRule/en-US/Get-PSRuleBaseline/#description","text":"Get a list of matching baselines within the search path.","title":"Description"},{"location":"commands/PSRule/en-US/Get-PSRuleBaseline/#examples","text":"","title":"Examples"},{"location":"commands/PSRule/en-US/Get-PSRuleBaseline/#example-1","text":"Get-PSRuleBaseline ; Get a list of baselines from the current working path.","title":"Example 1"},{"location":"commands/PSRule/en-US/Get-PSRuleBaseline/#parameters","text":"","title":"PARAMETERS"},{"location":"commands/PSRule/en-US/Get-PSRuleBaseline/#-module","text":"Search for baselines definitions within a module. If no sources are specified by -Path , -Module , or options, the current working directory is used. Type : String[] Parameter Sets : (All) Aliases : m Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Module"},{"location":"commands/PSRule/en-US/Get-PSRuleBaseline/#-listavailable","text":"Look for modules containing baselines including modules that are currently not imported. This switch is used with the -Module parameter. Type : SwitchParameter Parameter Sets : (All) Aliases : Required : False Position : Named Default value : False Accept pipeline input : False Accept wildcard characters : False","title":"-ListAvailable"},{"location":"commands/PSRule/en-US/Get-PSRuleBaseline/#-path","text":"One or more paths to search for baselines within. If no sources are specified by -Path , -Module , or options, the current working directory is used. Type : String[] Parameter Sets : (All) Aliases : p Required : False Position : 1 Default value : $PWD Accept pipeline input : False Accept wildcard characters : False","title":"-Path"},{"location":"commands/PSRule/en-US/Get-PSRuleBaseline/#-name","text":"The name of a specific baseline to list. If this parameter is not specified all baselines in search paths will be listed. Type : String[] Parameter Sets : (All) Aliases : n Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Name"},{"location":"commands/PSRule/en-US/Get-PSRuleBaseline/#-option","text":"Additional options that configure execution. A PSRuleOption can be created by using the New-PSRuleOption cmdlet. Alternatively a hashtable or path to YAML file can be specified with options. For more information on PSRule options see about_PSRule_Options. Type : PSRuleOption Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Option"},{"location":"commands/PSRule/en-US/Get-PSRuleBaseline/#-culture","text":"Specifies the culture to use for documentation and messages. By default, the culture of PowerShell is used. This option does not affect the culture used for the PSRule engine, which always uses the culture of PowerShell. The PowerShell cmdlet Get-Culture shows the current culture of PowerShell. Type : String Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Culture"},{"location":"commands/PSRule/en-US/Get-PSRuleBaseline/#-outputformat","text":"Configures the format that output is presented in. The following format options are available: None - Output is presented as an object using PowerShell defaults. This is the default. Yaml - Output is serialized as YAML. Json - Output is serialized as JSON. Type : OutputFormat Parameter Sets : (All) Aliases : o Accepted values : None, Yaml, Json Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-OutputFormat"},{"location":"commands/PSRule/en-US/Get-PSRuleBaseline/#commonparameters","text":"This cmdlet supports the common parameters: -Debug, -ErrorAction, -ErrorVariable, -InformationAction, -InformationVariable, -OutVariable, -OutBuffer, -PipelineVariable, -Verbose, -WarningAction, and -WarningVariable. For more information, see about_CommonParameters .","title":"CommonParameters"},{"location":"commands/PSRule/en-US/Get-PSRuleBaseline/#inputs","text":"","title":"INPUTS"},{"location":"commands/PSRule/en-US/Get-PSRuleBaseline/#outputs","text":"","title":"OUTPUTS"},{"location":"commands/PSRule/en-US/Get-PSRuleBaseline/#psruledefinitionsbaseline","text":"This is the default.","title":"PSRule.Definitions.Baseline"},{"location":"commands/PSRule/en-US/Get-PSRuleBaseline/#systemstring","text":"When you use -OutputFormat Yaml or -OutputFormat Json .","title":"System.String"},{"location":"commands/PSRule/en-US/Get-PSRuleBaseline/#notes","text":"","title":"Notes"},{"location":"commands/PSRule/en-US/Get-PSRuleBaseline/#related-links","text":"Get-PSRule","title":"RELATED LINKS"},{"location":"commands/PSRule/en-US/Get-PSRuleHelp/","text":"Get-PSRuleHelp # Displays information about a rule. SYNTAX # Get-PSRuleHelp [-Module <String>] [-Online] [-Full] [[-Name] <String>] [-Path <String>] [-Option <PSRuleOption>] [-Culture <String>] [<CommonParameters>] Description # The Get-PSRuleHelp cmdlet display information about a rule. By default, this cmdlet will look for rules in the current path and loaded modules. To get help for a specific rule or module use the -Name or -Module parameters. If the rule has an online version of the documentation, use the -Online parameter to view it in your default web browser. Examples # Example 1 # Get-PSRuleHelp ; Get a list of rule help within the current path or loaded modules. Example 2 # Get-PSRuleHelp Azure . ACR . AdminUser ; Get rule documentation for the rule Azure.ACR.AdminUser . Example 3 # Get-PSRuleHelp Azure . ACR . AdminUser -Online ; Browse to the online version of documentation for Azure.ACR.AdminUser using the default web browser. PARAMETERS # -Name # The name of the rule to get documentation for. Type : String Parameter Sets : (All) Aliases : n Required : False Position : 1 Default value : None Accept pipeline input : False Accept wildcard characters : True -Path # A path to check documentation for. By default, help from the current working path and loaded modules is listed. Results can be filtered by using -Name , -Path or -Module . Type : String Parameter Sets : (All) Aliases : p Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -Module # Limit returned information to rules in the specified module. By default, help from the current working path and loaded modules is listed. Results can be filtered by using -Name , -Path or -Module . Type : String Parameter Sets : (All) Aliases : m Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -Culture # Specifies the culture to use for rule documentation and messages. By default, the culture of PowerShell is used. This option does not affect the culture used for the PSRule engine, which always uses the culture of PowerShell. The PowerShell cmdlet Get-Culture shows the current culture of PowerShell. Type : String Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -Online # Instead of displaying documentation within PowerShell, browse to the online version using the default web browser. Type : SwitchParameter Parameter Sets : (All) Aliases : Required : False Position : Named Default value : False Accept pipeline input : False Accept wildcard characters : False -Full # Display additional information such as notes and links. Type : SwitchParameter Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -Option # Additional options that configure execution. A PSRuleOption can be created by using the New-PSRuleOption cmdlet. Alternatively a hashtable or path to YAML file can be specified with options. For more information on PSRule options see about_PSRule_Options. Type : PSRuleOption Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False CommonParameters # This cmdlet supports the common parameters: -Debug, -ErrorAction, -ErrorVariable, -InformationAction, -InformationVariable, -OutVariable, -OutBuffer, -PipelineVariable, -Verbose, -WarningAction, and -WarningVariable. For more information, see about_CommonParameters . INPUTS # None # OUTPUTS # PSRule.Rules.RuleHelpInfo # Notes # RELATED LINKS #","title":"Get-PSRuleHelp"},{"location":"commands/PSRule/en-US/Get-PSRuleHelp/#get-psrulehelp","text":"Displays information about a rule.","title":"Get-PSRuleHelp"},{"location":"commands/PSRule/en-US/Get-PSRuleHelp/#syntax","text":"Get-PSRuleHelp [-Module <String>] [-Online] [-Full] [[-Name] <String>] [-Path <String>] [-Option <PSRuleOption>] [-Culture <String>] [<CommonParameters>]","title":"SYNTAX"},{"location":"commands/PSRule/en-US/Get-PSRuleHelp/#description","text":"The Get-PSRuleHelp cmdlet display information about a rule. By default, this cmdlet will look for rules in the current path and loaded modules. To get help for a specific rule or module use the -Name or -Module parameters. If the rule has an online version of the documentation, use the -Online parameter to view it in your default web browser.","title":"Description"},{"location":"commands/PSRule/en-US/Get-PSRuleHelp/#examples","text":"","title":"Examples"},{"location":"commands/PSRule/en-US/Get-PSRuleHelp/#example-1","text":"Get-PSRuleHelp ; Get a list of rule help within the current path or loaded modules.","title":"Example 1"},{"location":"commands/PSRule/en-US/Get-PSRuleHelp/#example-2","text":"Get-PSRuleHelp Azure . ACR . AdminUser ; Get rule documentation for the rule Azure.ACR.AdminUser .","title":"Example 2"},{"location":"commands/PSRule/en-US/Get-PSRuleHelp/#example-3","text":"Get-PSRuleHelp Azure . ACR . AdminUser -Online ; Browse to the online version of documentation for Azure.ACR.AdminUser using the default web browser.","title":"Example 3"},{"location":"commands/PSRule/en-US/Get-PSRuleHelp/#parameters","text":"","title":"PARAMETERS"},{"location":"commands/PSRule/en-US/Get-PSRuleHelp/#-name","text":"The name of the rule to get documentation for. Type : String Parameter Sets : (All) Aliases : n Required : False Position : 1 Default value : None Accept pipeline input : False Accept wildcard characters : True","title":"-Name"},{"location":"commands/PSRule/en-US/Get-PSRuleHelp/#-path","text":"A path to check documentation for. By default, help from the current working path and loaded modules is listed. Results can be filtered by using -Name , -Path or -Module . Type : String Parameter Sets : (All) Aliases : p Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Path"},{"location":"commands/PSRule/en-US/Get-PSRuleHelp/#-module","text":"Limit returned information to rules in the specified module. By default, help from the current working path and loaded modules is listed. Results can be filtered by using -Name , -Path or -Module . Type : String Parameter Sets : (All) Aliases : m Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Module"},{"location":"commands/PSRule/en-US/Get-PSRuleHelp/#-culture","text":"Specifies the culture to use for rule documentation and messages. By default, the culture of PowerShell is used. This option does not affect the culture used for the PSRule engine, which always uses the culture of PowerShell. The PowerShell cmdlet Get-Culture shows the current culture of PowerShell. Type : String Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Culture"},{"location":"commands/PSRule/en-US/Get-PSRuleHelp/#-online","text":"Instead of displaying documentation within PowerShell, browse to the online version using the default web browser. Type : SwitchParameter Parameter Sets : (All) Aliases : Required : False Position : Named Default value : False Accept pipeline input : False Accept wildcard characters : False","title":"-Online"},{"location":"commands/PSRule/en-US/Get-PSRuleHelp/#-full","text":"Display additional information such as notes and links. Type : SwitchParameter Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Full"},{"location":"commands/PSRule/en-US/Get-PSRuleHelp/#-option","text":"Additional options that configure execution. A PSRuleOption can be created by using the New-PSRuleOption cmdlet. Alternatively a hashtable or path to YAML file can be specified with options. For more information on PSRule options see about_PSRule_Options. Type : PSRuleOption Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Option"},{"location":"commands/PSRule/en-US/Get-PSRuleHelp/#commonparameters","text":"This cmdlet supports the common parameters: -Debug, -ErrorAction, -ErrorVariable, -InformationAction, -InformationVariable, -OutVariable, -OutBuffer, -PipelineVariable, -Verbose, -WarningAction, and -WarningVariable. For more information, see about_CommonParameters .","title":"CommonParameters"},{"location":"commands/PSRule/en-US/Get-PSRuleHelp/#inputs","text":"","title":"INPUTS"},{"location":"commands/PSRule/en-US/Get-PSRuleHelp/#none","text":"","title":"None"},{"location":"commands/PSRule/en-US/Get-PSRuleHelp/#outputs","text":"","title":"OUTPUTS"},{"location":"commands/PSRule/en-US/Get-PSRuleHelp/#psrulerulesrulehelpinfo","text":"","title":"PSRule.Rules.RuleHelpInfo"},{"location":"commands/PSRule/en-US/Get-PSRuleHelp/#notes","text":"","title":"Notes"},{"location":"commands/PSRule/en-US/Get-PSRuleHelp/#related-links","text":"","title":"RELATED LINKS"},{"location":"commands/PSRule/en-US/Get-PSRuleTarget/","text":"Get-PSRuleTarget # Get a list of target objects. SYNTAX # Input (Default) # Get-PSRuleTarget [-Format <InputFormat>] [-Option <PSRuleOption>] [-ObjectPath <String>] -InputObject <PSObject> [-WhatIf] [-Confirm] [<CommonParameters>] InputPath # Get-PSRuleTarget -InputPath <String[]> [-Format <InputFormat>] [-Option <PSRuleOption>] [-ObjectPath <String>] [-WhatIf] [-Confirm] [<CommonParameters>] Description # Get a list of target objects from input. Examples # Example 1 # Get-PSRuleTarget -InputPath .\\ resources . json ; Get target objects from resources.json . PARAMETERS # -InputPath # Instead of processing objects from the pipeline, import objects file the specified file paths. Type : String[] Parameter Sets : InputPath Aliases : f Required : True Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -Format # Configures the input format for when a string is passed in as a target object. When the -InputObject parameter or pipeline input is used, strings are treated as plain text by default. Set this option to either Yaml , Json , Markdown , PowerShellData to have PSRule deserialize the object. When the -InputPath parameter is used with a file path or URL. If the Detect format is used, the file extension will be used to automatically detect the format. When -InputPath is not used, Detect is the same as None . See about_PSRule_Options for details. This parameter takes precedence over the Input.Format option if set. Type : InputFormat Parameter Sets : (All) Aliases : Accepted values : None, Yaml, Json, Markdown, PowerShellData, File, Detect Required : False Position : Named Default value : Detect Accept pipeline input : False Accept wildcard characters : False -Option # Additional options that configure execution. A PSRuleOption can be created by using the New-PSRuleOption cmdlet. Alternatively, a hashtable or path to YAML file can be specified with options. For more information on PSRule options see about_PSRule_Options. Type : PSRuleOption Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -ObjectPath # The name of a property to use instead of the pipeline object. If the property specified by ObjectPath is a collection or an array, then each item in evaluated separately. Type : String Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -InputObject # The pipeline object to process rules for. Type : PSObject Parameter Sets : Input Aliases : TargetObject Required : True Position : Named Default value : None Accept pipeline input : True (ByValue) Accept wildcard characters : False -WhatIf # Shows what would happen if the cmdlet runs. The cmdlet is not run. Type : SwitchParameter Parameter Sets : (All) Aliases : wi Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -Confirm # Prompts you for confirmation before running the cmdlet. Type : SwitchParameter Parameter Sets : (All) Aliases : cf Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False CommonParameters # This cmdlet supports the common parameters: -Debug, -ErrorAction, -ErrorVariable, -InformationAction, -InformationVariable, -OutVariable, -OutBuffer, -PipelineVariable, -Verbose, -WarningAction, and -WarningVariable. For more information, see about_CommonParameters . INPUTS # OUTPUTS # System.Management.Automation.PSObject # Notes # RELATED LINKS #","title":"Get-PSRuleTarget"},{"location":"commands/PSRule/en-US/Get-PSRuleTarget/#get-psruletarget","text":"Get a list of target objects.","title":"Get-PSRuleTarget"},{"location":"commands/PSRule/en-US/Get-PSRuleTarget/#syntax","text":"","title":"SYNTAX"},{"location":"commands/PSRule/en-US/Get-PSRuleTarget/#input-default","text":"Get-PSRuleTarget [-Format <InputFormat>] [-Option <PSRuleOption>] [-ObjectPath <String>] -InputObject <PSObject> [-WhatIf] [-Confirm] [<CommonParameters>]","title":"Input (Default)"},{"location":"commands/PSRule/en-US/Get-PSRuleTarget/#inputpath","text":"Get-PSRuleTarget -InputPath <String[]> [-Format <InputFormat>] [-Option <PSRuleOption>] [-ObjectPath <String>] [-WhatIf] [-Confirm] [<CommonParameters>]","title":"InputPath"},{"location":"commands/PSRule/en-US/Get-PSRuleTarget/#description","text":"Get a list of target objects from input.","title":"Description"},{"location":"commands/PSRule/en-US/Get-PSRuleTarget/#examples","text":"","title":"Examples"},{"location":"commands/PSRule/en-US/Get-PSRuleTarget/#example-1","text":"Get-PSRuleTarget -InputPath .\\ resources . json ; Get target objects from resources.json .","title":"Example 1"},{"location":"commands/PSRule/en-US/Get-PSRuleTarget/#parameters","text":"","title":"PARAMETERS"},{"location":"commands/PSRule/en-US/Get-PSRuleTarget/#-inputpath","text":"Instead of processing objects from the pipeline, import objects file the specified file paths. Type : String[] Parameter Sets : InputPath Aliases : f Required : True Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-InputPath"},{"location":"commands/PSRule/en-US/Get-PSRuleTarget/#-format","text":"Configures the input format for when a string is passed in as a target object. When the -InputObject parameter or pipeline input is used, strings are treated as plain text by default. Set this option to either Yaml , Json , Markdown , PowerShellData to have PSRule deserialize the object. When the -InputPath parameter is used with a file path or URL. If the Detect format is used, the file extension will be used to automatically detect the format. When -InputPath is not used, Detect is the same as None . See about_PSRule_Options for details. This parameter takes precedence over the Input.Format option if set. Type : InputFormat Parameter Sets : (All) Aliases : Accepted values : None, Yaml, Json, Markdown, PowerShellData, File, Detect Required : False Position : Named Default value : Detect Accept pipeline input : False Accept wildcard characters : False","title":"-Format"},{"location":"commands/PSRule/en-US/Get-PSRuleTarget/#-option","text":"Additional options that configure execution. A PSRuleOption can be created by using the New-PSRuleOption cmdlet. Alternatively, a hashtable or path to YAML file can be specified with options. For more information on PSRule options see about_PSRule_Options. Type : PSRuleOption Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Option"},{"location":"commands/PSRule/en-US/Get-PSRuleTarget/#-objectpath","text":"The name of a property to use instead of the pipeline object. If the property specified by ObjectPath is a collection or an array, then each item in evaluated separately. Type : String Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-ObjectPath"},{"location":"commands/PSRule/en-US/Get-PSRuleTarget/#-inputobject","text":"The pipeline object to process rules for. Type : PSObject Parameter Sets : Input Aliases : TargetObject Required : True Position : Named Default value : None Accept pipeline input : True (ByValue) Accept wildcard characters : False","title":"-InputObject"},{"location":"commands/PSRule/en-US/Get-PSRuleTarget/#-whatif","text":"Shows what would happen if the cmdlet runs. The cmdlet is not run. Type : SwitchParameter Parameter Sets : (All) Aliases : wi Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-WhatIf"},{"location":"commands/PSRule/en-US/Get-PSRuleTarget/#-confirm","text":"Prompts you for confirmation before running the cmdlet. Type : SwitchParameter Parameter Sets : (All) Aliases : cf Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Confirm"},{"location":"commands/PSRule/en-US/Get-PSRuleTarget/#commonparameters","text":"This cmdlet supports the common parameters: -Debug, -ErrorAction, -ErrorVariable, -InformationAction, -InformationVariable, -OutVariable, -OutBuffer, -PipelineVariable, -Verbose, -WarningAction, and -WarningVariable. For more information, see about_CommonParameters .","title":"CommonParameters"},{"location":"commands/PSRule/en-US/Get-PSRuleTarget/#inputs","text":"","title":"INPUTS"},{"location":"commands/PSRule/en-US/Get-PSRuleTarget/#outputs","text":"","title":"OUTPUTS"},{"location":"commands/PSRule/en-US/Get-PSRuleTarget/#systemmanagementautomationpsobject","text":"","title":"System.Management.Automation.PSObject"},{"location":"commands/PSRule/en-US/Get-PSRuleTarget/#notes","text":"","title":"Notes"},{"location":"commands/PSRule/en-US/Get-PSRuleTarget/#related-links","text":"","title":"RELATED LINKS"},{"location":"commands/PSRule/en-US/Invoke-PSRule/","text":"Invoke-PSRule # Evaluate objects against matching rules and output the results. SYNTAX # Input (Default) # Invoke-PSRule [-Module <String[]>] [-Outcome <RuleOutcome>] [-As <ResultFormat>] [-Format <InputFormat>] [-OutputPath <String>] [-OutputFormat <OutputFormat>] [-Baseline <BaselineOption>] [-Convention <String[]>] [[-Path] <String[]>] [-Name <String[]>] [-Tag <Hashtable>] [-Option <PSRuleOption>] [-ObjectPath <String>] [-TargetType <String[]>] [-Culture <String[]>] -InputObject <PSObject> [-WhatIf] [-Confirm] [<CommonParameters>] InputPath # Invoke-PSRule -InputPath <String[]> [-Module <String[]>] [-Outcome <RuleOutcome>] [-As <ResultFormat>] [-Format <InputFormat>] [-OutputPath <String>] [-OutputFormat <OutputFormat>] [-Baseline <BaselineOption>] [-Convention <String[]>] [[-Path] <String[]>] [-Name <String[]>] [-Tag <Hashtable>] [-Option <PSRuleOption>] [-ObjectPath <String>] [-TargetType <String[]>] [-Culture <String[]>] [-WhatIf] [-Confirm] [<CommonParameters>] Description # Evaluate objects against matching rules and output the results. Objects can be specified directly from the pipeline or provided from file. The commands Invoke-PSRule and Assert-PSRule provide similar functionality, as differ as follows: Invoke-PSRule writes results as structured objects Assert-PSRule writes results as a formatted string. Examples # Example 1 # @{ Name = 'Item 1' } | Invoke-PSRule ; Evaluate a simple hashtable on the pipeline against rules loaded from the current working path. Example 2 # # Define objects to validate $items = @(); $items += [PSCustomObject] @{ Name = 'Fridge' }; $items += [PSCustomObject] @{ Name = 'Apple' }; # Validate each item using rules saved in current working path $items | Invoke-PSRule ; TargetName: Fridge RuleName Outcome Recommendation -------- ------- -------------- isFruit Fail Fruit is only Apple, Orange and Pear TargetName: Apple RuleName Outcome Recommendation -------- ------- -------------- isFruit Pass Fruit is only Apple, Orange and Pear Evaluate an array of objects on the pipeline against rules loaded from the current working path. Example 3 # # Define objects to validate $items = @(); $items += [PSCustomObject] @{ Name = 'Fridge' }; $items += [PSCustomObject] @{ Name = 'Apple' }; # Validate each item and only return failing results $items | Invoke-PSRule -Outcome Fail ; TargetName: Fridge RuleName Outcome Recommendation -------- ------- -------------- isFruit Fail Fruit is only Apple, Orange and Pear Evaluate an array of objects, only failing object results are returned. Example 4 # # Define objects to validate $items = @(); $items += [PSCustomObject] @{ Name = 'Fridge' }; $items += [PSCustomObject] @{ Name = 'Apple' }; # Validate each item and show rule summary $items | Invoke-PSRule -As Summary ; RuleName Pass Fail Outcome -------- ---- ---- ------- isFruit 1 1 Fail Evaluate an array of objects. The results for each rule is returned as a summary. Outcome is represented as the worst outcome. PARAMETERS # -Name # The name of a specific rule to evaluate. If this parameter is not specified all rules in search paths will be evaluated. Type : String[] Parameter Sets : (All) Aliases : n Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -Path # One or more paths to search for rule definitions within. If no sources are specified by -Path , -Module , or options, the current working directory is used. Type : String[] Parameter Sets : (All) Aliases : p Required : False Position : 0 Default value : $PWD Accept pipeline input : False Accept wildcard characters : False -Outcome # Filter output to only show rule results with a specific outcome. Type : RuleOutcome Parameter Sets : (All) Aliases : Accepted values : Pass, Fail, Error, None, Processed, All Required : False Position : Named Default value : Pass, Fail, Error Accept pipeline input : False Accept wildcard characters : False -Tag # Only get rules with the specified tags set. If this parameter is not specified all rules in search paths will be returned. When more than one tag is used, all tags must match. Tags are not case sensitive. A tag value of * may be used to filter rules to any rule with the tag set, regardless of tag value. An array of tag values can be used to match a rule with either value. i.e. severity = important, critical matches rules with a category of either important or critical . Type : Hashtable Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -InputObject # The pipeline object to process rules for. Type : PSObject Parameter Sets : Input Aliases : TargetObject Required : True Position : Named Default value : None Accept pipeline input : True (ByValue) Accept wildcard characters : False -Option # Additional options that configure execution. A PSRuleOption can be created by using the New-PSRuleOption cmdlet. Alternatively, a hashtable or path to YAML file can be specified with options. For more information on PSRule options see about_PSRule_Options. Type : PSRuleOption Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -As # The type of results to produce. Detailed results are generated by default. The following result formats are available: Detail - Returns pass/ fail results for each rule per object. Summary - Returns summarized results for the rule and the worst outcome. Type : ResultFormat Parameter Sets : (All) Aliases : Accepted values : Detail, Summary Required : False Position : Named Default value : Detail Accept pipeline input : False Accept wildcard characters : False -Format # Configures the input format for when a string is passed in as a target object. When the -InputObject parameter or pipeline input is used, strings are treated as plain text by default. Set this option to either Yaml , Json , Markdown , PowerShellData to have PSRule deserialize the object. When the -InputPath parameter is used with a file path or URL. If the Detect format is used, the file extension will be used to automatically detect the format. When -InputPath is not used, Detect is the same as None . When this option is set to File PSRule scans the path and subdirectories specified by -InputPath . Files are treated as objects instead of being deserialized. Additional, PSRule uses the file extension as the object type. When files have no extension the whole file name is used. See about_PSRule_Options for details. This parameter takes precedence over the Input.Format option if set. Type : InputFormat Parameter Sets : (All) Aliases : Accepted values : None, Yaml, Json, Markdown, PowerShellData, File, Detect Required : False Position : Named Default value : Detect Accept pipeline input : False Accept wildcard characters : False -Baseline # Specifies an explicit baseline by name to use for evaluating rules. Baselines can contain filters and custom configuration that overrides the defaults. Type : BaselineOption Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -Convention # Specifies conventions by name to execute in the pipeline when processing objects. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -Culture # Specifies the culture to use for rule documentation and messages. By default, the culture of PowerShell is used. This option does not affect the culture used for the PSRule engine, which always uses the culture of PowerShell. The PowerShell cmdlet Get-Culture shows the current culture of PowerShell. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -ObjectPath # The name of a property to use instead of the pipeline object. If the property specified by ObjectPath is a collection or an array, then each item in evaluated separately. Type : String Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -TargetType # Filters input objects by TargetType. If specified, only objects with the specified TargetType are processed. Objects that do not match TargetType are ignored. If multiple values are specified, only one TargetType must match. This parameter is not case-sensitive. By default, all objects are processed. This parameter if set, overrides the Input.TargetType option. To change the field TargetType is bound to set the Binding.TargetType option. For details see the about_PSRule_Options help topic. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -Module # Search for rule definitions within a module. If no sources are specified by -Path , -Module , or options, the current working directory is used. Type : String[] Parameter Sets : (All) Aliases : m Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -InputPath # Instead of processing objects from the pipeline, import objects file the specified file paths. Type : String[] Parameter Sets : InputPath Aliases : f Required : True Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -OutputPath # Specifies the output file path to write results. Directories along the file path will automatically be created if they do not exist. Type : String Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -OutputFormat # Configures the format that output is presented in. The following format options are available: None - Output is presented as an object using PowerShell defaults. This is the default. Yaml - Output is serialized as YAML. Json - Output is serialized as JSON. Markdown - Output is serialized as Markdown. NUnit3 - Output is serialized as NUnit3 (XML). Csv - Output is serialized as a comma separated values (CSV). Wide - Output is presented using the wide table format, which includes reason and wraps columns. Type : OutputFormat Parameter Sets : (All) Aliases : o Accepted values : None, Yaml, Json, Markdown, NUnit3, Csv, Wide Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -Confirm # Prompts you for confirmation before running the cmdlet. Type : SwitchParameter Parameter Sets : (All) Aliases : cf Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -WhatIf # Shows what would happen if the cmdlet runs. The cmdlet is not run. Type : SwitchParameter Parameter Sets : (All) Aliases : wi Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False CommonParameters # This cmdlet supports the common parameters: -Debug, -ErrorAction, -ErrorVariable, -InformationAction, -InformationVariable, -OutVariable, -OutBuffer, -PipelineVariable, -Verbose, -WarningAction, and -WarningVariable. For more information, see about_CommonParameters . INPUTS # System.Management.Automation.PSObject # You can pipe any object to Invoke-PSRule . OUTPUTS # PSRule.Rules.RuleRecord # This is the default. PSRule.Rules.RuleSummaryRecord # When you use the -As Summary . Otherwise, it returns a RuleRecord object. Notes # RELATED LINKS # Get-PSRule Assert-PSRule Test-PSRuleTarget","title":"Invoke-PSRule"},{"location":"commands/PSRule/en-US/Invoke-PSRule/#invoke-psrule","text":"Evaluate objects against matching rules and output the results.","title":"Invoke-PSRule"},{"location":"commands/PSRule/en-US/Invoke-PSRule/#syntax","text":"","title":"SYNTAX"},{"location":"commands/PSRule/en-US/Invoke-PSRule/#input-default","text":"Invoke-PSRule [-Module <String[]>] [-Outcome <RuleOutcome>] [-As <ResultFormat>] [-Format <InputFormat>] [-OutputPath <String>] [-OutputFormat <OutputFormat>] [-Baseline <BaselineOption>] [-Convention <String[]>] [[-Path] <String[]>] [-Name <String[]>] [-Tag <Hashtable>] [-Option <PSRuleOption>] [-ObjectPath <String>] [-TargetType <String[]>] [-Culture <String[]>] -InputObject <PSObject> [-WhatIf] [-Confirm] [<CommonParameters>]","title":"Input (Default)"},{"location":"commands/PSRule/en-US/Invoke-PSRule/#inputpath","text":"Invoke-PSRule -InputPath <String[]> [-Module <String[]>] [-Outcome <RuleOutcome>] [-As <ResultFormat>] [-Format <InputFormat>] [-OutputPath <String>] [-OutputFormat <OutputFormat>] [-Baseline <BaselineOption>] [-Convention <String[]>] [[-Path] <String[]>] [-Name <String[]>] [-Tag <Hashtable>] [-Option <PSRuleOption>] [-ObjectPath <String>] [-TargetType <String[]>] [-Culture <String[]>] [-WhatIf] [-Confirm] [<CommonParameters>]","title":"InputPath"},{"location":"commands/PSRule/en-US/Invoke-PSRule/#description","text":"Evaluate objects against matching rules and output the results. Objects can be specified directly from the pipeline or provided from file. The commands Invoke-PSRule and Assert-PSRule provide similar functionality, as differ as follows: Invoke-PSRule writes results as structured objects Assert-PSRule writes results as a formatted string.","title":"Description"},{"location":"commands/PSRule/en-US/Invoke-PSRule/#examples","text":"","title":"Examples"},{"location":"commands/PSRule/en-US/Invoke-PSRule/#example-1","text":"@{ Name = 'Item 1' } | Invoke-PSRule ; Evaluate a simple hashtable on the pipeline against rules loaded from the current working path.","title":"Example 1"},{"location":"commands/PSRule/en-US/Invoke-PSRule/#example-2","text":"# Define objects to validate $items = @(); $items += [PSCustomObject] @{ Name = 'Fridge' }; $items += [PSCustomObject] @{ Name = 'Apple' }; # Validate each item using rules saved in current working path $items | Invoke-PSRule ; TargetName: Fridge RuleName Outcome Recommendation -------- ------- -------------- isFruit Fail Fruit is only Apple, Orange and Pear TargetName: Apple RuleName Outcome Recommendation -------- ------- -------------- isFruit Pass Fruit is only Apple, Orange and Pear Evaluate an array of objects on the pipeline against rules loaded from the current working path.","title":"Example 2"},{"location":"commands/PSRule/en-US/Invoke-PSRule/#example-3","text":"# Define objects to validate $items = @(); $items += [PSCustomObject] @{ Name = 'Fridge' }; $items += [PSCustomObject] @{ Name = 'Apple' }; # Validate each item and only return failing results $items | Invoke-PSRule -Outcome Fail ; TargetName: Fridge RuleName Outcome Recommendation -------- ------- -------------- isFruit Fail Fruit is only Apple, Orange and Pear Evaluate an array of objects, only failing object results are returned.","title":"Example 3"},{"location":"commands/PSRule/en-US/Invoke-PSRule/#example-4","text":"# Define objects to validate $items = @(); $items += [PSCustomObject] @{ Name = 'Fridge' }; $items += [PSCustomObject] @{ Name = 'Apple' }; # Validate each item and show rule summary $items | Invoke-PSRule -As Summary ; RuleName Pass Fail Outcome -------- ---- ---- ------- isFruit 1 1 Fail Evaluate an array of objects. The results for each rule is returned as a summary. Outcome is represented as the worst outcome.","title":"Example 4"},{"location":"commands/PSRule/en-US/Invoke-PSRule/#parameters","text":"","title":"PARAMETERS"},{"location":"commands/PSRule/en-US/Invoke-PSRule/#-name","text":"The name of a specific rule to evaluate. If this parameter is not specified all rules in search paths will be evaluated. Type : String[] Parameter Sets : (All) Aliases : n Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Name"},{"location":"commands/PSRule/en-US/Invoke-PSRule/#-path","text":"One or more paths to search for rule definitions within. If no sources are specified by -Path , -Module , or options, the current working directory is used. Type : String[] Parameter Sets : (All) Aliases : p Required : False Position : 0 Default value : $PWD Accept pipeline input : False Accept wildcard characters : False","title":"-Path"},{"location":"commands/PSRule/en-US/Invoke-PSRule/#-outcome","text":"Filter output to only show rule results with a specific outcome. Type : RuleOutcome Parameter Sets : (All) Aliases : Accepted values : Pass, Fail, Error, None, Processed, All Required : False Position : Named Default value : Pass, Fail, Error Accept pipeline input : False Accept wildcard characters : False","title":"-Outcome"},{"location":"commands/PSRule/en-US/Invoke-PSRule/#-tag","text":"Only get rules with the specified tags set. If this parameter is not specified all rules in search paths will be returned. When more than one tag is used, all tags must match. Tags are not case sensitive. A tag value of * may be used to filter rules to any rule with the tag set, regardless of tag value. An array of tag values can be used to match a rule with either value. i.e. severity = important, critical matches rules with a category of either important or critical . Type : Hashtable Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Tag"},{"location":"commands/PSRule/en-US/Invoke-PSRule/#-inputobject","text":"The pipeline object to process rules for. Type : PSObject Parameter Sets : Input Aliases : TargetObject Required : True Position : Named Default value : None Accept pipeline input : True (ByValue) Accept wildcard characters : False","title":"-InputObject"},{"location":"commands/PSRule/en-US/Invoke-PSRule/#-option","text":"Additional options that configure execution. A PSRuleOption can be created by using the New-PSRuleOption cmdlet. Alternatively, a hashtable or path to YAML file can be specified with options. For more information on PSRule options see about_PSRule_Options. Type : PSRuleOption Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Option"},{"location":"commands/PSRule/en-US/Invoke-PSRule/#-as","text":"The type of results to produce. Detailed results are generated by default. The following result formats are available: Detail - Returns pass/ fail results for each rule per object. Summary - Returns summarized results for the rule and the worst outcome. Type : ResultFormat Parameter Sets : (All) Aliases : Accepted values : Detail, Summary Required : False Position : Named Default value : Detail Accept pipeline input : False Accept wildcard characters : False","title":"-As"},{"location":"commands/PSRule/en-US/Invoke-PSRule/#-format","text":"Configures the input format for when a string is passed in as a target object. When the -InputObject parameter or pipeline input is used, strings are treated as plain text by default. Set this option to either Yaml , Json , Markdown , PowerShellData to have PSRule deserialize the object. When the -InputPath parameter is used with a file path or URL. If the Detect format is used, the file extension will be used to automatically detect the format. When -InputPath is not used, Detect is the same as None . When this option is set to File PSRule scans the path and subdirectories specified by -InputPath . Files are treated as objects instead of being deserialized. Additional, PSRule uses the file extension as the object type. When files have no extension the whole file name is used. See about_PSRule_Options for details. This parameter takes precedence over the Input.Format option if set. Type : InputFormat Parameter Sets : (All) Aliases : Accepted values : None, Yaml, Json, Markdown, PowerShellData, File, Detect Required : False Position : Named Default value : Detect Accept pipeline input : False Accept wildcard characters : False","title":"-Format"},{"location":"commands/PSRule/en-US/Invoke-PSRule/#-baseline","text":"Specifies an explicit baseline by name to use for evaluating rules. Baselines can contain filters and custom configuration that overrides the defaults. Type : BaselineOption Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Baseline"},{"location":"commands/PSRule/en-US/Invoke-PSRule/#-convention","text":"Specifies conventions by name to execute in the pipeline when processing objects. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Convention"},{"location":"commands/PSRule/en-US/Invoke-PSRule/#-culture","text":"Specifies the culture to use for rule documentation and messages. By default, the culture of PowerShell is used. This option does not affect the culture used for the PSRule engine, which always uses the culture of PowerShell. The PowerShell cmdlet Get-Culture shows the current culture of PowerShell. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Culture"},{"location":"commands/PSRule/en-US/Invoke-PSRule/#-objectpath","text":"The name of a property to use instead of the pipeline object. If the property specified by ObjectPath is a collection or an array, then each item in evaluated separately. Type : String Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-ObjectPath"},{"location":"commands/PSRule/en-US/Invoke-PSRule/#-targettype","text":"Filters input objects by TargetType. If specified, only objects with the specified TargetType are processed. Objects that do not match TargetType are ignored. If multiple values are specified, only one TargetType must match. This parameter is not case-sensitive. By default, all objects are processed. This parameter if set, overrides the Input.TargetType option. To change the field TargetType is bound to set the Binding.TargetType option. For details see the about_PSRule_Options help topic. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-TargetType"},{"location":"commands/PSRule/en-US/Invoke-PSRule/#-module","text":"Search for rule definitions within a module. If no sources are specified by -Path , -Module , or options, the current working directory is used. Type : String[] Parameter Sets : (All) Aliases : m Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Module"},{"location":"commands/PSRule/en-US/Invoke-PSRule/#-inputpath","text":"Instead of processing objects from the pipeline, import objects file the specified file paths. Type : String[] Parameter Sets : InputPath Aliases : f Required : True Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-InputPath"},{"location":"commands/PSRule/en-US/Invoke-PSRule/#-outputpath","text":"Specifies the output file path to write results. Directories along the file path will automatically be created if they do not exist. Type : String Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-OutputPath"},{"location":"commands/PSRule/en-US/Invoke-PSRule/#-outputformat","text":"Configures the format that output is presented in. The following format options are available: None - Output is presented as an object using PowerShell defaults. This is the default. Yaml - Output is serialized as YAML. Json - Output is serialized as JSON. Markdown - Output is serialized as Markdown. NUnit3 - Output is serialized as NUnit3 (XML). Csv - Output is serialized as a comma separated values (CSV). Wide - Output is presented using the wide table format, which includes reason and wraps columns. Type : OutputFormat Parameter Sets : (All) Aliases : o Accepted values : None, Yaml, Json, Markdown, NUnit3, Csv, Wide Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-OutputFormat"},{"location":"commands/PSRule/en-US/Invoke-PSRule/#-confirm","text":"Prompts you for confirmation before running the cmdlet. Type : SwitchParameter Parameter Sets : (All) Aliases : cf Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Confirm"},{"location":"commands/PSRule/en-US/Invoke-PSRule/#-whatif","text":"Shows what would happen if the cmdlet runs. The cmdlet is not run. Type : SwitchParameter Parameter Sets : (All) Aliases : wi Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-WhatIf"},{"location":"commands/PSRule/en-US/Invoke-PSRule/#commonparameters","text":"This cmdlet supports the common parameters: -Debug, -ErrorAction, -ErrorVariable, -InformationAction, -InformationVariable, -OutVariable, -OutBuffer, -PipelineVariable, -Verbose, -WarningAction, and -WarningVariable. For more information, see about_CommonParameters .","title":"CommonParameters"},{"location":"commands/PSRule/en-US/Invoke-PSRule/#inputs","text":"","title":"INPUTS"},{"location":"commands/PSRule/en-US/Invoke-PSRule/#systemmanagementautomationpsobject","text":"You can pipe any object to Invoke-PSRule .","title":"System.Management.Automation.PSObject"},{"location":"commands/PSRule/en-US/Invoke-PSRule/#outputs","text":"","title":"OUTPUTS"},{"location":"commands/PSRule/en-US/Invoke-PSRule/#psrulerulesrulerecord","text":"This is the default.","title":"PSRule.Rules.RuleRecord"},{"location":"commands/PSRule/en-US/Invoke-PSRule/#psrulerulesrulesummaryrecord","text":"When you use the -As Summary . Otherwise, it returns a RuleRecord object.","title":"PSRule.Rules.RuleSummaryRecord"},{"location":"commands/PSRule/en-US/Invoke-PSRule/#notes","text":"","title":"Notes"},{"location":"commands/PSRule/en-US/Invoke-PSRule/#related-links","text":"Get-PSRule Assert-PSRule Test-PSRuleTarget","title":"RELATED LINKS"},{"location":"commands/PSRule/en-US/New-PSRuleOption/","text":"New-PSRuleOption # Create options to configure PSRule execution. SYNTAX # FromPath (Default) # New-PSRuleOption [[-Path] <String>] [-Configuration <ConfigurationOption>] [-SuppressTargetName <SuppressionOption>] [-BindTargetName <BindTargetName[]>] [-BindTargetType <BindTargetName[]>] [-BindingIgnoreCase <Boolean>] [-BindingField <Hashtable>] [-BindingNameSeparator <String>] [-BindingPreferTargetInfo <Boolean>] [-TargetName <String[]>] [-TargetType <String[]>] [-BindingUseQualifiedName <Boolean>] [-Convention <String[]>] [-InconclusiveWarning <Boolean>] [-NotProcessedWarning <Boolean>] [-SuppressedRuleWarning <Boolean>] [-IncludeModule <String[]>] [-IncludePath <String[]>] [-Format <InputFormat>] [-InputIgnoreGitPath <Boolean>] [-InputIgnoreRepositoryCommon <Boolean>] [-ObjectPath <String>] [-InputTargetType <String[]>] [-InputPathIgnore <String[]>] [-LoggingLimitDebug <String[]>] [-LoggingLimitVerbose <String[]>] [-LoggingRuleFail <OutcomeLogStream>] [-LoggingRulePass <OutcomeLogStream>] [-OutputAs <ResultFormat>] [-OutputBanner <BannerFormat>] [-OutputCulture <String[]>] [-OutputEncoding <OutputEncoding>] [-OutputFooter <FooterFormat>] [-OutputFormat <OutputFormat>] [-OutputOutcome <RuleOutcome>] [-OutputPath <String>] [-OutputStyle <OutputStyle>] [-OutputJsonIndent <Int>] [-RuleIncludeLocal <Boolean>] [<CommonParameters>] FromOption # New-PSRuleOption [-Option] <PSRuleOption> [-Configuration <ConfigurationOption>] [-SuppressTargetName <SuppressionOption>] [-BindTargetName <BindTargetName[]>] [-BindTargetType <BindTargetName[]>] [-BindingIgnoreCase <Boolean>] [-BindingField <Hashtable>] [-BindingNameSeparator <String>] [-BindingPreferTargetInfo <Boolean>] [-TargetName <String[]>] [-TargetType <String[]>] [-BindingUseQualifiedName <Boolean>] [-Convention <String[]>] [-InconclusiveWarning <Boolean>] [-NotProcessedWarning <Boolean>] [-SuppressedRuleWarning <Boolean>] [-IncludeModule <String[]>] [-IncludePath <String[]>] [-Format <InputFormat>] [-InputIgnoreGitPath <Boolean>] [-InputIgnoreRepositoryCommon <Boolean>] [-ObjectPath <String>] [-InputTargetType <String[]>] [-InputPathIgnore <String[]>] [-LoggingLimitDebug <String[]>] [-LoggingLimitVerbose <String[]>] [-LoggingRuleFail <OutcomeLogStream>] [-LoggingRulePass <OutcomeLogStream>] [-OutputAs <ResultFormat>] [-OutputBanner <BannerFormat>] [-OutputCulture <String[]>] [-OutputEncoding <OutputEncoding>] [-OutputFooter <FooterFormat>] [-OutputFormat <OutputFormat>] [-OutputOutcome <RuleOutcome>] [-OutputPath <String>] [-OutputStyle <OutputStyle>] [-OutputJsonIndent <Int>] [-RuleIncludeLocal <Boolean>] [<CommonParameters>] FromDefault # New-PSRuleOption [-Default] [-Configuration <ConfigurationOption>] [-SuppressTargetName <SuppressionOption>] [-BindTargetName <BindTargetName[]>] [-BindTargetType <BindTargetName[]>] [-BindingIgnoreCase <Boolean>] [-BindingField <Hashtable>] [-BindingNameSeparator <String>] [-BindingPreferTargetInfo <Boolean>] [-TargetName <String[]>] [-TargetType <String[]>] [-BindingUseQualifiedName <Boolean>] [-Convention <String[]>] [-InconclusiveWarning <Boolean>] [-NotProcessedWarning <Boolean>] [-SuppressedRuleWarning <Boolean>] [-IncludeModule <String[]>] [-IncludePath <String[]>] [-Format <InputFormat>] [-InputIgnoreGitPath <Boolean>] [-InputIgnoreRepositoryCommon <Boolean>] [-ObjectPath <String>] [-InputTargetType <String[]>] [-InputPathIgnore <String[]>] [-LoggingLimitDebug <String[]>] [-LoggingLimitVerbose <String[]>] [-LoggingRuleFail <OutcomeLogStream>] [-LoggingRulePass <OutcomeLogStream>] [-OutputAs <ResultFormat>] [-OutputBanner <BannerFormat>] [-OutputCulture <String[]>] [-OutputEncoding <OutputEncoding>] [-OutputFooter <FooterFormat>] [-OutputFormat <OutputFormat>] [-OutputOutcome <RuleOutcome>] [-OutputPath <String>] [-OutputStyle <OutputStyle>] [-OutputJsonIndent <Int>] [-RuleIncludeLocal <Boolean>] [<CommonParameters>] Description # The New-PSRuleOption cmdlet creates an options object that can be passed to PSRule cmdlets to configure execution. Examples # Example 1 # $option = New-PSRuleOption -Option @{ 'execution.mode' = 'ConstrainedLanguage' } @{ Name = 'Item 1' } | Invoke-PSRule -Option $option Create an options object and run rules in constrained mode. Example 2 # $option = New-PSRuleOption -SuppressTargetName @{ 'storageAccounts.UseHttps' = 'TestObject1' , 'TestObject3' }; Create an options object that suppresses TestObject1 and TestObject3 for a rule named storageAccounts.UseHttps . Example 3 # # Create a custom function that returns a TargetName string $bindFn = { param ( $TargetObject ) $otherName = $TargetObject . PSObject . Properties [ 'OtherName' ]; if ( $otherName -eq $Null ) { return $Null } return $otherName . Value ; } # Specify the binding function script block code to execute $option = New-PSRuleOption -BindTargetName $bindFn ; Creates an options object that uses a custom function to bind the TargetName of an object. Example 4 # $option = New-PSRuleOption -Configuration @{ 'appServiceMinInstanceCount' = 2 }; Create an options object that sets the appServiceMinInstanceCount baseline configuration option to 2 . PARAMETERS # -Option # Additional options that configure execution. Option also accepts a hashtable to configure options. See about_PSRule_Options for more information. Type : PSRuleOption Parameter Sets : FromOption Aliases : Required : True Position : 0 Default value : None Accept pipeline input : False Accept wildcard characters : False -Path # The path to a YAML file containing options. By default the current working path ( $PWD ) is used. Either a directory or file path can be specified. When a directory is used, ps-rule.yaml will be used as the file name. If the -Path parameter is specified and the file does not exist, an exception will be generated. Type : String Parameter Sets : FromPath Aliases : Required : False Position : 1 Default value : $PWD Accept pipeline input : False Accept wildcard characters : False -Default # When specified, defaults are used for any options not overridden. Type : SwitchParameter Parameter Sets : FromDefault Aliases : Required : True Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -SuppressTargetName # Configures suppression for a list of objects by TargetName. SuppressTargetName also accepts a hashtable to configure rule suppression. See about_PSRule_Options for more information. Type : SuppressionOption Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -BindTargetName # Configures a custom function to use to bind TargetName of an object. See about_PSRule_Options for more information. Type : BindTargetName[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -Configuration # Configures a set of baseline configuration values that can be used in rule definitions instead of using hard coded values. Configuration also accepts a hashtable of configuration values as key/ value pairs. See about_PSRule_Options for more information. Type : ConfigurationOption Parameter Sets : (All) Aliases : BaselineConfiguration Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -BindTargetType # Configures a custom function to use to bind TargetType of an object. See about_PSRule_Options for more information. Type : BindTargetName[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -BindingIgnoreCase # Sets the option Binding.IgnoreCase . The option Binding.IgnoreCase determines if binding operations are case-sensitive or not. See about_PSRule_Options for more information. Type : Boolean Parameter Sets : (All) Aliases : Required : False Position : Named Default value : True Accept pipeline input : False Accept wildcard characters : False -BindingField # Sets the option Binding.Field . The option specified one or more custom field bindings. See about_PSRule_Options for more information. Type : Hashtable Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -BindingNameSeparator # Sets the option Binding.NameSeparator . This option specifies the separator to use for qualified names. See about_PSRule_Options for more information. Type : String Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -BindingPreferTargetInfo # Sets the option Binding.PreferTargetInfo . This option specifies if automatic binding is preferred over configured binding options. See about_PSRule_Options for more information. Type : Boolean Parameter Sets : (All) Aliases : Required : False Position : Named Default value : False Accept pipeline input : False Accept wildcard characters : False -Convention # Sets the Option.ConventionInclude option. This option specifies the name of conventions to execute in the pipeline when processing objects. See about_PSRule_Options for more information. Type : String[] Parameter Sets : (All) Aliases : ConventionInclude Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -TargetName # Sets the option Binding.TargetName . This option specifies one or more properties of TargetObject to use to bind TargetName to. See about_PSRule_Options for more information. Type : String[] Parameter Sets : (All) Aliases : BindingTargetName Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -TargetType # Sets the option Binding.TargetType . This option specifies one or more properties of TargetObject to use to bind TargetType to. See about_PSRule_Options for more information. Type : String[] Parameter Sets : (All) Aliases : BindingTargetType Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -BindingUseQualifiedName # Sets the option Binding.UseQualifiedName . This option specifies is qualified target names are used. See about_PSRule_Options for more information. Type : Boolean Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -InconclusiveWarning # Sets the option Execution.InconclusiveWarning . The Execution.InconclusiveWarning option determines if a warning is generated when the outcome of a rule is inconclusive. See about_PSRule_Options for more information. Type : Boolean Parameter Sets : (All) Aliases : ExecutionInconclusiveWarning Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -NotProcessedWarning # Sets the option Execution.NotProcessedWarning . The Execution.NotProcessedWarning option determines if a warning is generated when an object is not processed by any rule. See about_PSRule_Options for more information. Type : Boolean Parameter Sets : (All) Aliases : ExecutionNotProcessedWarning Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -SuppressedRuleWarning # Sets the Execution.SuppressedRuleWarning option. The Execution.SuppressedRuleWarning option determines if a warning is generated when a rule is suppressed. See about_PSRule_Options for more information. Type : Boolean Parameter Sets : (All) Aliases : ExecutionSuppressedRuleWarning Required : False Position : Named Default value : True Accept pipeline input : False Accept wildcard characters : False -IncludeModule # Sets the Include.Module option to include additional module sources. See about_PSRule_Options for more information. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -IncludePath # Sets the Include.Path option to include additional standalone sources. See about_PSRule_Options for more information. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -Format # Sets the Input.Format option to configure the input format for when a string is passed in as a target object. See about_PSRule_Options for more information. Type : InputFormat Parameter Sets : (All) Aliases : InputFormat Accepted values : None, Yaml, Json, Markdown, PowerShellData, File, Detect Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -InputIgnoreGitPath # Sets the Input.IgnoreGitPath option to determine if files within the .git path are ignored. See about_PSRule_Options for more information. Type : Boolean Parameter Sets : (All) Aliases : Required : False Position : Named Default value : True Accept pipeline input : False Accept wildcard characters : False -InputIgnoreRepositoryCommon # Sets the Input.IgnoreRepositoryCommon option to determine if files common repository files are ignored. See about_PSRule_Options for more information. Type : Boolean Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -ObjectPath # Sets the Input.ObjectPath option to use an object path to use instead of the pipeline object. See about_PSRule_Options for more information. Type : String Parameter Sets : (All) Aliases : InputObjectPath Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -InputPathIgnore # Sets the Input.PathIgnore option. If specified, files that match the path spec will not be processed. See about_PSRule_Options for more information. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -InputTargetType # Sets the Input.TargetType option to only process objects with the specified TargetType. See about_PSRule_Options for more information. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -LoggingLimitDebug # Sets the Logging.LimitDebug option to limit debug messages to a list of named debug scopes. See about_PSRule_Options for more information. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -LoggingLimitVerbose # Sets the Logging.LimitVerbose option to limit verbose messages to a list of named verbose scopes. See about_PSRule_Options for more information. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -LoggingRuleFail # Sets the Logging.RuleFail option to generate an informational message for each rule fail. See about_PSRule_Options for more information. Type : OutcomeLogStream Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -LoggingRulePass # Sets the Logging.RulePass option to generate an informational message for each rule pass. See about_PSRule_Options for more information. Type : OutcomeLogStream Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -OutputAs # Sets the option Output.As . The Output.As option configures the type of results to produce, either detail or summary. Type : ResultFormat Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -OutputBanner # Sets the option Output.Banner . The Output.Banner option configure information displayed with PSRule banner. This option is only applicable when using Assert-PSRule cmdlet. Type : BannerFormat Parameter Sets : (All) Aliases : Required : False Position : Named Default value : Default Accept pipeline input : False Accept wildcard characters : False -OutputCulture # Sets the option Output.Culture . The Output.Culture option configures the culture used to generated output. When multiple cultures are specified, the first matching culture will be used. See about_PSRule_Options for more information. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -OutputEncoding # Sets the option Output.Encoding . The Output.Encoding option configured the encoding used to write results to file. Type : OutputEncoding Parameter Sets : (All) Aliases : Accepted values : Default, UTF8, UTF7, Unicode, UTF32, ASCII Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -OutputFooter # Sets the option Output.Footer . The Output.Footer option configures the information displayed for PSRule footer. See about_PSRule_Options for more information. Type : FooterFormat Parameter Sets : (All) Aliases : Required : False Position : Named Default value : Default Accept pipeline input : False Accept wildcard characters : False -OutputFormat # Sets the option Output.Format . The Output.Format option configures the format that results will be presented in. See about_PSRule_Options for more information. Type : OutputFormat Parameter Sets : (All) Aliases : Accepted values : None, Yaml, Json, Markdown, NUnit3, Csv, Wide Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -OutputOutcome # Sets the Output.Outcome option. This option can be set to include or exclude output results. See about_PSRule_Options for more information. Type : RuleOutcome Parameter Sets : (All) Aliases : Outcome Required : False Position : Named Default value : Processed Accept pipeline input : False Accept wildcard characters : False -OutputPath # Sets the option Output.Path . The Output.Path option configures an output file path to write results. Type : String Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -OutputStyle # Sets the option Option.Style . The Output.Style option configures the style that results will be presented in. This option only applies to Assert-PSRule . Type : OutputStyle Parameter Sets : (All) Aliases : Accepted values : Client, Plain, AzurePipelines, GitHubActions Required : False Position : Named Default value : Client Accept pipeline input : False Accept wildcard characters : False -OutputJsonIndent # Sets the option Output.JsonIndent . The Output.JsonIndent option configures indentation for JSON output. This option only applies to Get-PSRule , Invoke-PSRule and Assert-PSRule cmdlets. Type : Int Parameter Sets : (All) Aliases : JsonIndent Accepted values : 0, 1, 2, 3, 4 Required : False Position : Named Default value : 0 Accept pipeline input : False Accept wildcard characters : False -RuleIncludeLocal # Sets the option Rule.IncludeLocal . The Rule.IncludeLocal option configures if local rules are automatically included. See about_PSRule_Options for more information. Type : Boolean Parameter Sets : (All) Aliases : Required : False Position : Named Default value : False Accept pipeline input : False Accept wildcard characters : False CommonParameters # This cmdlet supports the common parameters: -Debug, -ErrorAction, -ErrorVariable, -InformationAction, -InformationVariable, -OutVariable, -OutBuffer, -PipelineVariable, -Verbose, -WarningAction, and -WarningVariable. For more information, see about_CommonParameters . INPUTS # None # OUTPUTS # PSRule.Configuration.PSRuleOption # Notes # RELATED LINKS # Invoke-PSRule Set-PSRuleOption","title":"New-PSRuleOption"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#new-psruleoption","text":"Create options to configure PSRule execution.","title":"New-PSRuleOption"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#syntax","text":"","title":"SYNTAX"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#frompath-default","text":"New-PSRuleOption [[-Path] <String>] [-Configuration <ConfigurationOption>] [-SuppressTargetName <SuppressionOption>] [-BindTargetName <BindTargetName[]>] [-BindTargetType <BindTargetName[]>] [-BindingIgnoreCase <Boolean>] [-BindingField <Hashtable>] [-BindingNameSeparator <String>] [-BindingPreferTargetInfo <Boolean>] [-TargetName <String[]>] [-TargetType <String[]>] [-BindingUseQualifiedName <Boolean>] [-Convention <String[]>] [-InconclusiveWarning <Boolean>] [-NotProcessedWarning <Boolean>] [-SuppressedRuleWarning <Boolean>] [-IncludeModule <String[]>] [-IncludePath <String[]>] [-Format <InputFormat>] [-InputIgnoreGitPath <Boolean>] [-InputIgnoreRepositoryCommon <Boolean>] [-ObjectPath <String>] [-InputTargetType <String[]>] [-InputPathIgnore <String[]>] [-LoggingLimitDebug <String[]>] [-LoggingLimitVerbose <String[]>] [-LoggingRuleFail <OutcomeLogStream>] [-LoggingRulePass <OutcomeLogStream>] [-OutputAs <ResultFormat>] [-OutputBanner <BannerFormat>] [-OutputCulture <String[]>] [-OutputEncoding <OutputEncoding>] [-OutputFooter <FooterFormat>] [-OutputFormat <OutputFormat>] [-OutputOutcome <RuleOutcome>] [-OutputPath <String>] [-OutputStyle <OutputStyle>] [-OutputJsonIndent <Int>] [-RuleIncludeLocal <Boolean>] [<CommonParameters>]","title":"FromPath (Default)"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#fromoption","text":"New-PSRuleOption [-Option] <PSRuleOption> [-Configuration <ConfigurationOption>] [-SuppressTargetName <SuppressionOption>] [-BindTargetName <BindTargetName[]>] [-BindTargetType <BindTargetName[]>] [-BindingIgnoreCase <Boolean>] [-BindingField <Hashtable>] [-BindingNameSeparator <String>] [-BindingPreferTargetInfo <Boolean>] [-TargetName <String[]>] [-TargetType <String[]>] [-BindingUseQualifiedName <Boolean>] [-Convention <String[]>] [-InconclusiveWarning <Boolean>] [-NotProcessedWarning <Boolean>] [-SuppressedRuleWarning <Boolean>] [-IncludeModule <String[]>] [-IncludePath <String[]>] [-Format <InputFormat>] [-InputIgnoreGitPath <Boolean>] [-InputIgnoreRepositoryCommon <Boolean>] [-ObjectPath <String>] [-InputTargetType <String[]>] [-InputPathIgnore <String[]>] [-LoggingLimitDebug <String[]>] [-LoggingLimitVerbose <String[]>] [-LoggingRuleFail <OutcomeLogStream>] [-LoggingRulePass <OutcomeLogStream>] [-OutputAs <ResultFormat>] [-OutputBanner <BannerFormat>] [-OutputCulture <String[]>] [-OutputEncoding <OutputEncoding>] [-OutputFooter <FooterFormat>] [-OutputFormat <OutputFormat>] [-OutputOutcome <RuleOutcome>] [-OutputPath <String>] [-OutputStyle <OutputStyle>] [-OutputJsonIndent <Int>] [-RuleIncludeLocal <Boolean>] [<CommonParameters>]","title":"FromOption"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#fromdefault","text":"New-PSRuleOption [-Default] [-Configuration <ConfigurationOption>] [-SuppressTargetName <SuppressionOption>] [-BindTargetName <BindTargetName[]>] [-BindTargetType <BindTargetName[]>] [-BindingIgnoreCase <Boolean>] [-BindingField <Hashtable>] [-BindingNameSeparator <String>] [-BindingPreferTargetInfo <Boolean>] [-TargetName <String[]>] [-TargetType <String[]>] [-BindingUseQualifiedName <Boolean>] [-Convention <String[]>] [-InconclusiveWarning <Boolean>] [-NotProcessedWarning <Boolean>] [-SuppressedRuleWarning <Boolean>] [-IncludeModule <String[]>] [-IncludePath <String[]>] [-Format <InputFormat>] [-InputIgnoreGitPath <Boolean>] [-InputIgnoreRepositoryCommon <Boolean>] [-ObjectPath <String>] [-InputTargetType <String[]>] [-InputPathIgnore <String[]>] [-LoggingLimitDebug <String[]>] [-LoggingLimitVerbose <String[]>] [-LoggingRuleFail <OutcomeLogStream>] [-LoggingRulePass <OutcomeLogStream>] [-OutputAs <ResultFormat>] [-OutputBanner <BannerFormat>] [-OutputCulture <String[]>] [-OutputEncoding <OutputEncoding>] [-OutputFooter <FooterFormat>] [-OutputFormat <OutputFormat>] [-OutputOutcome <RuleOutcome>] [-OutputPath <String>] [-OutputStyle <OutputStyle>] [-OutputJsonIndent <Int>] [-RuleIncludeLocal <Boolean>] [<CommonParameters>]","title":"FromDefault"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#description","text":"The New-PSRuleOption cmdlet creates an options object that can be passed to PSRule cmdlets to configure execution.","title":"Description"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#examples","text":"","title":"Examples"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#example-1","text":"$option = New-PSRuleOption -Option @{ 'execution.mode' = 'ConstrainedLanguage' } @{ Name = 'Item 1' } | Invoke-PSRule -Option $option Create an options object and run rules in constrained mode.","title":"Example 1"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#example-2","text":"$option = New-PSRuleOption -SuppressTargetName @{ 'storageAccounts.UseHttps' = 'TestObject1' , 'TestObject3' }; Create an options object that suppresses TestObject1 and TestObject3 for a rule named storageAccounts.UseHttps .","title":"Example 2"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#example-3","text":"# Create a custom function that returns a TargetName string $bindFn = { param ( $TargetObject ) $otherName = $TargetObject . PSObject . Properties [ 'OtherName' ]; if ( $otherName -eq $Null ) { return $Null } return $otherName . Value ; } # Specify the binding function script block code to execute $option = New-PSRuleOption -BindTargetName $bindFn ; Creates an options object that uses a custom function to bind the TargetName of an object.","title":"Example 3"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#example-4","text":"$option = New-PSRuleOption -Configuration @{ 'appServiceMinInstanceCount' = 2 }; Create an options object that sets the appServiceMinInstanceCount baseline configuration option to 2 .","title":"Example 4"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#parameters","text":"","title":"PARAMETERS"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-option","text":"Additional options that configure execution. Option also accepts a hashtable to configure options. See about_PSRule_Options for more information. Type : PSRuleOption Parameter Sets : FromOption Aliases : Required : True Position : 0 Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Option"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-path","text":"The path to a YAML file containing options. By default the current working path ( $PWD ) is used. Either a directory or file path can be specified. When a directory is used, ps-rule.yaml will be used as the file name. If the -Path parameter is specified and the file does not exist, an exception will be generated. Type : String Parameter Sets : FromPath Aliases : Required : False Position : 1 Default value : $PWD Accept pipeline input : False Accept wildcard characters : False","title":"-Path"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-default","text":"When specified, defaults are used for any options not overridden. Type : SwitchParameter Parameter Sets : FromDefault Aliases : Required : True Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Default"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-suppresstargetname","text":"Configures suppression for a list of objects by TargetName. SuppressTargetName also accepts a hashtable to configure rule suppression. See about_PSRule_Options for more information. Type : SuppressionOption Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-SuppressTargetName"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-bindtargetname","text":"Configures a custom function to use to bind TargetName of an object. See about_PSRule_Options for more information. Type : BindTargetName[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-BindTargetName"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-configuration","text":"Configures a set of baseline configuration values that can be used in rule definitions instead of using hard coded values. Configuration also accepts a hashtable of configuration values as key/ value pairs. See about_PSRule_Options for more information. Type : ConfigurationOption Parameter Sets : (All) Aliases : BaselineConfiguration Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Configuration"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-bindtargettype","text":"Configures a custom function to use to bind TargetType of an object. See about_PSRule_Options for more information. Type : BindTargetName[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-BindTargetType"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-bindingignorecase","text":"Sets the option Binding.IgnoreCase . The option Binding.IgnoreCase determines if binding operations are case-sensitive or not. See about_PSRule_Options for more information. Type : Boolean Parameter Sets : (All) Aliases : Required : False Position : Named Default value : True Accept pipeline input : False Accept wildcard characters : False","title":"-BindingIgnoreCase"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-bindingfield","text":"Sets the option Binding.Field . The option specified one or more custom field bindings. See about_PSRule_Options for more information. Type : Hashtable Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-BindingField"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-bindingnameseparator","text":"Sets the option Binding.NameSeparator . This option specifies the separator to use for qualified names. See about_PSRule_Options for more information. Type : String Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-BindingNameSeparator"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-bindingprefertargetinfo","text":"Sets the option Binding.PreferTargetInfo . This option specifies if automatic binding is preferred over configured binding options. See about_PSRule_Options for more information. Type : Boolean Parameter Sets : (All) Aliases : Required : False Position : Named Default value : False Accept pipeline input : False Accept wildcard characters : False","title":"-BindingPreferTargetInfo"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-convention","text":"Sets the Option.ConventionInclude option. This option specifies the name of conventions to execute in the pipeline when processing objects. See about_PSRule_Options for more information. Type : String[] Parameter Sets : (All) Aliases : ConventionInclude Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Convention"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-targetname","text":"Sets the option Binding.TargetName . This option specifies one or more properties of TargetObject to use to bind TargetName to. See about_PSRule_Options for more information. Type : String[] Parameter Sets : (All) Aliases : BindingTargetName Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-TargetName"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-targettype","text":"Sets the option Binding.TargetType . This option specifies one or more properties of TargetObject to use to bind TargetType to. See about_PSRule_Options for more information. Type : String[] Parameter Sets : (All) Aliases : BindingTargetType Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-TargetType"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-bindingusequalifiedname","text":"Sets the option Binding.UseQualifiedName . This option specifies is qualified target names are used. See about_PSRule_Options for more information. Type : Boolean Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-BindingUseQualifiedName"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-inconclusivewarning","text":"Sets the option Execution.InconclusiveWarning . The Execution.InconclusiveWarning option determines if a warning is generated when the outcome of a rule is inconclusive. See about_PSRule_Options for more information. Type : Boolean Parameter Sets : (All) Aliases : ExecutionInconclusiveWarning Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-InconclusiveWarning"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-notprocessedwarning","text":"Sets the option Execution.NotProcessedWarning . The Execution.NotProcessedWarning option determines if a warning is generated when an object is not processed by any rule. See about_PSRule_Options for more information. Type : Boolean Parameter Sets : (All) Aliases : ExecutionNotProcessedWarning Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-NotProcessedWarning"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-suppressedrulewarning","text":"Sets the Execution.SuppressedRuleWarning option. The Execution.SuppressedRuleWarning option determines if a warning is generated when a rule is suppressed. See about_PSRule_Options for more information. Type : Boolean Parameter Sets : (All) Aliases : ExecutionSuppressedRuleWarning Required : False Position : Named Default value : True Accept pipeline input : False Accept wildcard characters : False","title":"-SuppressedRuleWarning"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-includemodule","text":"Sets the Include.Module option to include additional module sources. See about_PSRule_Options for more information. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-IncludeModule"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-includepath","text":"Sets the Include.Path option to include additional standalone sources. See about_PSRule_Options for more information. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-IncludePath"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-format","text":"Sets the Input.Format option to configure the input format for when a string is passed in as a target object. See about_PSRule_Options for more information. Type : InputFormat Parameter Sets : (All) Aliases : InputFormat Accepted values : None, Yaml, Json, Markdown, PowerShellData, File, Detect Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Format"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-inputignoregitpath","text":"Sets the Input.IgnoreGitPath option to determine if files within the .git path are ignored. See about_PSRule_Options for more information. Type : Boolean Parameter Sets : (All) Aliases : Required : False Position : Named Default value : True Accept pipeline input : False Accept wildcard characters : False","title":"-InputIgnoreGitPath"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-inputignorerepositorycommon","text":"Sets the Input.IgnoreRepositoryCommon option to determine if files common repository files are ignored. See about_PSRule_Options for more information. Type : Boolean Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-InputIgnoreRepositoryCommon"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-objectpath","text":"Sets the Input.ObjectPath option to use an object path to use instead of the pipeline object. See about_PSRule_Options for more information. Type : String Parameter Sets : (All) Aliases : InputObjectPath Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-ObjectPath"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-inputpathignore","text":"Sets the Input.PathIgnore option. If specified, files that match the path spec will not be processed. See about_PSRule_Options for more information. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-InputPathIgnore"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-inputtargettype","text":"Sets the Input.TargetType option to only process objects with the specified TargetType. See about_PSRule_Options for more information. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-InputTargetType"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-logginglimitdebug","text":"Sets the Logging.LimitDebug option to limit debug messages to a list of named debug scopes. See about_PSRule_Options for more information. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-LoggingLimitDebug"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-logginglimitverbose","text":"Sets the Logging.LimitVerbose option to limit verbose messages to a list of named verbose scopes. See about_PSRule_Options for more information. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-LoggingLimitVerbose"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-loggingrulefail","text":"Sets the Logging.RuleFail option to generate an informational message for each rule fail. See about_PSRule_Options for more information. Type : OutcomeLogStream Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-LoggingRuleFail"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-loggingrulepass","text":"Sets the Logging.RulePass option to generate an informational message for each rule pass. See about_PSRule_Options for more information. Type : OutcomeLogStream Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-LoggingRulePass"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-outputas","text":"Sets the option Output.As . The Output.As option configures the type of results to produce, either detail or summary. Type : ResultFormat Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-OutputAs"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-outputbanner","text":"Sets the option Output.Banner . The Output.Banner option configure information displayed with PSRule banner. This option is only applicable when using Assert-PSRule cmdlet. Type : BannerFormat Parameter Sets : (All) Aliases : Required : False Position : Named Default value : Default Accept pipeline input : False Accept wildcard characters : False","title":"-OutputBanner"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-outputculture","text":"Sets the option Output.Culture . The Output.Culture option configures the culture used to generated output. When multiple cultures are specified, the first matching culture will be used. See about_PSRule_Options for more information. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-OutputCulture"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-outputencoding","text":"Sets the option Output.Encoding . The Output.Encoding option configured the encoding used to write results to file. Type : OutputEncoding Parameter Sets : (All) Aliases : Accepted values : Default, UTF8, UTF7, Unicode, UTF32, ASCII Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-OutputEncoding"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-outputfooter","text":"Sets the option Output.Footer . The Output.Footer option configures the information displayed for PSRule footer. See about_PSRule_Options for more information. Type : FooterFormat Parameter Sets : (All) Aliases : Required : False Position : Named Default value : Default Accept pipeline input : False Accept wildcard characters : False","title":"-OutputFooter"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-outputformat","text":"Sets the option Output.Format . The Output.Format option configures the format that results will be presented in. See about_PSRule_Options for more information. Type : OutputFormat Parameter Sets : (All) Aliases : Accepted values : None, Yaml, Json, Markdown, NUnit3, Csv, Wide Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-OutputFormat"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-outputoutcome","text":"Sets the Output.Outcome option. This option can be set to include or exclude output results. See about_PSRule_Options for more information. Type : RuleOutcome Parameter Sets : (All) Aliases : Outcome Required : False Position : Named Default value : Processed Accept pipeline input : False Accept wildcard characters : False","title":"-OutputOutcome"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-outputpath","text":"Sets the option Output.Path . The Output.Path option configures an output file path to write results. Type : String Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-OutputPath"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-outputstyle","text":"Sets the option Option.Style . The Output.Style option configures the style that results will be presented in. This option only applies to Assert-PSRule . Type : OutputStyle Parameter Sets : (All) Aliases : Accepted values : Client, Plain, AzurePipelines, GitHubActions Required : False Position : Named Default value : Client Accept pipeline input : False Accept wildcard characters : False","title":"-OutputStyle"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-outputjsonindent","text":"Sets the option Output.JsonIndent . The Output.JsonIndent option configures indentation for JSON output. This option only applies to Get-PSRule , Invoke-PSRule and Assert-PSRule cmdlets. Type : Int Parameter Sets : (All) Aliases : JsonIndent Accepted values : 0, 1, 2, 3, 4 Required : False Position : Named Default value : 0 Accept pipeline input : False Accept wildcard characters : False","title":"-OutputJsonIndent"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#-ruleincludelocal","text":"Sets the option Rule.IncludeLocal . The Rule.IncludeLocal option configures if local rules are automatically included. See about_PSRule_Options for more information. Type : Boolean Parameter Sets : (All) Aliases : Required : False Position : Named Default value : False Accept pipeline input : False Accept wildcard characters : False","title":"-RuleIncludeLocal"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#commonparameters","text":"This cmdlet supports the common parameters: -Debug, -ErrorAction, -ErrorVariable, -InformationAction, -InformationVariable, -OutVariable, -OutBuffer, -PipelineVariable, -Verbose, -WarningAction, and -WarningVariable. For more information, see about_CommonParameters .","title":"CommonParameters"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#inputs","text":"","title":"INPUTS"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#none","text":"","title":"None"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#outputs","text":"","title":"OUTPUTS"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#psruleconfigurationpsruleoption","text":"","title":"PSRule.Configuration.PSRuleOption"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#notes","text":"","title":"Notes"},{"location":"commands/PSRule/en-US/New-PSRuleOption/#related-links","text":"Invoke-PSRule Set-PSRuleOption","title":"RELATED LINKS"},{"location":"commands/PSRule/en-US/PSRule/","text":"PSRule Module # Description # A PowerShell rules engine. PSRule Cmdlets # Assert-PSRule # Evaluate objects against matching rules and assert any failures. Export-PSRuleBaseline # Exports a list of baselines to a file. Get-PSRule # Get a list of matching rule definitions within the search path. Get-PSRuleBaseline # Get a list of matching baselines within the search path. Get-PSRuleHelp # Get documentation for a rule. Get-PSRuleTarget # Get a list of target object. Invoke-PSRule # Evaluate objects against matching rules and output the results. New-PSRuleOption # Create options to configure PSRule execution. Set-PSRuleOption # Set options to configure PSRule execution. Test-PSRuleTarget # Evaluate pipeline objects against matching rules.","title":"PSRule Module"},{"location":"commands/PSRule/en-US/PSRule/#psrule-module","text":"","title":"PSRule Module"},{"location":"commands/PSRule/en-US/PSRule/#description","text":"A PowerShell rules engine.","title":"Description"},{"location":"commands/PSRule/en-US/PSRule/#psrule-cmdlets","text":"","title":"PSRule Cmdlets"},{"location":"commands/PSRule/en-US/PSRule/#assert-psrule","text":"Evaluate objects against matching rules and assert any failures.","title":"Assert-PSRule"},{"location":"commands/PSRule/en-US/PSRule/#export-psrulebaseline","text":"Exports a list of baselines to a file.","title":"Export-PSRuleBaseline"},{"location":"commands/PSRule/en-US/PSRule/#get-psrule","text":"Get a list of matching rule definitions within the search path.","title":"Get-PSRule"},{"location":"commands/PSRule/en-US/PSRule/#get-psrulebaseline","text":"Get a list of matching baselines within the search path.","title":"Get-PSRuleBaseline"},{"location":"commands/PSRule/en-US/PSRule/#get-psrulehelp","text":"Get documentation for a rule.","title":"Get-PSRuleHelp"},{"location":"commands/PSRule/en-US/PSRule/#get-psruletarget","text":"Get a list of target object.","title":"Get-PSRuleTarget"},{"location":"commands/PSRule/en-US/PSRule/#invoke-psrule","text":"Evaluate objects against matching rules and output the results.","title":"Invoke-PSRule"},{"location":"commands/PSRule/en-US/PSRule/#new-psruleoption","text":"Create options to configure PSRule execution.","title":"New-PSRuleOption"},{"location":"commands/PSRule/en-US/PSRule/#set-psruleoption","text":"Set options to configure PSRule execution.","title":"Set-PSRuleOption"},{"location":"commands/PSRule/en-US/PSRule/#test-psruletarget","text":"Evaluate pipeline objects against matching rules.","title":"Test-PSRuleTarget"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/","text":"Set-PSRuleOption # Sets options that configure PSRule execution. SYNTAX # Set-PSRuleOption [[-Path] <String>] [-Option <PSRuleOption>] [-PassThru] [-Force] [-AllowClobber] [-BindingIgnoreCase <Boolean>] [-BindingField <Hashtable>] [-BindingNameSeparator <String>] [-BindingPreferTargetInfo <Boolean>] [-TargetName <String[]>] [-TargetType <String[]>] [-BindingUseQualifiedName <Boolean>] [-Convention <String[]>] [-InconclusiveWarning <Boolean>] [-NotProcessedWarning <Boolean>] [-SuppressedRuleWarning <Boolean>] [-IncludeModule <String[]>] [-IncludePath <String[]>] [-Format <InputFormat>] [-InputIgnoreGitPath <Boolean>] [-InputIgnoreRepositoryCommon <Boolean>] [-ObjectPath <String>] [-InputPathIgnore <String[]>] [-InputTargetType <String[]>] [-LoggingLimitDebug <String[]>] [-LoggingLimitVerbose <String[]>] [-LoggingRuleFail <OutcomeLogStream>] [-LoggingRulePass <OutcomeLogStream>] [-OutputAs <ResultFormat>] [-OutputBanner <BannerFormat>] [-OutputCulture <String[]>] [-OutputEncoding <OutputEncoding>] [-OutputFooter <FooterFormat>] [-OutputFormat <OutputFormat>] [-OutputOutcome <RuleOutcome>] [-OutputPath <String>] [-OutputStyle <OutputStyle>] [-OutputJsonIndent <Int>] [-RuleIncludeLocal <Boolean>] [-WhatIf] [-Confirm] [<CommonParameters>] Description # Sets options that configure PSRule execution. Examples # Example 1 # PS C :\\> Set-PSRuleOption -OutputFormat Yaml ; Sets the Output.Format to Yaml for ps-rule.yaml in the current working path. If the ps-rule.yaml file exists, it is merged with the existing file and overwritten. If the file does not exist, a new file is created. Example 2 # PS C :\\> Set-PSRuleOption -OutputFormat Yaml -Path .\\ project-options . yaml ; Sets the Output.Format to Yaml for project-options.yaml in the current working path. If the project-options.yaml file exists, it is merged with the existing file and overwritten. If the file does not exist, a new file is created. PARAMETERS # -Path # The path to a YAML file where options will be set. By default the current working path ( $PWD ) is used. Either a directory or file path can be specified. When a directory is used, ps-rule.yaml will be used as the file name. The file will be created if it does not exist. If the file already exists it will be merged with the existing options and overwritten . If the directory does not exist an error will be generated. To force the creation of the directory path use the -Force switch. Type : String Parameter Sets : (All) Aliases : Required : False Position : 1 Default value : $PWD Accept pipeline input : False Accept wildcard characters : False -Option # An options object to use. Type : PSRuleOption Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : True (ByValue) Accept wildcard characters : False -PassThru # Use this option to return the options object to the pipeline instead of saving to disk. Type : SwitchParameter Parameter Sets : (All) Aliases : Required : False Position : Named Default value : False Accept pipeline input : False Accept wildcard characters : False -Force # Force creation of directory path for Path parameter, when the directory does not already exist. Type : SwitchParameter Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -AllowClobber # Overwrite YAML files that contain comments. Type : SwitchParameter Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -BindingIgnoreCase # Sets the option Binding.IgnoreCase . The option Binding.IgnoreCase determines if binding operations are case-sensitive or not. See about_PSRule_Options for more information. Type : Boolean Parameter Sets : (All) Aliases : Required : False Position : Named Default value : True Accept pipeline input : False Accept wildcard characters : False -BindingField # Sets the option Binding.Field . The option specified one or more custom field bindings. See about_PSRule_Options for more information. Type : Hashtable Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -BindingNameSeparator # Sets the option Binding.NameSeparator . This option specifies the separator to use for qualified names. See about_PSRule_Options for more information. Type : String Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -BindingPreferTargetInfo # Sets the option Binding.PreferTargetInfo . This option specifies if automatic binding is preferred over configured binding options. See about_PSRule_Options for more information. Type : Boolean Parameter Sets : (All) Aliases : Required : False Position : Named Default value : False Accept pipeline input : False Accept wildcard characters : False -Convention # Sets the Option.ConventionInclude option. This option specifies the name of conventions to execute in the pipeline when processing objects. See about_PSRule_Options for more information. Type : String[] Parameter Sets : (All) Aliases : ConventionInclude Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -TargetName # Sets the option Binding.TargetName . This option specifies one or more properties of TargetObject to use to bind TargetName to. See about_PSRule_Options for more information. Type : String[] Parameter Sets : (All) Aliases : BindingTargetName Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -TargetType # Sets the option Binding.TargetType . This option specifies one or more properties of TargetObject to use to bind TargetType to. See about_PSRule_Options for more information. Type : String[] Parameter Sets : (All) Aliases : BindingTargetType Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -BindingUseQualifiedName # Sets the option Binding.UseQualifiedName . This option specifies is qualified target names are used. See about_PSRule_Options for more information. Type : Boolean Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -InconclusiveWarning # Sets the option Execution.InconclusiveWarning . The Execution.InconclusiveWarning option determines if a warning is generated when the outcome of a rule is inconclusive. See about_PSRule_Options for more information. Type : Boolean Parameter Sets : (All) Aliases : ExecutionInconclusiveWarning Required : False Position : Named Default value : True Accept pipeline input : False Accept wildcard characters : False -NotProcessedWarning # Sets the Execution.NotProcessedWarning option. The Execution.NotProcessedWarning option determines if a warning is generated when an object is not processed by any rule. See about_PSRule_Options for more information. Type : Boolean Parameter Sets : (All) Aliases : ExecutionNotProcessedWarning Required : False Position : Named Default value : True Accept pipeline input : False Accept wildcard characters : False -SuppressedRuleWarning # Sets the Execution.SuppressedRuleWarning option. The Execution.SuppressedRuleWarning option determines if a warning is generated when a rule is suppressed. See about_PSRule_Options for more information. Type : Boolean Parameter Sets : (All) Aliases : ExecutionSuppressedRuleWarning Required : False Position : Named Default value : True Accept pipeline input : False Accept wildcard characters : False -IncludeModule # Sets the Include.Module option to include additional module sources. See about_PSRule_Options for more information. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -IncludePath # Sets the Include.Path option to include additional standalone sources. See about_PSRule_Options for more information. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -Format # Sets the Input.Format option to configure the input format for when a string is passed in as a target object. See about_PSRule_Options for more information. Type : InputFormat Parameter Sets : (All) Aliases : InputFormat Accepted values : None, Yaml, Json, Markdown, PowerShellData, File, Detect Required : False Position : Named Default value : Detect Accept pipeline input : False Accept wildcard characters : False -InputIgnoreGitPath # Sets the Input.IgnoreGitPath option to determine if files within the .git path are ignored. See about_PSRule_Options for more information. Type : Boolean Parameter Sets : (All) Aliases : Required : False Position : Named Default value : True Accept pipeline input : False Accept wildcard characters : False -InputIgnoreRepositoryCommon # Sets the Input.IgnoreRepositoryCommon option to determine if files common repository files are ignored. See about_PSRule_Options for more information. Type : Boolean Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -ObjectPath # Sets the Input.ObjectPath option to use an object path to use instead of the pipeline object. See about_PSRule_Options for more information. Type : String Parameter Sets : (All) Aliases : InputObjectPath Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -InputPathIgnore # Sets the Input.PathIgnore option. If specified, files that match the path spec will not be processed. See about_PSRule_Options for more information. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -InputTargetType # Sets the Input.TargetType option to only process objects with the specified TargetType. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -LoggingLimitDebug # Sets the Logging.LimitDebug option to limit debug messages to a list of named debug scopes. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -LoggingLimitVerbose # Sets the Logging.LimitVerbose option to limit verbose messages to a list of named verbose scopes. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -LoggingRuleFail # Sets the Logging.RuleFail option to generate an informational message for each rule fail. Type : OutcomeLogStream Parameter Sets : (All) Aliases : Accepted values : None, Error, Warning, Information Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -LoggingRulePass # Sets the Logging.RulePass option to generate an informational message for each rule pass. Type : OutcomeLogStream Parameter Sets : (All) Aliases : Accepted values : None, Error, Warning, Information Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -OutputAs # Sets the option Output.As . The Output.As option configures the type of results to produce, either detail or summary. Type : ResultFormat Parameter Sets : (All) Aliases : Accepted values : Detail, Summary Required : False Position : Named Default value : Detail Accept pipeline input : False Accept wildcard characters : False -OutputBanner # Sets the option Output.Banner . The Output.Banner option configure information displayed with PSRule banner. This option is only applicable when using Assert-PSRule cmdlet. Type : BannerFormat Parameter Sets : (All) Aliases : Required : False Position : Named Default value : Default Accept pipeline input : False Accept wildcard characters : False -OutputCulture # Sets the option Output.Culture . The Output.Culture option configures the culture used to generated output. When multiple cultures are specified, the first matching culture will be used. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -OutputEncoding # Sets the option Output.Encoding . The Output.Encoding option configured the encoding used to write results to file. Type : OutputEncoding Parameter Sets : (All) Aliases : Accepted values : Default, UTF8, UTF7, Unicode, UTF32, ASCII Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -OutputFooter # Sets the option Output.Footer . The Output.Footer option configures the information displayed for PSRule footer. See about_PSRule_Options for more information. Type : FooterFormat Parameter Sets : (All) Aliases : Required : False Position : Named Default value : Default Accept pipeline input : False Accept wildcard characters : False -OutputFormat # Sets the option Output.Format . The Output.Format option configures the format that results will be presented in. Type : OutputFormat Parameter Sets : (All) Aliases : Accepted values : None, Yaml, Json, Markdown, NUnit3, Csv, Wide Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -OutputOutcome # Sets the Output.Outcome option. This option can be set to include or exclude output results. See about_PSRule_Options for more information. Type : RuleOutcome Parameter Sets : (All) Aliases : Outcome Required : False Position : Named Default value : Processed Accept pipeline input : False Accept wildcard characters : False -OutputPath # Sets the option Output.Path . The Output.Path option configures an output file path to write results. Type : String Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -OutputStyle # Sets the option Option.Style . The Output.Style option configures the style that results will be presented in. This option only applies to Assert-PSRule . Type : OutputStyle Parameter Sets : (All) Aliases : Accepted values : Client, Plain, AzurePipelines, GitHubActions Required : False Position : Named Default value : Client Accept pipeline input : False Accept wildcard characters : False -OutputJsonIndent # Sets the option Output.JsonIndent . The Output.JsonIndent option configures indentation for JSON output. This option only applies to Get-PSRule , Invoke-PSRule and Assert-PSRule cmdlets. Type : Int Parameter Sets : (All) Aliases : JsonIndent Accepted values : 0, 1, 2, 3, 4 Required : False Position : Named Default value : 0 Accept pipeline input : False Accept wildcard characters : False -WhatIf # Shows what would happen if the cmdlet runs. The cmdlet is not run. Type : SwitchParameter Parameter Sets : (All) Aliases : wi Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -Confirm # Prompts you for confirmation before running the cmdlet. Type : SwitchParameter Parameter Sets : (All) Aliases : cf Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -RuleIncludeLocal # Sets the option Rule.IncludeLocal . The Rule.IncludeLocal option configures if local rules are automatically included. See about_PSRule_Options for more information. Type : Boolean Parameter Sets : (All) Aliases : Required : False Position : Named Default value : False Accept pipeline input : False Accept wildcard characters : False CommonParameters # This cmdlet supports the common parameters: -Debug, -ErrorAction, -ErrorVariable, -InformationAction, -InformationVariable, -OutVariable, -OutBuffer, -PipelineVariable, -Verbose, -WarningAction, and -WarningVariable. For more information, see about_CommonParameters . INPUTS # OUTPUTS # PSRule.Configuration.PSRuleOption # When you use the -PassThru switch, an options object is returned to the pipeline. Notes # RELATED LINKS # New-PSRuleOption","title":"Set-PSRuleOption"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#set-psruleoption","text":"Sets options that configure PSRule execution.","title":"Set-PSRuleOption"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#syntax","text":"Set-PSRuleOption [[-Path] <String>] [-Option <PSRuleOption>] [-PassThru] [-Force] [-AllowClobber] [-BindingIgnoreCase <Boolean>] [-BindingField <Hashtable>] [-BindingNameSeparator <String>] [-BindingPreferTargetInfo <Boolean>] [-TargetName <String[]>] [-TargetType <String[]>] [-BindingUseQualifiedName <Boolean>] [-Convention <String[]>] [-InconclusiveWarning <Boolean>] [-NotProcessedWarning <Boolean>] [-SuppressedRuleWarning <Boolean>] [-IncludeModule <String[]>] [-IncludePath <String[]>] [-Format <InputFormat>] [-InputIgnoreGitPath <Boolean>] [-InputIgnoreRepositoryCommon <Boolean>] [-ObjectPath <String>] [-InputPathIgnore <String[]>] [-InputTargetType <String[]>] [-LoggingLimitDebug <String[]>] [-LoggingLimitVerbose <String[]>] [-LoggingRuleFail <OutcomeLogStream>] [-LoggingRulePass <OutcomeLogStream>] [-OutputAs <ResultFormat>] [-OutputBanner <BannerFormat>] [-OutputCulture <String[]>] [-OutputEncoding <OutputEncoding>] [-OutputFooter <FooterFormat>] [-OutputFormat <OutputFormat>] [-OutputOutcome <RuleOutcome>] [-OutputPath <String>] [-OutputStyle <OutputStyle>] [-OutputJsonIndent <Int>] [-RuleIncludeLocal <Boolean>] [-WhatIf] [-Confirm] [<CommonParameters>]","title":"SYNTAX"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#description","text":"Sets options that configure PSRule execution.","title":"Description"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#examples","text":"","title":"Examples"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#example-1","text":"PS C :\\> Set-PSRuleOption -OutputFormat Yaml ; Sets the Output.Format to Yaml for ps-rule.yaml in the current working path. If the ps-rule.yaml file exists, it is merged with the existing file and overwritten. If the file does not exist, a new file is created.","title":"Example 1"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#example-2","text":"PS C :\\> Set-PSRuleOption -OutputFormat Yaml -Path .\\ project-options . yaml ; Sets the Output.Format to Yaml for project-options.yaml in the current working path. If the project-options.yaml file exists, it is merged with the existing file and overwritten. If the file does not exist, a new file is created.","title":"Example 2"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#parameters","text":"","title":"PARAMETERS"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-path","text":"The path to a YAML file where options will be set. By default the current working path ( $PWD ) is used. Either a directory or file path can be specified. When a directory is used, ps-rule.yaml will be used as the file name. The file will be created if it does not exist. If the file already exists it will be merged with the existing options and overwritten . If the directory does not exist an error will be generated. To force the creation of the directory path use the -Force switch. Type : String Parameter Sets : (All) Aliases : Required : False Position : 1 Default value : $PWD Accept pipeline input : False Accept wildcard characters : False","title":"-Path"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-option","text":"An options object to use. Type : PSRuleOption Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : True (ByValue) Accept wildcard characters : False","title":"-Option"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-passthru","text":"Use this option to return the options object to the pipeline instead of saving to disk. Type : SwitchParameter Parameter Sets : (All) Aliases : Required : False Position : Named Default value : False Accept pipeline input : False Accept wildcard characters : False","title":"-PassThru"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-force","text":"Force creation of directory path for Path parameter, when the directory does not already exist. Type : SwitchParameter Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Force"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-allowclobber","text":"Overwrite YAML files that contain comments. Type : SwitchParameter Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-AllowClobber"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-bindingignorecase","text":"Sets the option Binding.IgnoreCase . The option Binding.IgnoreCase determines if binding operations are case-sensitive or not. See about_PSRule_Options for more information. Type : Boolean Parameter Sets : (All) Aliases : Required : False Position : Named Default value : True Accept pipeline input : False Accept wildcard characters : False","title":"-BindingIgnoreCase"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-bindingfield","text":"Sets the option Binding.Field . The option specified one or more custom field bindings. See about_PSRule_Options for more information. Type : Hashtable Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-BindingField"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-bindingnameseparator","text":"Sets the option Binding.NameSeparator . This option specifies the separator to use for qualified names. See about_PSRule_Options for more information. Type : String Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-BindingNameSeparator"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-bindingprefertargetinfo","text":"Sets the option Binding.PreferTargetInfo . This option specifies if automatic binding is preferred over configured binding options. See about_PSRule_Options for more information. Type : Boolean Parameter Sets : (All) Aliases : Required : False Position : Named Default value : False Accept pipeline input : False Accept wildcard characters : False","title":"-BindingPreferTargetInfo"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-convention","text":"Sets the Option.ConventionInclude option. This option specifies the name of conventions to execute in the pipeline when processing objects. See about_PSRule_Options for more information. Type : String[] Parameter Sets : (All) Aliases : ConventionInclude Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Convention"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-targetname","text":"Sets the option Binding.TargetName . This option specifies one or more properties of TargetObject to use to bind TargetName to. See about_PSRule_Options for more information. Type : String[] Parameter Sets : (All) Aliases : BindingTargetName Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-TargetName"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-targettype","text":"Sets the option Binding.TargetType . This option specifies one or more properties of TargetObject to use to bind TargetType to. See about_PSRule_Options for more information. Type : String[] Parameter Sets : (All) Aliases : BindingTargetType Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-TargetType"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-bindingusequalifiedname","text":"Sets the option Binding.UseQualifiedName . This option specifies is qualified target names are used. See about_PSRule_Options for more information. Type : Boolean Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-BindingUseQualifiedName"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-inconclusivewarning","text":"Sets the option Execution.InconclusiveWarning . The Execution.InconclusiveWarning option determines if a warning is generated when the outcome of a rule is inconclusive. See about_PSRule_Options for more information. Type : Boolean Parameter Sets : (All) Aliases : ExecutionInconclusiveWarning Required : False Position : Named Default value : True Accept pipeline input : False Accept wildcard characters : False","title":"-InconclusiveWarning"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-notprocessedwarning","text":"Sets the Execution.NotProcessedWarning option. The Execution.NotProcessedWarning option determines if a warning is generated when an object is not processed by any rule. See about_PSRule_Options for more information. Type : Boolean Parameter Sets : (All) Aliases : ExecutionNotProcessedWarning Required : False Position : Named Default value : True Accept pipeline input : False Accept wildcard characters : False","title":"-NotProcessedWarning"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-suppressedrulewarning","text":"Sets the Execution.SuppressedRuleWarning option. The Execution.SuppressedRuleWarning option determines if a warning is generated when a rule is suppressed. See about_PSRule_Options for more information. Type : Boolean Parameter Sets : (All) Aliases : ExecutionSuppressedRuleWarning Required : False Position : Named Default value : True Accept pipeline input : False Accept wildcard characters : False","title":"-SuppressedRuleWarning"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-includemodule","text":"Sets the Include.Module option to include additional module sources. See about_PSRule_Options for more information. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-IncludeModule"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-includepath","text":"Sets the Include.Path option to include additional standalone sources. See about_PSRule_Options for more information. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-IncludePath"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-format","text":"Sets the Input.Format option to configure the input format for when a string is passed in as a target object. See about_PSRule_Options for more information. Type : InputFormat Parameter Sets : (All) Aliases : InputFormat Accepted values : None, Yaml, Json, Markdown, PowerShellData, File, Detect Required : False Position : Named Default value : Detect Accept pipeline input : False Accept wildcard characters : False","title":"-Format"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-inputignoregitpath","text":"Sets the Input.IgnoreGitPath option to determine if files within the .git path are ignored. See about_PSRule_Options for more information. Type : Boolean Parameter Sets : (All) Aliases : Required : False Position : Named Default value : True Accept pipeline input : False Accept wildcard characters : False","title":"-InputIgnoreGitPath"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-inputignorerepositorycommon","text":"Sets the Input.IgnoreRepositoryCommon option to determine if files common repository files are ignored. See about_PSRule_Options for more information. Type : Boolean Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-InputIgnoreRepositoryCommon"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-objectpath","text":"Sets the Input.ObjectPath option to use an object path to use instead of the pipeline object. See about_PSRule_Options for more information. Type : String Parameter Sets : (All) Aliases : InputObjectPath Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-ObjectPath"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-inputpathignore","text":"Sets the Input.PathIgnore option. If specified, files that match the path spec will not be processed. See about_PSRule_Options for more information. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-InputPathIgnore"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-inputtargettype","text":"Sets the Input.TargetType option to only process objects with the specified TargetType. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-InputTargetType"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-logginglimitdebug","text":"Sets the Logging.LimitDebug option to limit debug messages to a list of named debug scopes. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-LoggingLimitDebug"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-logginglimitverbose","text":"Sets the Logging.LimitVerbose option to limit verbose messages to a list of named verbose scopes. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-LoggingLimitVerbose"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-loggingrulefail","text":"Sets the Logging.RuleFail option to generate an informational message for each rule fail. Type : OutcomeLogStream Parameter Sets : (All) Aliases : Accepted values : None, Error, Warning, Information Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-LoggingRuleFail"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-loggingrulepass","text":"Sets the Logging.RulePass option to generate an informational message for each rule pass. Type : OutcomeLogStream Parameter Sets : (All) Aliases : Accepted values : None, Error, Warning, Information Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-LoggingRulePass"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-outputas","text":"Sets the option Output.As . The Output.As option configures the type of results to produce, either detail or summary. Type : ResultFormat Parameter Sets : (All) Aliases : Accepted values : Detail, Summary Required : False Position : Named Default value : Detail Accept pipeline input : False Accept wildcard characters : False","title":"-OutputAs"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-outputbanner","text":"Sets the option Output.Banner . The Output.Banner option configure information displayed with PSRule banner. This option is only applicable when using Assert-PSRule cmdlet. Type : BannerFormat Parameter Sets : (All) Aliases : Required : False Position : Named Default value : Default Accept pipeline input : False Accept wildcard characters : False","title":"-OutputBanner"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-outputculture","text":"Sets the option Output.Culture . The Output.Culture option configures the culture used to generated output. When multiple cultures are specified, the first matching culture will be used. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-OutputCulture"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-outputencoding","text":"Sets the option Output.Encoding . The Output.Encoding option configured the encoding used to write results to file. Type : OutputEncoding Parameter Sets : (All) Aliases : Accepted values : Default, UTF8, UTF7, Unicode, UTF32, ASCII Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-OutputEncoding"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-outputfooter","text":"Sets the option Output.Footer . The Output.Footer option configures the information displayed for PSRule footer. See about_PSRule_Options for more information. Type : FooterFormat Parameter Sets : (All) Aliases : Required : False Position : Named Default value : Default Accept pipeline input : False Accept wildcard characters : False","title":"-OutputFooter"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-outputformat","text":"Sets the option Output.Format . The Output.Format option configures the format that results will be presented in. Type : OutputFormat Parameter Sets : (All) Aliases : Accepted values : None, Yaml, Json, Markdown, NUnit3, Csv, Wide Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-OutputFormat"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-outputoutcome","text":"Sets the Output.Outcome option. This option can be set to include or exclude output results. See about_PSRule_Options for more information. Type : RuleOutcome Parameter Sets : (All) Aliases : Outcome Required : False Position : Named Default value : Processed Accept pipeline input : False Accept wildcard characters : False","title":"-OutputOutcome"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-outputpath","text":"Sets the option Output.Path . The Output.Path option configures an output file path to write results. Type : String Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-OutputPath"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-outputstyle","text":"Sets the option Option.Style . The Output.Style option configures the style that results will be presented in. This option only applies to Assert-PSRule . Type : OutputStyle Parameter Sets : (All) Aliases : Accepted values : Client, Plain, AzurePipelines, GitHubActions Required : False Position : Named Default value : Client Accept pipeline input : False Accept wildcard characters : False","title":"-OutputStyle"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-outputjsonindent","text":"Sets the option Output.JsonIndent . The Output.JsonIndent option configures indentation for JSON output. This option only applies to Get-PSRule , Invoke-PSRule and Assert-PSRule cmdlets. Type : Int Parameter Sets : (All) Aliases : JsonIndent Accepted values : 0, 1, 2, 3, 4 Required : False Position : Named Default value : 0 Accept pipeline input : False Accept wildcard characters : False","title":"-OutputJsonIndent"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-whatif","text":"Shows what would happen if the cmdlet runs. The cmdlet is not run. Type : SwitchParameter Parameter Sets : (All) Aliases : wi Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-WhatIf"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-confirm","text":"Prompts you for confirmation before running the cmdlet. Type : SwitchParameter Parameter Sets : (All) Aliases : cf Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Confirm"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#-ruleincludelocal","text":"Sets the option Rule.IncludeLocal . The Rule.IncludeLocal option configures if local rules are automatically included. See about_PSRule_Options for more information. Type : Boolean Parameter Sets : (All) Aliases : Required : False Position : Named Default value : False Accept pipeline input : False Accept wildcard characters : False","title":"-RuleIncludeLocal"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#commonparameters","text":"This cmdlet supports the common parameters: -Debug, -ErrorAction, -ErrorVariable, -InformationAction, -InformationVariable, -OutVariable, -OutBuffer, -PipelineVariable, -Verbose, -WarningAction, and -WarningVariable. For more information, see about_CommonParameters .","title":"CommonParameters"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#inputs","text":"","title":"INPUTS"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#outputs","text":"","title":"OUTPUTS"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#psruleconfigurationpsruleoption","text":"When you use the -PassThru switch, an options object is returned to the pipeline.","title":"PSRule.Configuration.PSRuleOption"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#notes","text":"","title":"Notes"},{"location":"commands/PSRule/en-US/Set-PSRuleOption/#related-links","text":"New-PSRuleOption","title":"RELATED LINKS"},{"location":"commands/PSRule/en-US/Test-PSRuleTarget/","text":"Test-PSRuleTarget # Pass or fail objects against matching rules. SYNTAX # Input (Default) # Test-PSRuleTarget [-Module <String[]>] [-Outcome <RuleOutcome>] [-Format <InputFormat>] [-Convention <String[]>] [[-Path] <String[]>] [-Name <String[]>] [-Tag <Hashtable>] -InputObject <PSObject> [-Option <PSRuleOption>] [-ObjectPath <String>] [-TargetType <String[]>] [-Culture <String>] [<CommonParameters>] InputPath # Test-PSRuleTarget -InputPath <String[]> [-Module <String[]>] [-Outcome <RuleOutcome>] [-Format <InputFormat>] [-Convention <String[]>] [[-Path] <String[]>] [-Name <String[]>] [-Tag <Hashtable>] [-Option <PSRuleOption>] [-ObjectPath <String>] [-TargetType <String[]>] [-Culture <String>] [<CommonParameters>] Description # Evaluate objects against matching rules and return an overall pass or fail for the object as $True (pass) or $False (fail). PSRule uses the following logic to determine overall pass or fail for an object: The object fails if: Any rules fail or error. Any rules are inconclusive. The object passes if: No matching rules were found. All rules pass. By default, objects that do match any rules are not returned in results. To return $True for these objects, use -Outcome All . Examples # Example 1 # @{ Name = 'Item 1' } | Test-PSRuleTarget ; Evaluate a simple hashtable on the pipeline against rules loaded from the current working path. PARAMETERS # -Path # One or more paths to search for rule definitions within. If this parameter is not specified the current working path will be used, unless the -Module parameter is used. If the -Module parameter is used, rule definitions from the currently working path will not be included by default. Type : String[] Parameter Sets : (All) Aliases : p Required : False Position : 1 Default value : $PWD Accept pipeline input : False Accept wildcard characters : False -Name # The name of a specific rule to evaluate. If this parameter is not specified all rules in search paths will be evaluated. Type : String[] Parameter Sets : (All) Aliases : n Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -Outcome # Filter output to only show pipeline objects with a specific outcome. Type : RuleOutcome Parameter Sets : (All) Aliases : Accepted values : Pass, Fail, Error, None, Processed, All Required : False Position : Named Default value : Pass, Fail, Error Accept pipeline input : False Accept wildcard characters : False -Tag # Only get rules with the specified tags set. If this parameter is not specified all rules in search paths will be returned. When more than one tag is used, all tags must match. Tags are not case sensitive. A tag value of * may be used to filter rules to any rule with the tag set, regardless of tag value. An array of tag values can be used to match a rule with either value. i.e. severity = important, critical matches rules with a category of either important or critical . Type : Hashtable Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -InputObject # The pipeline object to process rules for. Type : PSObject Parameter Sets : Input Aliases : TargetObject Required : True Position : Named Default value : None Accept pipeline input : True (ByValue) Accept wildcard characters : False -Option # Additional options that configure execution. A PSRuleOption can be created by using the New-PSRuleOption cmdlet. Alternatively, a hashtable or path to YAML file can be specified with options. For more information on PSRule options see about_PSRule_Options. Type : PSRuleOption Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -Format # Configures the input format for when a string is passed in as a target object. When the -InputObject parameter or pipeline input is used, strings are treated as plain text by default. Set this option to either Yaml , Json , Markdown , PowerShellData to have PSRule deserialize the object. When the -InputPath parameter is used with a file path or URL. If the Detect format is used, the file extension will be used to automatically detect the format. When -InputPath is not used, Detect is the same as None . When this option is set to File PSRule scans the path and subdirectories specified by -InputPath . Files are treated as objects instead of being deserialized. Additional, PSRule uses the file extension as the object type. When files have no extension the whole file name is used. See about_PSRule_Options for details. This parameter takes precedence over the Input.Format option if set. Type : InputFormat Parameter Sets : (All) Aliases : Accepted values : None, Yaml, Json, Markdown, PowerShellData, Repository, Detect Required : False Position : Named Default value : Detect Accept pipeline input : False Accept wildcard characters : False -Convention # Specifies conventions by name to execute in the pipeline when processing objects. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -Culture # Specifies the culture to use for rule documentation and messages. By default, the culture of PowerShell is used. This option does not affect the culture used for the PSRule engine, which always uses the culture of PowerShell. The PowerShell cmdlet Get-Culture shows the current culture of PowerShell. Type : String Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -ObjectPath # The name of a property to use instead of the pipeline object. If the property specified by ObjectPath is a collection or an array, then each item in evaluated separately. Type : String Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -TargetType # Filters input objects by TargetType. If specified, only objects with the specified TargetType are processed. Objects that do not match TargetType are ignored. If multiple values are specified, only one TargetType must match. This parameter is not case-sensitive. By default, all objects are processed. This parameter if set, overrides the Input.TargetType option. To change the field TargetType is bound to set the Binding.TargetType option. For details see the about_PSRule_Options help topic. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -Module # Search for rule definitions within a module. When specified without the -Path parameter, only rule definitions in the module will be discovered. When both -Path and -Module are specified, rule definitions from both are discovered. Type : String[] Parameter Sets : (All) Aliases : m Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False -InputPath # Instead of processing objects from the pipeline, import objects file the specified file paths. Type : String[] Parameter Sets : InputPath Aliases : f Required : True Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False CommonParameters # This cmdlet supports the common parameters: -Debug, -ErrorAction, -ErrorVariable, -InformationAction, -InformationVariable, -OutVariable, -OutBuffer, -PipelineVariable, -Verbose, -WarningAction, and -WarningVariable. For more information, see about_CommonParameters . INPUTS # System.Management.Automation.PSObject # You can pipe any object to Test-PSRuleTarget . OUTPUTS # System.Boolean # Returns $True when the object passes and $False when the object fails. Notes # RELATED LINKS # Invoke-PSRule Assert-PSRule Get-PSRule","title":"Test-PSRuleTarget"},{"location":"commands/PSRule/en-US/Test-PSRuleTarget/#test-psruletarget","text":"Pass or fail objects against matching rules.","title":"Test-PSRuleTarget"},{"location":"commands/PSRule/en-US/Test-PSRuleTarget/#syntax","text":"","title":"SYNTAX"},{"location":"commands/PSRule/en-US/Test-PSRuleTarget/#input-default","text":"Test-PSRuleTarget [-Module <String[]>] [-Outcome <RuleOutcome>] [-Format <InputFormat>] [-Convention <String[]>] [[-Path] <String[]>] [-Name <String[]>] [-Tag <Hashtable>] -InputObject <PSObject> [-Option <PSRuleOption>] [-ObjectPath <String>] [-TargetType <String[]>] [-Culture <String>] [<CommonParameters>]","title":"Input (Default)"},{"location":"commands/PSRule/en-US/Test-PSRuleTarget/#inputpath","text":"Test-PSRuleTarget -InputPath <String[]> [-Module <String[]>] [-Outcome <RuleOutcome>] [-Format <InputFormat>] [-Convention <String[]>] [[-Path] <String[]>] [-Name <String[]>] [-Tag <Hashtable>] [-Option <PSRuleOption>] [-ObjectPath <String>] [-TargetType <String[]>] [-Culture <String>] [<CommonParameters>]","title":"InputPath"},{"location":"commands/PSRule/en-US/Test-PSRuleTarget/#description","text":"Evaluate objects against matching rules and return an overall pass or fail for the object as $True (pass) or $False (fail). PSRule uses the following logic to determine overall pass or fail for an object: The object fails if: Any rules fail or error. Any rules are inconclusive. The object passes if: No matching rules were found. All rules pass. By default, objects that do match any rules are not returned in results. To return $True for these objects, use -Outcome All .","title":"Description"},{"location":"commands/PSRule/en-US/Test-PSRuleTarget/#examples","text":"","title":"Examples"},{"location":"commands/PSRule/en-US/Test-PSRuleTarget/#example-1","text":"@{ Name = 'Item 1' } | Test-PSRuleTarget ; Evaluate a simple hashtable on the pipeline against rules loaded from the current working path.","title":"Example 1"},{"location":"commands/PSRule/en-US/Test-PSRuleTarget/#parameters","text":"","title":"PARAMETERS"},{"location":"commands/PSRule/en-US/Test-PSRuleTarget/#-path","text":"One or more paths to search for rule definitions within. If this parameter is not specified the current working path will be used, unless the -Module parameter is used. If the -Module parameter is used, rule definitions from the currently working path will not be included by default. Type : String[] Parameter Sets : (All) Aliases : p Required : False Position : 1 Default value : $PWD Accept pipeline input : False Accept wildcard characters : False","title":"-Path"},{"location":"commands/PSRule/en-US/Test-PSRuleTarget/#-name","text":"The name of a specific rule to evaluate. If this parameter is not specified all rules in search paths will be evaluated. Type : String[] Parameter Sets : (All) Aliases : n Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Name"},{"location":"commands/PSRule/en-US/Test-PSRuleTarget/#-outcome","text":"Filter output to only show pipeline objects with a specific outcome. Type : RuleOutcome Parameter Sets : (All) Aliases : Accepted values : Pass, Fail, Error, None, Processed, All Required : False Position : Named Default value : Pass, Fail, Error Accept pipeline input : False Accept wildcard characters : False","title":"-Outcome"},{"location":"commands/PSRule/en-US/Test-PSRuleTarget/#-tag","text":"Only get rules with the specified tags set. If this parameter is not specified all rules in search paths will be returned. When more than one tag is used, all tags must match. Tags are not case sensitive. A tag value of * may be used to filter rules to any rule with the tag set, regardless of tag value. An array of tag values can be used to match a rule with either value. i.e. severity = important, critical matches rules with a category of either important or critical . Type : Hashtable Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Tag"},{"location":"commands/PSRule/en-US/Test-PSRuleTarget/#-inputobject","text":"The pipeline object to process rules for. Type : PSObject Parameter Sets : Input Aliases : TargetObject Required : True Position : Named Default value : None Accept pipeline input : True (ByValue) Accept wildcard characters : False","title":"-InputObject"},{"location":"commands/PSRule/en-US/Test-PSRuleTarget/#-option","text":"Additional options that configure execution. A PSRuleOption can be created by using the New-PSRuleOption cmdlet. Alternatively, a hashtable or path to YAML file can be specified with options. For more information on PSRule options see about_PSRule_Options. Type : PSRuleOption Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Option"},{"location":"commands/PSRule/en-US/Test-PSRuleTarget/#-format","text":"Configures the input format for when a string is passed in as a target object. When the -InputObject parameter or pipeline input is used, strings are treated as plain text by default. Set this option to either Yaml , Json , Markdown , PowerShellData to have PSRule deserialize the object. When the -InputPath parameter is used with a file path or URL. If the Detect format is used, the file extension will be used to automatically detect the format. When -InputPath is not used, Detect is the same as None . When this option is set to File PSRule scans the path and subdirectories specified by -InputPath . Files are treated as objects instead of being deserialized. Additional, PSRule uses the file extension as the object type. When files have no extension the whole file name is used. See about_PSRule_Options for details. This parameter takes precedence over the Input.Format option if set. Type : InputFormat Parameter Sets : (All) Aliases : Accepted values : None, Yaml, Json, Markdown, PowerShellData, Repository, Detect Required : False Position : Named Default value : Detect Accept pipeline input : False Accept wildcard characters : False","title":"-Format"},{"location":"commands/PSRule/en-US/Test-PSRuleTarget/#-convention","text":"Specifies conventions by name to execute in the pipeline when processing objects. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Convention"},{"location":"commands/PSRule/en-US/Test-PSRuleTarget/#-culture","text":"Specifies the culture to use for rule documentation and messages. By default, the culture of PowerShell is used. This option does not affect the culture used for the PSRule engine, which always uses the culture of PowerShell. The PowerShell cmdlet Get-Culture shows the current culture of PowerShell. Type : String Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Culture"},{"location":"commands/PSRule/en-US/Test-PSRuleTarget/#-objectpath","text":"The name of a property to use instead of the pipeline object. If the property specified by ObjectPath is a collection or an array, then each item in evaluated separately. Type : String Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-ObjectPath"},{"location":"commands/PSRule/en-US/Test-PSRuleTarget/#-targettype","text":"Filters input objects by TargetType. If specified, only objects with the specified TargetType are processed. Objects that do not match TargetType are ignored. If multiple values are specified, only one TargetType must match. This parameter is not case-sensitive. By default, all objects are processed. This parameter if set, overrides the Input.TargetType option. To change the field TargetType is bound to set the Binding.TargetType option. For details see the about_PSRule_Options help topic. Type : String[] Parameter Sets : (All) Aliases : Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-TargetType"},{"location":"commands/PSRule/en-US/Test-PSRuleTarget/#-module","text":"Search for rule definitions within a module. When specified without the -Path parameter, only rule definitions in the module will be discovered. When both -Path and -Module are specified, rule definitions from both are discovered. Type : String[] Parameter Sets : (All) Aliases : m Required : False Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-Module"},{"location":"commands/PSRule/en-US/Test-PSRuleTarget/#-inputpath","text":"Instead of processing objects from the pipeline, import objects file the specified file paths. Type : String[] Parameter Sets : InputPath Aliases : f Required : True Position : Named Default value : None Accept pipeline input : False Accept wildcard characters : False","title":"-InputPath"},{"location":"commands/PSRule/en-US/Test-PSRuleTarget/#commonparameters","text":"This cmdlet supports the common parameters: -Debug, -ErrorAction, -ErrorVariable, -InformationAction, -InformationVariable, -OutVariable, -OutBuffer, -PipelineVariable, -Verbose, -WarningAction, and -WarningVariable. For more information, see about_CommonParameters .","title":"CommonParameters"},{"location":"commands/PSRule/en-US/Test-PSRuleTarget/#inputs","text":"","title":"INPUTS"},{"location":"commands/PSRule/en-US/Test-PSRuleTarget/#systemmanagementautomationpsobject","text":"You can pipe any object to Test-PSRuleTarget .","title":"System.Management.Automation.PSObject"},{"location":"commands/PSRule/en-US/Test-PSRuleTarget/#outputs","text":"","title":"OUTPUTS"},{"location":"commands/PSRule/en-US/Test-PSRuleTarget/#systemboolean","text":"Returns $True when the object passes and $False when the object fails.","title":"System.Boolean"},{"location":"commands/PSRule/en-US/Test-PSRuleTarget/#notes","text":"","title":"Notes"},{"location":"commands/PSRule/en-US/Test-PSRuleTarget/#related-links","text":"Invoke-PSRule Assert-PSRule Get-PSRule","title":"RELATED LINKS"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/","text":"Assertion helpers # Describes the assertion helper that can be used within PSRule rule definitions. Description # PSRule includes an assertion helper exposed as a built-in variable $Assert . The $Assert object provides a consistent set of methods to evaluate objects. Each $Assert method returns an AssertResult object that contains the result of the assertion. The following built-in assertion methods are provided: Contains - The field value must contain at least one of the strings. Count - The field value must contain the specified number of items. EndsWith - The field value must match at least one suffix. FileHeader - The file must contain a comment header. FilePath - The file path must exist. Greater - The field value must be greater. GreaterOrEqual - The field value must be greater or equal to. HasDefaultValue - The object should not have the field or the field value is set to the default value. HasField - The object must have any of the specified fields. HasFields - The object must have all of the specified fields. HasFieldValue - The object must have the specified field and that field is not empty. HasJsonSchema - The object must reference a JSON schema with the $schema field. In - The field value must be included in the set. IsArray - The field value must be an array. IsBoolean - The field value must be a boolean. IsDateTime - The field value must be a DateTime. IsInteger - The field value must be an integer. IsLower - The field value must include only lowercase characters. IsNumeric - The field value must be a numeric type. IsString - The field value must be a string. IsUpper - The field value must include only uppercase characters. JsonSchema - The object must validate successfully against a JSON schema. Less - The field value must be less. LessOrEqual - The field value must be less or equal to. Match - The field value matches a regular expression pattern. NotHasField - The object must not have any of the specified fields. NotIn - The field value must not be included in the set. NotMatch - The field value does not match a regular expression pattern. NotNull - The field value must not be null. NotWithinPath - The field must not be within the specified path. Null - The field value must not exist or be null. NullOrEmpty - The object must not have the specified field or it must be empty. TypeOf - The field value must be of the specified type. SetOf - The field value must match a set of specified values. StartsWith - The field value must match at least one prefix. Subset - The field value must include a set of specified values. Version - The field value must be a semantic version string. WithinPath - The field value must be within the specified path. The $Assert variable can only be used within a rule definition block or script pre-conditions. Using assertion methods # An assertion method can be used like other methods in PowerShell. i.e. $Assert.methodName(parameters) . Assertion methods use the following standard pattern: The first parameter is always the input object of type PSObject , additional parameters can be included based on the functionality required by the method. In many cases the input object will be $TargetObject , however assertion methods must not assume that $TargetObject will be used. Assertion methods must accept a $Null input object. Assertion methods return the AssertResult object that is interpreted by the rule pipeline. Some assertion methods may overlap or provide similar functionality to built-in keywords. Where you have the choice, use built-in keywords. Use assertion methods for advanced cases or increased flexibility. In the following example, Assert.HasFieldValue asserts that $TargetObject should have a field named Type with a non-empty value. Rule 'Assert.HasTypeField' { $Assert . HasFieldValue ( $TargetObject , 'Type' ) } To find perform multiple assertions use. Rule 'Assert.HasRequiredFields' { $Assert . HasFieldValue ( $TargetObject , 'Name' ) $Assert . HasFieldValue ( $TargetObject , 'Type' ) $Assert . HasFieldValue ( $TargetObject , 'Value' ) } Field names # Many of the built-in assertion methods accept an object path or field name. An object path is an expression that traverses object properties, keys or indexes of the input object . The syntax for an object path is inspired by JSONPath which is current an IETF Internet-Draft. The object path expression can contain: Property names for PSObjects or .NET objects. Keys for hash table or dictionaries. Indexes for arrays or collections. Queries that filter items from array or collection properties. For example: . , or $ refers to input object itself. Name , .Name , or $.Name refers to the name member of the input object . Properties.enabled refers to the enabled member under the Properties member. Alternatively this can also be written as Properties['enabled'] . Tags.env refers to the env member under a hash table property of the input object . Tags+env refers to the env member using a case-sensitive match. Properties.securityRules[0].name references to the name member of the first security rule. Properties.securityRules[-1].name references to the name member of the last security rule. Properties.securityRules[?@direction == 'Inbound'].name returns the name of any inbound rules. This will return an array of security rule names. Notable differences between object paths and JSONPath are: Member names (properties and keys) are case-insensitive by default. To perform a case-sensitive match of a member name use a plus selector + in front of the member name. Some assertions such as HasField provide an option to match case when matching member names. When this is used, the plus selector perform an case-insensitive match. Quoted member names with single or double quotes are supported with dot selector. i.e. Properties.'spaced name' is valid. Member names with a dash - are supported without being quoted. However member names can not start or end with a dash. i.e. Properties.dashed-name and Properties.'-dashed-name' are valid. Contains # The Contains assertion method checks the field value contains the specified string. Optionally a case-sensitive compare can be used, however case is ignored by default. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. text - A string or an array of strings to compare the field value with. Only one string must match. When an empty array of strings is specified or text is an empty string, Contains always passes. caseSensitive (optional) - Use a case sensitive compare of the field value. Case is ignored by default. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The parameter 'text' is null. The field '{0}' does not exist. The field value '{0}' is not a string. The field '{0}' does not contain '{1}'. Examples: Rule 'Contains' { $Assert . Contains ( $TargetObject , 'ResourceGroupName' , 'prod' ) $Assert . Contains ( $TargetObject , 'Name' , @( 'prod' , 'test' ), $True ) } Count # The Count assertion method checks the field value contains the specified number of items. The field value must be an array or collection. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. count - The number of items that the field value must contain. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' does not exist. The field '{0}' is not enumerable. The field '{0}' has '{1}' items instead of '{2}'. Examples: Rule 'Count' { $Assert . Count ( $TargetObject , 'items' , 2 ) } EndsWith # The EndsWith assertion method checks the field value ends with the specified suffix. Optionally a case-sensitive compare can be used, however case is ignored by default. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. suffix - A suffix or an array of suffixes to compare the field value with. Only one suffix must match. When an empty array of suffixes is specified or suffix is an empty string, EndsWith always passes. caseSensitive (optional) - Use a case sensitive compare of the field value. Case is ignored by default. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The parameter 'suffix' is null. The field '{0}' does not exist. The field value '{0}' is not a string. The field '{0}' does not end with '{1}'. Examples: Rule 'EndsWith' { $Assert . EndsWith ( $TargetObject , 'ResourceGroupName' , 'eus' ) $Assert . EndsWith ( $TargetObject , 'Name' , @( 'db' , 'web' ), $True ) } FileHeader # The FileHeader assertion method checks a file for a comment header. When comparing the file header, the format of line comments are automatically detected by file extension. Single line comments are supported. Multi-line comments are not supported. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field containing a valid file path. header - One or more lines of a header to compare with file contents. prefix (optional) - An optional comment prefix for each line. By default a comment prefix will automatically detected based on file extension. When set, detection by file extension is skipped. Prefix detection for line comments is supported with the following file extensions: .bicep , .cs , .csx .ts , .js , .jsx , .fs , .go , .groovy , .php , .cpp , .h , .java , .json , .jsonc , .scala , Jenkinsfile - Use a prefix of ( // ). .ps1 , .psd1 , .psm1 , .yaml , .yml , .r , .py , .sh , .tf , .tfvars , .gitignore , .pl , .rb , Dockerfile - Use a prefix of ( # ). .sql , .lau - Use a prefix of ( -- ). .bat , .cmd - Use a prefix of ( :: ). Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' does not exist. The field value '{0}' is not a string. The file '{0}' does not exist. The header was not set. Examples: Rule 'FileHeader' { $Assert . FileHeader ( $TargetObject , 'FullName' , @( 'Copyright (c) Microsoft Corporation.' 'Licensed under the MIT License.' )); } FilePath # The FilePath assertion method checks the file exists. Checks use file system case-sensitivity rules. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field containing a file path. suffix (optional) - Additional file path suffixes to append. When specified each suffix is combined with the file path. Only one full file path must be a valid file for the assertion method to pass. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' does not exist. The field value '{0}' is not a string. The file '{0}' does not exist. Examples: Rule 'FilePath' { $Assert . FilePath ( $TargetObject , 'FullName' , @( 'CHANGELOG.md' )); $Assert . FilePath ( $TargetObject , 'FullName' , @( 'LICENSE' , 'LICENSE.txt' )); $Assert . FilePath ( $TargetObject , 'FullName' , @( 'CODE_OF_CONDUCT.md' )); $Assert . FilePath ( $TargetObject , 'FullName' , @( 'CONTRIBUTING.md' )); $Assert . FilePath ( $TargetObject , 'FullName' , @( 'SECURITY.md' )); $Assert . FilePath ( $TargetObject , 'FullName' , @( 'README.md' )); $Assert . FilePath ( $TargetObject , 'FullName' , @( '.github/CODEOWNERS' )); $Assert . FilePath ( $TargetObject , 'FullName' , @( '.github/PULL_REQUEST_TEMPLATE.md' )); } Greater # The Greater assertion method checks the field value is greater than the specified value. The field value can either be an integer, float, array, or string. When the field value is: An integer or float, a numerical comparison is used. An array, the number of elements is compared. A string, the length of the string is compared. A DateTime, the number of days from the current time is compared. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. value - A integer to compare the field value against. convert (optional) - Convert numerical strings and use a numerical comparison instead of using string length. By default the string length is compared. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' does not exist. The value '{0}' was not > '{1}'. The field value '{0}' can not be compared with '{1}'. Examples: Rule 'Greater' { $Assert . Greater ( $TargetObject , 'value' , 3 ) } GreaterOrEqual # The GreaterOrEqual assertion method checks the field value is greater or equal to the specified value. The field value can either be an integer, float, array, or string. When the field value is: An integer or float, a numerical comparison is used. An array, the number of elements is compared. A string, the length of the string is compared. A DateTime, the number of days from the current time is compared. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. value - A integer to compare the field value against. convert (optional) - Convert numerical strings and use a numerical comparison instead of using string length. By default the string length is compared. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' does not exist. The value '{0}' was not >= '{1}'. The field value '{0}' can not be compared with '{1}'. Examples: Rule 'GreaterOrEqual' { $Assert . GreaterOrEqual ( $TargetObject , 'value' , 3 ) } HasDefaultValue # The HasDefaultValue assertion method check that the field does not exist or the field value is set to the default value. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. defaultValue - The expected value if the field exists. This assertion will pass if: The field does not exist. The field value is set to defaultValue . This assertion will fail if: The field value is set to a value different from defaultValue . Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' is set to '{1}'. Examples: Rule 'HasDefaultValue' { $Assert . HasDefaultValue ( $TargetObject , 'Properties.osProfile.linuxConfiguration.provisionVMAgent' , $True ) } HasField # The HasField assertion method checks the object has any of the specified fields. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of one or more fields to check. By default, a case insensitive compare is used. If more than one field is specified, only one must exist. caseSensitive (optional) - Use a case sensitive compare of the field name. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' does not exist. Examples: Rule 'HasField' { $Assert . HasField ( $TargetObject , 'Name' ) $Assert . HasField ( $TargetObject , 'tag.Environment' , $True ) $Assert . HasField ( $TargetObject , @( 'tag.Environment' , 'tag.Env' ), $True ) } HasFields # The HasFields assertion method checks the object has all of the specified fields. The following parameters are accepted: inputObject - The object being checked for the specified fields. field - The name of one or more fields to check. By default, a case insensitive compare is used. If more than one field is specified, all fields must exist. caseSensitive (optional) - Use a case sensitive compare of the field name. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' does not exist. Examples: Rule 'HasFields' { $Assert . HasFields ( $TargetObject , 'Name' ) $Assert . HasFields ( $TargetObject , 'tag.Environment' , $True ) $Assert . HasFields ( $TargetObject , @( 'tag.Environment' , 'tag.Env' ), $True ) } HasFieldValue # The HasFieldValue assertion method checks the field value of the object is not empty. A field value is empty if any of the following are true: The field does not exist. The field value is $Null . The field value is an empty array or collection. The field value is an empty string '' . The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. expectedValue (optional) - Check that the field value is set to a specific value. To check $Null use NullOrEmpty instead. If expectedValue is $Null the field value will not be compared. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' does not exist. The value of '{0}' is null or empty. The field '{0}' is set to '{1}'. Examples: Rule 'HasFieldValue' { $Assert . HasFieldValue ( $TargetObject , 'Name' ) $Assert . HasFieldValue ( $TargetObject , 'tag.Environment' , 'production' ) } HasJsonSchema # The HasJsonSchema assertion method determines if the input object has a $schema property defined. If the $schema property is defined, it must not be empty and match one of the supplied schemas. If a trailing # is specified it is ignored from the $schema property and uri parameter below. The following parameters are accepted: inputObject - The object being compared. uri - Optional. When specified, the object being compared must have a $schema property set to one of the specified schemas. ignoreScheme - Optional. By default, ignoreScheme is $False . When $True , the schema will match if http or https is specified. Reasons include: The parameter 'inputObject' is null. The field '$schema' does not exist. The field value '$schema' is not a string. The value of '$schema' is null or empty. None of the specified schemas match '{0}'. Examples: Rule 'HasFieldValue' { $Assert . HasJsonSchema ( $TargetObject ) $Assert . HasJsonSchema ( $TargetObject , \"http://json-schema.org/draft-07/schema`#\" ) $Assert . HasJsonSchema ( $TargetObject , \"https://json-schema.org/draft-07/schema\" , $True ) } JsonSchema # The JsonSchema assertion method compares the input object against a defined JSON schema. The following parameters are accepted: inputObject - The object being compared against the JSON schema. uri - A URL or file path to a JSON schema file formatted as UTF-8. Either a file path or URL can be used to specify the location of the schema file. Reasons include: The parameter 'inputObject' is null. The parameter 'uri' is null or empty. The JSON schema '{0}' could not be found. Failed schema validation on {0}. {1} Examples: Rule 'JsonSchema' { $Assert . JsonSchema ( $TargetObject , 'tests/PSRule.Tests/FromFile.Json.schema.json' ) } In # The In assertion method checks the field value is included in a set of values. The field value can either be an integer, float, array, or string. When the field value is an array, only one item must be included in the set. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. values - An array of values that the field value is compared against. When an empty array is specified, In will always fail. caseSensitive (optional) - Use a case sensitive compare of the field value. Case is ignored by default. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The parameter 'values' is null. The field '{0}' does not exist. The field value '{0}' was not included in the set. Examples: Rule 'In' { $Assert . In ( $TargetObject , 'Sku.tier' , @( 'PremiumV2' , 'Premium' , 'Standard' )) $Assert . In ( $TargetObject , 'Sku.tier' , @( 'PremiumV2' , 'Premium' , 'Standard' ), $True ) } IsArray # The IsArray assertion method checks the field value is an array type. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' does not exist. The field value '{0}' is null. The field value '{1}' of type {0} is not [array]. Examples: Rule 'IsArray' { # Require Value1 to be an array $Assert . IsArray ( $TargetObject , 'Value1' ) } IsBoolean # The IsBoolean assertion method checks the field value is a boolean type. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. convert (optional) - Try to convert strings. By default strings are not converted. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' does not exist. The field value '{0}' is null. The field value '{1}' of type {0} is not [bool]. Examples: Rule 'IsBoolean' { # Require Value1 to be a boolean $Assert . IsBoolean ( $TargetObject , 'Value1' ) # Require Value1 to be a boolean or a boolean string $Assert . IsBoolean ( $TargetObject , 'Value1' , $True ) } IsDateTime # The IsBoolean assertion method checks the field value is a DateTime type. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. convert (optional) - Try to convert strings. By default strings are not converted. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' does not exist. The field value '{0}' is null. The field value '{1}' of type {0} is not [DateTime]. Examples: Rule 'IsBoolean' { # Require Value1 to be a DateTime $Assert . IsDateTime ( $TargetObject , 'Value1' ) # Require Value1 to be a DateTime or a DateTime string $Assert . IsDateTime ( $TargetObject , 'Value1' , $True ) } IsInteger # The IsInteger assertion method checks the field value is a integer type. The following types are considered integer types int , long , byte . The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. convert (optional) - Try to convert strings. By default strings are not converted. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' does not exist. The field value '{0}' is null. The field value '{1}' of type {0} is not an integer. Examples: Rule 'IsInteger' { # Require Value1 to be an integer $Assert . IsInteger ( $TargetObject , 'Value1' ) # Require Value1 to be an integer or a integer string $Assert . IsInteger ( $TargetObject , 'Value1' , $True ) } IsLower # The IsLower assertion method checks the field value uses only lowercase characters. Non-letter characters are ignored by default and will pass. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. requireLetters (optional) - Require each character to be lowercase letters only. Non-letter characters are ignored by default. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' does not exist. The field value '{0}' is not a string. The value '{0}' does not contain only lowercase characters. The value '{0}' does not contain only letters. Examples: Rule 'IsLower' { # Require Name to be lowercase $Assert . IsLower ( $TargetObject , 'Name' ) # Require Name to only contain lowercase letters $Assert . IsLower ( $TargetObject , 'Name' , $True ) } IsNumeric # The IsNumeric assertion method checks the field value is a numeric type. The following types are considered numeric types int , long , float , byte , double . The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. convert (optional) - Try to convert numerical strings. By default strings are not converted. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' does not exist. The field value '{0}' is null. The field value '{1}' of type {0} is not numeric. Examples: Rule 'IsNumeric' { # Require Value1 to be numeric $Assert . IsNumeric ( $TargetObject , 'Value1' ) # Require Value1 to be numeric or a numerical string $Assert . IsNumeric ( $TargetObject , 'Value1' , $True ) } IsString # The IsString assertion method checks the field value is a string type. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' does not exist. The field value '{0}' is null. The field value '{1}' of type {0} is not [string]. Examples: Rule 'IsString' { # Require Value1 to be a string $Assert . IsString ( $TargetObject , 'Value1' ) } IsUpper # The IsUpper assertion method checks the field value uses only uppercase characters. Non-letter characters are ignored by default and will pass. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. requireLetters (optional) - Require each character to be uppercase letters only. Non-letter characters are ignored by default. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' does not exist. The field value '{0}' is not a string. The value '{0}' does not contain only uppercase characters. The value '{0}' does not contain only letters. Examples: Rule 'IsUpper' { # Require Name to be uppercase $Assert . IsUpper ( $TargetObject , 'Name' ) # Require Name to only contain uppercase letters $Assert . IsUpper ( $TargetObject , 'Name' , $True ) } Less # The Less assertion method checks the field value is less than the specified value. The field value can either be an integer, float, array, or string. When the field value is: An integer or float, a numerical comparison is used. An array, the number of elements is compared. A string, the length of the string is compared. A DateTime, the number of days from the current time is compared. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. value - A integer to compare the field value against. convert (optional) - Convert numerical strings and use a numerical comparison instead of using string length. By default the string length is compared. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' does not exist. The value '{0}' was not < '{1}'. The field value '{0}' can not be compared with '{1}'. Examples: Rule 'Less' { $Assert . Less ( $TargetObject , 'value' , 3 ) } LessOrEqual # The LessOrEqual assertion method checks the field value is less or equal to the specified value. The field value can either be an integer, float, array, or string. When the field value is: An integer or float, a numerical comparison is used. An array, the number of elements is compared. A string, the length of the string is compared. A DateTime, the number of days from the current time is compared. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. value - A integer to compare the field value against. convert (optional) - Convert numerical strings and use a numerical comparison instead of using string length. By default the string length is compared. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' does not exist. The value '{0}' was not <= '{1}'. The field value '{0}' can not be compared with '{1}'. Examples: Rule 'LessOrEqual' { $Assert . LessOrEqual ( $TargetObject , 'value' , 3 ) } Match # The Match assertion method checks the field value matches a regular expression pattern. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. pattern - A regular expression pattern to match. caseSensitive (optional) - Use a case sensitive compare of the field value. Case is ignored by default. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' does not exist. The field value '{0}' is not a string. The field value '{0}' does not match the pattern '{1}'. Examples: Rule 'Match' { $Assert . Match ( $TargetObject , 'value' , '^[a-z]*$' ) $Assert . Match ( $TargetObject , 'value' , '^[a-z]*$' , $True ) } NotHasField # The NotHasField assertion method checks the object does not have any of the specified fields. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of one or more fields to check. By default, a case insensitive compare is used. If more than one field is specified, all must not exist. caseSensitive (optional) - Use a case sensitive compare of the field name. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' exists. Examples: Rule 'NotHasField' { $Assert . NotHasField ( $TargetObject , 'Name' ) $Assert . NotHasField ( $TargetObject , 'tag.Environment' , $True ) $Assert . NotHasField ( $TargetObject , @( 'tag.Environment' , 'tag.Env' ), $True ) } NotIn # The NotIn assertion method checks the field value is not in a set of values. The field value can either be an integer, array, float, or string. When the field value is an array, none of the items must be included in the set. If the field does not exist at all, it is not in the set and passes. To check the field exists combine this assertion method with HasFieldValue . The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. values - An array values that the field value is compared against. When an empty array is specified, NotIn will always pass. caseSensitive (optional) - Use a case sensitive compare of the field value. Case is ignored by default. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The parameter 'values' is null. The field value '{0}' was in the set. Examples: Rule 'In' { $Assert . NotIn ( $TargetObject , 'Sku.tier' , @( 'Free' , 'Shared' , 'Basic' )) $Assert . NotIn ( $TargetObject , 'Sku.tier' , @( 'Free' , 'Shared' , 'Basic' ), $True ) } NotMatch # The NotMatch assertion method checks the field value does not match a regular expression pattern. If the field does not exist at all, it does not match and passes. To check the field exists combine this assertion method with HasFieldValue . The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. pattern - A regular expression pattern to match. caseSensitive (optional) - Use a case sensitive compare of the field value. Case is ignored by default. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field value '{0}' is not a string. The field value '{0}' matches the pattern '{1}'. Examples: Rule 'NotMatch' { $Assert . NotMatch ( $TargetObject , 'value' , '^[a-z]*$' ) $Assert . NotMatch ( $TargetObject , 'value' , '^[a-z]*$' , $True ) } NotNull # The NotNull assertion method checks the field value of the object is not null. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' does not exist. The field value '{0}' is null. Examples: Rule 'NotNull' { $Assert . NotNull ( $TargetObject , 'Name' ) $Assert . NotNull ( $TargetObject , 'tag.Environment' ) } NotWithinPath # The NotWithinPath assertion method checks the file is not within a specified path. Checks use file system case-sensitivity rules by default. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field containing a file path. When the field is InputFileInfo or FileInfo , PSRule will automatically resolve the file path. path - An array of one or more directory paths to check. Only one path must match. caseSensitive (optional) - Determines if case-sensitive path matching is used. This can be set to $True or $False . When not set or $Null , the case-sensitivity rules of the working path file system will be used. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The parameter 'path' is null or empty. The field '{0}' does not exist. The file '{0}' is within the path '{1}'. Examples: Rule 'NotWithinPath' { # The file must not be within either policy/ or security/ sub-directories. $Assert . NotWithinPath ( $TargetObject , 'FullName' , @( 'policy/' , 'security/' )); } Null # The Null assertion method checks the field value of the object is null. A field value is null if any of the following are true: The field does not exist. The field value is $Null . The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field value '{0}' is not null. Examples: Rule 'Null' { $Assert . Null ( $TargetObject , 'NotField' ) $Assert . Null ( $TargetObject , 'tag.NullField' ) } NullOrEmpty # The NullOrEmpty assertion method checks the field value of the object is null or empty. A field value is null or empty if any of the following are true: The field does not exist. The field value is $Null . The field value is an empty array or collection. The field value is an empty string '' . The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' is not empty. Examples: Rule 'NullOrEmpty' { $Assert . NullOrEmpty ( $TargetObject , 'Name' ) $Assert . NullOrEmpty ( $TargetObject , 'tag.Environment' ) } TypeOf # The TypeOf assertion method checks the field value is a specified type. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. type - One or more specified types to check. The field value only has to match a single type of more than one type is specified. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The parameter 'type' is null or empty. The field '{0}' does not exist. The field value '{0}' is null. The field value '{2}' of type {1} is not {0}. Examples: Rule 'TypeOf' { # Require Value1 to be [int] $Assert . TypeOf ( $TargetObject , 'Value1' , [int] ) # Require Value1 to be [int] or [long] $Assert . TypeOf ( $TargetObject , 'Value1' , @( [int], [long] )) } SetOf # The SetOf assertion method checks the field value only includes all of the specified values. The field value must be an array or collection. Specified values can be included in the field value in any order. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. values - An array of values that the field value is compared against. caseSensitive (optional) - Use a case sensitive compare of the field value. Case is ignored by default. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The parameter 'values' is null. The field '{0}' does not exist. The field '{0}' is not enumerable. The field '{0}' did not contain '{1}'. The field '{0}' has '{1}' items instead of '{2}'. Examples: Rule 'Subset' { $Assert . SetOf ( $TargetObject , 'zones' , @( '1' , '2' , '3' )) } StartsWith # The StartsWith assertion method checks the field value starts with the specified prefix. Optionally a case-sensitive compare can be used, however case is ignored by default. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. prefix - A prefix or an array of prefixes to compare the field value with. Only one prefix must match. When an empty array of prefixes is specified or prefix is an empty string, StartsWith always passes. caseSensitive (optional) - Use a case sensitive compare of the field value. Case is ignored by default. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The parameter 'prefix' is null. The field '{0}' does not exist. The field value '{0}' is not a string. The field '{0}' does not start with '{1}'. Examples: Rule 'StartsWith' { $Assert . StartsWith ( $TargetObject , 'ResourceGroupName' , 'rg-' ) $Assert . StartsWith ( $TargetObject , 'Name' , @( 'st' , 'diag' ), $True ) } Subset # The Subset assertion method checks the field value includes all of the specified values. The field value may also contain additional values that are not specified in the values parameter. The field value must be an array or collection. Specified values can be included in the field value in any order. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. values - An array of values that the field value is compared against. When an empty array is specified, Subset will always pass. caseSensitive (optional) - Use a case sensitive compare of the field value. Case is ignored by default. unique (optional) - A boolean value that indicates if the items must be unique. When true the field value must not contain duplicate items. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The parameter 'values' is null. The field '{0}' does not exist. The field '{0}' is not enumerable. The field '{0}' did not contain '{1}'. The field '{0}' included multiple instances of '{1}'. Examples: Rule 'Subset' { $Assert . Subset ( $TargetObject , 'logs' , @( 'cluster-autoscaler' , 'kube-apiserver' , 'kube-scheduler' ), $True , $True ) } Version # The Version assertion method checks the field value is a valid semantic version. A constraint can optionally be provided to require the semantic version to be within a range. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. constraint (optional) - A version constraint, see below for details of version constrain format. includePrerelease (optional) - Determines if prerelease versions are included. Unless specified this defaults to $False . The following are supported constraints: version - Must match version exactly. This also accepts the following prefixes; = , v , V . e.g. 1.2.3 , =1.2.3 >version - Must be greater than version. e.g. >1.2.3 >=version - Must be greater than or equal to version. e.g. >=1.2.3 <version - Must be less than version. e.g. <1.2.3 <=version - Must be less than or equal to version. e.g. <=1.2.3 ^version - Compatible with version. e.g. ^1.2.3 - >=1.2.3 , <2.0.0 ~version - Approximately equivalent to version e.g. ~1.2.3 - >=1.2.3 , <1.3.0 An empty, null or * constraint matches all valid semantic versions. Multiple constraints can be joined together: Use a space to separate multiple constraints, each must be true ( logical AND ). Separates constraint sets with the double pipe || . Only one constraint set must be true ( logical OR ). By example: 1.2.3 || >=3.4.5 <5.0.0 results in: Pass: 1.2.3 , 3.4.5 , 3.5.0 , 4.9.9 . Fail: 3.0.0 , 5.0.0 . Handling for prerelease versions: Constraints and versions containing prerelease identifiers are supported. i.e. >=1.2.3-build.1 or 1.2.3-build.1 . A version containing a prerelease identifer follows semantic versioning rules. i.e. 1.2.3-alpha < 1.2.3-alpha.1 < 1.2.3-alpha.beta < 1.2.3-beta < 1.2.3-beta.2 < 1.2.3-beta.11 < 1.2.3-rc.1 < 1.2.3 . A constraint without a prerelease identifer will only match a stable version by default. Set includePrerelease to $True to include prerelease versions. Constraints with a prerelease identifer will only match: Matching prerelease versions of the same major.minor.patch version by default. Set includePrerelease to $True to include prerelease versions of all matching versions. Alternatively use the @pre or @prerelease flag in a constraint. Matching stable versions. By example: >=1.2.3 results in: Pass: 1.2.3 , 9.9.9 . Fail: 1.2.3-build.1 , 9.9.9-build.1 . >=1.2.3-0 results in: Pass: 1.2.3 , 1.2.3-build.1 , 9.9.9 . Fail: 9.9.9-build.1 . <1.2.3 results in: Pass: 1.2.2 , 1.0.0 . Fail: 1.0.0-build.1 , 1.2.3-build.1 . <1.2.3-0 results in: Pass: 1.2.2 , 1.0.0 . Fail: 1.0.0-build.1 , 1.2.3-build.1 . @pre >=1.2.3 results in: Pass: 1.2.3 , 9.9.9 , 9.9.9-build.1 Fail: 1.2.3-build.1 . @pre >=1.2.3-0 results in: Pass: 1.2.3 , 1.2.3-build.1 , 9.9.9 , 9.9.9-build.1 . Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' does not exist. The field value '{0}' is not a version string. The version '{0}' does not match the constraint '{1}'. Examples: Rule 'ValidVersion' { $Assert . Version ( $TargetObject , 'version' ) } Rule 'MinimumVersion' { $Assert . Version ( $TargetObject , 'version' , '>=1.2.3' ) } Rule 'MinimumVersionWithPrerelease' { $Assert . Version ( $TargetObject , 'version' , '>=1.2.3-0' , $True ) } Rule 'MinimumVersionWithFlag' { $Assert . Version ( $TargetObject , 'version' , '@pre >=1.2.3-0' ) } WithinPath # The WithinPath assertion method checks if the file path is within a required path. Checks use file system case-sensitivity rules by default. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field containing a file path. When the field is InputFileInfo or FileInfo , PSRule will automatically resolve the file path. path - An array of one or more directory paths to check. Only one path must match. caseSensitive (optional) - Determines if case-sensitive path matching is used. This can be set to $True or $False . When not set or $Null , the case-sensitivity rules of the working path file system will be used. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The parameter 'path' is null or empty. The field '{0}' does not exist. The file '{0}' is not within the path '{1}'. Examples: Rule 'WithinPath' { # Require the file to be within either policy/ or security/ sub-directories. $Assert . WithinPath ( $TargetObject , 'FullName' , @( 'policy/' , 'security/' )); } Advanced usage # The AssertResult object returned from assertion methods: Handles pass/ fail conditions and collection of reason information. Allows rules to implement their own handling or forward it up the stack to affect the rule outcome. The following properties are available: Result - Either $True (Pass) or $False (Fail). The following methods are available: AddReason(<string> text) - Can be used to append additional reasons to the result. A reason can only be set if the assertion failed. Reason text should be localized before calling this method. Localization can be done using the $LocalizedData automatic variable. WithReason(<string> text, <bool> replace) - Can be used to append or replace reasons on the result. In addition, WithReason can be chained. Reason(<string> text, params <object[]> args) - Replaces the reason on the results with a formatted string. This method can be chained. For usage see examples below. ReasonIf(<bool> condition, <string> text, params <object[]> args) - Replaces the reason if the condition is true. This method can be chained, similar to Reason . GetReason() - Gets any reasons currently associated with the failed result. Complete() - Returns $True (Pass) or $False (Fail) to the rule record. If the assertion failed, any reasons are automatically added to the rule record. To read the result without adding reason to the rule record use the Result property. Ignore() - Ignores the result. Nothing future is returned and any reasons are cleared. Use this method when implementing custom handling. Use of Complete is optional, uncompleted results are automatically completed after the rule has executed. Uncompleted results may return reasons out of sequence. Using these advanced methods is not supported in rule script pre-conditions. In this example, Complete is used to find the first field with an empty value. Rule 'Assert.HasFieldValue' { $Assert . HasFieldValue ( $TargetObject , 'Name' ). Complete () -and $Assert . HasFieldValue ( $TargetObject , 'Type' ). Complete () -and $Assert . HasFieldValue ( $TargetObject , 'Value' ). Complete () } In this example, the built-in reason is replaced with a custom reason, and immediately returned. The reason text is automatically formatted with any parameters provided. Rule 'Assert.HasCustomValue' { $Assert . HasDefaultValue ( $TargetObject , 'value' , 'test' ). Reason ( 'The field {0} is using a non-default value: {1}' , 'value' , $TargetObject . value ) # With localized string $Assert . HasDefaultValue ( $TargetObject , 'value' , 'test' ). Reason ( $LocalizedData . NonDefaultValue , 'value' , $TargetObject . value ) } Downstream issues # Before PSRule performs analysis external tools or rules modules may have already performed analysis. Issues identified by downstream tools can be consumed by PSRule using the _PSRule.issue property. If a _PSRule property exists with issue sub-property PSRule will consume issue as an array of issues. Each issue has the following properties: type - The issue type. Issues are filtered by type. name - The name of a specific issue. message - The reason message for the issue. To get issues for an object use the Get or Any methods. # Get an array of all issues for the current object. $PSRule . Issue . Get (); # Get an array of issues of a specific type. $PSRule . Issue . Get ( 'CustomIssue' ); # Return true of any issues exist. $PSRule . Issue . Any (); # Return true of any issues of a specific type exist. $PSRule . Issue . Any ( 'CustomIssue' ); For example: # Synopsis: Fail if the object has any 'PSRule.Rules.Azure.Parameter.Insecure' issues. Rule 'IssueReportTest' { $Assert . Create ( $PSRule . Issue . Get ( 'PSRule.Rules.Azure.Parameter.Insecure' )); } Authoring assertion methods # The following built-in helper methods are provided for working with $Assert when authoring new assertion methods: Create(<bool> condition, <string> reason, params <object[]> args) - Returns a result either pass or fail assertion result. Additional arguments can be provided to format the custom reason string. Create(<TargetIssueInfo[]>) - Returns a result based on reported downstream issues. Pass() - Returns a pass assertion result. Fail() - Results a fail assertion result. Fail(<string> reason, params <object[]> args) - Results a fail assertion result with a custom reason. Additional arguments can be provided to format the custom reason string. Aggregating assertion methods # The following built-in helper methods are provided for aggregating assertion results: AnyOf(<AssertResult[]> results) - Results from assertion methods are aggregated into a single result. If any result is a pass, the result is a pass. If all results are fails, the result is a fail and any reasons are added to the result. If no results are provided, the result is a fail. AllOf(<AssertResult[]> results) - Results from assertion methods are aggregated into a single result. If all results are passes, the result is a pass. If any result is a fail, the result is a fail and any reasons are added to the result. If no results are provided, the result is a fail. For example: Rule 'Assert.HasFieldValue' { $Assert . AllOf ( $Assert . HasFieldValue ( $TargetObject , 'Name' ), $Assert . HasFieldValue ( $TargetObject , 'Type' ), $Assert . HasFieldValue ( $TargetObject , 'Value' ) ) } Links # about_PSRule_Variables","title":"Assertion helpers"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#assertion-helpers","text":"Describes the assertion helper that can be used within PSRule rule definitions.","title":"Assertion helpers"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#description","text":"PSRule includes an assertion helper exposed as a built-in variable $Assert . The $Assert object provides a consistent set of methods to evaluate objects. Each $Assert method returns an AssertResult object that contains the result of the assertion. The following built-in assertion methods are provided: Contains - The field value must contain at least one of the strings. Count - The field value must contain the specified number of items. EndsWith - The field value must match at least one suffix. FileHeader - The file must contain a comment header. FilePath - The file path must exist. Greater - The field value must be greater. GreaterOrEqual - The field value must be greater or equal to. HasDefaultValue - The object should not have the field or the field value is set to the default value. HasField - The object must have any of the specified fields. HasFields - The object must have all of the specified fields. HasFieldValue - The object must have the specified field and that field is not empty. HasJsonSchema - The object must reference a JSON schema with the $schema field. In - The field value must be included in the set. IsArray - The field value must be an array. IsBoolean - The field value must be a boolean. IsDateTime - The field value must be a DateTime. IsInteger - The field value must be an integer. IsLower - The field value must include only lowercase characters. IsNumeric - The field value must be a numeric type. IsString - The field value must be a string. IsUpper - The field value must include only uppercase characters. JsonSchema - The object must validate successfully against a JSON schema. Less - The field value must be less. LessOrEqual - The field value must be less or equal to. Match - The field value matches a regular expression pattern. NotHasField - The object must not have any of the specified fields. NotIn - The field value must not be included in the set. NotMatch - The field value does not match a regular expression pattern. NotNull - The field value must not be null. NotWithinPath - The field must not be within the specified path. Null - The field value must not exist or be null. NullOrEmpty - The object must not have the specified field or it must be empty. TypeOf - The field value must be of the specified type. SetOf - The field value must match a set of specified values. StartsWith - The field value must match at least one prefix. Subset - The field value must include a set of specified values. Version - The field value must be a semantic version string. WithinPath - The field value must be within the specified path. The $Assert variable can only be used within a rule definition block or script pre-conditions.","title":"Description"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#using-assertion-methods","text":"An assertion method can be used like other methods in PowerShell. i.e. $Assert.methodName(parameters) . Assertion methods use the following standard pattern: The first parameter is always the input object of type PSObject , additional parameters can be included based on the functionality required by the method. In many cases the input object will be $TargetObject , however assertion methods must not assume that $TargetObject will be used. Assertion methods must accept a $Null input object. Assertion methods return the AssertResult object that is interpreted by the rule pipeline. Some assertion methods may overlap or provide similar functionality to built-in keywords. Where you have the choice, use built-in keywords. Use assertion methods for advanced cases or increased flexibility. In the following example, Assert.HasFieldValue asserts that $TargetObject should have a field named Type with a non-empty value. Rule 'Assert.HasTypeField' { $Assert . HasFieldValue ( $TargetObject , 'Type' ) } To find perform multiple assertions use. Rule 'Assert.HasRequiredFields' { $Assert . HasFieldValue ( $TargetObject , 'Name' ) $Assert . HasFieldValue ( $TargetObject , 'Type' ) $Assert . HasFieldValue ( $TargetObject , 'Value' ) }","title":"Using assertion methods"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#field-names","text":"Many of the built-in assertion methods accept an object path or field name. An object path is an expression that traverses object properties, keys or indexes of the input object . The syntax for an object path is inspired by JSONPath which is current an IETF Internet-Draft. The object path expression can contain: Property names for PSObjects or .NET objects. Keys for hash table or dictionaries. Indexes for arrays or collections. Queries that filter items from array or collection properties. For example: . , or $ refers to input object itself. Name , .Name , or $.Name refers to the name member of the input object . Properties.enabled refers to the enabled member under the Properties member. Alternatively this can also be written as Properties['enabled'] . Tags.env refers to the env member under a hash table property of the input object . Tags+env refers to the env member using a case-sensitive match. Properties.securityRules[0].name references to the name member of the first security rule. Properties.securityRules[-1].name references to the name member of the last security rule. Properties.securityRules[?@direction == 'Inbound'].name returns the name of any inbound rules. This will return an array of security rule names. Notable differences between object paths and JSONPath are: Member names (properties and keys) are case-insensitive by default. To perform a case-sensitive match of a member name use a plus selector + in front of the member name. Some assertions such as HasField provide an option to match case when matching member names. When this is used, the plus selector perform an case-insensitive match. Quoted member names with single or double quotes are supported with dot selector. i.e. Properties.'spaced name' is valid. Member names with a dash - are supported without being quoted. However member names can not start or end with a dash. i.e. Properties.dashed-name and Properties.'-dashed-name' are valid.","title":"Field names"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#contains","text":"The Contains assertion method checks the field value contains the specified string. Optionally a case-sensitive compare can be used, however case is ignored by default. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. text - A string or an array of strings to compare the field value with. Only one string must match. When an empty array of strings is specified or text is an empty string, Contains always passes. caseSensitive (optional) - Use a case sensitive compare of the field value. Case is ignored by default. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The parameter 'text' is null. The field '{0}' does not exist. The field value '{0}' is not a string. The field '{0}' does not contain '{1}'. Examples: Rule 'Contains' { $Assert . Contains ( $TargetObject , 'ResourceGroupName' , 'prod' ) $Assert . Contains ( $TargetObject , 'Name' , @( 'prod' , 'test' ), $True ) }","title":"Contains"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#count","text":"The Count assertion method checks the field value contains the specified number of items. The field value must be an array or collection. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. count - The number of items that the field value must contain. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' does not exist. The field '{0}' is not enumerable. The field '{0}' has '{1}' items instead of '{2}'. Examples: Rule 'Count' { $Assert . Count ( $TargetObject , 'items' , 2 ) }","title":"Count"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#endswith","text":"The EndsWith assertion method checks the field value ends with the specified suffix. Optionally a case-sensitive compare can be used, however case is ignored by default. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. suffix - A suffix or an array of suffixes to compare the field value with. Only one suffix must match. When an empty array of suffixes is specified or suffix is an empty string, EndsWith always passes. caseSensitive (optional) - Use a case sensitive compare of the field value. Case is ignored by default. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The parameter 'suffix' is null. The field '{0}' does not exist. The field value '{0}' is not a string. The field '{0}' does not end with '{1}'. Examples: Rule 'EndsWith' { $Assert . EndsWith ( $TargetObject , 'ResourceGroupName' , 'eus' ) $Assert . EndsWith ( $TargetObject , 'Name' , @( 'db' , 'web' ), $True ) }","title":"EndsWith"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#fileheader","text":"The FileHeader assertion method checks a file for a comment header. When comparing the file header, the format of line comments are automatically detected by file extension. Single line comments are supported. Multi-line comments are not supported. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field containing a valid file path. header - One or more lines of a header to compare with file contents. prefix (optional) - An optional comment prefix for each line. By default a comment prefix will automatically detected based on file extension. When set, detection by file extension is skipped. Prefix detection for line comments is supported with the following file extensions: .bicep , .cs , .csx .ts , .js , .jsx , .fs , .go , .groovy , .php , .cpp , .h , .java , .json , .jsonc , .scala , Jenkinsfile - Use a prefix of ( // ). .ps1 , .psd1 , .psm1 , .yaml , .yml , .r , .py , .sh , .tf , .tfvars , .gitignore , .pl , .rb , Dockerfile - Use a prefix of ( # ). .sql , .lau - Use a prefix of ( -- ). .bat , .cmd - Use a prefix of ( :: ). Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' does not exist. The field value '{0}' is not a string. The file '{0}' does not exist. The header was not set. Examples: Rule 'FileHeader' { $Assert . FileHeader ( $TargetObject , 'FullName' , @( 'Copyright (c) Microsoft Corporation.' 'Licensed under the MIT License.' )); }","title":"FileHeader"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#filepath","text":"The FilePath assertion method checks the file exists. Checks use file system case-sensitivity rules. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field containing a file path. suffix (optional) - Additional file path suffixes to append. When specified each suffix is combined with the file path. Only one full file path must be a valid file for the assertion method to pass. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' does not exist. The field value '{0}' is not a string. The file '{0}' does not exist. Examples: Rule 'FilePath' { $Assert . FilePath ( $TargetObject , 'FullName' , @( 'CHANGELOG.md' )); $Assert . FilePath ( $TargetObject , 'FullName' , @( 'LICENSE' , 'LICENSE.txt' )); $Assert . FilePath ( $TargetObject , 'FullName' , @( 'CODE_OF_CONDUCT.md' )); $Assert . FilePath ( $TargetObject , 'FullName' , @( 'CONTRIBUTING.md' )); $Assert . FilePath ( $TargetObject , 'FullName' , @( 'SECURITY.md' )); $Assert . FilePath ( $TargetObject , 'FullName' , @( 'README.md' )); $Assert . FilePath ( $TargetObject , 'FullName' , @( '.github/CODEOWNERS' )); $Assert . FilePath ( $TargetObject , 'FullName' , @( '.github/PULL_REQUEST_TEMPLATE.md' )); }","title":"FilePath"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#greater","text":"The Greater assertion method checks the field value is greater than the specified value. The field value can either be an integer, float, array, or string. When the field value is: An integer or float, a numerical comparison is used. An array, the number of elements is compared. A string, the length of the string is compared. A DateTime, the number of days from the current time is compared. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. value - A integer to compare the field value against. convert (optional) - Convert numerical strings and use a numerical comparison instead of using string length. By default the string length is compared. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' does not exist. The value '{0}' was not > '{1}'. The field value '{0}' can not be compared with '{1}'. Examples: Rule 'Greater' { $Assert . Greater ( $TargetObject , 'value' , 3 ) }","title":"Greater"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#greaterorequal","text":"The GreaterOrEqual assertion method checks the field value is greater or equal to the specified value. The field value can either be an integer, float, array, or string. When the field value is: An integer or float, a numerical comparison is used. An array, the number of elements is compared. A string, the length of the string is compared. A DateTime, the number of days from the current time is compared. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. value - A integer to compare the field value against. convert (optional) - Convert numerical strings and use a numerical comparison instead of using string length. By default the string length is compared. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' does not exist. The value '{0}' was not >= '{1}'. The field value '{0}' can not be compared with '{1}'. Examples: Rule 'GreaterOrEqual' { $Assert . GreaterOrEqual ( $TargetObject , 'value' , 3 ) }","title":"GreaterOrEqual"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#hasdefaultvalue","text":"The HasDefaultValue assertion method check that the field does not exist or the field value is set to the default value. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. defaultValue - The expected value if the field exists. This assertion will pass if: The field does not exist. The field value is set to defaultValue . This assertion will fail if: The field value is set to a value different from defaultValue . Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' is set to '{1}'. Examples: Rule 'HasDefaultValue' { $Assert . HasDefaultValue ( $TargetObject , 'Properties.osProfile.linuxConfiguration.provisionVMAgent' , $True ) }","title":"HasDefaultValue"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#hasfield","text":"The HasField assertion method checks the object has any of the specified fields. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of one or more fields to check. By default, a case insensitive compare is used. If more than one field is specified, only one must exist. caseSensitive (optional) - Use a case sensitive compare of the field name. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' does not exist. Examples: Rule 'HasField' { $Assert . HasField ( $TargetObject , 'Name' ) $Assert . HasField ( $TargetObject , 'tag.Environment' , $True ) $Assert . HasField ( $TargetObject , @( 'tag.Environment' , 'tag.Env' ), $True ) }","title":"HasField"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#hasfields","text":"The HasFields assertion method checks the object has all of the specified fields. The following parameters are accepted: inputObject - The object being checked for the specified fields. field - The name of one or more fields to check. By default, a case insensitive compare is used. If more than one field is specified, all fields must exist. caseSensitive (optional) - Use a case sensitive compare of the field name. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' does not exist. Examples: Rule 'HasFields' { $Assert . HasFields ( $TargetObject , 'Name' ) $Assert . HasFields ( $TargetObject , 'tag.Environment' , $True ) $Assert . HasFields ( $TargetObject , @( 'tag.Environment' , 'tag.Env' ), $True ) }","title":"HasFields"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#hasfieldvalue","text":"The HasFieldValue assertion method checks the field value of the object is not empty. A field value is empty if any of the following are true: The field does not exist. The field value is $Null . The field value is an empty array or collection. The field value is an empty string '' . The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. expectedValue (optional) - Check that the field value is set to a specific value. To check $Null use NullOrEmpty instead. If expectedValue is $Null the field value will not be compared. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' does not exist. The value of '{0}' is null or empty. The field '{0}' is set to '{1}'. Examples: Rule 'HasFieldValue' { $Assert . HasFieldValue ( $TargetObject , 'Name' ) $Assert . HasFieldValue ( $TargetObject , 'tag.Environment' , 'production' ) }","title":"HasFieldValue"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#hasjsonschema","text":"The HasJsonSchema assertion method determines if the input object has a $schema property defined. If the $schema property is defined, it must not be empty and match one of the supplied schemas. If a trailing # is specified it is ignored from the $schema property and uri parameter below. The following parameters are accepted: inputObject - The object being compared. uri - Optional. When specified, the object being compared must have a $schema property set to one of the specified schemas. ignoreScheme - Optional. By default, ignoreScheme is $False . When $True , the schema will match if http or https is specified. Reasons include: The parameter 'inputObject' is null. The field '$schema' does not exist. The field value '$schema' is not a string. The value of '$schema' is null or empty. None of the specified schemas match '{0}'. Examples: Rule 'HasFieldValue' { $Assert . HasJsonSchema ( $TargetObject ) $Assert . HasJsonSchema ( $TargetObject , \"http://json-schema.org/draft-07/schema`#\" ) $Assert . HasJsonSchema ( $TargetObject , \"https://json-schema.org/draft-07/schema\" , $True ) }","title":"HasJsonSchema"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#jsonschema","text":"The JsonSchema assertion method compares the input object against a defined JSON schema. The following parameters are accepted: inputObject - The object being compared against the JSON schema. uri - A URL or file path to a JSON schema file formatted as UTF-8. Either a file path or URL can be used to specify the location of the schema file. Reasons include: The parameter 'inputObject' is null. The parameter 'uri' is null or empty. The JSON schema '{0}' could not be found. Failed schema validation on {0}. {1} Examples: Rule 'JsonSchema' { $Assert . JsonSchema ( $TargetObject , 'tests/PSRule.Tests/FromFile.Json.schema.json' ) }","title":"JsonSchema"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#in","text":"The In assertion method checks the field value is included in a set of values. The field value can either be an integer, float, array, or string. When the field value is an array, only one item must be included in the set. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. values - An array of values that the field value is compared against. When an empty array is specified, In will always fail. caseSensitive (optional) - Use a case sensitive compare of the field value. Case is ignored by default. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The parameter 'values' is null. The field '{0}' does not exist. The field value '{0}' was not included in the set. Examples: Rule 'In' { $Assert . In ( $TargetObject , 'Sku.tier' , @( 'PremiumV2' , 'Premium' , 'Standard' )) $Assert . In ( $TargetObject , 'Sku.tier' , @( 'PremiumV2' , 'Premium' , 'Standard' ), $True ) }","title":"In"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#isarray","text":"The IsArray assertion method checks the field value is an array type. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' does not exist. The field value '{0}' is null. The field value '{1}' of type {0} is not [array]. Examples: Rule 'IsArray' { # Require Value1 to be an array $Assert . IsArray ( $TargetObject , 'Value1' ) }","title":"IsArray"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#isboolean","text":"The IsBoolean assertion method checks the field value is a boolean type. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. convert (optional) - Try to convert strings. By default strings are not converted. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' does not exist. The field value '{0}' is null. The field value '{1}' of type {0} is not [bool]. Examples: Rule 'IsBoolean' { # Require Value1 to be a boolean $Assert . IsBoolean ( $TargetObject , 'Value1' ) # Require Value1 to be a boolean or a boolean string $Assert . IsBoolean ( $TargetObject , 'Value1' , $True ) }","title":"IsBoolean"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#isdatetime","text":"The IsBoolean assertion method checks the field value is a DateTime type. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. convert (optional) - Try to convert strings. By default strings are not converted. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' does not exist. The field value '{0}' is null. The field value '{1}' of type {0} is not [DateTime]. Examples: Rule 'IsBoolean' { # Require Value1 to be a DateTime $Assert . IsDateTime ( $TargetObject , 'Value1' ) # Require Value1 to be a DateTime or a DateTime string $Assert . IsDateTime ( $TargetObject , 'Value1' , $True ) }","title":"IsDateTime"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#isinteger","text":"The IsInteger assertion method checks the field value is a integer type. The following types are considered integer types int , long , byte . The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. convert (optional) - Try to convert strings. By default strings are not converted. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' does not exist. The field value '{0}' is null. The field value '{1}' of type {0} is not an integer. Examples: Rule 'IsInteger' { # Require Value1 to be an integer $Assert . IsInteger ( $TargetObject , 'Value1' ) # Require Value1 to be an integer or a integer string $Assert . IsInteger ( $TargetObject , 'Value1' , $True ) }","title":"IsInteger"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#islower","text":"The IsLower assertion method checks the field value uses only lowercase characters. Non-letter characters are ignored by default and will pass. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. requireLetters (optional) - Require each character to be lowercase letters only. Non-letter characters are ignored by default. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' does not exist. The field value '{0}' is not a string. The value '{0}' does not contain only lowercase characters. The value '{0}' does not contain only letters. Examples: Rule 'IsLower' { # Require Name to be lowercase $Assert . IsLower ( $TargetObject , 'Name' ) # Require Name to only contain lowercase letters $Assert . IsLower ( $TargetObject , 'Name' , $True ) }","title":"IsLower"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#isnumeric","text":"The IsNumeric assertion method checks the field value is a numeric type. The following types are considered numeric types int , long , float , byte , double . The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. convert (optional) - Try to convert numerical strings. By default strings are not converted. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' does not exist. The field value '{0}' is null. The field value '{1}' of type {0} is not numeric. Examples: Rule 'IsNumeric' { # Require Value1 to be numeric $Assert . IsNumeric ( $TargetObject , 'Value1' ) # Require Value1 to be numeric or a numerical string $Assert . IsNumeric ( $TargetObject , 'Value1' , $True ) }","title":"IsNumeric"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#isstring","text":"The IsString assertion method checks the field value is a string type. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' does not exist. The field value '{0}' is null. The field value '{1}' of type {0} is not [string]. Examples: Rule 'IsString' { # Require Value1 to be a string $Assert . IsString ( $TargetObject , 'Value1' ) }","title":"IsString"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#isupper","text":"The IsUpper assertion method checks the field value uses only uppercase characters. Non-letter characters are ignored by default and will pass. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. requireLetters (optional) - Require each character to be uppercase letters only. Non-letter characters are ignored by default. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' does not exist. The field value '{0}' is not a string. The value '{0}' does not contain only uppercase characters. The value '{0}' does not contain only letters. Examples: Rule 'IsUpper' { # Require Name to be uppercase $Assert . IsUpper ( $TargetObject , 'Name' ) # Require Name to only contain uppercase letters $Assert . IsUpper ( $TargetObject , 'Name' , $True ) }","title":"IsUpper"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#less","text":"The Less assertion method checks the field value is less than the specified value. The field value can either be an integer, float, array, or string. When the field value is: An integer or float, a numerical comparison is used. An array, the number of elements is compared. A string, the length of the string is compared. A DateTime, the number of days from the current time is compared. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. value - A integer to compare the field value against. convert (optional) - Convert numerical strings and use a numerical comparison instead of using string length. By default the string length is compared. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' does not exist. The value '{0}' was not < '{1}'. The field value '{0}' can not be compared with '{1}'. Examples: Rule 'Less' { $Assert . Less ( $TargetObject , 'value' , 3 ) }","title":"Less"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#lessorequal","text":"The LessOrEqual assertion method checks the field value is less or equal to the specified value. The field value can either be an integer, float, array, or string. When the field value is: An integer or float, a numerical comparison is used. An array, the number of elements is compared. A string, the length of the string is compared. A DateTime, the number of days from the current time is compared. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. value - A integer to compare the field value against. convert (optional) - Convert numerical strings and use a numerical comparison instead of using string length. By default the string length is compared. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' does not exist. The value '{0}' was not <= '{1}'. The field value '{0}' can not be compared with '{1}'. Examples: Rule 'LessOrEqual' { $Assert . LessOrEqual ( $TargetObject , 'value' , 3 ) }","title":"LessOrEqual"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#match","text":"The Match assertion method checks the field value matches a regular expression pattern. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. pattern - A regular expression pattern to match. caseSensitive (optional) - Use a case sensitive compare of the field value. Case is ignored by default. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' does not exist. The field value '{0}' is not a string. The field value '{0}' does not match the pattern '{1}'. Examples: Rule 'Match' { $Assert . Match ( $TargetObject , 'value' , '^[a-z]*$' ) $Assert . Match ( $TargetObject , 'value' , '^[a-z]*$' , $True ) }","title":"Match"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#nothasfield","text":"The NotHasField assertion method checks the object does not have any of the specified fields. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of one or more fields to check. By default, a case insensitive compare is used. If more than one field is specified, all must not exist. caseSensitive (optional) - Use a case sensitive compare of the field name. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' exists. Examples: Rule 'NotHasField' { $Assert . NotHasField ( $TargetObject , 'Name' ) $Assert . NotHasField ( $TargetObject , 'tag.Environment' , $True ) $Assert . NotHasField ( $TargetObject , @( 'tag.Environment' , 'tag.Env' ), $True ) }","title":"NotHasField"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#notin","text":"The NotIn assertion method checks the field value is not in a set of values. The field value can either be an integer, array, float, or string. When the field value is an array, none of the items must be included in the set. If the field does not exist at all, it is not in the set and passes. To check the field exists combine this assertion method with HasFieldValue . The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. values - An array values that the field value is compared against. When an empty array is specified, NotIn will always pass. caseSensitive (optional) - Use a case sensitive compare of the field value. Case is ignored by default. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The parameter 'values' is null. The field value '{0}' was in the set. Examples: Rule 'In' { $Assert . NotIn ( $TargetObject , 'Sku.tier' , @( 'Free' , 'Shared' , 'Basic' )) $Assert . NotIn ( $TargetObject , 'Sku.tier' , @( 'Free' , 'Shared' , 'Basic' ), $True ) }","title":"NotIn"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#notmatch","text":"The NotMatch assertion method checks the field value does not match a regular expression pattern. If the field does not exist at all, it does not match and passes. To check the field exists combine this assertion method with HasFieldValue . The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. pattern - A regular expression pattern to match. caseSensitive (optional) - Use a case sensitive compare of the field value. Case is ignored by default. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field value '{0}' is not a string. The field value '{0}' matches the pattern '{1}'. Examples: Rule 'NotMatch' { $Assert . NotMatch ( $TargetObject , 'value' , '^[a-z]*$' ) $Assert . NotMatch ( $TargetObject , 'value' , '^[a-z]*$' , $True ) }","title":"NotMatch"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#notnull","text":"The NotNull assertion method checks the field value of the object is not null. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' does not exist. The field value '{0}' is null. Examples: Rule 'NotNull' { $Assert . NotNull ( $TargetObject , 'Name' ) $Assert . NotNull ( $TargetObject , 'tag.Environment' ) }","title":"NotNull"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#notwithinpath","text":"The NotWithinPath assertion method checks the file is not within a specified path. Checks use file system case-sensitivity rules by default. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field containing a file path. When the field is InputFileInfo or FileInfo , PSRule will automatically resolve the file path. path - An array of one or more directory paths to check. Only one path must match. caseSensitive (optional) - Determines if case-sensitive path matching is used. This can be set to $True or $False . When not set or $Null , the case-sensitivity rules of the working path file system will be used. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The parameter 'path' is null or empty. The field '{0}' does not exist. The file '{0}' is within the path '{1}'. Examples: Rule 'NotWithinPath' { # The file must not be within either policy/ or security/ sub-directories. $Assert . NotWithinPath ( $TargetObject , 'FullName' , @( 'policy/' , 'security/' )); }","title":"NotWithinPath"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#null","text":"The Null assertion method checks the field value of the object is null. A field value is null if any of the following are true: The field does not exist. The field value is $Null . The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field value '{0}' is not null. Examples: Rule 'Null' { $Assert . Null ( $TargetObject , 'NotField' ) $Assert . Null ( $TargetObject , 'tag.NullField' ) }","title":"Null"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#nullorempty","text":"The NullOrEmpty assertion method checks the field value of the object is null or empty. A field value is null or empty if any of the following are true: The field does not exist. The field value is $Null . The field value is an empty array or collection. The field value is an empty string '' . The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' is not empty. Examples: Rule 'NullOrEmpty' { $Assert . NullOrEmpty ( $TargetObject , 'Name' ) $Assert . NullOrEmpty ( $TargetObject , 'tag.Environment' ) }","title":"NullOrEmpty"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#typeof","text":"The TypeOf assertion method checks the field value is a specified type. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. type - One or more specified types to check. The field value only has to match a single type of more than one type is specified. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The parameter 'type' is null or empty. The field '{0}' does not exist. The field value '{0}' is null. The field value '{2}' of type {1} is not {0}. Examples: Rule 'TypeOf' { # Require Value1 to be [int] $Assert . TypeOf ( $TargetObject , 'Value1' , [int] ) # Require Value1 to be [int] or [long] $Assert . TypeOf ( $TargetObject , 'Value1' , @( [int], [long] )) }","title":"TypeOf"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#setof","text":"The SetOf assertion method checks the field value only includes all of the specified values. The field value must be an array or collection. Specified values can be included in the field value in any order. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. values - An array of values that the field value is compared against. caseSensitive (optional) - Use a case sensitive compare of the field value. Case is ignored by default. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The parameter 'values' is null. The field '{0}' does not exist. The field '{0}' is not enumerable. The field '{0}' did not contain '{1}'. The field '{0}' has '{1}' items instead of '{2}'. Examples: Rule 'Subset' { $Assert . SetOf ( $TargetObject , 'zones' , @( '1' , '2' , '3' )) }","title":"SetOf"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#startswith","text":"The StartsWith assertion method checks the field value starts with the specified prefix. Optionally a case-sensitive compare can be used, however case is ignored by default. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. prefix - A prefix or an array of prefixes to compare the field value with. Only one prefix must match. When an empty array of prefixes is specified or prefix is an empty string, StartsWith always passes. caseSensitive (optional) - Use a case sensitive compare of the field value. Case is ignored by default. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The parameter 'prefix' is null. The field '{0}' does not exist. The field value '{0}' is not a string. The field '{0}' does not start with '{1}'. Examples: Rule 'StartsWith' { $Assert . StartsWith ( $TargetObject , 'ResourceGroupName' , 'rg-' ) $Assert . StartsWith ( $TargetObject , 'Name' , @( 'st' , 'diag' ), $True ) }","title":"StartsWith"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#subset","text":"The Subset assertion method checks the field value includes all of the specified values. The field value may also contain additional values that are not specified in the values parameter. The field value must be an array or collection. Specified values can be included in the field value in any order. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. values - An array of values that the field value is compared against. When an empty array is specified, Subset will always pass. caseSensitive (optional) - Use a case sensitive compare of the field value. Case is ignored by default. unique (optional) - A boolean value that indicates if the items must be unique. When true the field value must not contain duplicate items. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The parameter 'values' is null. The field '{0}' does not exist. The field '{0}' is not enumerable. The field '{0}' did not contain '{1}'. The field '{0}' included multiple instances of '{1}'. Examples: Rule 'Subset' { $Assert . Subset ( $TargetObject , 'logs' , @( 'cluster-autoscaler' , 'kube-apiserver' , 'kube-scheduler' ), $True , $True ) }","title":"Subset"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#version","text":"The Version assertion method checks the field value is a valid semantic version. A constraint can optionally be provided to require the semantic version to be within a range. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field to check. This is a case insensitive compare. constraint (optional) - A version constraint, see below for details of version constrain format. includePrerelease (optional) - Determines if prerelease versions are included. Unless specified this defaults to $False . The following are supported constraints: version - Must match version exactly. This also accepts the following prefixes; = , v , V . e.g. 1.2.3 , =1.2.3 >version - Must be greater than version. e.g. >1.2.3 >=version - Must be greater than or equal to version. e.g. >=1.2.3 <version - Must be less than version. e.g. <1.2.3 <=version - Must be less than or equal to version. e.g. <=1.2.3 ^version - Compatible with version. e.g. ^1.2.3 - >=1.2.3 , <2.0.0 ~version - Approximately equivalent to version e.g. ~1.2.3 - >=1.2.3 , <1.3.0 An empty, null or * constraint matches all valid semantic versions. Multiple constraints can be joined together: Use a space to separate multiple constraints, each must be true ( logical AND ). Separates constraint sets with the double pipe || . Only one constraint set must be true ( logical OR ). By example: 1.2.3 || >=3.4.5 <5.0.0 results in: Pass: 1.2.3 , 3.4.5 , 3.5.0 , 4.9.9 . Fail: 3.0.0 , 5.0.0 . Handling for prerelease versions: Constraints and versions containing prerelease identifiers are supported. i.e. >=1.2.3-build.1 or 1.2.3-build.1 . A version containing a prerelease identifer follows semantic versioning rules. i.e. 1.2.3-alpha < 1.2.3-alpha.1 < 1.2.3-alpha.beta < 1.2.3-beta < 1.2.3-beta.2 < 1.2.3-beta.11 < 1.2.3-rc.1 < 1.2.3 . A constraint without a prerelease identifer will only match a stable version by default. Set includePrerelease to $True to include prerelease versions. Constraints with a prerelease identifer will only match: Matching prerelease versions of the same major.minor.patch version by default. Set includePrerelease to $True to include prerelease versions of all matching versions. Alternatively use the @pre or @prerelease flag in a constraint. Matching stable versions. By example: >=1.2.3 results in: Pass: 1.2.3 , 9.9.9 . Fail: 1.2.3-build.1 , 9.9.9-build.1 . >=1.2.3-0 results in: Pass: 1.2.3 , 1.2.3-build.1 , 9.9.9 . Fail: 9.9.9-build.1 . <1.2.3 results in: Pass: 1.2.2 , 1.0.0 . Fail: 1.0.0-build.1 , 1.2.3-build.1 . <1.2.3-0 results in: Pass: 1.2.2 , 1.0.0 . Fail: 1.0.0-build.1 , 1.2.3-build.1 . @pre >=1.2.3 results in: Pass: 1.2.3 , 9.9.9 , 9.9.9-build.1 Fail: 1.2.3-build.1 . @pre >=1.2.3-0 results in: Pass: 1.2.3 , 1.2.3-build.1 , 9.9.9 , 9.9.9-build.1 . Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The field '{0}' does not exist. The field value '{0}' is not a version string. The version '{0}' does not match the constraint '{1}'. Examples: Rule 'ValidVersion' { $Assert . Version ( $TargetObject , 'version' ) } Rule 'MinimumVersion' { $Assert . Version ( $TargetObject , 'version' , '>=1.2.3' ) } Rule 'MinimumVersionWithPrerelease' { $Assert . Version ( $TargetObject , 'version' , '>=1.2.3-0' , $True ) } Rule 'MinimumVersionWithFlag' { $Assert . Version ( $TargetObject , 'version' , '@pre >=1.2.3-0' ) }","title":"Version"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#withinpath","text":"The WithinPath assertion method checks if the file path is within a required path. Checks use file system case-sensitivity rules by default. The following parameters are accepted: inputObject - The object being checked for the specified field. field - The name of the field containing a file path. When the field is InputFileInfo or FileInfo , PSRule will automatically resolve the file path. path - An array of one or more directory paths to check. Only one path must match. caseSensitive (optional) - Determines if case-sensitive path matching is used. This can be set to $True or $False . When not set or $Null , the case-sensitivity rules of the working path file system will be used. Reasons include: The parameter 'inputObject' is null. The parameter 'field' is null or empty. The parameter 'path' is null or empty. The field '{0}' does not exist. The file '{0}' is not within the path '{1}'. Examples: Rule 'WithinPath' { # Require the file to be within either policy/ or security/ sub-directories. $Assert . WithinPath ( $TargetObject , 'FullName' , @( 'policy/' , 'security/' )); }","title":"WithinPath"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#advanced-usage","text":"The AssertResult object returned from assertion methods: Handles pass/ fail conditions and collection of reason information. Allows rules to implement their own handling or forward it up the stack to affect the rule outcome. The following properties are available: Result - Either $True (Pass) or $False (Fail). The following methods are available: AddReason(<string> text) - Can be used to append additional reasons to the result. A reason can only be set if the assertion failed. Reason text should be localized before calling this method. Localization can be done using the $LocalizedData automatic variable. WithReason(<string> text, <bool> replace) - Can be used to append or replace reasons on the result. In addition, WithReason can be chained. Reason(<string> text, params <object[]> args) - Replaces the reason on the results with a formatted string. This method can be chained. For usage see examples below. ReasonIf(<bool> condition, <string> text, params <object[]> args) - Replaces the reason if the condition is true. This method can be chained, similar to Reason . GetReason() - Gets any reasons currently associated with the failed result. Complete() - Returns $True (Pass) or $False (Fail) to the rule record. If the assertion failed, any reasons are automatically added to the rule record. To read the result without adding reason to the rule record use the Result property. Ignore() - Ignores the result. Nothing future is returned and any reasons are cleared. Use this method when implementing custom handling. Use of Complete is optional, uncompleted results are automatically completed after the rule has executed. Uncompleted results may return reasons out of sequence. Using these advanced methods is not supported in rule script pre-conditions. In this example, Complete is used to find the first field with an empty value. Rule 'Assert.HasFieldValue' { $Assert . HasFieldValue ( $TargetObject , 'Name' ). Complete () -and $Assert . HasFieldValue ( $TargetObject , 'Type' ). Complete () -and $Assert . HasFieldValue ( $TargetObject , 'Value' ). Complete () } In this example, the built-in reason is replaced with a custom reason, and immediately returned. The reason text is automatically formatted with any parameters provided. Rule 'Assert.HasCustomValue' { $Assert . HasDefaultValue ( $TargetObject , 'value' , 'test' ). Reason ( 'The field {0} is using a non-default value: {1}' , 'value' , $TargetObject . value ) # With localized string $Assert . HasDefaultValue ( $TargetObject , 'value' , 'test' ). Reason ( $LocalizedData . NonDefaultValue , 'value' , $TargetObject . value ) }","title":"Advanced usage"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#downstream-issues","text":"Before PSRule performs analysis external tools or rules modules may have already performed analysis. Issues identified by downstream tools can be consumed by PSRule using the _PSRule.issue property. If a _PSRule property exists with issue sub-property PSRule will consume issue as an array of issues. Each issue has the following properties: type - The issue type. Issues are filtered by type. name - The name of a specific issue. message - The reason message for the issue. To get issues for an object use the Get or Any methods. # Get an array of all issues for the current object. $PSRule . Issue . Get (); # Get an array of issues of a specific type. $PSRule . Issue . Get ( 'CustomIssue' ); # Return true of any issues exist. $PSRule . Issue . Any (); # Return true of any issues of a specific type exist. $PSRule . Issue . Any ( 'CustomIssue' ); For example: # Synopsis: Fail if the object has any 'PSRule.Rules.Azure.Parameter.Insecure' issues. Rule 'IssueReportTest' { $Assert . Create ( $PSRule . Issue . Get ( 'PSRule.Rules.Azure.Parameter.Insecure' )); }","title":"Downstream issues"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#authoring-assertion-methods","text":"The following built-in helper methods are provided for working with $Assert when authoring new assertion methods: Create(<bool> condition, <string> reason, params <object[]> args) - Returns a result either pass or fail assertion result. Additional arguments can be provided to format the custom reason string. Create(<TargetIssueInfo[]>) - Returns a result based on reported downstream issues. Pass() - Returns a pass assertion result. Fail() - Results a fail assertion result. Fail(<string> reason, params <object[]> args) - Results a fail assertion result with a custom reason. Additional arguments can be provided to format the custom reason string.","title":"Authoring assertion methods"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#aggregating-assertion-methods","text":"The following built-in helper methods are provided for aggregating assertion results: AnyOf(<AssertResult[]> results) - Results from assertion methods are aggregated into a single result. If any result is a pass, the result is a pass. If all results are fails, the result is a fail and any reasons are added to the result. If no results are provided, the result is a fail. AllOf(<AssertResult[]> results) - Results from assertion methods are aggregated into a single result. If all results are passes, the result is a pass. If any result is a fail, the result is a fail and any reasons are added to the result. If no results are provided, the result is a fail. For example: Rule 'Assert.HasFieldValue' { $Assert . AllOf ( $Assert . HasFieldValue ( $TargetObject , 'Name' ), $Assert . HasFieldValue ( $TargetObject , 'Type' ), $Assert . HasFieldValue ( $TargetObject , 'Value' ) ) }","title":"Aggregating assertion methods"},{"location":"concepts/PSRule/en-US/about_PSRule_Assert/#links","text":"about_PSRule_Variables","title":"Links"},{"location":"concepts/PSRule/en-US/about_PSRule_Badges/","text":"Badges # Describes using the badge API with PSRule. Description # PSRule executes rules to validate an object from input. When processing input it may be necessary to perform custom actions before or after rules execute. Conventions provide an extensibility point that can be shipped with or external to standard rules. The badge API can be used to create badges within a convention. Using the API # PSRule provides the $PSRule built-in variable that exposes the badge API. By using the $PSRule.Badges.Create method you can create a standard or custom badge. The create method provides the following overloads: // Create a badge for the worst case of an analyzed object. IBadge Create ( InvokeResult result ); // Create a badge for the worst case of all analyzed objects. IBadge Create ( IEnumerable < InvokeResult > result ); // Create a custom badge. IBadge Create ( string title , BadgeType type , string label ); A badge once created can be read as a string or written to disk with the following methods: // Get the badge as SVG text content. string ToSvg (); // Write the SVG badge content directly to disk. void ToFile ( string path ); Defining conventions # To define a convention, add a Export-PSRuleConvention block within a .Rule.ps1 file. The .Rule.ps1 must be in an included path or module with -Path or -Module . The Export-PSRuleConvention block works similar to the Rule block. Each convention must have a unique name. Currently the badge API support creating badges in the -End block. For example: # Synopsis: A convention that generates a badge for an aggregate result. Export-PSRuleConvention 'Local.Aggregate' -End { $PSRule . Badges . Create ( $PSRule . Output ). ToFile ( 'out/badges/aggregate.svg' ); } # Synopsis: A convention that generates a custom badge. Export-PSRuleConvention 'Local.CustomBadge' -End { $PSRule . Badges . Create ( 'PSRule' , [PSRule.Badges.BadgeType] :: Success , 'OK' ). ToFile ( 'out/badges/custom.svg' ); } Using conventions # A convention can be included by using the -Convention parameter when executing a PSRule cmdlet. Alternatively, conventions can be included with options. To use a convention specify the name of the convention by name. For example: Invoke-PSRule -Convention 'Local.Aggregate' ; Links # Invoke-PSRule","title":"Badges"},{"location":"concepts/PSRule/en-US/about_PSRule_Badges/#badges","text":"Describes using the badge API with PSRule.","title":"Badges"},{"location":"concepts/PSRule/en-US/about_PSRule_Badges/#description","text":"PSRule executes rules to validate an object from input. When processing input it may be necessary to perform custom actions before or after rules execute. Conventions provide an extensibility point that can be shipped with or external to standard rules. The badge API can be used to create badges within a convention.","title":"Description"},{"location":"concepts/PSRule/en-US/about_PSRule_Badges/#using-the-api","text":"PSRule provides the $PSRule built-in variable that exposes the badge API. By using the $PSRule.Badges.Create method you can create a standard or custom badge. The create method provides the following overloads: // Create a badge for the worst case of an analyzed object. IBadge Create ( InvokeResult result ); // Create a badge for the worst case of all analyzed objects. IBadge Create ( IEnumerable < InvokeResult > result ); // Create a custom badge. IBadge Create ( string title , BadgeType type , string label ); A badge once created can be read as a string or written to disk with the following methods: // Get the badge as SVG text content. string ToSvg (); // Write the SVG badge content directly to disk. void ToFile ( string path );","title":"Using the API"},{"location":"concepts/PSRule/en-US/about_PSRule_Badges/#defining-conventions","text":"To define a convention, add a Export-PSRuleConvention block within a .Rule.ps1 file. The .Rule.ps1 must be in an included path or module with -Path or -Module . The Export-PSRuleConvention block works similar to the Rule block. Each convention must have a unique name. Currently the badge API support creating badges in the -End block. For example: # Synopsis: A convention that generates a badge for an aggregate result. Export-PSRuleConvention 'Local.Aggregate' -End { $PSRule . Badges . Create ( $PSRule . Output ). ToFile ( 'out/badges/aggregate.svg' ); } # Synopsis: A convention that generates a custom badge. Export-PSRuleConvention 'Local.CustomBadge' -End { $PSRule . Badges . Create ( 'PSRule' , [PSRule.Badges.BadgeType] :: Success , 'OK' ). ToFile ( 'out/badges/custom.svg' ); }","title":"Defining conventions"},{"location":"concepts/PSRule/en-US/about_PSRule_Badges/#using-conventions","text":"A convention can be included by using the -Convention parameter when executing a PSRule cmdlet. Alternatively, conventions can be included with options. To use a convention specify the name of the convention by name. For example: Invoke-PSRule -Convention 'Local.Aggregate' ;","title":"Using conventions"},{"location":"concepts/PSRule/en-US/about_PSRule_Badges/#links","text":"Invoke-PSRule","title":"Links"},{"location":"concepts/PSRule/en-US/about_PSRule_Baseline/","text":"Baselines # Describes usage of baselines within PSRule. Description # PSRule lets you define a baseline. A baseline includes a set of rule and configuration options that are used for evaluating objects. The following baseline options can be configured: Binding.Field Binding.IgnoreCase Binding.NameSeparator Binding.PreferTargetInfo Binding.TargetName Binding.TargetType Binding.UseQualifiedName Configuration Rule.Include Rule.IncludeLocal Rule.Exclude Rule.Tag Baseline options can be: Included as a baseline spec within a YAML or JSON file. When using this method, multiple baseline specs can be defined within the same YAML/JSON file. Each YAML baseline spec is separated using --- . Each JSON baseline spec is separated by JSON objects in a JSON array. Set within a workspace options file like ps-rule.yaml or ps-rule.json . Only a single baseline can be specified. See about_PSRule_Options for details on using this method. Baseline specs # YAML baseline specs are saved within a YAML file with a .Rule.yaml or .Rule.yml extension, for example Baseline.Rule.yaml . JSON baseline specs are saved within a file with a .Rule.json or .Rule.jsonc extension, for example Baseline.Rule.json . Use .jsonc to view JSON with Comments in Visual Studio Code. To define a YAML baseline spec use the following structure: --- # Synopsis: <synopsis> apiVersion : github.com/microsoft/PSRule/v1 kind : Baseline metadata : name : <name> annotations : { } spec : # One or more baseline options binding : { } rule : { } configuration : { } For example: --- # Synopsis: This is an example baseline apiVersion : github.com/microsoft/PSRule/v1 kind : Baseline metadata : name : Baseline1 spec : binding : field : id : - ResourceId targetName : - Name - ResourceName - ResourceGroupName targetType : - ResourceType rule : include : - Rule1 - Rule2 configuration : allowedLocations : - 'Australia East' - 'Australia South East' --- # Synopsis: This is an example baseline apiVersion : github.com/microsoft/PSRule/v1 kind : Baseline metadata : name : Baseline2 spec : binding : targetName : - Name - ResourceName - ResourceGroupName targetType : - ResourceType rule : include : - Rule1 - Rule3 configuration : allowedLocations : - 'Australia East' To define a JSON baseline spec use the following structure: [ { // Sy n opsis : <sy n opsis> \"apiVersion\" : \"github.com/microsoft/PSRule/v1\" , \"kind\" : \"Baseline\" , \"metadata\" : { \"name\" : \"<name>\" , \"annotations\" : {} }, \"spec\" : { \"binding\" : {}, \"rule\" : {}, \"configuration\" : {} } } ] For example: [ { // Sy n opsis : This is a n example baseli ne \"apiVersion\" : \"github.com/microsoft/PSRule/v1\" , \"kind\" : \"Baseline\" , \"metadata\" : { \"name\" : \"Baseline1\" }, \"spec\" : { \"binding\" : { \"field\" : { \"id\" : [ \"ResourceId\" ] }, \"targetName\" : [ \"Name\" , \"ResourceName\" , \"ResourceGroupName\" ], \"targetType\" : [ \"ResourceType\" ] }, \"rule\" : { \"include\" : [ \"Rule1\" , \"Rule2\" ] }, \"configuration\" : { \"allowedLocations\" : [ \"Australia East\" , \"Australia South East\" ] } } }, { // Sy n opsis : This is a n example baseli ne \"apiVersion\" : \"github.com/microsoft/PSRule/v1\" , \"kind\" : \"Baseline\" , \"metadata\" : { \"name\" : \"Baseline2\" }, \"spec\" : { \"binding\" : { \"targetName\" : [ \"Name\" , \"ResourceName\" , \"ResourceGroupName\" ], \"targetType\" : [ \"ResourceType\" ] }, \"rule\" : { \"include\" : [ \"Rule1\" , \"Rule3\" ] }, \"configuration\" : { \"allowedLocations\" : [ \"Australia East\" ] } } } ] Baseline scopes # When baseline options are set, PSRule uses the following order to determine precedence. Parameter - -Name and -Tag . Explicit - A named baseline specified with -Baseline . Workspace - Included in ps-rule.yaml or specified on the command line with -Option . Module - A baseline object included in a .Rule.yaml or .Rule.json file. After precedence is determined, baselines are merged and null values are ignored, such that: Annotations # Additional baseline annotations can be provided as key/ value pairs. Annotations can be used to provide additional information that is available in Get-PSRuleBaseline output. The following reserved annotation exists: obsolete - Marks the baseline as obsolete when set to true . PSRule will generate a warning when an obsolete baseline is used. YAML example: --- # Synopsis: This is an example baseline that is obsolete apiVersion : github.com/microsoft/PSRule/v1 kind : Baseline metadata : name : ObsoleteBaseline annotations : obsolete : true spec : { } JSON example: [ { // Sy n opsis : This is a n example baseli ne t ha t is obsole te \"apiVersion\" : \"github.com/microsoft/PSRule/v1\" , \"kind\" : \"Baseline\" , \"metadata\" : { \"name\" : \"ObsoleteBaseline\" , \"annotations\" : { \"obsolete\" : true } }, \"spec\" : {} } ] Examples # Example Baseline.Rule.yaml # # Example Baseline.Rule.yaml --- # Synopsis: This is an example baseline apiVersion : github.com/microsoft/PSRule/v1 kind : Baseline metadata : name : TestBaseline1 spec : binding : targetName : - AlternateName targetType : - kind rule : include : - 'WithBaseline' configuration : key1 : value1 --- # Synopsis: This is an example baseline apiVersion : github.com/microsoft/PSRule/v1 kind : Baseline metadata : name : TestBaseline2 spec : binding : targetName : - AlternateName targetType : - kind rule : include : - 'WithBaseline' configuration : key1 : value1 Example Baseline.Rule.json # // Example Baseli ne .Rule.jso n [ { // Sy n opsis : This is a n example baseli ne \"apiVersion\" : \"github.com/microsoft/PSRule/v1\" , \"kind\" : \"Baseline\" , \"metadata\" : { \"name\" : \"TestBaseline1\" }, \"spec\" : { \"binding\" : { \"targetName\" : [ \"AlternateName\" ], \"targetType\" : [ \"kind\" ] }, \"rule\" : { \"include\" : [ \"WithBaseline\" ] }, \"configuration\" : { \"key1\" : \"value1\" } } }, { // Sy n opsis : This is a n example baseli ne \"apiVersion\" : \"github.com/microsoft/PSRule/v1\" , \"kind\" : \"Baseline\" , \"metadata\" : { \"name\" : \"TestBaseline2\" }, \"spec\" : { \"binding\" : { \"targetName\" : [ \"AlternateName\" ], \"targetType\" : [ \"kind\" ] }, \"rule\" : { \"include\" : [ \"WithBaseline\" ] }, \"configuration\" : { \"key1\" : \"value1\" } } } ]","title":"Baselines"},{"location":"concepts/PSRule/en-US/about_PSRule_Baseline/#baselines","text":"Describes usage of baselines within PSRule.","title":"Baselines"},{"location":"concepts/PSRule/en-US/about_PSRule_Baseline/#description","text":"PSRule lets you define a baseline. A baseline includes a set of rule and configuration options that are used for evaluating objects. The following baseline options can be configured: Binding.Field Binding.IgnoreCase Binding.NameSeparator Binding.PreferTargetInfo Binding.TargetName Binding.TargetType Binding.UseQualifiedName Configuration Rule.Include Rule.IncludeLocal Rule.Exclude Rule.Tag Baseline options can be: Included as a baseline spec within a YAML or JSON file. When using this method, multiple baseline specs can be defined within the same YAML/JSON file. Each YAML baseline spec is separated using --- . Each JSON baseline spec is separated by JSON objects in a JSON array. Set within a workspace options file like ps-rule.yaml or ps-rule.json . Only a single baseline can be specified. See about_PSRule_Options for details on using this method.","title":"Description"},{"location":"concepts/PSRule/en-US/about_PSRule_Baseline/#baseline-specs","text":"YAML baseline specs are saved within a YAML file with a .Rule.yaml or .Rule.yml extension, for example Baseline.Rule.yaml . JSON baseline specs are saved within a file with a .Rule.json or .Rule.jsonc extension, for example Baseline.Rule.json . Use .jsonc to view JSON with Comments in Visual Studio Code. To define a YAML baseline spec use the following structure: --- # Synopsis: <synopsis> apiVersion : github.com/microsoft/PSRule/v1 kind : Baseline metadata : name : <name> annotations : { } spec : # One or more baseline options binding : { } rule : { } configuration : { } For example: --- # Synopsis: This is an example baseline apiVersion : github.com/microsoft/PSRule/v1 kind : Baseline metadata : name : Baseline1 spec : binding : field : id : - ResourceId targetName : - Name - ResourceName - ResourceGroupName targetType : - ResourceType rule : include : - Rule1 - Rule2 configuration : allowedLocations : - 'Australia East' - 'Australia South East' --- # Synopsis: This is an example baseline apiVersion : github.com/microsoft/PSRule/v1 kind : Baseline metadata : name : Baseline2 spec : binding : targetName : - Name - ResourceName - ResourceGroupName targetType : - ResourceType rule : include : - Rule1 - Rule3 configuration : allowedLocations : - 'Australia East' To define a JSON baseline spec use the following structure: [ { // Sy n opsis : <sy n opsis> \"apiVersion\" : \"github.com/microsoft/PSRule/v1\" , \"kind\" : \"Baseline\" , \"metadata\" : { \"name\" : \"<name>\" , \"annotations\" : {} }, \"spec\" : { \"binding\" : {}, \"rule\" : {}, \"configuration\" : {} } } ] For example: [ { // Sy n opsis : This is a n example baseli ne \"apiVersion\" : \"github.com/microsoft/PSRule/v1\" , \"kind\" : \"Baseline\" , \"metadata\" : { \"name\" : \"Baseline1\" }, \"spec\" : { \"binding\" : { \"field\" : { \"id\" : [ \"ResourceId\" ] }, \"targetName\" : [ \"Name\" , \"ResourceName\" , \"ResourceGroupName\" ], \"targetType\" : [ \"ResourceType\" ] }, \"rule\" : { \"include\" : [ \"Rule1\" , \"Rule2\" ] }, \"configuration\" : { \"allowedLocations\" : [ \"Australia East\" , \"Australia South East\" ] } } }, { // Sy n opsis : This is a n example baseli ne \"apiVersion\" : \"github.com/microsoft/PSRule/v1\" , \"kind\" : \"Baseline\" , \"metadata\" : { \"name\" : \"Baseline2\" }, \"spec\" : { \"binding\" : { \"targetName\" : [ \"Name\" , \"ResourceName\" , \"ResourceGroupName\" ], \"targetType\" : [ \"ResourceType\" ] }, \"rule\" : { \"include\" : [ \"Rule1\" , \"Rule3\" ] }, \"configuration\" : { \"allowedLocations\" : [ \"Australia East\" ] } } } ]","title":"Baseline specs"},{"location":"concepts/PSRule/en-US/about_PSRule_Baseline/#baseline-scopes","text":"When baseline options are set, PSRule uses the following order to determine precedence. Parameter - -Name and -Tag . Explicit - A named baseline specified with -Baseline . Workspace - Included in ps-rule.yaml or specified on the command line with -Option . Module - A baseline object included in a .Rule.yaml or .Rule.json file. After precedence is determined, baselines are merged and null values are ignored, such that:","title":"Baseline scopes"},{"location":"concepts/PSRule/en-US/about_PSRule_Baseline/#annotations","text":"Additional baseline annotations can be provided as key/ value pairs. Annotations can be used to provide additional information that is available in Get-PSRuleBaseline output. The following reserved annotation exists: obsolete - Marks the baseline as obsolete when set to true . PSRule will generate a warning when an obsolete baseline is used. YAML example: --- # Synopsis: This is an example baseline that is obsolete apiVersion : github.com/microsoft/PSRule/v1 kind : Baseline metadata : name : ObsoleteBaseline annotations : obsolete : true spec : { } JSON example: [ { // Sy n opsis : This is a n example baseli ne t ha t is obsole te \"apiVersion\" : \"github.com/microsoft/PSRule/v1\" , \"kind\" : \"Baseline\" , \"metadata\" : { \"name\" : \"ObsoleteBaseline\" , \"annotations\" : { \"obsolete\" : true } }, \"spec\" : {} } ]","title":"Annotations"},{"location":"concepts/PSRule/en-US/about_PSRule_Baseline/#examples","text":"","title":"Examples"},{"location":"concepts/PSRule/en-US/about_PSRule_Baseline/#example-baselineruleyaml","text":"# Example Baseline.Rule.yaml --- # Synopsis: This is an example baseline apiVersion : github.com/microsoft/PSRule/v1 kind : Baseline metadata : name : TestBaseline1 spec : binding : targetName : - AlternateName targetType : - kind rule : include : - 'WithBaseline' configuration : key1 : value1 --- # Synopsis: This is an example baseline apiVersion : github.com/microsoft/PSRule/v1 kind : Baseline metadata : name : TestBaseline2 spec : binding : targetName : - AlternateName targetType : - kind rule : include : - 'WithBaseline' configuration : key1 : value1","title":"Example Baseline.Rule.yaml"},{"location":"concepts/PSRule/en-US/about_PSRule_Baseline/#example-baselinerulejson","text":"// Example Baseli ne .Rule.jso n [ { // Sy n opsis : This is a n example baseli ne \"apiVersion\" : \"github.com/microsoft/PSRule/v1\" , \"kind\" : \"Baseline\" , \"metadata\" : { \"name\" : \"TestBaseline1\" }, \"spec\" : { \"binding\" : { \"targetName\" : [ \"AlternateName\" ], \"targetType\" : [ \"kind\" ] }, \"rule\" : { \"include\" : [ \"WithBaseline\" ] }, \"configuration\" : { \"key1\" : \"value1\" } } }, { // Sy n opsis : This is a n example baseli ne \"apiVersion\" : \"github.com/microsoft/PSRule/v1\" , \"kind\" : \"Baseline\" , \"metadata\" : { \"name\" : \"TestBaseline2\" }, \"spec\" : { \"binding\" : { \"targetName\" : [ \"AlternateName\" ], \"targetType\" : [ \"kind\" ] }, \"rule\" : { \"include\" : [ \"WithBaseline\" ] }, \"configuration\" : { \"key1\" : \"value1\" } } } ]","title":"Example Baseline.Rule.json"},{"location":"concepts/PSRule/en-US/about_PSRule_Conventions/","text":"Conventions # Describes PSRule Conventions including how to use and author them. Description # PSRule executes rules to validate an object from input. When processing input it may be necessary to perform custom actions before or after rules execute. Conventions provide an extensibility point that can be shipped with or external to standard rules. Each convention, hooks into one or more places within the pipeline. Using conventions # A convention can be included by using the -Convention parameter when executing a PSRule cmdlet. Alternatively, conventions can be included with options. To use a convention specify the name of the convention by name. For example: Invoke-PSRule -Convention 'ExampleConvention' ; If multiple conventions are specified in an array, all are executed in they are specified. As a result, the convention specified last may override state set by earlier conventions. Assert-PSRule -Convention 'ExampleConvention1' , 'ExampleConvention2' ; Defining conventions # To define a convention, add a Export-PSRuleConvention block within a .Rule.ps1 file. The .Rule.ps1 must be in an included path or module with -Path or -Module . The Export-PSRuleConvention block works similar to the Rule block. Each convention must have a unique name. For example: # Synopsis: An example convention. Export-PSRuleConvention 'ExampleConvention' { # Add code here } Initialize Begin Process End blocks # Conventions define four executable blocks Initialize , Begin , Process , End similar to a PowerShell function. Each block is injected in a different part of the pipeline as follows: Initialize occurs once at the beginning of the pipeline. Use Initialize to perform any initialization required by the convention. Begin occurs once per object before the any rules are executed. Use Begin blocks to perform expansion, set data, or alter the object before rules are processed. Process occurs once per object after all rules are executed. Use Process blocks to perform per object tasks such as generate badges. End occurs only once after all objects have been processed. Use End blocks to upload results to an external service. Convention block limitations: Initialize can not use automatic variables except $PSRule . Most methods and properties of $PSRule are not available in Initialize . Begin and Process can not use rule specific variables such as $Rule . These blocks are executed outside of the context of a single rule. End can not use automatic variables except $PSRule . Most methods and properties of $PSRule are not available in End . By default, the Process block used. For example: # Synopsis: The default { } executes the process block Export-PSRuleConvention 'ExampleConvention' { # Process block } # Synopsis: With optional -Process parameter name Export-PSRuleConvention 'ExampleConvention' -Process { # Process block } To use Initialize , Begin , or End explicitly add these blocks. For example: Export-PSRuleConvention 'ExampleConvention' -Process { # Process block } -Begin { # Begin block } -End { # End block } -Initialize { # Initialize block } Including with options # Conventions can be included by name within options in addition to using the -Convention parameter. To specify a convention within YAML options use the following: # Example ps-docs.yaml convention : include : - 'ExampleConvention1' - 'ExampleConvention2' Using within modules # Conventions can be shipped within a module using the same packaging and distribution process as rules. Additionally, conventions shipped within a module can be automatically included. By default, PSRule does not include conventions shipped within a module. To use a convention included in a module use the -Convention parameter or options configuration. A module can automatically include a convention by specifying the convention by name in module configuration. For example: # Example Config.Rule.yaml --- apiVersion : github.com/microsoft/PSRule/v1 kind : ModuleConfig metadata : name : ExampleModule spec : convention : include : - 'ExampleConvention1' - 'ExampleConvention2' Execution order # Conventions are executed in the order they are specified. This is true for Initialize , Begin , Process , and End blocks. i.e. In the following example ExampleConvention1 is execute before ExampleConvention2 . Assert-PSRule -Convention 'ExampleConvention1' , 'ExampleConvention2' ; When conventions are specified from multiple locations PSRule orders conventions as follows: Using -Convention parameter. PSRule options. Module configuration. Links # Invoke-PSRule","title":"Conventions"},{"location":"concepts/PSRule/en-US/about_PSRule_Conventions/#conventions","text":"Describes PSRule Conventions including how to use and author them.","title":"Conventions"},{"location":"concepts/PSRule/en-US/about_PSRule_Conventions/#description","text":"PSRule executes rules to validate an object from input. When processing input it may be necessary to perform custom actions before or after rules execute. Conventions provide an extensibility point that can be shipped with or external to standard rules. Each convention, hooks into one or more places within the pipeline.","title":"Description"},{"location":"concepts/PSRule/en-US/about_PSRule_Conventions/#using-conventions","text":"A convention can be included by using the -Convention parameter when executing a PSRule cmdlet. Alternatively, conventions can be included with options. To use a convention specify the name of the convention by name. For example: Invoke-PSRule -Convention 'ExampleConvention' ; If multiple conventions are specified in an array, all are executed in they are specified. As a result, the convention specified last may override state set by earlier conventions. Assert-PSRule -Convention 'ExampleConvention1' , 'ExampleConvention2' ;","title":"Using conventions"},{"location":"concepts/PSRule/en-US/about_PSRule_Conventions/#defining-conventions","text":"To define a convention, add a Export-PSRuleConvention block within a .Rule.ps1 file. The .Rule.ps1 must be in an included path or module with -Path or -Module . The Export-PSRuleConvention block works similar to the Rule block. Each convention must have a unique name. For example: # Synopsis: An example convention. Export-PSRuleConvention 'ExampleConvention' { # Add code here }","title":"Defining conventions"},{"location":"concepts/PSRule/en-US/about_PSRule_Conventions/#initialize-begin-process-end-blocks","text":"Conventions define four executable blocks Initialize , Begin , Process , End similar to a PowerShell function. Each block is injected in a different part of the pipeline as follows: Initialize occurs once at the beginning of the pipeline. Use Initialize to perform any initialization required by the convention. Begin occurs once per object before the any rules are executed. Use Begin blocks to perform expansion, set data, or alter the object before rules are processed. Process occurs once per object after all rules are executed. Use Process blocks to perform per object tasks such as generate badges. End occurs only once after all objects have been processed. Use End blocks to upload results to an external service. Convention block limitations: Initialize can not use automatic variables except $PSRule . Most methods and properties of $PSRule are not available in Initialize . Begin and Process can not use rule specific variables such as $Rule . These blocks are executed outside of the context of a single rule. End can not use automatic variables except $PSRule . Most methods and properties of $PSRule are not available in End . By default, the Process block used. For example: # Synopsis: The default { } executes the process block Export-PSRuleConvention 'ExampleConvention' { # Process block } # Synopsis: With optional -Process parameter name Export-PSRuleConvention 'ExampleConvention' -Process { # Process block } To use Initialize , Begin , or End explicitly add these blocks. For example: Export-PSRuleConvention 'ExampleConvention' -Process { # Process block } -Begin { # Begin block } -End { # End block } -Initialize { # Initialize block }","title":"Initialize Begin Process End blocks"},{"location":"concepts/PSRule/en-US/about_PSRule_Conventions/#including-with-options","text":"Conventions can be included by name within options in addition to using the -Convention parameter. To specify a convention within YAML options use the following: # Example ps-docs.yaml convention : include : - 'ExampleConvention1' - 'ExampleConvention2'","title":"Including with options"},{"location":"concepts/PSRule/en-US/about_PSRule_Conventions/#using-within-modules","text":"Conventions can be shipped within a module using the same packaging and distribution process as rules. Additionally, conventions shipped within a module can be automatically included. By default, PSRule does not include conventions shipped within a module. To use a convention included in a module use the -Convention parameter or options configuration. A module can automatically include a convention by specifying the convention by name in module configuration. For example: # Example Config.Rule.yaml --- apiVersion : github.com/microsoft/PSRule/v1 kind : ModuleConfig metadata : name : ExampleModule spec : convention : include : - 'ExampleConvention1' - 'ExampleConvention2'","title":"Using within modules"},{"location":"concepts/PSRule/en-US/about_PSRule_Conventions/#execution-order","text":"Conventions are executed in the order they are specified. This is true for Initialize , Begin , Process , and End blocks. i.e. In the following example ExampleConvention1 is execute before ExampleConvention2 . Assert-PSRule -Convention 'ExampleConvention1' , 'ExampleConvention2' ; When conventions are specified from multiple locations PSRule orders conventions as follows: Using -Convention parameter. PSRule options. Module configuration.","title":"Execution order"},{"location":"concepts/PSRule/en-US/about_PSRule_Conventions/#links","text":"Invoke-PSRule","title":"Links"},{"location":"concepts/PSRule/en-US/about_PSRule_Docs/","text":"Documentation # Describes usage of documentation within PSRule. Description # PSRule includes a built-in documentation system that provide culture specific help and metadata for rules. Rule documentation is composed of markdown files that can be optionally shipped with a module. Getting documentation # To get documentation for a rule use the Get-PSRuleHelp cmdlet. For example: Get-PSRuleHelp < rule-name > Each rule can include the following documentation: Annotations - Additional metadata included in results. Synopsis - A brief description on the intended purpose of the rule. Description - A detailed description on the intended purpose of the rule. Recommendation - A detailed explanation of the requirements to pass the rule. Notes - Any additional information or configuration options. Links - Any links to external references. See cmdlet help for detailed information on the Get-PSRuleHelp cmdlet. Online help # Rule documentation may optionally include a link to an online version. When included, the -Online parameter can be used to open the online version in the default web browser. For example: Get-PSRuleHelp < rule-name > -Online Creating documentation # Rule documentation is composed of markdown files, one per rule. When creating rules for more then one culture, a separate markdown file is created per rule per culture. The markdown files for each rule is automatically discovered based on naming convention. Markdown is saved in a file with the same filename as the rule name with the .md extension. The file name should match the same case exactly, with a lower case extension. As an example, the storageAccounts.UseHttps.md markdown file would be created. # Synopsis: Configure storage accounts to only accept encrypted traffic i.e. HTTPS/SMB Rule 'storageAccounts.UseHttps' -If { ResourceType 'Microsoft.Storage/storageAccounts' } { Recommend 'Storage accounts should only allow secure traffic' $TargetObject . Properties . supportsHttpsTrafficOnly } This directory PSRule will look for these markdown files depends on how the rules are packaged: If the rules are loose (not part of a module), PSRule will search for documentation in the .\\<culture>\\ subdirectory relative to where the rule script .ps1 file is located. When the rules are shipped as part of a module, PSRule will search for documentation in the .\\<culture>\\ subdirectory relative to where the module manifest .psd1 file is located. The <culture> subdirectory will be the current culture that PowerShell is executed under (the same as (Get-Culture).Name ). Alternatively, the culture can set by using the -Culture parameter of PSRule cmdlets. The markdown of each file uses following structure. --- {{ Annotations }} --- # {{ Name of rule }} {{ A brief summary of the rule }} ## Description {{ A detailed description of the rule }} ## Recommendation {{ A detailed explanation of the steps required to pass the rule }} ## Notes {{ Additional information or configuration options }} ## Links {{ Links to external references }} Optionally, one or more annotations formatted as YAML key value pairs can be included. i.e. severity: Critical Additional sections such as EXAMPLES can be included although are not exposed with Get-PSRuleHelp . Links # Get-PSRuleHelp","title":"Documentation"},{"location":"concepts/PSRule/en-US/about_PSRule_Docs/#documentation","text":"Describes usage of documentation within PSRule.","title":"Documentation"},{"location":"concepts/PSRule/en-US/about_PSRule_Docs/#description","text":"PSRule includes a built-in documentation system that provide culture specific help and metadata for rules. Rule documentation is composed of markdown files that can be optionally shipped with a module.","title":"Description"},{"location":"concepts/PSRule/en-US/about_PSRule_Docs/#getting-documentation","text":"To get documentation for a rule use the Get-PSRuleHelp cmdlet. For example: Get-PSRuleHelp < rule-name > Each rule can include the following documentation: Annotations - Additional metadata included in results. Synopsis - A brief description on the intended purpose of the rule. Description - A detailed description on the intended purpose of the rule. Recommendation - A detailed explanation of the requirements to pass the rule. Notes - Any additional information or configuration options. Links - Any links to external references. See cmdlet help for detailed information on the Get-PSRuleHelp cmdlet.","title":"Getting documentation"},{"location":"concepts/PSRule/en-US/about_PSRule_Docs/#online-help","text":"Rule documentation may optionally include a link to an online version. When included, the -Online parameter can be used to open the online version in the default web browser. For example: Get-PSRuleHelp < rule-name > -Online","title":"Online help"},{"location":"concepts/PSRule/en-US/about_PSRule_Docs/#creating-documentation","text":"Rule documentation is composed of markdown files, one per rule. When creating rules for more then one culture, a separate markdown file is created per rule per culture. The markdown files for each rule is automatically discovered based on naming convention. Markdown is saved in a file with the same filename as the rule name with the .md extension. The file name should match the same case exactly, with a lower case extension. As an example, the storageAccounts.UseHttps.md markdown file would be created. # Synopsis: Configure storage accounts to only accept encrypted traffic i.e. HTTPS/SMB Rule 'storageAccounts.UseHttps' -If { ResourceType 'Microsoft.Storage/storageAccounts' } { Recommend 'Storage accounts should only allow secure traffic' $TargetObject . Properties . supportsHttpsTrafficOnly } This directory PSRule will look for these markdown files depends on how the rules are packaged: If the rules are loose (not part of a module), PSRule will search for documentation in the .\\<culture>\\ subdirectory relative to where the rule script .ps1 file is located. When the rules are shipped as part of a module, PSRule will search for documentation in the .\\<culture>\\ subdirectory relative to where the module manifest .psd1 file is located. The <culture> subdirectory will be the current culture that PowerShell is executed under (the same as (Get-Culture).Name ). Alternatively, the culture can set by using the -Culture parameter of PSRule cmdlets. The markdown of each file uses following structure. --- {{ Annotations }} --- # {{ Name of rule }} {{ A brief summary of the rule }} ## Description {{ A detailed description of the rule }} ## Recommendation {{ A detailed explanation of the steps required to pass the rule }} ## Notes {{ Additional information or configuration options }} ## Links {{ Links to external references }} Optionally, one or more annotations formatted as YAML key value pairs can be included. i.e. severity: Critical Additional sections such as EXAMPLES can be included although are not exposed with Get-PSRuleHelp .","title":"Creating documentation"},{"location":"concepts/PSRule/en-US/about_PSRule_Docs/#links","text":"Get-PSRuleHelp","title":"Links"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/","text":"Expressions # Describes PSRule expressions and how to use them. Description # PSRule expressions are used within YAML-based rules or selectors to evaluate an object. Expressions are comprised of nested conditions, operators, and comparison properties. The following conditions are available: Contains Count Equals EndsWith Exists Greater GreaterOrEquals HasDefault HasSchema HasValue In IsLower IsString IsUpper Less LessOrEquals Match NotEquals NotIn NotMatch SetOf StartsWith Subset Version The following operators are available: AllOf AnyOf Not The following comparison properties are available: Field Name Type AllOf # The allOf operator is used to require all nested expressions to match. When any nested expression does not match, allOf does not match. This is similar to a logical and operation. Syntax: allOf : <expression[]> For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleAllOf' spec : condition : allOf : # Both Name and Description must exist. - field : 'Name' exists : true - field : 'Description' exists : true --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleAllOf' spec : if : allOf : # Both Name and Description must exist. - field : 'Name' exists : true - field : 'Description' exists : true AnyOf # The anyOf operator is used to require one or more nested expressions to match. When any nested expression matches, allOf matches. This is similar to a logical or operation. Syntax: anyOf : <expression[]> For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleAnyOf' spec : condition : anyOf : # Name and/ or AlternativeName must exist. - field : 'Name' exists : true - field : 'AlternativeName' exists : true --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleAnyOf' spec : if : anyOf : # Name and/ or AlternativeName must exist. - field : 'Name' exists : true - field : 'AlternativeName' exists : true Contains # The contains condition can be used to determine if the operand contains a specified sub-string. One or more strings to compare can be specified. Syntax: contains : <string | array> If the operand is a field, and the field does not exist, contains always returns false . For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleContains' spec : condition : anyOf : - field : 'url' contains : '/azure/' - field : 'url' contains : - 'github.io' - 'github.com' --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleContains' spec : if : anyOf : - field : 'url' contains : '/azure/' - field : 'url' contains : - 'github.io' - 'github.com' Count # The count condition is used to determine if the operand contains a specified number of items. Syntax: count : <int> For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleCount' spec : condition : field : 'items' count : 2 --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleCount' spec : if : field : 'items' count : 2 Equals # The equals condition can be used to compare if the operand is equal to a supplied value. Syntax: equals : <string | int | bool> For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleEquals' spec : condition : field : 'Name' equals : 'TargetObject1' --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleEquals' spec : if : field : 'Name' equals : 'TargetObject1' EndsWith # The endsWith condition can be used to determine if the operand ends with a specified string. One or more strings to compare can be specified. Syntax: endsWith : <string | array> If the operand is a field, and the field does not exist, endsWith always returns false . For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleEndsWith' spec : condition : anyOf : - field : 'hostname' endsWith : '.com' - field : 'hostname' endsWith : - '.com.au' - '.com' --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleEndsWith' spec : if : anyOf : - field : 'hostname' endsWith : '.com' - field : 'hostname' endsWith : - '.com.au' - '.com' Exists # The exists condition determines if the specified field exists. Syntax: exists : <bool> When exists: true , exists will return true if the field exists. When exists: false , exists will return true if the field does not exist. For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleExists' spec : condition : field : 'Name' exists : true --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleExists' spec : if : field : 'Name' exists : true Field # The comparison property field is used with a condition to determine field of the object to evaluate. A field can be: A property name. A key within a hashtable or dictionary. An index in an array or collection. A nested path through an object. Syntax: field : <string> For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleField' spec : condition : field : 'Properties.securityRules[0].name' exists : true --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleField' spec : if : field : 'Properties.securityRules[0].name' exists : true Greater # The greater condition determines if the operand is greater than a supplied value. The field value can either be an integer, float, array, or string. When the field value is: An integer or float, a numerical comparison is used. An array, the number of elements is compared. A string, the length of the string is compared. A DateTime, the number of days from the current time is compared. Syntax: greater : <int> For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleGreater' spec : condition : field : 'Name' greater : 3 --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleGreater' spec : if : field : 'Name' greater : 3 GreaterOrEquals # The greaterOrEquals condition determines if the operand is greater or equal to the supplied value. The field value can either be an integer, float, array, or string. When the field value is: An integer or float, a numerical comparison is used. An array, the number of elements is compared. A string, the length of the string is compared. A DateTime, the number of days from the current time is compared. Syntax: greaterOrEquals : <int> For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleGreaterOrEquals' spec : condition : field : 'Name' greaterOrEquals : 3 --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleGreaterOrEquals' spec : if : field : 'Name' greaterOrEquals : 3 HasDefault # The hasDefault condition determines if the field exists that it is set to the specified value. If the field does not exist, the condition will return true . The following properties are accepted: caseSensitive - Optionally, a case-sensitive comparison can be performed for string values. By default, case-insensitive comparison is performed. Syntax: hasDefault : <string | int | bool> caseSensitive : <bool> For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleHasDefault' spec : condition : field : 'enabled' hasDefault : true --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleHasDefault' spec : if : field : 'enabled' hasDefault : true HasSchema # The hasSchema condition determines if the operand has a $schema property defined. If the $schema property is defined, it must match one of the specified schemas. If a trailing # is specified it is ignored. The following properties are accepted: caseSensitive - Optionally, a case-sensitive comparison can be performed. By default, case-insensitive comparison is performed. ignoreScheme - Optionally, the URI scheme is ignored in the comparison. By default, the scheme is compared. When true , the schema will match if either http:// or https:// is specified. Syntax: hasSchema : <array> caseSensitive : <bool> ignoreScheme : <bool> When hasSchema: [] , hasSchema will return true if any non-empty $schema property is defined. For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleHasSchema' spec : condition : field : '.' hasSchema : - https://schema.management.azure.com/schemas/2019-04-01/deploymentParameters.json# --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleHasSchema' spec : if : field : '.' hasSchema : - https://schema.management.azure.com/schemas/2019-04-01/deploymentParameters.json# - https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json# ignoreScheme : true --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleHasAnySchema' spec : if : field : '.' hasSchema : [] HasValue # The hasValue condition determines if the field exists and has a non-empty value. Syntax: hasValue : <bool> When hasValue: true , hasValue will return true if the field is not empty. When hasValue: false , hasValue will return true if the field is empty. For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleHasValue' spec : condition : field : 'Name' hasValue : true --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleHasValue' spec : if : field : 'Name' hasValue : true In # The in condition can be used to compare if a field contains one of the specified values. Syntax: in : <array> For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleIn' spec : condition : field : 'Name' in : - 'Value1' - 'Value2' --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleIn' spec : if : field : 'Name' in : - 'Value1' - 'Value2' IsLower # The isLower condition determines if the operand is a lowercase string. Syntax: isLower : <bool> When isLower: true , isLower will return true if the operand is a lowercase string. Non-letter characters are ignored. When isLower: false , isLower will return true if the operand is not a lowercase string. If the operand is a field, and the field does not exist isLower always returns false . For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleIsLower' spec : condition : field : 'Name' isLower : true --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleIsLower' spec : if : field : 'Name' isLower : true IsString # The isString condition determines if the operand is a string or other type. Syntax: isString : <bool> When isString: true , isString will return true if the operand is a string. When isString: false , isString will return true if the operand is not a string or is null. If the operand is a field, and the field does not exist isString always returns false . For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleIsString' spec : condition : field : 'Name' isString : true --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleIsString' spec : if : field : 'Name' isString : true IsUpper # The isUpper condition determines if the operand is an uppercase string. Syntax: isUpper : <bool> When isUpper: true , isUpper will return true if the operand is an uppercase string. Non-letter characters are ignored. When isUpper: false , isUpper will return true if the operand is not an uppercase string. If the operand is a field, and the field does not exist isUpper always returns false . For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleIsUpper' spec : condition : field : 'Name' isUpper : true --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleIsUpper' spec : if : field : 'Name' isUpper : true Less # The less condition determines if the operand is less than a supplied value. The field value can either be an integer, float, array, or string. When the field value is: An integer or float, a numerical comparison is used. An array, the number of elements is compared. A string, the length of the string is compared. A DateTime, the number of days from the current time is compared. Syntax: less : <int> For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleLess' spec : condition : field : 'Name' less : 3 --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleLess' spec : if : field : 'Name' less : 3 LessOrEquals # The lessOrEquals condition determines if the operand is less or equal to the supplied value. The field value can either be an integer, float, array, or string. When the field value is: An integer or float, a numerical comparison is used. An array, the number of elements is compared. A string, the length of the string is compared. A DateTime, the number of days from the current time is compared. Syntax: lessOrEquals : <int> For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleLessOrEquals' spec : condition : field : 'Name' lessOrEquals : 3 --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleLessOrEquals' spec : if : field : 'Name' lessOrEquals : 3 Match # The match condition can be used to compare if a field matches a supplied regular expression. Syntax: match : <string> For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleMatch' spec : condition : field : 'Name' match : '$(abc|efg)$' --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleMatch' spec : if : field : 'Name' match : '$(abc|efg)$' Name # The comparison property name is used with a condition to evaluate the target name of the object. The name property must be set to . . Any other value will cause the condition to evaluate to false . Syntax: name : '.' For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleName' spec : condition : name : '.' equals : 'TargetObject1' --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleName' spec : if : name : '.' in : - 'TargetObject1' - 'TargetObject2' Not # The any operator is used to invert the result of the nested expression. When a nested expression matches, not does not match. When a nested expression does not match, not matches. Syntax: not : <expression> For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleNot' spec : condition : not : # The AlternativeName field must not exist. field : 'AlternativeName' exists : true --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleNot' spec : if : not : # The AlternativeName field must not exist. field : 'AlternativeName' exists : true NotEquals # The notEquals condition can be used to compare if a field is equal to a supplied value. Syntax: notEquals : <string | int | bool> For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleNotEquals' spec : condition : field : 'Name' notEquals : 'TargetObject1' --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleNotEquals' spec : if : field : 'Name' notEquals : 'TargetObject1' NotIn # The notIn condition can be used to compare if a field does not contains one of the specified values. Syntax: notIn : <array> For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleNotIn' spec : condition : field : 'Name' notIn : - 'Value1' - 'Value2' --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleNotIn' spec : if : field : 'Name' notIn : - 'Value1' - 'Value2' NotMatch # The notMatch condition can be used to compare if a field does not matches a supplied regular expression. Syntax: notMatch : <string> For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleNotMatch' spec : condition : field : 'Name' notMatch : '$(abc|efg)$' --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleNotMatch' spec : if : field : 'Name' notMatch : '$(abc|efg)$' SetOf # The setOf condition can be used to determine if the operand is a set of specified values. Additionally the following properties are accepted: caseSensitive - Optionally, a case sensitive-comparison can be performed. By default, case-insensitive comparison is performed. Syntax: setOf : <array> caseSensitive : <bool> For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleSetOf' spec : condition : field : 'zones' setOf : - 1 - 2 - 3 caseSensitive : false --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleSetOf' spec : if : field : 'zones' setOf : - 1 - 2 - 3 caseSensitive : false StartsWith # The startsWith condition can be used to determine if the operand starts with a specified string. One or more strings to compare can be specified. Syntax: startsWith : <string | array> If the operand is a field, and the field does not exist, startsWith always returns false . For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleStartsWith' spec : condition : anyOf : - field : 'url' startsWith : 'http' - field : 'url' startsWith : - 'http://' - 'https://' --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleStartsWith' spec : if : anyOf : - field : 'url' startsWith : 'http' - field : 'url' startsWith : - 'http://' - 'https://' Subset # The subset condition can be used to determine if the operand is a set of specified values. The following properties are accepted: caseSensitive - Optionally, a case-sensitive comparison can be performed. By default, case-insensitive comparison is performed. unique - Optionally, the operand must not contain duplicates. By default, duplicates are allowed. Syntax: subset : <array> caseSensitive : <bool> unique : <bool> For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleSubset' spec : condition : field : 'logs' subset : - 'cluster-autoscaler' - 'kube-apiserver' - 'kube-scheduler' caseSensitive : true unique : true --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleSubset' spec : if : field : 'logs' subset : - 'cluster-autoscaler' - 'kube-apiserver' - 'kube-scheduler' caseSensitive : true unique : true Type # The comparison property type is used with a condition to evaluate the target type of the object. The type property must be set to . . Any other value will cause the condition to evaluate to false . Syntax: type : '.' For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleType' spec : condition : type : '.' equals : 'CustomType' --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleType' spec : if : type : '.' in : - 'Microsoft.Storage/storageAccounts' - 'Microsoft.Storage/storageAccounts/blobServices' Version # The version condition determines if the operand is a valid semantic version. A constraint can optionally be provided to require the semantic version to be within a range. Supported version constraints for expression are the same as the $Assert.Version assertion helper. Syntax: version : <string> includePrerelease : <bool> For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleVersion' spec : condition : field : 'engine.version' version : '^1.2.3' --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleAnyVersion' spec : if : field : 'engine.version' version : '' --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleVersionIncludingPrerelease' spec : if : field : 'engine.version' version : '>=1.5.0' includePrerelease : true Links # Invoke-PSRule","title":"Expressions"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/#expressions","text":"Describes PSRule expressions and how to use them.","title":"Expressions"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/#description","text":"PSRule expressions are used within YAML-based rules or selectors to evaluate an object. Expressions are comprised of nested conditions, operators, and comparison properties. The following conditions are available: Contains Count Equals EndsWith Exists Greater GreaterOrEquals HasDefault HasSchema HasValue In IsLower IsString IsUpper Less LessOrEquals Match NotEquals NotIn NotMatch SetOf StartsWith Subset Version The following operators are available: AllOf AnyOf Not The following comparison properties are available: Field Name Type","title":"Description"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/#allof","text":"The allOf operator is used to require all nested expressions to match. When any nested expression does not match, allOf does not match. This is similar to a logical and operation. Syntax: allOf : <expression[]> For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleAllOf' spec : condition : allOf : # Both Name and Description must exist. - field : 'Name' exists : true - field : 'Description' exists : true --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleAllOf' spec : if : allOf : # Both Name and Description must exist. - field : 'Name' exists : true - field : 'Description' exists : true","title":"AllOf"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/#anyof","text":"The anyOf operator is used to require one or more nested expressions to match. When any nested expression matches, allOf matches. This is similar to a logical or operation. Syntax: anyOf : <expression[]> For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleAnyOf' spec : condition : anyOf : # Name and/ or AlternativeName must exist. - field : 'Name' exists : true - field : 'AlternativeName' exists : true --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleAnyOf' spec : if : anyOf : # Name and/ or AlternativeName must exist. - field : 'Name' exists : true - field : 'AlternativeName' exists : true","title":"AnyOf"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/#contains","text":"The contains condition can be used to determine if the operand contains a specified sub-string. One or more strings to compare can be specified. Syntax: contains : <string | array> If the operand is a field, and the field does not exist, contains always returns false . For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleContains' spec : condition : anyOf : - field : 'url' contains : '/azure/' - field : 'url' contains : - 'github.io' - 'github.com' --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleContains' spec : if : anyOf : - field : 'url' contains : '/azure/' - field : 'url' contains : - 'github.io' - 'github.com'","title":"Contains"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/#count","text":"The count condition is used to determine if the operand contains a specified number of items. Syntax: count : <int> For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleCount' spec : condition : field : 'items' count : 2 --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleCount' spec : if : field : 'items' count : 2","title":"Count"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/#equals","text":"The equals condition can be used to compare if the operand is equal to a supplied value. Syntax: equals : <string | int | bool> For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleEquals' spec : condition : field : 'Name' equals : 'TargetObject1' --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleEquals' spec : if : field : 'Name' equals : 'TargetObject1'","title":"Equals"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/#endswith","text":"The endsWith condition can be used to determine if the operand ends with a specified string. One or more strings to compare can be specified. Syntax: endsWith : <string | array> If the operand is a field, and the field does not exist, endsWith always returns false . For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleEndsWith' spec : condition : anyOf : - field : 'hostname' endsWith : '.com' - field : 'hostname' endsWith : - '.com.au' - '.com' --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleEndsWith' spec : if : anyOf : - field : 'hostname' endsWith : '.com' - field : 'hostname' endsWith : - '.com.au' - '.com'","title":"EndsWith"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/#exists","text":"The exists condition determines if the specified field exists. Syntax: exists : <bool> When exists: true , exists will return true if the field exists. When exists: false , exists will return true if the field does not exist. For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleExists' spec : condition : field : 'Name' exists : true --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleExists' spec : if : field : 'Name' exists : true","title":"Exists"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/#field","text":"The comparison property field is used with a condition to determine field of the object to evaluate. A field can be: A property name. A key within a hashtable or dictionary. An index in an array or collection. A nested path through an object. Syntax: field : <string> For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleField' spec : condition : field : 'Properties.securityRules[0].name' exists : true --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleField' spec : if : field : 'Properties.securityRules[0].name' exists : true","title":"Field"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/#greater","text":"The greater condition determines if the operand is greater than a supplied value. The field value can either be an integer, float, array, or string. When the field value is: An integer or float, a numerical comparison is used. An array, the number of elements is compared. A string, the length of the string is compared. A DateTime, the number of days from the current time is compared. Syntax: greater : <int> For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleGreater' spec : condition : field : 'Name' greater : 3 --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleGreater' spec : if : field : 'Name' greater : 3","title":"Greater"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/#greaterorequals","text":"The greaterOrEquals condition determines if the operand is greater or equal to the supplied value. The field value can either be an integer, float, array, or string. When the field value is: An integer or float, a numerical comparison is used. An array, the number of elements is compared. A string, the length of the string is compared. A DateTime, the number of days from the current time is compared. Syntax: greaterOrEquals : <int> For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleGreaterOrEquals' spec : condition : field : 'Name' greaterOrEquals : 3 --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleGreaterOrEquals' spec : if : field : 'Name' greaterOrEquals : 3","title":"GreaterOrEquals"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/#hasdefault","text":"The hasDefault condition determines if the field exists that it is set to the specified value. If the field does not exist, the condition will return true . The following properties are accepted: caseSensitive - Optionally, a case-sensitive comparison can be performed for string values. By default, case-insensitive comparison is performed. Syntax: hasDefault : <string | int | bool> caseSensitive : <bool> For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleHasDefault' spec : condition : field : 'enabled' hasDefault : true --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleHasDefault' spec : if : field : 'enabled' hasDefault : true","title":"HasDefault"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/#hasschema","text":"The hasSchema condition determines if the operand has a $schema property defined. If the $schema property is defined, it must match one of the specified schemas. If a trailing # is specified it is ignored. The following properties are accepted: caseSensitive - Optionally, a case-sensitive comparison can be performed. By default, case-insensitive comparison is performed. ignoreScheme - Optionally, the URI scheme is ignored in the comparison. By default, the scheme is compared. When true , the schema will match if either http:// or https:// is specified. Syntax: hasSchema : <array> caseSensitive : <bool> ignoreScheme : <bool> When hasSchema: [] , hasSchema will return true if any non-empty $schema property is defined. For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleHasSchema' spec : condition : field : '.' hasSchema : - https://schema.management.azure.com/schemas/2019-04-01/deploymentParameters.json# --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleHasSchema' spec : if : field : '.' hasSchema : - https://schema.management.azure.com/schemas/2019-04-01/deploymentParameters.json# - https://schema.management.azure.com/schemas/2015-01-01/deploymentParameters.json# ignoreScheme : true --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleHasAnySchema' spec : if : field : '.' hasSchema : []","title":"HasSchema"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/#hasvalue","text":"The hasValue condition determines if the field exists and has a non-empty value. Syntax: hasValue : <bool> When hasValue: true , hasValue will return true if the field is not empty. When hasValue: false , hasValue will return true if the field is empty. For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleHasValue' spec : condition : field : 'Name' hasValue : true --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleHasValue' spec : if : field : 'Name' hasValue : true","title":"HasValue"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/#in","text":"The in condition can be used to compare if a field contains one of the specified values. Syntax: in : <array> For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleIn' spec : condition : field : 'Name' in : - 'Value1' - 'Value2' --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleIn' spec : if : field : 'Name' in : - 'Value1' - 'Value2'","title":"In"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/#islower","text":"The isLower condition determines if the operand is a lowercase string. Syntax: isLower : <bool> When isLower: true , isLower will return true if the operand is a lowercase string. Non-letter characters are ignored. When isLower: false , isLower will return true if the operand is not a lowercase string. If the operand is a field, and the field does not exist isLower always returns false . For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleIsLower' spec : condition : field : 'Name' isLower : true --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleIsLower' spec : if : field : 'Name' isLower : true","title":"IsLower"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/#isstring","text":"The isString condition determines if the operand is a string or other type. Syntax: isString : <bool> When isString: true , isString will return true if the operand is a string. When isString: false , isString will return true if the operand is not a string or is null. If the operand is a field, and the field does not exist isString always returns false . For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleIsString' spec : condition : field : 'Name' isString : true --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleIsString' spec : if : field : 'Name' isString : true","title":"IsString"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/#isupper","text":"The isUpper condition determines if the operand is an uppercase string. Syntax: isUpper : <bool> When isUpper: true , isUpper will return true if the operand is an uppercase string. Non-letter characters are ignored. When isUpper: false , isUpper will return true if the operand is not an uppercase string. If the operand is a field, and the field does not exist isUpper always returns false . For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleIsUpper' spec : condition : field : 'Name' isUpper : true --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleIsUpper' spec : if : field : 'Name' isUpper : true","title":"IsUpper"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/#less","text":"The less condition determines if the operand is less than a supplied value. The field value can either be an integer, float, array, or string. When the field value is: An integer or float, a numerical comparison is used. An array, the number of elements is compared. A string, the length of the string is compared. A DateTime, the number of days from the current time is compared. Syntax: less : <int> For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleLess' spec : condition : field : 'Name' less : 3 --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleLess' spec : if : field : 'Name' less : 3","title":"Less"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/#lessorequals","text":"The lessOrEquals condition determines if the operand is less or equal to the supplied value. The field value can either be an integer, float, array, or string. When the field value is: An integer or float, a numerical comparison is used. An array, the number of elements is compared. A string, the length of the string is compared. A DateTime, the number of days from the current time is compared. Syntax: lessOrEquals : <int> For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleLessOrEquals' spec : condition : field : 'Name' lessOrEquals : 3 --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleLessOrEquals' spec : if : field : 'Name' lessOrEquals : 3","title":"LessOrEquals"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/#match","text":"The match condition can be used to compare if a field matches a supplied regular expression. Syntax: match : <string> For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleMatch' spec : condition : field : 'Name' match : '$(abc|efg)$' --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleMatch' spec : if : field : 'Name' match : '$(abc|efg)$'","title":"Match"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/#name","text":"The comparison property name is used with a condition to evaluate the target name of the object. The name property must be set to . . Any other value will cause the condition to evaluate to false . Syntax: name : '.' For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleName' spec : condition : name : '.' equals : 'TargetObject1' --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleName' spec : if : name : '.' in : - 'TargetObject1' - 'TargetObject2'","title":"Name"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/#not","text":"The any operator is used to invert the result of the nested expression. When a nested expression matches, not does not match. When a nested expression does not match, not matches. Syntax: not : <expression> For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleNot' spec : condition : not : # The AlternativeName field must not exist. field : 'AlternativeName' exists : true --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleNot' spec : if : not : # The AlternativeName field must not exist. field : 'AlternativeName' exists : true","title":"Not"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/#notequals","text":"The notEquals condition can be used to compare if a field is equal to a supplied value. Syntax: notEquals : <string | int | bool> For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleNotEquals' spec : condition : field : 'Name' notEquals : 'TargetObject1' --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleNotEquals' spec : if : field : 'Name' notEquals : 'TargetObject1'","title":"NotEquals"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/#notin","text":"The notIn condition can be used to compare if a field does not contains one of the specified values. Syntax: notIn : <array> For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleNotIn' spec : condition : field : 'Name' notIn : - 'Value1' - 'Value2' --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleNotIn' spec : if : field : 'Name' notIn : - 'Value1' - 'Value2'","title":"NotIn"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/#notmatch","text":"The notMatch condition can be used to compare if a field does not matches a supplied regular expression. Syntax: notMatch : <string> For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleNotMatch' spec : condition : field : 'Name' notMatch : '$(abc|efg)$' --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleNotMatch' spec : if : field : 'Name' notMatch : '$(abc|efg)$'","title":"NotMatch"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/#setof","text":"The setOf condition can be used to determine if the operand is a set of specified values. Additionally the following properties are accepted: caseSensitive - Optionally, a case sensitive-comparison can be performed. By default, case-insensitive comparison is performed. Syntax: setOf : <array> caseSensitive : <bool> For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleSetOf' spec : condition : field : 'zones' setOf : - 1 - 2 - 3 caseSensitive : false --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleSetOf' spec : if : field : 'zones' setOf : - 1 - 2 - 3 caseSensitive : false","title":"SetOf"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/#startswith","text":"The startsWith condition can be used to determine if the operand starts with a specified string. One or more strings to compare can be specified. Syntax: startsWith : <string | array> If the operand is a field, and the field does not exist, startsWith always returns false . For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleStartsWith' spec : condition : anyOf : - field : 'url' startsWith : 'http' - field : 'url' startsWith : - 'http://' - 'https://' --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleStartsWith' spec : if : anyOf : - field : 'url' startsWith : 'http' - field : 'url' startsWith : - 'http://' - 'https://'","title":"StartsWith"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/#subset","text":"The subset condition can be used to determine if the operand is a set of specified values. The following properties are accepted: caseSensitive - Optionally, a case-sensitive comparison can be performed. By default, case-insensitive comparison is performed. unique - Optionally, the operand must not contain duplicates. By default, duplicates are allowed. Syntax: subset : <array> caseSensitive : <bool> unique : <bool> For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleSubset' spec : condition : field : 'logs' subset : - 'cluster-autoscaler' - 'kube-apiserver' - 'kube-scheduler' caseSensitive : true unique : true --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleSubset' spec : if : field : 'logs' subset : - 'cluster-autoscaler' - 'kube-apiserver' - 'kube-scheduler' caseSensitive : true unique : true","title":"Subset"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/#type","text":"The comparison property type is used with a condition to evaluate the target type of the object. The type property must be set to . . Any other value will cause the condition to evaluate to false . Syntax: type : '.' For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleType' spec : condition : type : '.' equals : 'CustomType' --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleType' spec : if : type : '.' in : - 'Microsoft.Storage/storageAccounts' - 'Microsoft.Storage/storageAccounts/blobServices'","title":"Type"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/#version","text":"The version condition determines if the operand is a valid semantic version. A constraint can optionally be provided to require the semantic version to be within a range. Supported version constraints for expression are the same as the $Assert.Version assertion helper. Syntax: version : <string> includePrerelease : <bool> For example: --- apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'ExampleVersion' spec : condition : field : 'engine.version' version : '^1.2.3' --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleAnyVersion' spec : if : field : 'engine.version' version : '' --- apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : 'ExampleVersionIncludingPrerelease' spec : if : field : 'engine.version' version : '>=1.5.0' includePrerelease : true","title":"Version"},{"location":"concepts/PSRule/en-US/about_PSRule_Expressions/#links","text":"Invoke-PSRule","title":"Links"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/","text":"Options # Describes additional options that can be used during rule execution. Description # PSRule lets you use options when calling cmdlets such as Invoke-PSRule and Test-PSRuleTarget to change how rules are processed. This topic describes what options are available, when to and how to use them. The following workspace options are available for use: Convention.Include Execution.AliasReferenceWarning Execution.LanguageMode Execution.InconclusiveWarning Execution.NotProcessedWarning Execution.SuppressedRuleWarning Execution.InvariantCultureWarning Include.Module Include.Path Input.Format Input.IgnoreGitPath Input.IgnoreRepositoryCommon Input.ObjectPath Input.PathIgnore Input.TargetType Logging.LimitDebug Logging.LimitVerbose Logging.RuleFail Logging.RulePass Output.As Output.Banner Output.Culture Output.Encoding Output.Footer Output.Format Output.Outcome Output.Path Output.Style Output.JsonIndent Requires Suppression Additionally the following baseline options can be included: Binding.Field Binding.IgnoreCase Binding.NameSeparator Binding.PreferTargetInfo Binding.TargetName Binding.TargetType Binding.UseQualifiedName Configuration Rule.Baseline Rule.Include Rule.IncludeLocal Rule.Exclude Rule.Tag See about_PSRule_Baseline for more information on baseline options. Options can be used with the following PSRule cmdlets: Export-PSRuleBaseline Get-PSRule Get-PSRuleBaseline Get-PSRuleHelp Invoke-PSRule Test-PSRuleTarget Each of these cmdlets support: Using the -Option parameter with an object created with the New-PSRuleOption cmdlet. See cmdlet help for syntax and examples. Using the -Option parameter with a hashtable object. Using the -Option parameter with a YAML file path. When using a hashtable object @{} , one or more options can be specified as keys using a dotted notation. For example: $option = @{ 'Output.Format' = 'Yaml' }; Invoke-PSRule -Path . -Option $option ; Invoke-PSRule -Path . -Option @{ 'Output.Format' = 'Yaml' }; The above example shows how the Output.Format option as a hashtable key can be used. Continue reading for a full list of options and how each can be used. Alternatively, options can be stored in a YAML formatted file and loaded from disk. Storing options as YAML allows different configurations to be loaded in a repeatable way instead of having to create an options object each time. Options are stored as YAML properties using a lower camel case naming convention, for example: output : format : Yaml The Set-PSRuleOption cmdlet can be used to set options stored in YAML or the YAML file can be manually edited. Set-PSRuleOption -OutputFormat Yaml ; By default, PSRule will automatically look for a default YAML options file in the current working directory. Alternatively, you can specify a specific file path. For example: Invoke-PSRule -Option '.\\myconfig.yml' ; New-PSRuleOption -Path '.\\myconfig.yaml' ; PSRule uses any of the following file names (in order) as the default YAML options file. If more than one of these files exist, the following order will be used to find the first match. ps-rule.yaml ps-rule.yml psrule.yaml psrule.yml We recommend only using lowercase characters as shown above. This is because not all operating systems treat case in the same way. Most options can be set using environment variables. When configuring environment variables we recommend that all capital letters are used. This is because environment variables are case-sensitive on some operating systems. PSRule environment variables use a consistent naming pattern of PSRULE_<PARENT>_<NAME> . Where <PARENT> is the parent class and <NAME> is the specific option. For example: Execution.InconclusiveWarning is configured by PSRULE_EXECUTION_INCONCLUSIVEWARNING . Input.TargetType is configured by PSRULE_INPUT_TARGETTYPE . Output.Format is configured by PSRULE_OUTPUT_FORMAT . When setting environment variables: Enum values are set by string. For example PSRULE_OUTPUT_FORMAT could be set to Yaml . Enum values are case-insensitive. Boolean values are set by true , false , 1 , or 0 . For example PSRULE_EXECUTION_INCONCLUSIVEWARNING could be set to false . Boolean values are case-insensitive. String array values can specify multiple items by using a semi-colon separator. For example PSRULE_INPUT_TARGETTYPE could be set to virtualMachine;virtualNetwork . Binding.Field # When an object is passed from the pipeline, PSRule automatically extracts fields from object properties. PSRule provides standard fields such as TargetName and TargetType . In addition to standard fields, custom fields can be bound. Custom fields are available to rules and included in output. PSRule uses the following logic to determine which property should be used for binding: By default PSRule will not extract any custom fields. If custom fields are configured, PSRule will attempt to bind the field. If none of the configured property names exist, the field will be skipped. If more then one property name is configured, the order they are specified in the configuration determines precedence. i.e. The first configured property name will take precedence over the second property name. By default the property name will be matched ignoring case sensitivity. To use a case sensitive match, configure the Binding.IgnoreCase option. Custom field bindings can be specified using: # PowerShell: Using the BindingField parameter $option = New-PSRuleOption -BindingField @{ id = 'ResourceId' , 'AlternativeId' }; # PowerShell: Using the Binding.Field hashtable key $option = New-PSRuleOption -Option @{ 'Binding.Field' = @{ id = 'ResourceId' , 'AlternativeId' } }; # PowerShell: Using the BindingField parameter to set YAML Set-PSRuleOption -BindingField @{ id = 'ResourceId' , 'AlternativeId' }; # YAML: Using the binding/field property binding : field : id : - ResourceId - AlternativeId Binding.IgnoreCase # When evaluating an object, PSRule extracts a few key properties from the object to help filter rules and display output results. The process of extract these key properties is called binding . The properties that PSRule uses for binding can be customized by providing a order list of alternative properties to use. See Binding.TargetName and Binding.TargetType for these options. By default, custom property binding finds the first matching property by name regardless of case. i.e. Binding.IgnoreCase is true . To make custom bindings case sensitive, set the Binding.IgnoreCase option to false . Changing this option will affect custom property bindings for both TargetName and TargetType . Setting this option has no affect on binding defaults or custom scripts. This option can be specified using: # PowerShell: Using the BindingIgnoreCase parameter $option = New-PSRuleOption -BindingIgnoreCase $False ; # PowerShell: Using the Binding.IgnoreCase hashtable key $option = New-PSRuleOption -Option @{ 'Binding.IgnoreCase' = $False }; # PowerShell: Using the BindingIgnoreCase parameter to set YAML Set-PSRuleOption -BindingIgnoreCase $False ; # YAML: Using the binding/ignoreCase property binding : ignoreCase : false # Bash: Using environment variable export PSRULE_BINDING_IGNORECASE = false # GitHub Actions: Using environment variable env : PSRULE_BINDING_IGNORECASE : false # Azure Pipelines: Using environment variable variables : - name : PSRULE_BINDING_IGNORECASE value : false Binding.NameSeparator # When an object is passed from the pipeline, PSRule assigns the object a TargetName . TargetName is used in output results to identify one object from another. In cases where different types of objects share the same TargetName , this may become confusing. Using a qualified name, prefixes the TargetName with TargetType . i.e. TargetType/TargetName To use a qualified name, see the Binding.UseQualifiedName option. By default, PSRule uses / to separate TargetType from TargetName . This option configures the separator that PSRule uses between the two components. This option can be specified using: # PowerShell: Using the BindingNameSeparator parameter $option = New-PSRuleOption -BindingNameSeparator '::' ; # PowerShell: Using the Binding.NameSeparator hashtable key $option = New-PSRuleOption -Option @{ 'Binding.NameSeparator' = '::' }; # PowerShell: Using the BindingNameSeparator parameter to set YAML Set-PSRuleOption -BindingNameSeparator '::' ; # YAML: Using the binding/nameSeparator property binding : nameSeparator : '::' # Bash: Using environment variable export PSRULE_BINDING_NAMESEPARATOR = '::' # GitHub Actions: Using environment variable env : PSRULE_BINDING_NAMESEPARATOR : '::' # Azure Pipelines: Using environment variable variables : - name : PSRULE_BINDING_NAMESEPARATOR value : '::' Binding.PreferTargetInfo # Some built-in objects within PSRule perform automatic binding of TargetName and TargetType. These built-in objects provide their own target info. When binding has been configured these values override automatic binding by default. This can occur when the built-in object uses one of the fields specified by the custom configuration. The common occurrences of this are on fields such as Name and FullName which are widely used. To prefer automatic binding when specified set this option to $True . This option can be specified using: # PowerShell: Using the BindingPreferTargetInfo parameter $option = New-PSRuleOption -BindingPreferTargetInfo $True ; # PowerShell: Using the Binding.PreferTargetInfo hashtable key $option = New-PSRuleOption -Option @{ 'Binding.PreferTargetInfo' = $True }; # PowerShell: Using the BindingPreferTargetInfo parameter to set YAML Set-PSRuleOption -BindingPreferTargetInfo $True ; # YAML: Using the binding/preferTargetInfo property binding : preferTargetInfo : true # Bash: Using environment variable export PSRULE_BINDING_PREFERTARGETINFO = false # GitHub Actions: Using environment variable env : PSRULE_BINDING_PREFERTARGETINFO : false # Azure Pipelines: Using environment variable variables : - name : PSRULE_BINDING_PREFERTARGETINFO value : false Binding.TargetName # When an object is passed from the pipeline, PSRule assigns the object a TargetName . TargetName is used in output results to identify one object from another. Many objects could be passed down the pipeline at the same time, so using a TargetName that is meaningful is important. TargetName is also used for advanced features such as rule suppression. The value that PSRule uses for TargetName is configurable. PSRule uses the following logic to determine what TargetName should be used: By default PSRule will: Use TargetName or Name properties on the object. These property names are case insensitive. If both TargetName and Name properties exist, TargetName will take precedence over Name . If neither TargetName or Name properties exist, a SHA1 hash of the object will be used as TargetName . If custom TargetName binding properties are configured, the property names specified will override the defaults. If none of the configured property names exist, PSRule will revert back to TargetName then Name . If more then one property name is configured, the order they are specified in the configuration determines precedence. i.e. The first configured property name will take precedence over the second property name. By default the property name will be matched ignoring case sensitivity. To use a case sensitive match, configure the Binding.IgnoreCase option. If a custom TargetName binding function is specified, the function will be evaluated first before any other option. If the function returns $Null then custom properties, TargetName and Name properties will be used. The custom binding function is executed outside the PSRule engine, so PSRule keywords and variables will not be available. Custom binding functions are blocked in constrained language mode is used. See language mode for more information. Custom property names to use for binding can be specified using: # PowerShell: Using the TargetName parameter $option = New-PSRuleOption -TargetName 'ResourceName' , 'AlternateName' ; # PowerShell: Using the Binding.TargetName hashtable key $option = New-PSRuleOption -Option @{ 'Binding.TargetName' = 'ResourceName' , 'AlternateName' }; # PowerShell: Using the TargetName parameter to set YAML Set-PSRuleOption -TargetName 'ResourceName' , 'AlternateName' ; # YAML: Using the binding/targetName property binding : targetName : - ResourceName - AlternateName # Bash: Using environment variable export PSRULE_BINDING_TARGETNAME = 'ResourceName;AlternateName' # GitHub Actions: Using environment variable env : PSRULE_BINDING_TARGETNAME : 'ResourceName;AlternateName' # Azure Pipelines: Using environment variable variables : - name : PSRULE_BINDING_TARGETNAME value : 'ResourceName;AlternateName' To specify a custom binding function use: # Create a custom function that returns a TargetName string $bindFn = { param ( $TargetObject ) $otherName = $TargetObject . PSObject . Properties [ 'OtherName' ]; if ( $Null -eq $otherName ) { return $Null } return $otherName . Value ; } # Specify the binding function script block code to execute $option = New-PSRuleOption -BindTargetName $bindFn ; Binding.TargetType # When an object is passed from the pipeline, PSRule assigns the object a TargetType . TargetType is used to filter rules based on object type and appears in output results. The value that PSRule uses for TargetType is configurable. PSRule uses the following logic to determine what TargetType should be used: By default PSRule will: Use the default type presented by PowerShell from TypeNames . i.e. .PSObject.TypeNames[0] If custom TargetType binding properties are configured, the property names specified will override the defaults. If none of the configured property names exist, PSRule will revert back to the type presented by PowerShell. If more then one property name is configured, the order they are specified in the configuration determines precedence. i.e. The first configured property name will take precedence over the second property name. By default the property name will be matched ignoring case sensitivity. To use a case sensitive match, configure the Binding.IgnoreCase option. If a custom TargetType binding function is specified, the function will be evaluated first before any other option. If the function returns $Null then custom properties, or the type presented by PowerShell will be used in order instead. The custom binding function is executed outside the PSRule engine, so PSRule keywords and variables will not be available. Custom binding functions are blocked in constrained language mode is used. See language mode for more information. Custom property names to use for binding can be specified using: # PowerShell: Using the TargetType parameter $option = New-PSRuleOption -TargetType 'ResourceType' , 'kind' ; # PowerShell: Using the Binding.TargetType hashtable key $option = New-PSRuleOption -Option @{ 'Binding.TargetType' = 'ResourceType' , 'kind' }; # PowerShell: Using the TargetType parameter to set YAML Set-PSRuleOption -TargetType 'ResourceType' , 'kind' ; # YAML: Using the binding/targetType property binding : targetType : - ResourceType - kind # Bash: Using environment variable export PSRULE_BINDING_TARGETTYPE = 'ResourceType;kind' # GitHub Actions: Using environment variable env : PSRULE_BINDING_TARGETTYPE : 'ResourceType;kind' # Azure Pipelines: Using environment variable variables : - name : PSRULE_BINDING_TARGETTYPE value : 'ResourceType;kind' To specify a custom binding function use: # Create a custom function that returns a TargetType string $bindFn = { param ( $TargetObject ) $otherType = $TargetObject . PSObject . Properties [ 'OtherType' ]; if ( $otherType -eq $Null ) { return $Null } return $otherType . Value ; } # Specify the binding function script block code to execute $option = New-PSRuleOption -BindTargetType $bindFn ; Binding.UseQualifiedName # When an object is passed from the pipeline, PSRule assigns the object a TargetName . TargetName is used in output results to identify one object from another. In cases where different types of objects share the same TargetName , this may become confusing. Using a qualified name, prefixes the TargetName with TargetType . i.e. TargetType/TargetName This option determines if PSRule uses qualified or unqualified names (default). By default, PSRule uses / to separate TargetType from TargetName . Set Binding.NameSeparator to change. This option can be specified using: # PowerShell: Using the BindingUseQualifiedName parameter $option = New-PSRuleOption -BindingUseQualifiedName $True ; # PowerShell: Using the Binding.UseQualifiedName hashtable key $option = New-PSRuleOption -Option @{ 'Binding.UseQualifiedName' = $True }; # PowerShell: Using the BindingUseQualifiedName parameter to set YAML Set-PSRuleOption -BindingUseQualifiedName $True ; # YAML: Using the binding/useQualifiedName property binding : useQualifiedName : true # Bash: Using environment variable export PSRULE_BINDING_USEQUALIFIEDNAME = false # GitHub Actions: Using environment variable env : PSRULE_BINDING_USEQUALIFIEDNAME : false # Azure Pipelines: Using environment variable variables : - name : PSRULE_BINDING_USEQUALIFIEDNAME value : false Configuration # Configures a set of baseline configuration values that can be used in rule definitions. Configuration values can be overridden at different scopes. This option can be specified using: # PowerShell: Using the Configuration option with a hashtable $option = New-PSRuleOption -Configuration @{ LOCAL_APPSERVICEMININSTANCECOUNT = 2 }; # YAML: Using the configuration property configuration : LOCAL_APPSERVICEMININSTANCECOUNT : 2 Configuration values can be specified using environment variables. To specify a configuration value, prefix the configuration value with PSRULE_CONFIGURATION_ . # Bash: Using environment variable export PSRULE_CONFIGURATION_LOCAL_APPSERVICEMININSTANCECOUNT = 2 # GitHub Actions: Using environment variable env : PSRULE_CONFIGURATION_LOCAL_APPSERVICEMININSTANCECOUNT : '2' # Azure Pipelines: Using environment variable variables : - name : PSRULE_CONFIGURATION_LOCAL_APPSERVICEMININSTANCECOUNT value : '2' Convention.Include # Specifies conventions to execute when the pipeline run. Conventions are included by name and must be defined within files included in -Path or -Module . This option can be specified using: # PowerShell: Using the Convention parameter $option = New-PSRuleOption -Convention 'Convention1' , 'Convention2' ; # PowerShell: Using the Convention.Include hashtable key $option = New-PSRuleOption -Option @{ 'Convention.Include' = $True }; # PowerShell: Using the Convention parameter to set YAML Set-PSRuleOption -Convention 'Convention1' , 'Convention2' ; # YAML: Using the convention/include property convention : include : - 'Convention1' - 'Convention2' # Bash: Using environment variable export PSRULE_CONVENTION_INCLUDE = 'Convention1;Convention2' # GitHub Actions: Using environment variable env : PSRULE_CONVENTION_INCLUDE : 'Convention1;Convention2' # Azure Pipelines: Using environment variable variables : - name : PSRULE_CONVENTION_INCLUDE value : 'Convention1;Convention2' Execution.AliasReferenceWarning # Rules may define one or more aliases. These aliases are alternative names to identify the rule. An alias may be used to reference the rule anywhere a rule name is used. The primary purpose of an alias is to provide a non-breaking method to change the rule name. Alises can be removed at a later revision once the rule is no longer referenced by the alias. A warning is logged by default to help identify when an alias is used. We recommend taking action to update your usage of the alis to use the rule name or ref instead. Alternatively, the alias reference warning can be disabled by using: # PowerShell: Using the AliasReferenceWarning parameter $option = New-PSRuleOption -AliasReferenceWarning $False ; # PowerShell: Using the Execution.AliasReferenceWarning hashtable key $option = New-PSRuleOption -Option @{ 'Execution.AliasReferenceWarning' = $False }; # PowerShell: Using the AliasReferenceWarning parameter to set YAML Set-PSRuleOption -AliasReferenceWarning $False ; # YAML: Using the execution/aliasReferenceWarning property execution : aliasReferenceWarning : false # Bash: Using environment variable export PSRULE_EXECUTION_ALIASREFERENCEWARNING = false # GitHub Actions: Using environment variable env : PSRULE_EXECUTION_ALIASREFERENCEWARNING : false # Azure Pipelines: Using environment variable variables : - name : PSRULE_EXECUTION_ALIASREFERENCEWARNING value : false Execution.LanguageMode # Unless PowerShell has been constrained, full language features of PowerShell are available to use within rule definitions. In locked down environments, a reduced set of language features may be desired. When PSRule is executed in an environment configured for Device Guard, only constrained language features are available. The following language modes are available for use in PSRule: FullLanguage ConstrainedLanguage This option can be specified using: # PowerShell: Using the Execution.LanguageMode hashtable key $option = New-PSRuleOption -Option @{ 'Execution.LanguageMode' = 'ConstrainedLanguage' }; # YAML: Using the execution/languageMode property execution : languageMode : ConstrainedLanguage # Bash: Using environment variable export PSRULE_EXECUTION_LANGUAGEMODE = ConstrainedLanguage # GitHub Actions: Using environment variable env : PSRULE_EXECUTION_LANGUAGEMODE : ConstrainedLanguage # Azure Pipelines: Using environment variable variables : - name : PSRULE_EXECUTION_LANGUAGEMODE value : ConstrainedLanguage Execution.InconclusiveWarning # When defining rules, it is possible not return a valid $True or $False result within the definition script block. Rule authors should not intentionally avoid returning a result, however a possible cause for not returning a result may be a rule logic error. If a rule should not be evaluated, use pre-conditions to avoid processing the rule for objects where the rule is not applicable. In cases where the rule does not return a result it is marked as inconclusive. Inconclusive results will: Generate a warning by default. Fail the object. Outcome will be reported as Fail with an OutcomeReason of Inconclusive . The inconclusive warning can be disabled by using: # PowerShell: Using the InconclusiveWarning parameter $option = New-PSRuleOption -InconclusiveWarning $False ; # PowerShell: Using the Execution.InconclusiveWarning hashtable key $option = New-PSRuleOption -Option @{ 'Execution.InconclusiveWarning' = $False }; # PowerShell: Using the InconclusiveWarning parameter to set YAML Set-PSRuleOption -InconclusiveWarning $False ; # YAML: Using the execution/inconclusiveWarning property execution : inconclusiveWarning : false # Bash: Using environment variable export PSRULE_EXECUTION_INCONCLUSIVEWARNING = false # GitHub Actions: Using environment variable env : PSRULE_EXECUTION_INCONCLUSIVEWARNING : false # Azure Pipelines: Using environment variable variables : - name : PSRULE_EXECUTION_INCONCLUSIVEWARNING value : false Execution.NotProcessedWarning # When evaluating rules, it is possible to incorrectly select a path with rules that use pre-conditions that do not accept the pipeline object. In this case the object has not been processed by any rule. Not processed objects will: Generate a warning by default. Pass the object. Outcome will be reported as None . The not processed warning can be disabled by using: # PowerShell: Using the NotProcessedWarning parameter $option = New-PSRuleOption -NotProcessedWarning $False ; # PowerShell: Using the Execution.NotProcessedWarning hashtable key $option = New-PSRuleOption -Option @{ 'Execution.NotProcessedWarning' = $False }; # PowerShell: Using the NotProcessedWarning parameter to set YAML Set-PSRuleOption -NotProcessedWarning $False ; # YAML: Using the execution/notProcessedWarning property execution : notProcessedWarning : false # Bash: Using environment variable export PSRULE_EXECUTION_NOTPROCESSEDWARNING = false # GitHub Actions: Using environment variable env : PSRULE_EXECUTION_NOTPROCESSEDWARNING : false # Azure Pipelines: Using environment variable variables : - name : PSRULE_EXECUTION_NOTPROCESSEDWARNING value : false Execution.SuppressedRuleWarning # When evaluating rules, it is possible to output suppressed rules as warnings. Suppressed rules will: Output a warning by default. Show which rules were suppressed when Output.As is set to Detail . Show how many rules were suppressed when Output.As is set to Summary . The suppressed rule can be disabled by using: # PowerShell: Using the SuppressedRuleWarning parameter $option = New-PSRuleOption -SuppressedRuleWarning $False ; # PowerShell: Using the Execution.SuppressedRuleWarning hashtable key $option = New-PSRuleOption -Option @{ 'Execution.SuppressedRuleWarning' = $False }; # PowerShell: Using the SuppressedRuleWarning parameter to set YAML Set-PSRuleOption -SuppressedRuleWarning $False ; # YAML: Using the execution/suppressedRuleWarning property execution : suppressedRuleWarning : false # Bash: Using environment variable export PSRULE_EXECUTION_SUPPRESSEDRULEWARNING = false # GitHub Actions: Using environment variable env : PSRULE_EXECUTION_SUPPRESSEDRULEWARNING : false # Azure Pipelines: Using environment variable variables : - name : PSRULE_EXECUTION_SUPPRESSEDRULEWARNING value : false Execution.InvariantCultureWarning # When evaluating rules inside a CI host, if invariant culture is used, a warning is shown by default. You can suppress this warning if you set the culture with -Culture or the Output.Culture option. This warning can also be suppressed by using: # PowerShell: Using the InvariantCultureWarning parameter $option = New-PSRuleOption -InvariantCultureWarning $False ; # PowerShell: Using the Execution.InvariantCultureWarning hashtable key $option = New-PSRuleOption -Option @{ 'Execution.InvariantCultureWarning' = $False }; # PowerShell: Using the InvariantCultureWarning parameter to set YAML Set-PSRuleOption -InvariantCultureWarning $False ; # YAML: Using the execution/invariantCultureWarning property execution : invariantCultureWarning : false # Bash: Using environment variable export PSRULE_EXECUTION_INVARIANTCULTUREWARNING = false # GitHub Actions: Using environment variable env : PSRULE_EXECUTION_INVARIANTCULTUREWARNING : false # Azure Pipelines: Using environment variable variables : - name : PSRULE_EXECUTION_INVARIANTCULTUREWARNING value : false Include.Module # Automatically include rules and resources from the specified module. To automatically import and include a module specify the module by name. The module must already be installed on the system. When $PSModuleAutoLoadingPreference is set to a value other then All the module must be imported. This option is equivalent to using the -Module parameter on PSRule cmdlets, with the following addition: Modules specified with Include.Module are combined with -Module . Both sets of modules will be imported and used using execution. This option can be specified using: # PowerShell: Using the IncludeModule parameter $option = New-PSRuleOption -IncludeModule 'TestModule1' , 'TestModule2' ; # PowerShell: Using the Include.Module hashtable key $option = New-PSRuleOption -Option @{ 'Include.Module' = 'TestModule1' , 'TestModule2' }; # PowerShell: Using the IncludeModule parameter to set YAML Set-PSRuleOption -IncludeModule 'TestModule1' , 'TestModule2' ; # YAML: Using the include/module property include : module : - TestModule1 # Bash: Using environment variable export PSRULE_INCLUDE_MODULE = TestModule1 ; TestModule2 # GitHub Actions: Using environment variable env : PSRULE_INCLUDE_MODULE : TestModule1;TestModule2 # Azure Pipelines: Using environment variable variables : - name : PSRULE_INCLUDE_MODULE value : TestModule1;TestModule2 Include.Path # Automatically include rules and resources from the specified path. By default, .ps-rule/ is included. This option is equivalent to using the -Path parameter on PSRule cmdlets, with the following additions: Paths specified with Include.Path are combined with -Path . Both sets of paths will be imported and used using execution. The Include.Path option defaults to .ps-rule/ . To override this default, specify one or more alternative paths or an empty array. This option can be specified using: # PowerShell: Using the IncludePath parameter $option = New-PSRuleOption -IncludePath '.ps-rule/' , 'custom-rules/' ; # PowerShell: Using the Include.Path hashtable key $option = New-PSRuleOption -Option @{ 'Include.Path' = '.ps-rule/' , 'custom-rules/' }; # PowerShell: Using the IncludePath parameter to set YAML Set-PSRuleOption -IncludePath '.ps-rule/' , 'custom-rules/' ; # YAML: Using the include/path property include : path : - custom-rules/ # Bash: Using environment variable export PSRULE_INCLUDE_PATH = .ps-rule/ ; custom-rules/ # GitHub Actions: Using environment variable env : PSRULE_INCLUDE_PATH : .ps-rule/;custom-rules/ # Azure Pipelines: Using environment variable variables : - name : PSRULE_INCLUDE_PATH value : .ps-rule/;custom-rules/ Input.Format # Configures the input format for when a string is passed in as a target object. This option determines if the target object is deserialized into an alternative form. Use this option with Assert-PSRule , Invoke-PSRule or Test-PSRuleTarget . Set this option to either Yaml , Json , Markdown , PowerShellData to deserialize as a specific format. The -Format parameter will override any value set in configuration. When the -InputObject parameter or pipeline input is used, strings are treated as plain text by default. FileInfo objects for supported file formats will be deserialized based on file extension. When the -InputPath parameter is used, supported file formats will be deserialized based on file extension. The -InputPath parameter can be used with a file path or URL. The following formats are available: None - Treat strings as plain text and do not deserialize files. Yaml - Deserialize as one or more YAML objects. Json - Deserialize as one or more JSON objects. Markdown - Deserialize as a markdown object. PowerShellData - Deserialize as a PowerShell data object. File - Files are not deserialized. Detect - Detect format based on file extension. This is the default. If the Detect format is used, the file extension will be used to automatically detect the format. When the file extension can not be determined Detect is the same as None . The Markdown format does not parse the whole markdown document. Specifically this format deserializes YAML front matter from the top of the document if any exists. The File format does not deserialize file contents. Each file is returned as an object. Files within .git sub-directories are ignored. Path specs specified in .gitignore directly in the current working path are ignored. A RepositoryInfo object is generated if the current working path if a .git sub-directory is present. Additionally, PSRule performs automatic type binding for file objects, using the extension as the type. When files have no extension the whole file name is used. Detect uses the following file extensions: Yaml - .yaml or .yml Json - .json or .jsonc Markdown - .md or .markdown PowerShellData - .psd1 This option can be specified using: # PowerShell: Using the Format parameter $option = New-PSRuleOption -Format Yaml ; # PowerShell: Using the Input.Format hashtable key $option = New-PSRuleOption -Option @{ 'Input.Format' = 'Yaml' }; # PowerShell: Using the Format parameter to set YAML Set-PSRuleOption -Format Yaml ; # YAML: Using the input/format property input : format : Yaml # Bash: Using environment variable export PSRULE_INPUT_FORMAT = Yaml # GitHub Actions: Using environment variable env : PSRULE_INPUT_FORMAT : Yaml # Azure Pipelines: Using environment variable variables : - name : PSRULE_INPUT_FORMAT value : Yaml Input.IgnoreGitPath # When reading files from an input path, files within the .git sub-directory are ignored by default. Files stored within the .git sub-directory are system repository files used by git. To read files stored within the .git path, set this option to $False . This option can be specified using: # PowerShell: Using the InputIgnoreGitPath parameter $option = New-PSRuleOption -InputIgnoreGitPath $False ; # PowerShell: Using the Input.IgnoreGitPath hashtable key $option = New-PSRuleOption -Option @{ 'Input.IgnoreGitPath' = $False }; # PowerShell: Using the InputIgnoreGitPath parameter to set YAML Set-PSRuleOption -InputIgnoreGitPath $False ; # YAML: Using the input/ignoreGitPath property input : ignoreGitPath : false # Bash: Using environment variable export PSRULE_INPUT_IGNOREGITPATH = false # GitHub Actions: Using environment variable env : PSRULE_INPUT_IGNOREGITPATH : false # Azure Pipelines: Using environment variable variables : - name : PSRULE_INPUT_IGNOREGITPATH value : false Input.IgnoreRepositoryCommon # When reading files from an input path, files are discovered recursively. A number of files are commonly found within a private and open-source repositories. In many cases these files are of no interest for analysis and should be ignored by rules. PSRule will ignore the following files by default: README.md .DS_Store .gitignore .gitattributes .gitmodules LICENSE LICENSE.txt CODE_OF_CONDUCT.md CONTRIBUTING.md SECURITY.md SUPPORT.md .vscode/*.json .github/**/*.md .github/CODEOWNERS To include these files, set this option to $False . This option can be specified using: # PowerShell: Using the InputIgnoreRepositoryCommon parameter $option = New-PSRuleOption -InputIgnoreRepositoryCommon $False ; # PowerShell: Using the Input.IgnoreRepositoryCommon hashtable key $option = New-PSRuleOption -Option @{ 'Input.IgnoreRepositoryCommon' = $False }; # PowerShell: Using the InputIgnoreRepositoryCommon parameter to set YAML Set-PSRuleOption -InputIgnoreRepositoryCommon $False ; # YAML: Using the input/ignoreRepositoryCommon property input : ignoreRepositoryCommon : false # Bash: Using environment variable export PSRULE_INPUT_IGNOREREPOSITORYCOMMON = false # GitHub Actions: Using environment variable env : PSRULE_INPUT_IGNOREREPOSITORYCOMMON : false # Azure Pipelines: Using environment variable variables : - name : PSRULE_INPUT_IGNOREREPOSITORYCOMMON value : false Input.ObjectPath # The object path to a property to use instead of the pipeline object. By default, PSRule processes objects passed from the pipeline against selected rules. When this option is set, instead of evaluating the pipeline object, PSRule looks for a property of the pipeline object specified by ObjectPath and uses that instead. If the property specified by ObjectPath is a collection/ array, then each item is evaluated separately. If the property specified by ObjectPath does not exist, PSRule skips the object. When using Invoke-PSRule , Test-PSRuleTarget and Assert-PSRule the -ObjectPath parameter will override any value set in configuration. This option can be specified using: # PowerShell: Using the ObjectPath parameter $option = New-PSRuleOption -ObjectPath 'items' ; # PowerShell: Using the Input.ObjectPath hashtable key $option = New-PSRuleOption -Option @{ 'Input.ObjectPath' = 'items' }; # PowerShell: Using the ObjectPath parameter to set YAML Set-PSRuleOption -ObjectPath 'items' ; # YAML: Using the input/objectPath property input : objectPath : items # Bash: Using environment variable export PSRULE_INPUT_OBJECTPATH = items # GitHub Actions: Using environment variable env : PSRULE_INPUT_OBJECTPATH : items # Azure Pipelines: Using environment variable variables : - name : PSRULE_INPUT_OBJECTPATH value : items Input.PathIgnore # Ignores input files that match the path spec when using -InputPath . If specified, files that match the path spec will not be processed. By default, all files are processed. This option can be specified using: # PowerShell: Using the InputPathIgnore parameter $option = New-PSRuleOption -InputPathIgnore '*.Designer.cs' ; # PowerShell: Using the Input.PathIgnore hashtable key $option = New-PSRuleOption -Option @{ 'Input.PathIgnore' = '*.Designer.cs' }; # PowerShell: Using the InputPathIgnore parameter to set YAML Set-PSRuleOption -InputPathIgnore '*.Designer.cs' ; # YAML: Using the input/pathIgnore property input : pathIgnore : - '*.Designer.cs' # Bash: Using environment variable export PSRULE_INPUT_PATHIGNORE = *.Designer.cs # GitHub Actions: Using environment variable env : PSRULE_INPUT_PATHIGNORE : '*.Designer.cs' # Azure Pipelines: Using environment variable variables : - name : PSRULE_INPUT_PATHIGNORE value : '*.Designer.cs' Input.TargetType # Filters input objects by TargetType. If specified, only objects with the specified TargetType are processed. Objects that do not match TargetType are ignored. If multiple values are specified, only one TargetType must match. This option is not case-sensitive. By default, all objects are processed. To change the field TargetType is bound to set the Binding.TargetType option. When using Invoke-PSRule , Test-PSRuleTarget and Assert-PSRule the -TargetType parameter will override any value set in configuration. This option can be specified using: # PowerShell: Using the InputTargetType parameter $option = New-PSRuleOption -InputTargetType 'virtualMachine' , 'virtualNetwork' ; # PowerShell: Using the Input.TargetType hashtable key $option = New-PSRuleOption -Option @{ 'Input.TargetType' = 'virtualMachine' , 'virtualNetwork' }; # PowerShell: Using the InputTargetType parameter to set YAML Set-PSRuleOption -InputTargetType 'virtualMachine' , 'virtualNetwork' ; # YAML: Using the input/targetType property input : targetType : - virtualMachine # Bash: Using environment variable export PSRULE_INPUT_TARGETTYPE = virtualMachine ; virtualNetwork # GitHub Actions: Using environment variable env : PSRULE_INPUT_TARGETTYPE : virtualMachine;virtualNetwork # Azure Pipelines: Using environment variable variables : - name : PSRULE_INPUT_TARGETTYPE value : virtualMachine;virtualNetwork Logging.LimitDebug # Limits debug messages to a list of named debug scopes. When using the -Debug switch or preference variable, by default PSRule cmdlets log all debug output. When using debug output for debugging a specific rule, it may be helpful to limit debug message to a specific rule. To identify a rule to include in debug output use the rule name. The following built-in scopes exist in addition to rule names: [Discovery.Source] - Discovery messages for .Rule.ps1 files and rule modules. [Discovery.Rule] - Discovery messages for individual rules within .Rule.ps1 files. This option can be specified using: # PowerShell: Using the LoggingLimitDebug parameter $option = New-PSRuleOption -LoggingLimitDebug Rule1 , Rule2 ; # PowerShell: Using the Logging.LimitDebug hashtable key $option = New-PSRuleOption -Option @{ 'Logging.LimitDebug' = Rule1 , Rule2 }; # PowerShell: Using the LoggingLimitDebug parameter to set YAML Set-PSRuleOption -LoggingLimitDebug Rule1 , Rule2 ; # YAML: Using the logging/limitDebug property logging : limitDebug : - Rule1 - Rule2 Logging.LimitVerbose # Limits verbose messages to a list of named verbose scopes. When using the -Verbose switch or preference variable, by default PSRule cmdlets log all verbose output. When using verbose output for troubleshooting a specific rule, it may be helpful to limit verbose messages to a specific rule. To identify a rule to include in verbose output use the rule name. The following built-in scopes exist in addition to rule names: [Discovery.Source] - Discovery messages for .Rule.ps1 files and rule modules. [Discovery.Rule] - Discovery messages for individual rules within .Rule.ps1 files. This option can be specified using: # PowerShell: Using the LoggingLimitVerbose parameter $option = New-PSRuleOption -LoggingLimitVerbose Rule1 , Rule2 ; # PowerShell: Using the Logging.LimitVerbose hashtable key $option = New-PSRuleOption -Option @{ 'Logging.LimitVerbose' = Rule1 , Rule2 }; # PowerShell: Using the LoggingLimitVerbose parameter to set YAML Set-PSRuleOption -LoggingLimitVerbose Rule1 , Rule2 ; # YAML: Using the logging/limitVerbose property logging : limitVerbose : - Rule1 - Rule2 Logging.RuleFail # When an object fails a rule condition the results are written to output as a structured object marked with the outcome of Fail . If the rule executed successfully regardless of outcome no other informational messages are shown by default. In some circumstances such as a continuous integration (CI) pipeline, it may be preferable to see informational messages or abort the CI process if one or more Fail outcomes are returned. By settings this option, error, warning or information messages will be generated for each rule fail outcome in addition to structured output. By default, outcomes are not logged to an informational stream (i.e. None). The following streams available: None Error Warning Information This option can be specified using: # PowerShell: Using the LoggingRuleFail parameter $option = New-PSRuleOption -LoggingRuleFail Error ; # PowerShell: Using the Logging.RuleFail hashtable key $option = New-PSRuleOption -Option @{ 'Logging.RuleFail' = 'Error' }; # PowerShell: Using the LoggingRuleFail parameter to set YAML Set-PSRuleOption -LoggingRuleFail Error ; # YAML: Using the logging/ruleFail property logging : ruleFail : Error Logging.RulePass # When an object passes a rule condition the results are written to output as a structured object marked with the outcome of Pass . If the rule executed successfully regardless of outcome no other informational messages are shown by default. In some circumstances such as a continuous integration (CI) pipeline, it may be preferable to see informational messages. By settings this option, error, warning or information messages will be generated for each rule pass outcome in addition to structured output. By default, outcomes are not logged to an informational stream (i.e. None). The following streams available: None Error Warning Information This option can be specified using: # PowerShell: Using the LoggingRulePass parameter $option = New-PSRuleOption -LoggingRulePass Information ; # PowerShell: Using the Logging.RulePass hashtable key $option = New-PSRuleOption -Option @{ 'Logging.RulePass' = 'Information' }; # PowerShell: Using the LoggingRulePass parameter to set YAML Set-PSRuleOption -LoggingRulePass Information ; # YAML: Using the logging/rulePass property logging : rulePass : Information Output.As # Configures the type of results to produce. This option only applies to Invoke-PSRule and Assert-PSRule . Invoke-PSRule and Assert-PSRule also include a -As parameter to set this option at runtime. If specified, the -As parameter take precedence, over this option. The following options are available: Detail - Return a record per rule per object. Summary - Return summary results. This option can be specified using: # PowerShell: Using the OutputAs parameter $option = New-PSRuleOption -OutputAs Summary ; # PowerShell: Using the Output.As hashtable key $option = New-PSRuleOption -Option @{ 'Output.As' = 'Summary' }; # PowerShell: Using the OutputAs parameter to set YAML Set-PSRuleOption -OutputAs Summary ; # YAML: Using the output/as property output : as : Summary # Bash: Using environment variable export PSRULE_OUTPUT_AS = Summary # GitHub Actions: Using environment variable env : PSRULE_OUTPUT_AS : Summary # Azure Pipelines: Using environment variable variables : - name : PSRULE_OUTPUT_AS value : Summary Output.Banner # The information displayed for PSRule banner. This option is only applicable when using Assert-PSRule cmdlet. The following information can be shown or hidden by configuring this option. Title (1) - Shows the PSRule title ASCII text. Source (2) - Shows rules module versions used in this run. SupportLinks (4) - Shows supporting links for PSRule and rules modules. Additionally the following rollup options exist: Default - Shows Title , Source , and SupportLinks . This is the default option. Minimal - Shows Source . This option can be configured using one of the named values described above. Alternatively, this value can be configured by specifying a bit mask as an integer. For example 6 would show Source , and SupportLinks . This option can be specified using: # PowerShell: Using the OutputBanner parameter $option = New-PSRuleOption -OutputBanner Minimal ; # PowerShell: Using the Output.Banner hashtable key $option = New-PSRuleOption -Option @{ 'Output.Banner' = 'Minimal' }; # PowerShell: Using the OutputBanner parameter to set YAML Set-PSRuleOption -OutputBanner Minimal ; # YAML: Using the output/banner property output : banner : Minimal # Bash: Using environment variable export PSRULE_OUTPUT_BANNER = Minimal # GitHub Actions: Using environment variable env : PSRULE_OUTPUT_BANNER : Minimal # Azure Pipelines: Using environment variable variables : - name : PSRULE_OUTPUT_BANNER value : Minimal Output.Culture # Specified the name of one or more cultures to use for generating output. When multiple cultures are specified, the first matching culture will be used. If a culture is not specified, PSRule will use the current PowerShell culture. PSRule cmdlets also include a -Culture parameter to set this option at runtime. If specified, the -Culture parameter take precedence, over this option. To get a list of cultures use the Get-Culture -ListAvailable cmdlet. This option can be specified using: # PowerShell: Using the OutputCulture parameter $option = New-PSRuleOption -OutputCulture 'en-AU' ; # PowerShell: Using the Output.Culture hashtable key $option = New-PSRuleOption -Option @{ 'Output.Culture' = 'en-AU' }; # PowerShell: Using the OutputCulture parameter to set YAML Set-PSRuleOption -OutputCulture 'en-AU' , 'en-US' ; # YAML: Using the output/culture property output : culture : [ 'en-AU' , 'en-US' ] # Bash: Using environment variable export PSRULE_OUTPUT_CULTURE = en-AU ; en-US # GitHub Actions: Using environment variable env : PSRULE_OUTPUT_CULTURE : en-AU;en-US # Azure Pipelines: Using environment variable variables : - name : PSRULE_OUTPUT_CULTURE value : en-AU;en-US Output.Encoding # Configures the encoding used when output is written to file. This option has no affect when Output.Path is not set. The following encoding options are available: Default UTF-8 UTF-7 Unicode UTF-32 ASCII This option can be specified using: # PowerShell: Using the OutputEncoding parameter $option = New-PSRuleOption -OutputEncoding UTF8 ; # PowerShell: Using the Output.Format hashtable key $option = New-PSRuleOption -Option @{ 'Output.Encoding' = 'UTF8' }; # PowerShell: Using the OutputEncoding parameter to set YAML Set-PSRuleOption -OutputEncoding UTF8 ; # YAML: Using the output/encoding property output : encoding : UTF8 # Bash: Using environment variable export PSRULE_OUTPUT_ENCODING = UTF8 # GitHub Actions: Using environment variable env : PSRULE_OUTPUT_ENCODING : UTF8 # Azure Pipelines: Using environment variable variables : - name : PSRULE_OUTPUT_ENCODING value : UTF8 Output.Footer # The information displayed for PSRule footer. This option is only applicable when using Assert-PSRule cmdlet. The following information can be shown or hidden by configuring this option. RuleCount (1) - Shows a summary of rules processed. RunInfo (2) - Shows information about the run. Additionally the following rollup options exist: Default - Shows RuleCount , and RunInfo . This is the default option. This option can be configured using one of the named values described above. Alternatively, this value can be configured by specifying a bit mask as an integer. For example 3 would show RunInfo , and RuleCount . This option can be specified using: # PowerShell: Using the OutputFooter parameter $option = New-PSRuleOption -OutputFooter RuleCount ; # PowerShell: Using the Output.Footer hashtable key $option = New-PSRuleOption -Option @{ 'Output.Footer' = 'RuleCount' }; # PowerShell: Using the OutputFooter parameter to set YAML Set-PSRuleOption -OutputFooter RuleCount ; # YAML: Using the output/footer property output : footer : RuleCount # Bash: Using environment variable export PSRULE_OUTPUT_FOOTER = RuleCount # GitHub Actions: Using environment variable env : PSRULE_OUTPUT_FOOTER : RuleCount # Azure Pipelines: Using environment variable variables : - name : PSRULE_OUTPUT_FOOTER value : RuleCount Output.Format # Configures the format that results will be presented in. This option applies to Invoke-PSRule , Assert-PSRule , Get-PSRule and Get-PSRuleBaseline . This options is ignored by other cmdlets. The following format options are available: None - Output is presented as an object using PowerShell defaults. This is the default. Yaml - Output is serialized as YAML. Json - Output is serialized as JSON. Markdown - Output is serialized as Markdown. NUnit3 - Output is serialized as NUnit3 (XML). Csv - Output is serialized as a comma separated values (CSV). The following columns are included for Detail output: RuleName, TargetName, TargetType, Outcome, OutcomeReason, Synopsis, Recommendation The following columns are included for Summary output: RuleName, Pass, Fail, Outcome, Synopsis, Recommendation Wide - Output is presented using the wide table format, which includes reason and wraps columns. The Wide format is ignored by Assert-PSRule . Get-PSRule only accepts None , Wide , Yaml and Json . Usage of other formats are treated as None . The Get-PSRuleBaseline cmdlet only accepts None or Yaml . The Export-PSRuleBaseline cmdlet only accepts Yaml . This option can be specified using: # PowerShell: Using the OutputFormat parameter $option = New-PSRuleOption -OutputFormat Yaml ; # PowerShell: Using the Output.Format hashtable key $option = New-PSRuleOption -Option @{ 'Output.Format' = 'Yaml' }; # PowerShell: Using the OutputFormat parameter to set YAML Set-PSRuleOption -OutputFormat Yaml ; # YAML: Using the output/format property output : format : Yaml # Bash: Using environment variable export PSRULE_OUTPUT_FORMAT = Yaml # GitHub Actions: Using environment variable env : PSRULE_OUTPUT_FORMAT : Yaml # Azure Pipelines: Using environment variable variables : - name : PSRULE_OUTPUT_FORMAT value : Yaml Output.Outcome # Filters output to include results with the specified outcome. The following outcome options are available: None - Results for rules that did not get processed are returned. Pass - Results for rules that passed are returned. Fail - Results for rules that failed are returned. Error - Results for rules that raised an error are returned. Processed - Results for rules that either passed, failed, or raised an error are returned. This is the default option. All - All results for rules are returned. This option can be specified using: # PowerShell: Using the OutputOutcome parameter $option = New-PSRuleOption -OutputOutcome Fail ; # PowerShell: Using the Output.Outcome hashtable key $option = New-PSRuleOption -Option @{ 'Output.Outcome' = 'Fail' }; # PowerShell: Using the OutputOutcome parameter to set YAML Set-PSRuleOption -OutputOutcome Fail ; # YAML: Using the output/outcome property output : outcome : 'Fail' # Bash: Using environment variable export PSRULE_OUTPUT_OUTCOME = Fail # GitHub Actions: Using environment variable env : PSRULE_OUTPUT_OUTCOME : Fail # Azure Pipelines: Using environment variable variables : - name : PSRULE_OUTPUT_OUTCOME value : Fail Output.Path # Specifies the output file path to write results. Directories along the file path will automatically be created if they do not exist. This option only applies to Invoke-PSRule . Invoke-PSRule also includes a parameter -OutputPath to set this option at runtime. If specified, the -OutputPath parameter take precedence, over this option. This option can be specified using: # PowerShell: Using the OutputPath parameter $option = New-PSRuleOption -OutputPath 'out/results.yaml' ; # PowerShell: Using the Output.Path hashtable key $option = New-PSRuleOption -Option @{ 'Output.Path' = 'out/results.yaml' }; # PowerShell: Using the OutputPath parameter to set YAML Set-PSRuleOption -OutputPath 'out/results.yaml' ; # YAML: Using the output/path property output : path : 'out/results.yaml' # Bash: Using environment variable export PSRULE_OUTPUT_PATH = out/results.yaml # GitHub Actions: Using environment variable env : PSRULE_OUTPUT_PATH : out/results.yaml # Azure Pipelines: Using environment variable variables : - name : PSRULE_OUTPUT_PATH value : out/results.yaml Output.Style # Configures the style that results will be presented in. This option only applies to output generated from Assert-PSRule . Assert-PSRule also include a parameter -Style to set this option at runtime. If specified, the -Style parameter takes precedence, over this option. The following styles are available: Client - Output is written to the host directly in green/ red to indicate outcome. Plain - Output is written as an unformatted string. This option can be redirected to a file. AzurePipelines - Output is written for integration Azure Pipelines. GitHubActions - Output is written for integration GitHub Actions. VisualStudioCode - Output is written for integration with Visual Studio Code. Detect - Output style will be detected by checking the environment variables. This is the default. Detect uses the following logic: If the TF_BUILD environment variable is set to true , AzurePipelines will be used. If the GITHUB_ACTIONS environment variable is set to true , GitHubActions will be used. If the TERM_PROGRAM environment variable is set to vscode , VisualStudioCode will be used. Use Client . This option can be specified using: # PowerShell: Using the OutputStyle parameter $option = New-PSRuleOption -OutputStyle AzurePipelines ; # PowerShell: Using the Output.Style hashtable key $option = New-PSRuleOption -Option @{ 'Output.Style' = 'AzurePipelines' }; # PowerShell: Using the OutputStyle parameter to set YAML Set-PSRuleOption -OutputFormat AzurePipelines ; # YAML: Using the output/style property output : style : AzurePipelines # Bash: Using environment variable export PSRULE_OUTPUT_STYLE = AzurePipelines # GitHub Actions: Using environment variable env : PSRULE_OUTPUT_STYLE : AzurePipelines # Azure Pipelines: Using environment variable variables : - name : PSRULE_OUTPUT_STYLE value : AzurePipelines Output.JsonIndent # Configures the indentation level for JSON output. This option applies to output generated from -OutputFormat Json for Get-PSRule and Invoke-PSRule . This option also applies to output generated from -OutputPath for Assert-PSRule . The range of indentation accepts a minimum of 0(machine first) spaces and a maximum of 4 spaces. This option can be specified using: # PowerShell: Using the OutputJsonIndent parameter $option = New-PSRuleOption -OutputJsonIndent 2 ; # PowerShell: Using the Output.JsonIndent hashtable key $option = New-PSRuleOption -Option @{ 'Output.JsonIndent' = 2 }; # PowerShell: Using the OutputStyle parameter to set YAML Set-PSRuleOption -OutputJsonIndent 2 ; # YAML: Using the output/jsonIndent property output : jsonIndent : 2 # Bash: Using environment variable export PSRULE_OUTPUT_JSONINDENT = 2 # PowerShell: Using environment variable $env:PSRULE_OUTPUT_JSONINDENT = 2 ; # GitHub Actions: Using environment variable env : PSRULE_OUTPUT_JSONINDENT : 2 # Azure Pipelines: Using environment variable variables : - name : PSRULE_OUTPUT_JSONINDENT value : 2 Requires # Specifies module version constraints for running PSRule. When set PSRule will error if a module version is used that does not satisfy the requirements. The format for version constraints are the same as the Version assertion method. See [about_PSRule_Assert] for more information. Module version constraints a not enforced prior to PSRule v0.19.0. The version constraint for a rule module is enforced when the module is included with -Module . A version constraint does not require a rule module to be included. Use the Include.Module option to automatically include a rule module. This option can be specified using: # PowerShell: Using the Requires.module hashtable key $option = New-PSRuleOption -Option @{ 'Requires.PSRule' = '>=1.0.0' }; # YAML: Using the requires property requires : PSRule : '>=1.0.0' # Require v1.0.0 or greater. PSRule.Rules.Azure : '>=1.0.0' # Require v1.0.0 or greater. PSRule.Rules.CAF : '@pre >=0.1.0' # Require stable or pre-releases v0.1.0 or greater. This option can be configured using environment variables. To specify a module version constraint, prefix the module name with PSRULE_REQUIRES_ . When the module name includes a dot ( . ) use an underscore ( _ ) instead. # Bash: Using environment variable export PSRULE_REQUIRES_PSRULE = '>=1.0.0' export PSRULE_REQUIRES_PSRULE_RULES_AZURE = '>=1.0.0' export PSRULE_REQUIRES_PSRULE_RULES_CAF = '@pre >=0.1.0' # GitHub Actions: Using environment variable env : PSRULE_REQUIRES_PSRULE : '>=1.0.0' PSRULE_REQUIRES_PSRULE_RULES_AZURE : '>=1.0.0' PSRULE_REQUIRES_PSRULE_RULES_CAF : '@pre >=0.1.0' # Azure Pipelines: Using environment variable variables : - name : PSRULE_REQUIRES_PSRULE value : '>=1.0.0' - name : PSRULE_REQUIRES_PSRULE_RULES_AZURE value : '>=1.0.0' - name : PSRULE_REQUIRES_PSRULE_RULES_CAF value : '@pre >=0.1.0' Rule.Baseline # The name of a default baseline to use for the module. Currently this option can only be set within a module configuration resource. For example: --- # Synopsis: Example module configuration for Enterprise.Rules module. apiVersion : github.com/microsoft/PSRule/v1 kind : ModuleConfig metadata : name : Enterprise.Rules spec : rule : baseline : Enterprise.Baseline1 Rule.Include # The name of specific rules to evaluate. If this option is not specified all rules in search paths will be evaluated. This option can be overridden at runtime by using the -Name cmdlet parameter. This option can be specified using: # PowerShell: Using the Rule.Include hashtable key $option = New-PSRuleOption -Option @{ 'Rule.Include' = 'Rule1' , 'Rule2' }; # YAML: Using the rule/include property rule : include : - Rule1 - Rule2 # Bash: Using environment variable export PSRULE_RULE_INCLUDE = 'Rule1;Rule2' # GitHub Actions: Using environment variable env : PSRULE_RULE_INCLUDE : 'Rule1;Rule2' # Azure Pipelines: Using environment variable variables : - name : PSRULE_RULE_INCLUDE value : 'Rule1;Rule2' Rule.IncludeLocal # Automatically include all local rules in the search path unless they have been explicitly excluded. This option will include local rules even when they do not match Rule.Include or Rule.Tag filters. By default, local rules will be filtered with Rule.Include and Rule.Tag filters. This option is useful when you want to include local rules not included in a baseline. This option can be specified using: # PowerShell: Using the RuleIncludeLocal parameter $option = New-PSRuleOption -RuleIncludeLocal $True ; # PowerShell: Using the Rule.IncludeLocal hashtable key $option = New-PSRuleOption -Option @{ 'Rule.IncludeLocal' = $True }; # PowerShell: Using the RuleIncludeLocal parameter to set YAML Set-PSRuleOption -RuleIncludeLocal $True ; # YAML: Using the rule/includeLocal property rule : includeLocal : true # Bash: Using environment variable export PSRULE_RULE_INCLUDELOCAL = true # GitHub Actions: Using environment variable env : PSRULE_RULE_INCLUDELOCAL : true # Azure Pipelines: Using environment variable variables : - name : PSRULE_RULE_INCLUDELOCAL value : true Rule.Exclude # The name of specific rules to exclude from being evaluated. This will exclude rules specified by Rule.Include or discovered from a search path. This option can be specified using: # PowerShell: Using the Rule.Exclude hashtable key $option = New-PSRuleOption -Option @{ 'Rule.Exclude' = 'Rule3' , 'Rule4' }; # YAML: Using the rule/exclude property rule : exclude : - Rule3 - Rule4 # Bash: Using environment variable export PSRULE_RULE_EXCLUDE = 'Rule3;Rule4' # GitHub Actions: Using environment variable env : PSRULE_RULE_EXCLUDE : 'Rule3;Rule4' # Azure Pipelines: Using environment variable variables : - name : PSRULE_RULE_EXCLUDE value : 'Rule3;Rule4' Rule.Tag # A set of required key value pairs (tags) that rules must have applied to them to be included. Multiple values can be specified for the same tag. When multiple values are used, only one must match. This option can be overridden at runtime by using the -Tag cmdlet parameter. This option can be specified using: # PowerShell: Using the Rule.Tag hashtable key $option = New-PSRuleOption -Option @{ 'Rule.Tag' = @{ severity = 'Critical' , 'Warning' } }; # YAML: Using the rule/tag property rule : tag : severity : Critical # YAML: Using the rule/tag property, with multiple values rule : tag : severity : - Critical - Warning In the example above, rules must have a tag of severity set to either Critical or Warning to be included. Suppression # In certain circumstances it may be necessary to exclude or suppress rules from processing objects that are in a known failed state. PSRule allows objects to be suppressed for a rule by TargetName. Objects that are suppressed are not processed by the rule at all but will continue to be processed by other rules. Rule suppression complements pre-filtering and pre-conditions. This option can be specified using: # PowerShell: Using the SuppressTargetName option with a hashtable $option = New-PSRuleOption -SuppressTargetName @{ 'storageAccounts.UseHttps' = 'TestObject1' , 'TestObject3' }; # YAML: Using the suppression property suppression : storageAccounts.UseHttps : targetName : - TestObject1 - TestObject3 In both of the above examples, TestObject1 and TestObject3 have been suppressed from being processed by a rule named storageAccounts.UseHttps . When to use rule suppression: A temporary exclusion for an object that is in a known failed state. When not to use rule suppression: An object should never be processed by any rule. Pre-filter the pipeline instead. The rule is not applicable because the object is the wrong type. Use pre-conditions on the rule instead. An example of pre-filtering: # Define objects to validate $items = @(); $items += [PSCustomObject] @{ Name = 'Fridge' ; Type = 'Equipment' ; Category = 'White goods' ; }; $items += [PSCustomObject] @{ Name = 'Apple' ; Type = 'Food' ; Category = 'Produce' ; }; $items += [PSCustomObject] @{ Name = 'Carrot' ; Type = 'Food' ; Category = 'Produce' ; }; # Example of pre-filtering, only food items are sent to Invoke-PSRule $items | Where-Object { $_ . Type -eq 'Food' } | Invoke-PSRule ; An example of pre-conditions: # A rule with a pre-condition to only process produce Rule 'isFruit' -If { $TargetObject . Category -eq 'Produce' } { # Condition to determine if the object is fruit $TargetObject . Name -in 'Apple' , 'Orange' , 'Pear' } Examples # Example ps-rule.yaml # # # PSRule example configuration # # Configure required module versions requires : PSRule.Rules.Azure : '>=1.1.0' # Configure convention options convention : include : - 'Convention1' # Configure execution options execution : aliasReferenceWarning : false languageMode : ConstrainedLanguage inconclusiveWarning : false notProcessedWarning : false suppressedRuleWarning : false # Configure include options include : module : - 'PSRule.Rules.Azure' path : [ ] # Configures input options input : format : Yaml ignoreGitPath : false objectPath : items pathIgnore : - '*.Designer.cs' targetType : - Microsoft.Compute/virtualMachines - Microsoft.Network/virtualNetworks # Configures outcome logging options logging : limitDebug : - Rule1 - Rule2 limitVerbose : - Rule1 - Rule2 ruleFail : Error rulePass : Information output : as : Summary banner : Minimal culture : - en-US encoding : UTF8 footer : RuleCount format : Json outcome : Fail style : GitHubActions # Configure rule suppression suppression : storageAccounts.UseHttps : targetName : - TestObject1 - TestObject3 # Configure baseline options binding : field : id : - ResourceId - AlternativeId ignoreCase : false nameSeparator : '::' preferTargetInfo : true targetName : - ResourceName - AlternateName targetType : - ResourceType - kind useQualifiedName : true configuration : appServiceMinInstanceCount : 2 rule : include : - rule1 - rule2 includeLocal : true exclude : - rule3 - rule4 tag : severity : - Critical - Warning Default ps-rule.yaml # # # PSRule defaults # # Note: Only properties that differ from the default values need to be specified. # Configure required module versions requires : { } # Configure convention options convention : include : [ ] # Configure execution options execution : aliasReferenceWarning : true languageMode : FullLanguage inconclusiveWarning : true notProcessedWarning : true suppressedRuleWarning : true # Configure include options include : module : [ ] path : - '.ps-rule/' # Configures input options input : format : Detect ignoreGitPath : true objectPath : null pathIgnore : [ ] targetType : [ ] # Configures outcome logging options logging : limitDebug : [ ] limitVerbose : [ ] ruleFail : None rulePass : None output : as : Detail banner : Default culture : [ ] encoding : Default footer : Default format : None outcome : Processed style : Detect # Configure rule suppression suppression : { } # Configure baseline options binding : field : { } ignoreCase : true nameSeparator : '/' preferTargetInfo : false targetName : - TargetName - Name targetType : - PSObject.TypeNames[0] useQualifiedName : false configuration : { } rule : include : [ ] includeLocal : false exclude : [ ] tag : { } Links # Invoke-PSRule New-PSRuleOption Set-PSRuleOption","title":"Options"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#options","text":"Describes additional options that can be used during rule execution.","title":"Options"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#description","text":"PSRule lets you use options when calling cmdlets such as Invoke-PSRule and Test-PSRuleTarget to change how rules are processed. This topic describes what options are available, when to and how to use them. The following workspace options are available for use: Convention.Include Execution.AliasReferenceWarning Execution.LanguageMode Execution.InconclusiveWarning Execution.NotProcessedWarning Execution.SuppressedRuleWarning Execution.InvariantCultureWarning Include.Module Include.Path Input.Format Input.IgnoreGitPath Input.IgnoreRepositoryCommon Input.ObjectPath Input.PathIgnore Input.TargetType Logging.LimitDebug Logging.LimitVerbose Logging.RuleFail Logging.RulePass Output.As Output.Banner Output.Culture Output.Encoding Output.Footer Output.Format Output.Outcome Output.Path Output.Style Output.JsonIndent Requires Suppression Additionally the following baseline options can be included: Binding.Field Binding.IgnoreCase Binding.NameSeparator Binding.PreferTargetInfo Binding.TargetName Binding.TargetType Binding.UseQualifiedName Configuration Rule.Baseline Rule.Include Rule.IncludeLocal Rule.Exclude Rule.Tag See about_PSRule_Baseline for more information on baseline options. Options can be used with the following PSRule cmdlets: Export-PSRuleBaseline Get-PSRule Get-PSRuleBaseline Get-PSRuleHelp Invoke-PSRule Test-PSRuleTarget Each of these cmdlets support: Using the -Option parameter with an object created with the New-PSRuleOption cmdlet. See cmdlet help for syntax and examples. Using the -Option parameter with a hashtable object. Using the -Option parameter with a YAML file path. When using a hashtable object @{} , one or more options can be specified as keys using a dotted notation. For example: $option = @{ 'Output.Format' = 'Yaml' }; Invoke-PSRule -Path . -Option $option ; Invoke-PSRule -Path . -Option @{ 'Output.Format' = 'Yaml' }; The above example shows how the Output.Format option as a hashtable key can be used. Continue reading for a full list of options and how each can be used. Alternatively, options can be stored in a YAML formatted file and loaded from disk. Storing options as YAML allows different configurations to be loaded in a repeatable way instead of having to create an options object each time. Options are stored as YAML properties using a lower camel case naming convention, for example: output : format : Yaml The Set-PSRuleOption cmdlet can be used to set options stored in YAML or the YAML file can be manually edited. Set-PSRuleOption -OutputFormat Yaml ; By default, PSRule will automatically look for a default YAML options file in the current working directory. Alternatively, you can specify a specific file path. For example: Invoke-PSRule -Option '.\\myconfig.yml' ; New-PSRuleOption -Path '.\\myconfig.yaml' ; PSRule uses any of the following file names (in order) as the default YAML options file. If more than one of these files exist, the following order will be used to find the first match. ps-rule.yaml ps-rule.yml psrule.yaml psrule.yml We recommend only using lowercase characters as shown above. This is because not all operating systems treat case in the same way. Most options can be set using environment variables. When configuring environment variables we recommend that all capital letters are used. This is because environment variables are case-sensitive on some operating systems. PSRule environment variables use a consistent naming pattern of PSRULE_<PARENT>_<NAME> . Where <PARENT> is the parent class and <NAME> is the specific option. For example: Execution.InconclusiveWarning is configured by PSRULE_EXECUTION_INCONCLUSIVEWARNING . Input.TargetType is configured by PSRULE_INPUT_TARGETTYPE . Output.Format is configured by PSRULE_OUTPUT_FORMAT . When setting environment variables: Enum values are set by string. For example PSRULE_OUTPUT_FORMAT could be set to Yaml . Enum values are case-insensitive. Boolean values are set by true , false , 1 , or 0 . For example PSRULE_EXECUTION_INCONCLUSIVEWARNING could be set to false . Boolean values are case-insensitive. String array values can specify multiple items by using a semi-colon separator. For example PSRULE_INPUT_TARGETTYPE could be set to virtualMachine;virtualNetwork .","title":"Description"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#bindingfield","text":"When an object is passed from the pipeline, PSRule automatically extracts fields from object properties. PSRule provides standard fields such as TargetName and TargetType . In addition to standard fields, custom fields can be bound. Custom fields are available to rules and included in output. PSRule uses the following logic to determine which property should be used for binding: By default PSRule will not extract any custom fields. If custom fields are configured, PSRule will attempt to bind the field. If none of the configured property names exist, the field will be skipped. If more then one property name is configured, the order they are specified in the configuration determines precedence. i.e. The first configured property name will take precedence over the second property name. By default the property name will be matched ignoring case sensitivity. To use a case sensitive match, configure the Binding.IgnoreCase option. Custom field bindings can be specified using: # PowerShell: Using the BindingField parameter $option = New-PSRuleOption -BindingField @{ id = 'ResourceId' , 'AlternativeId' }; # PowerShell: Using the Binding.Field hashtable key $option = New-PSRuleOption -Option @{ 'Binding.Field' = @{ id = 'ResourceId' , 'AlternativeId' } }; # PowerShell: Using the BindingField parameter to set YAML Set-PSRuleOption -BindingField @{ id = 'ResourceId' , 'AlternativeId' }; # YAML: Using the binding/field property binding : field : id : - ResourceId - AlternativeId","title":"Binding.Field"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#bindingignorecase","text":"When evaluating an object, PSRule extracts a few key properties from the object to help filter rules and display output results. The process of extract these key properties is called binding . The properties that PSRule uses for binding can be customized by providing a order list of alternative properties to use. See Binding.TargetName and Binding.TargetType for these options. By default, custom property binding finds the first matching property by name regardless of case. i.e. Binding.IgnoreCase is true . To make custom bindings case sensitive, set the Binding.IgnoreCase option to false . Changing this option will affect custom property bindings for both TargetName and TargetType . Setting this option has no affect on binding defaults or custom scripts. This option can be specified using: # PowerShell: Using the BindingIgnoreCase parameter $option = New-PSRuleOption -BindingIgnoreCase $False ; # PowerShell: Using the Binding.IgnoreCase hashtable key $option = New-PSRuleOption -Option @{ 'Binding.IgnoreCase' = $False }; # PowerShell: Using the BindingIgnoreCase parameter to set YAML Set-PSRuleOption -BindingIgnoreCase $False ; # YAML: Using the binding/ignoreCase property binding : ignoreCase : false # Bash: Using environment variable export PSRULE_BINDING_IGNORECASE = false # GitHub Actions: Using environment variable env : PSRULE_BINDING_IGNORECASE : false # Azure Pipelines: Using environment variable variables : - name : PSRULE_BINDING_IGNORECASE value : false","title":"Binding.IgnoreCase"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#bindingnameseparator","text":"When an object is passed from the pipeline, PSRule assigns the object a TargetName . TargetName is used in output results to identify one object from another. In cases where different types of objects share the same TargetName , this may become confusing. Using a qualified name, prefixes the TargetName with TargetType . i.e. TargetType/TargetName To use a qualified name, see the Binding.UseQualifiedName option. By default, PSRule uses / to separate TargetType from TargetName . This option configures the separator that PSRule uses between the two components. This option can be specified using: # PowerShell: Using the BindingNameSeparator parameter $option = New-PSRuleOption -BindingNameSeparator '::' ; # PowerShell: Using the Binding.NameSeparator hashtable key $option = New-PSRuleOption -Option @{ 'Binding.NameSeparator' = '::' }; # PowerShell: Using the BindingNameSeparator parameter to set YAML Set-PSRuleOption -BindingNameSeparator '::' ; # YAML: Using the binding/nameSeparator property binding : nameSeparator : '::' # Bash: Using environment variable export PSRULE_BINDING_NAMESEPARATOR = '::' # GitHub Actions: Using environment variable env : PSRULE_BINDING_NAMESEPARATOR : '::' # Azure Pipelines: Using environment variable variables : - name : PSRULE_BINDING_NAMESEPARATOR value : '::'","title":"Binding.NameSeparator"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#bindingprefertargetinfo","text":"Some built-in objects within PSRule perform automatic binding of TargetName and TargetType. These built-in objects provide their own target info. When binding has been configured these values override automatic binding by default. This can occur when the built-in object uses one of the fields specified by the custom configuration. The common occurrences of this are on fields such as Name and FullName which are widely used. To prefer automatic binding when specified set this option to $True . This option can be specified using: # PowerShell: Using the BindingPreferTargetInfo parameter $option = New-PSRuleOption -BindingPreferTargetInfo $True ; # PowerShell: Using the Binding.PreferTargetInfo hashtable key $option = New-PSRuleOption -Option @{ 'Binding.PreferTargetInfo' = $True }; # PowerShell: Using the BindingPreferTargetInfo parameter to set YAML Set-PSRuleOption -BindingPreferTargetInfo $True ; # YAML: Using the binding/preferTargetInfo property binding : preferTargetInfo : true # Bash: Using environment variable export PSRULE_BINDING_PREFERTARGETINFO = false # GitHub Actions: Using environment variable env : PSRULE_BINDING_PREFERTARGETINFO : false # Azure Pipelines: Using environment variable variables : - name : PSRULE_BINDING_PREFERTARGETINFO value : false","title":"Binding.PreferTargetInfo"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#bindingtargetname","text":"When an object is passed from the pipeline, PSRule assigns the object a TargetName . TargetName is used in output results to identify one object from another. Many objects could be passed down the pipeline at the same time, so using a TargetName that is meaningful is important. TargetName is also used for advanced features such as rule suppression. The value that PSRule uses for TargetName is configurable. PSRule uses the following logic to determine what TargetName should be used: By default PSRule will: Use TargetName or Name properties on the object. These property names are case insensitive. If both TargetName and Name properties exist, TargetName will take precedence over Name . If neither TargetName or Name properties exist, a SHA1 hash of the object will be used as TargetName . If custom TargetName binding properties are configured, the property names specified will override the defaults. If none of the configured property names exist, PSRule will revert back to TargetName then Name . If more then one property name is configured, the order they are specified in the configuration determines precedence. i.e. The first configured property name will take precedence over the second property name. By default the property name will be matched ignoring case sensitivity. To use a case sensitive match, configure the Binding.IgnoreCase option. If a custom TargetName binding function is specified, the function will be evaluated first before any other option. If the function returns $Null then custom properties, TargetName and Name properties will be used. The custom binding function is executed outside the PSRule engine, so PSRule keywords and variables will not be available. Custom binding functions are blocked in constrained language mode is used. See language mode for more information. Custom property names to use for binding can be specified using: # PowerShell: Using the TargetName parameter $option = New-PSRuleOption -TargetName 'ResourceName' , 'AlternateName' ; # PowerShell: Using the Binding.TargetName hashtable key $option = New-PSRuleOption -Option @{ 'Binding.TargetName' = 'ResourceName' , 'AlternateName' }; # PowerShell: Using the TargetName parameter to set YAML Set-PSRuleOption -TargetName 'ResourceName' , 'AlternateName' ; # YAML: Using the binding/targetName property binding : targetName : - ResourceName - AlternateName # Bash: Using environment variable export PSRULE_BINDING_TARGETNAME = 'ResourceName;AlternateName' # GitHub Actions: Using environment variable env : PSRULE_BINDING_TARGETNAME : 'ResourceName;AlternateName' # Azure Pipelines: Using environment variable variables : - name : PSRULE_BINDING_TARGETNAME value : 'ResourceName;AlternateName' To specify a custom binding function use: # Create a custom function that returns a TargetName string $bindFn = { param ( $TargetObject ) $otherName = $TargetObject . PSObject . Properties [ 'OtherName' ]; if ( $Null -eq $otherName ) { return $Null } return $otherName . Value ; } # Specify the binding function script block code to execute $option = New-PSRuleOption -BindTargetName $bindFn ;","title":"Binding.TargetName"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#bindingtargettype","text":"When an object is passed from the pipeline, PSRule assigns the object a TargetType . TargetType is used to filter rules based on object type and appears in output results. The value that PSRule uses for TargetType is configurable. PSRule uses the following logic to determine what TargetType should be used: By default PSRule will: Use the default type presented by PowerShell from TypeNames . i.e. .PSObject.TypeNames[0] If custom TargetType binding properties are configured, the property names specified will override the defaults. If none of the configured property names exist, PSRule will revert back to the type presented by PowerShell. If more then one property name is configured, the order they are specified in the configuration determines precedence. i.e. The first configured property name will take precedence over the second property name. By default the property name will be matched ignoring case sensitivity. To use a case sensitive match, configure the Binding.IgnoreCase option. If a custom TargetType binding function is specified, the function will be evaluated first before any other option. If the function returns $Null then custom properties, or the type presented by PowerShell will be used in order instead. The custom binding function is executed outside the PSRule engine, so PSRule keywords and variables will not be available. Custom binding functions are blocked in constrained language mode is used. See language mode for more information. Custom property names to use for binding can be specified using: # PowerShell: Using the TargetType parameter $option = New-PSRuleOption -TargetType 'ResourceType' , 'kind' ; # PowerShell: Using the Binding.TargetType hashtable key $option = New-PSRuleOption -Option @{ 'Binding.TargetType' = 'ResourceType' , 'kind' }; # PowerShell: Using the TargetType parameter to set YAML Set-PSRuleOption -TargetType 'ResourceType' , 'kind' ; # YAML: Using the binding/targetType property binding : targetType : - ResourceType - kind # Bash: Using environment variable export PSRULE_BINDING_TARGETTYPE = 'ResourceType;kind' # GitHub Actions: Using environment variable env : PSRULE_BINDING_TARGETTYPE : 'ResourceType;kind' # Azure Pipelines: Using environment variable variables : - name : PSRULE_BINDING_TARGETTYPE value : 'ResourceType;kind' To specify a custom binding function use: # Create a custom function that returns a TargetType string $bindFn = { param ( $TargetObject ) $otherType = $TargetObject . PSObject . Properties [ 'OtherType' ]; if ( $otherType -eq $Null ) { return $Null } return $otherType . Value ; } # Specify the binding function script block code to execute $option = New-PSRuleOption -BindTargetType $bindFn ;","title":"Binding.TargetType"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#bindingusequalifiedname","text":"When an object is passed from the pipeline, PSRule assigns the object a TargetName . TargetName is used in output results to identify one object from another. In cases where different types of objects share the same TargetName , this may become confusing. Using a qualified name, prefixes the TargetName with TargetType . i.e. TargetType/TargetName This option determines if PSRule uses qualified or unqualified names (default). By default, PSRule uses / to separate TargetType from TargetName . Set Binding.NameSeparator to change. This option can be specified using: # PowerShell: Using the BindingUseQualifiedName parameter $option = New-PSRuleOption -BindingUseQualifiedName $True ; # PowerShell: Using the Binding.UseQualifiedName hashtable key $option = New-PSRuleOption -Option @{ 'Binding.UseQualifiedName' = $True }; # PowerShell: Using the BindingUseQualifiedName parameter to set YAML Set-PSRuleOption -BindingUseQualifiedName $True ; # YAML: Using the binding/useQualifiedName property binding : useQualifiedName : true # Bash: Using environment variable export PSRULE_BINDING_USEQUALIFIEDNAME = false # GitHub Actions: Using environment variable env : PSRULE_BINDING_USEQUALIFIEDNAME : false # Azure Pipelines: Using environment variable variables : - name : PSRULE_BINDING_USEQUALIFIEDNAME value : false","title":"Binding.UseQualifiedName"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#configuration","text":"Configures a set of baseline configuration values that can be used in rule definitions. Configuration values can be overridden at different scopes. This option can be specified using: # PowerShell: Using the Configuration option with a hashtable $option = New-PSRuleOption -Configuration @{ LOCAL_APPSERVICEMININSTANCECOUNT = 2 }; # YAML: Using the configuration property configuration : LOCAL_APPSERVICEMININSTANCECOUNT : 2 Configuration values can be specified using environment variables. To specify a configuration value, prefix the configuration value with PSRULE_CONFIGURATION_ . # Bash: Using environment variable export PSRULE_CONFIGURATION_LOCAL_APPSERVICEMININSTANCECOUNT = 2 # GitHub Actions: Using environment variable env : PSRULE_CONFIGURATION_LOCAL_APPSERVICEMININSTANCECOUNT : '2' # Azure Pipelines: Using environment variable variables : - name : PSRULE_CONFIGURATION_LOCAL_APPSERVICEMININSTANCECOUNT value : '2'","title":"Configuration"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#conventioninclude","text":"Specifies conventions to execute when the pipeline run. Conventions are included by name and must be defined within files included in -Path or -Module . This option can be specified using: # PowerShell: Using the Convention parameter $option = New-PSRuleOption -Convention 'Convention1' , 'Convention2' ; # PowerShell: Using the Convention.Include hashtable key $option = New-PSRuleOption -Option @{ 'Convention.Include' = $True }; # PowerShell: Using the Convention parameter to set YAML Set-PSRuleOption -Convention 'Convention1' , 'Convention2' ; # YAML: Using the convention/include property convention : include : - 'Convention1' - 'Convention2' # Bash: Using environment variable export PSRULE_CONVENTION_INCLUDE = 'Convention1;Convention2' # GitHub Actions: Using environment variable env : PSRULE_CONVENTION_INCLUDE : 'Convention1;Convention2' # Azure Pipelines: Using environment variable variables : - name : PSRULE_CONVENTION_INCLUDE value : 'Convention1;Convention2'","title":"Convention.Include"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#executionaliasreferencewarning","text":"Rules may define one or more aliases. These aliases are alternative names to identify the rule. An alias may be used to reference the rule anywhere a rule name is used. The primary purpose of an alias is to provide a non-breaking method to change the rule name. Alises can be removed at a later revision once the rule is no longer referenced by the alias. A warning is logged by default to help identify when an alias is used. We recommend taking action to update your usage of the alis to use the rule name or ref instead. Alternatively, the alias reference warning can be disabled by using: # PowerShell: Using the AliasReferenceWarning parameter $option = New-PSRuleOption -AliasReferenceWarning $False ; # PowerShell: Using the Execution.AliasReferenceWarning hashtable key $option = New-PSRuleOption -Option @{ 'Execution.AliasReferenceWarning' = $False }; # PowerShell: Using the AliasReferenceWarning parameter to set YAML Set-PSRuleOption -AliasReferenceWarning $False ; # YAML: Using the execution/aliasReferenceWarning property execution : aliasReferenceWarning : false # Bash: Using environment variable export PSRULE_EXECUTION_ALIASREFERENCEWARNING = false # GitHub Actions: Using environment variable env : PSRULE_EXECUTION_ALIASREFERENCEWARNING : false # Azure Pipelines: Using environment variable variables : - name : PSRULE_EXECUTION_ALIASREFERENCEWARNING value : false","title":"Execution.AliasReferenceWarning"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#executionlanguagemode","text":"Unless PowerShell has been constrained, full language features of PowerShell are available to use within rule definitions. In locked down environments, a reduced set of language features may be desired. When PSRule is executed in an environment configured for Device Guard, only constrained language features are available. The following language modes are available for use in PSRule: FullLanguage ConstrainedLanguage This option can be specified using: # PowerShell: Using the Execution.LanguageMode hashtable key $option = New-PSRuleOption -Option @{ 'Execution.LanguageMode' = 'ConstrainedLanguage' }; # YAML: Using the execution/languageMode property execution : languageMode : ConstrainedLanguage # Bash: Using environment variable export PSRULE_EXECUTION_LANGUAGEMODE = ConstrainedLanguage # GitHub Actions: Using environment variable env : PSRULE_EXECUTION_LANGUAGEMODE : ConstrainedLanguage # Azure Pipelines: Using environment variable variables : - name : PSRULE_EXECUTION_LANGUAGEMODE value : ConstrainedLanguage","title":"Execution.LanguageMode"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#executioninconclusivewarning","text":"When defining rules, it is possible not return a valid $True or $False result within the definition script block. Rule authors should not intentionally avoid returning a result, however a possible cause for not returning a result may be a rule logic error. If a rule should not be evaluated, use pre-conditions to avoid processing the rule for objects where the rule is not applicable. In cases where the rule does not return a result it is marked as inconclusive. Inconclusive results will: Generate a warning by default. Fail the object. Outcome will be reported as Fail with an OutcomeReason of Inconclusive . The inconclusive warning can be disabled by using: # PowerShell: Using the InconclusiveWarning parameter $option = New-PSRuleOption -InconclusiveWarning $False ; # PowerShell: Using the Execution.InconclusiveWarning hashtable key $option = New-PSRuleOption -Option @{ 'Execution.InconclusiveWarning' = $False }; # PowerShell: Using the InconclusiveWarning parameter to set YAML Set-PSRuleOption -InconclusiveWarning $False ; # YAML: Using the execution/inconclusiveWarning property execution : inconclusiveWarning : false # Bash: Using environment variable export PSRULE_EXECUTION_INCONCLUSIVEWARNING = false # GitHub Actions: Using environment variable env : PSRULE_EXECUTION_INCONCLUSIVEWARNING : false # Azure Pipelines: Using environment variable variables : - name : PSRULE_EXECUTION_INCONCLUSIVEWARNING value : false","title":"Execution.InconclusiveWarning"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#executionnotprocessedwarning","text":"When evaluating rules, it is possible to incorrectly select a path with rules that use pre-conditions that do not accept the pipeline object. In this case the object has not been processed by any rule. Not processed objects will: Generate a warning by default. Pass the object. Outcome will be reported as None . The not processed warning can be disabled by using: # PowerShell: Using the NotProcessedWarning parameter $option = New-PSRuleOption -NotProcessedWarning $False ; # PowerShell: Using the Execution.NotProcessedWarning hashtable key $option = New-PSRuleOption -Option @{ 'Execution.NotProcessedWarning' = $False }; # PowerShell: Using the NotProcessedWarning parameter to set YAML Set-PSRuleOption -NotProcessedWarning $False ; # YAML: Using the execution/notProcessedWarning property execution : notProcessedWarning : false # Bash: Using environment variable export PSRULE_EXECUTION_NOTPROCESSEDWARNING = false # GitHub Actions: Using environment variable env : PSRULE_EXECUTION_NOTPROCESSEDWARNING : false # Azure Pipelines: Using environment variable variables : - name : PSRULE_EXECUTION_NOTPROCESSEDWARNING value : false","title":"Execution.NotProcessedWarning"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#executionsuppressedrulewarning","text":"When evaluating rules, it is possible to output suppressed rules as warnings. Suppressed rules will: Output a warning by default. Show which rules were suppressed when Output.As is set to Detail . Show how many rules were suppressed when Output.As is set to Summary . The suppressed rule can be disabled by using: # PowerShell: Using the SuppressedRuleWarning parameter $option = New-PSRuleOption -SuppressedRuleWarning $False ; # PowerShell: Using the Execution.SuppressedRuleWarning hashtable key $option = New-PSRuleOption -Option @{ 'Execution.SuppressedRuleWarning' = $False }; # PowerShell: Using the SuppressedRuleWarning parameter to set YAML Set-PSRuleOption -SuppressedRuleWarning $False ; # YAML: Using the execution/suppressedRuleWarning property execution : suppressedRuleWarning : false # Bash: Using environment variable export PSRULE_EXECUTION_SUPPRESSEDRULEWARNING = false # GitHub Actions: Using environment variable env : PSRULE_EXECUTION_SUPPRESSEDRULEWARNING : false # Azure Pipelines: Using environment variable variables : - name : PSRULE_EXECUTION_SUPPRESSEDRULEWARNING value : false","title":"Execution.SuppressedRuleWarning"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#executioninvariantculturewarning","text":"When evaluating rules inside a CI host, if invariant culture is used, a warning is shown by default. You can suppress this warning if you set the culture with -Culture or the Output.Culture option. This warning can also be suppressed by using: # PowerShell: Using the InvariantCultureWarning parameter $option = New-PSRuleOption -InvariantCultureWarning $False ; # PowerShell: Using the Execution.InvariantCultureWarning hashtable key $option = New-PSRuleOption -Option @{ 'Execution.InvariantCultureWarning' = $False }; # PowerShell: Using the InvariantCultureWarning parameter to set YAML Set-PSRuleOption -InvariantCultureWarning $False ; # YAML: Using the execution/invariantCultureWarning property execution : invariantCultureWarning : false # Bash: Using environment variable export PSRULE_EXECUTION_INVARIANTCULTUREWARNING = false # GitHub Actions: Using environment variable env : PSRULE_EXECUTION_INVARIANTCULTUREWARNING : false # Azure Pipelines: Using environment variable variables : - name : PSRULE_EXECUTION_INVARIANTCULTUREWARNING value : false","title":"Execution.InvariantCultureWarning"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#includemodule","text":"Automatically include rules and resources from the specified module. To automatically import and include a module specify the module by name. The module must already be installed on the system. When $PSModuleAutoLoadingPreference is set to a value other then All the module must be imported. This option is equivalent to using the -Module parameter on PSRule cmdlets, with the following addition: Modules specified with Include.Module are combined with -Module . Both sets of modules will be imported and used using execution. This option can be specified using: # PowerShell: Using the IncludeModule parameter $option = New-PSRuleOption -IncludeModule 'TestModule1' , 'TestModule2' ; # PowerShell: Using the Include.Module hashtable key $option = New-PSRuleOption -Option @{ 'Include.Module' = 'TestModule1' , 'TestModule2' }; # PowerShell: Using the IncludeModule parameter to set YAML Set-PSRuleOption -IncludeModule 'TestModule1' , 'TestModule2' ; # YAML: Using the include/module property include : module : - TestModule1 # Bash: Using environment variable export PSRULE_INCLUDE_MODULE = TestModule1 ; TestModule2 # GitHub Actions: Using environment variable env : PSRULE_INCLUDE_MODULE : TestModule1;TestModule2 # Azure Pipelines: Using environment variable variables : - name : PSRULE_INCLUDE_MODULE value : TestModule1;TestModule2","title":"Include.Module"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#includepath","text":"Automatically include rules and resources from the specified path. By default, .ps-rule/ is included. This option is equivalent to using the -Path parameter on PSRule cmdlets, with the following additions: Paths specified with Include.Path are combined with -Path . Both sets of paths will be imported and used using execution. The Include.Path option defaults to .ps-rule/ . To override this default, specify one or more alternative paths or an empty array. This option can be specified using: # PowerShell: Using the IncludePath parameter $option = New-PSRuleOption -IncludePath '.ps-rule/' , 'custom-rules/' ; # PowerShell: Using the Include.Path hashtable key $option = New-PSRuleOption -Option @{ 'Include.Path' = '.ps-rule/' , 'custom-rules/' }; # PowerShell: Using the IncludePath parameter to set YAML Set-PSRuleOption -IncludePath '.ps-rule/' , 'custom-rules/' ; # YAML: Using the include/path property include : path : - custom-rules/ # Bash: Using environment variable export PSRULE_INCLUDE_PATH = .ps-rule/ ; custom-rules/ # GitHub Actions: Using environment variable env : PSRULE_INCLUDE_PATH : .ps-rule/;custom-rules/ # Azure Pipelines: Using environment variable variables : - name : PSRULE_INCLUDE_PATH value : .ps-rule/;custom-rules/","title":"Include.Path"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#inputformat","text":"Configures the input format for when a string is passed in as a target object. This option determines if the target object is deserialized into an alternative form. Use this option with Assert-PSRule , Invoke-PSRule or Test-PSRuleTarget . Set this option to either Yaml , Json , Markdown , PowerShellData to deserialize as a specific format. The -Format parameter will override any value set in configuration. When the -InputObject parameter or pipeline input is used, strings are treated as plain text by default. FileInfo objects for supported file formats will be deserialized based on file extension. When the -InputPath parameter is used, supported file formats will be deserialized based on file extension. The -InputPath parameter can be used with a file path or URL. The following formats are available: None - Treat strings as plain text and do not deserialize files. Yaml - Deserialize as one or more YAML objects. Json - Deserialize as one or more JSON objects. Markdown - Deserialize as a markdown object. PowerShellData - Deserialize as a PowerShell data object. File - Files are not deserialized. Detect - Detect format based on file extension. This is the default. If the Detect format is used, the file extension will be used to automatically detect the format. When the file extension can not be determined Detect is the same as None . The Markdown format does not parse the whole markdown document. Specifically this format deserializes YAML front matter from the top of the document if any exists. The File format does not deserialize file contents. Each file is returned as an object. Files within .git sub-directories are ignored. Path specs specified in .gitignore directly in the current working path are ignored. A RepositoryInfo object is generated if the current working path if a .git sub-directory is present. Additionally, PSRule performs automatic type binding for file objects, using the extension as the type. When files have no extension the whole file name is used. Detect uses the following file extensions: Yaml - .yaml or .yml Json - .json or .jsonc Markdown - .md or .markdown PowerShellData - .psd1 This option can be specified using: # PowerShell: Using the Format parameter $option = New-PSRuleOption -Format Yaml ; # PowerShell: Using the Input.Format hashtable key $option = New-PSRuleOption -Option @{ 'Input.Format' = 'Yaml' }; # PowerShell: Using the Format parameter to set YAML Set-PSRuleOption -Format Yaml ; # YAML: Using the input/format property input : format : Yaml # Bash: Using environment variable export PSRULE_INPUT_FORMAT = Yaml # GitHub Actions: Using environment variable env : PSRULE_INPUT_FORMAT : Yaml # Azure Pipelines: Using environment variable variables : - name : PSRULE_INPUT_FORMAT value : Yaml","title":"Input.Format"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#inputignoregitpath","text":"When reading files from an input path, files within the .git sub-directory are ignored by default. Files stored within the .git sub-directory are system repository files used by git. To read files stored within the .git path, set this option to $False . This option can be specified using: # PowerShell: Using the InputIgnoreGitPath parameter $option = New-PSRuleOption -InputIgnoreGitPath $False ; # PowerShell: Using the Input.IgnoreGitPath hashtable key $option = New-PSRuleOption -Option @{ 'Input.IgnoreGitPath' = $False }; # PowerShell: Using the InputIgnoreGitPath parameter to set YAML Set-PSRuleOption -InputIgnoreGitPath $False ; # YAML: Using the input/ignoreGitPath property input : ignoreGitPath : false # Bash: Using environment variable export PSRULE_INPUT_IGNOREGITPATH = false # GitHub Actions: Using environment variable env : PSRULE_INPUT_IGNOREGITPATH : false # Azure Pipelines: Using environment variable variables : - name : PSRULE_INPUT_IGNOREGITPATH value : false","title":"Input.IgnoreGitPath"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#inputignorerepositorycommon","text":"When reading files from an input path, files are discovered recursively. A number of files are commonly found within a private and open-source repositories. In many cases these files are of no interest for analysis and should be ignored by rules. PSRule will ignore the following files by default: README.md .DS_Store .gitignore .gitattributes .gitmodules LICENSE LICENSE.txt CODE_OF_CONDUCT.md CONTRIBUTING.md SECURITY.md SUPPORT.md .vscode/*.json .github/**/*.md .github/CODEOWNERS To include these files, set this option to $False . This option can be specified using: # PowerShell: Using the InputIgnoreRepositoryCommon parameter $option = New-PSRuleOption -InputIgnoreRepositoryCommon $False ; # PowerShell: Using the Input.IgnoreRepositoryCommon hashtable key $option = New-PSRuleOption -Option @{ 'Input.IgnoreRepositoryCommon' = $False }; # PowerShell: Using the InputIgnoreRepositoryCommon parameter to set YAML Set-PSRuleOption -InputIgnoreRepositoryCommon $False ; # YAML: Using the input/ignoreRepositoryCommon property input : ignoreRepositoryCommon : false # Bash: Using environment variable export PSRULE_INPUT_IGNOREREPOSITORYCOMMON = false # GitHub Actions: Using environment variable env : PSRULE_INPUT_IGNOREREPOSITORYCOMMON : false # Azure Pipelines: Using environment variable variables : - name : PSRULE_INPUT_IGNOREREPOSITORYCOMMON value : false","title":"Input.IgnoreRepositoryCommon"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#inputobjectpath","text":"The object path to a property to use instead of the pipeline object. By default, PSRule processes objects passed from the pipeline against selected rules. When this option is set, instead of evaluating the pipeline object, PSRule looks for a property of the pipeline object specified by ObjectPath and uses that instead. If the property specified by ObjectPath is a collection/ array, then each item is evaluated separately. If the property specified by ObjectPath does not exist, PSRule skips the object. When using Invoke-PSRule , Test-PSRuleTarget and Assert-PSRule the -ObjectPath parameter will override any value set in configuration. This option can be specified using: # PowerShell: Using the ObjectPath parameter $option = New-PSRuleOption -ObjectPath 'items' ; # PowerShell: Using the Input.ObjectPath hashtable key $option = New-PSRuleOption -Option @{ 'Input.ObjectPath' = 'items' }; # PowerShell: Using the ObjectPath parameter to set YAML Set-PSRuleOption -ObjectPath 'items' ; # YAML: Using the input/objectPath property input : objectPath : items # Bash: Using environment variable export PSRULE_INPUT_OBJECTPATH = items # GitHub Actions: Using environment variable env : PSRULE_INPUT_OBJECTPATH : items # Azure Pipelines: Using environment variable variables : - name : PSRULE_INPUT_OBJECTPATH value : items","title":"Input.ObjectPath"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#inputpathignore","text":"Ignores input files that match the path spec when using -InputPath . If specified, files that match the path spec will not be processed. By default, all files are processed. This option can be specified using: # PowerShell: Using the InputPathIgnore parameter $option = New-PSRuleOption -InputPathIgnore '*.Designer.cs' ; # PowerShell: Using the Input.PathIgnore hashtable key $option = New-PSRuleOption -Option @{ 'Input.PathIgnore' = '*.Designer.cs' }; # PowerShell: Using the InputPathIgnore parameter to set YAML Set-PSRuleOption -InputPathIgnore '*.Designer.cs' ; # YAML: Using the input/pathIgnore property input : pathIgnore : - '*.Designer.cs' # Bash: Using environment variable export PSRULE_INPUT_PATHIGNORE = *.Designer.cs # GitHub Actions: Using environment variable env : PSRULE_INPUT_PATHIGNORE : '*.Designer.cs' # Azure Pipelines: Using environment variable variables : - name : PSRULE_INPUT_PATHIGNORE value : '*.Designer.cs'","title":"Input.PathIgnore"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#inputtargettype","text":"Filters input objects by TargetType. If specified, only objects with the specified TargetType are processed. Objects that do not match TargetType are ignored. If multiple values are specified, only one TargetType must match. This option is not case-sensitive. By default, all objects are processed. To change the field TargetType is bound to set the Binding.TargetType option. When using Invoke-PSRule , Test-PSRuleTarget and Assert-PSRule the -TargetType parameter will override any value set in configuration. This option can be specified using: # PowerShell: Using the InputTargetType parameter $option = New-PSRuleOption -InputTargetType 'virtualMachine' , 'virtualNetwork' ; # PowerShell: Using the Input.TargetType hashtable key $option = New-PSRuleOption -Option @{ 'Input.TargetType' = 'virtualMachine' , 'virtualNetwork' }; # PowerShell: Using the InputTargetType parameter to set YAML Set-PSRuleOption -InputTargetType 'virtualMachine' , 'virtualNetwork' ; # YAML: Using the input/targetType property input : targetType : - virtualMachine # Bash: Using environment variable export PSRULE_INPUT_TARGETTYPE = virtualMachine ; virtualNetwork # GitHub Actions: Using environment variable env : PSRULE_INPUT_TARGETTYPE : virtualMachine;virtualNetwork # Azure Pipelines: Using environment variable variables : - name : PSRULE_INPUT_TARGETTYPE value : virtualMachine;virtualNetwork","title":"Input.TargetType"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#logginglimitdebug","text":"Limits debug messages to a list of named debug scopes. When using the -Debug switch or preference variable, by default PSRule cmdlets log all debug output. When using debug output for debugging a specific rule, it may be helpful to limit debug message to a specific rule. To identify a rule to include in debug output use the rule name. The following built-in scopes exist in addition to rule names: [Discovery.Source] - Discovery messages for .Rule.ps1 files and rule modules. [Discovery.Rule] - Discovery messages for individual rules within .Rule.ps1 files. This option can be specified using: # PowerShell: Using the LoggingLimitDebug parameter $option = New-PSRuleOption -LoggingLimitDebug Rule1 , Rule2 ; # PowerShell: Using the Logging.LimitDebug hashtable key $option = New-PSRuleOption -Option @{ 'Logging.LimitDebug' = Rule1 , Rule2 }; # PowerShell: Using the LoggingLimitDebug parameter to set YAML Set-PSRuleOption -LoggingLimitDebug Rule1 , Rule2 ; # YAML: Using the logging/limitDebug property logging : limitDebug : - Rule1 - Rule2","title":"Logging.LimitDebug"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#logginglimitverbose","text":"Limits verbose messages to a list of named verbose scopes. When using the -Verbose switch or preference variable, by default PSRule cmdlets log all verbose output. When using verbose output for troubleshooting a specific rule, it may be helpful to limit verbose messages to a specific rule. To identify a rule to include in verbose output use the rule name. The following built-in scopes exist in addition to rule names: [Discovery.Source] - Discovery messages for .Rule.ps1 files and rule modules. [Discovery.Rule] - Discovery messages for individual rules within .Rule.ps1 files. This option can be specified using: # PowerShell: Using the LoggingLimitVerbose parameter $option = New-PSRuleOption -LoggingLimitVerbose Rule1 , Rule2 ; # PowerShell: Using the Logging.LimitVerbose hashtable key $option = New-PSRuleOption -Option @{ 'Logging.LimitVerbose' = Rule1 , Rule2 }; # PowerShell: Using the LoggingLimitVerbose parameter to set YAML Set-PSRuleOption -LoggingLimitVerbose Rule1 , Rule2 ; # YAML: Using the logging/limitVerbose property logging : limitVerbose : - Rule1 - Rule2","title":"Logging.LimitVerbose"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#loggingrulefail","text":"When an object fails a rule condition the results are written to output as a structured object marked with the outcome of Fail . If the rule executed successfully regardless of outcome no other informational messages are shown by default. In some circumstances such as a continuous integration (CI) pipeline, it may be preferable to see informational messages or abort the CI process if one or more Fail outcomes are returned. By settings this option, error, warning or information messages will be generated for each rule fail outcome in addition to structured output. By default, outcomes are not logged to an informational stream (i.e. None). The following streams available: None Error Warning Information This option can be specified using: # PowerShell: Using the LoggingRuleFail parameter $option = New-PSRuleOption -LoggingRuleFail Error ; # PowerShell: Using the Logging.RuleFail hashtable key $option = New-PSRuleOption -Option @{ 'Logging.RuleFail' = 'Error' }; # PowerShell: Using the LoggingRuleFail parameter to set YAML Set-PSRuleOption -LoggingRuleFail Error ; # YAML: Using the logging/ruleFail property logging : ruleFail : Error","title":"Logging.RuleFail"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#loggingrulepass","text":"When an object passes a rule condition the results are written to output as a structured object marked with the outcome of Pass . If the rule executed successfully regardless of outcome no other informational messages are shown by default. In some circumstances such as a continuous integration (CI) pipeline, it may be preferable to see informational messages. By settings this option, error, warning or information messages will be generated for each rule pass outcome in addition to structured output. By default, outcomes are not logged to an informational stream (i.e. None). The following streams available: None Error Warning Information This option can be specified using: # PowerShell: Using the LoggingRulePass parameter $option = New-PSRuleOption -LoggingRulePass Information ; # PowerShell: Using the Logging.RulePass hashtable key $option = New-PSRuleOption -Option @{ 'Logging.RulePass' = 'Information' }; # PowerShell: Using the LoggingRulePass parameter to set YAML Set-PSRuleOption -LoggingRulePass Information ; # YAML: Using the logging/rulePass property logging : rulePass : Information","title":"Logging.RulePass"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#outputas","text":"Configures the type of results to produce. This option only applies to Invoke-PSRule and Assert-PSRule . Invoke-PSRule and Assert-PSRule also include a -As parameter to set this option at runtime. If specified, the -As parameter take precedence, over this option. The following options are available: Detail - Return a record per rule per object. Summary - Return summary results. This option can be specified using: # PowerShell: Using the OutputAs parameter $option = New-PSRuleOption -OutputAs Summary ; # PowerShell: Using the Output.As hashtable key $option = New-PSRuleOption -Option @{ 'Output.As' = 'Summary' }; # PowerShell: Using the OutputAs parameter to set YAML Set-PSRuleOption -OutputAs Summary ; # YAML: Using the output/as property output : as : Summary # Bash: Using environment variable export PSRULE_OUTPUT_AS = Summary # GitHub Actions: Using environment variable env : PSRULE_OUTPUT_AS : Summary # Azure Pipelines: Using environment variable variables : - name : PSRULE_OUTPUT_AS value : Summary","title":"Output.As"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#outputbanner","text":"The information displayed for PSRule banner. This option is only applicable when using Assert-PSRule cmdlet. The following information can be shown or hidden by configuring this option. Title (1) - Shows the PSRule title ASCII text. Source (2) - Shows rules module versions used in this run. SupportLinks (4) - Shows supporting links for PSRule and rules modules. Additionally the following rollup options exist: Default - Shows Title , Source , and SupportLinks . This is the default option. Minimal - Shows Source . This option can be configured using one of the named values described above. Alternatively, this value can be configured by specifying a bit mask as an integer. For example 6 would show Source , and SupportLinks . This option can be specified using: # PowerShell: Using the OutputBanner parameter $option = New-PSRuleOption -OutputBanner Minimal ; # PowerShell: Using the Output.Banner hashtable key $option = New-PSRuleOption -Option @{ 'Output.Banner' = 'Minimal' }; # PowerShell: Using the OutputBanner parameter to set YAML Set-PSRuleOption -OutputBanner Minimal ; # YAML: Using the output/banner property output : banner : Minimal # Bash: Using environment variable export PSRULE_OUTPUT_BANNER = Minimal # GitHub Actions: Using environment variable env : PSRULE_OUTPUT_BANNER : Minimal # Azure Pipelines: Using environment variable variables : - name : PSRULE_OUTPUT_BANNER value : Minimal","title":"Output.Banner"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#outputculture","text":"Specified the name of one or more cultures to use for generating output. When multiple cultures are specified, the first matching culture will be used. If a culture is not specified, PSRule will use the current PowerShell culture. PSRule cmdlets also include a -Culture parameter to set this option at runtime. If specified, the -Culture parameter take precedence, over this option. To get a list of cultures use the Get-Culture -ListAvailable cmdlet. This option can be specified using: # PowerShell: Using the OutputCulture parameter $option = New-PSRuleOption -OutputCulture 'en-AU' ; # PowerShell: Using the Output.Culture hashtable key $option = New-PSRuleOption -Option @{ 'Output.Culture' = 'en-AU' }; # PowerShell: Using the OutputCulture parameter to set YAML Set-PSRuleOption -OutputCulture 'en-AU' , 'en-US' ; # YAML: Using the output/culture property output : culture : [ 'en-AU' , 'en-US' ] # Bash: Using environment variable export PSRULE_OUTPUT_CULTURE = en-AU ; en-US # GitHub Actions: Using environment variable env : PSRULE_OUTPUT_CULTURE : en-AU;en-US # Azure Pipelines: Using environment variable variables : - name : PSRULE_OUTPUT_CULTURE value : en-AU;en-US","title":"Output.Culture"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#outputencoding","text":"Configures the encoding used when output is written to file. This option has no affect when Output.Path is not set. The following encoding options are available: Default UTF-8 UTF-7 Unicode UTF-32 ASCII This option can be specified using: # PowerShell: Using the OutputEncoding parameter $option = New-PSRuleOption -OutputEncoding UTF8 ; # PowerShell: Using the Output.Format hashtable key $option = New-PSRuleOption -Option @{ 'Output.Encoding' = 'UTF8' }; # PowerShell: Using the OutputEncoding parameter to set YAML Set-PSRuleOption -OutputEncoding UTF8 ; # YAML: Using the output/encoding property output : encoding : UTF8 # Bash: Using environment variable export PSRULE_OUTPUT_ENCODING = UTF8 # GitHub Actions: Using environment variable env : PSRULE_OUTPUT_ENCODING : UTF8 # Azure Pipelines: Using environment variable variables : - name : PSRULE_OUTPUT_ENCODING value : UTF8","title":"Output.Encoding"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#outputfooter","text":"The information displayed for PSRule footer. This option is only applicable when using Assert-PSRule cmdlet. The following information can be shown or hidden by configuring this option. RuleCount (1) - Shows a summary of rules processed. RunInfo (2) - Shows information about the run. Additionally the following rollup options exist: Default - Shows RuleCount , and RunInfo . This is the default option. This option can be configured using one of the named values described above. Alternatively, this value can be configured by specifying a bit mask as an integer. For example 3 would show RunInfo , and RuleCount . This option can be specified using: # PowerShell: Using the OutputFooter parameter $option = New-PSRuleOption -OutputFooter RuleCount ; # PowerShell: Using the Output.Footer hashtable key $option = New-PSRuleOption -Option @{ 'Output.Footer' = 'RuleCount' }; # PowerShell: Using the OutputFooter parameter to set YAML Set-PSRuleOption -OutputFooter RuleCount ; # YAML: Using the output/footer property output : footer : RuleCount # Bash: Using environment variable export PSRULE_OUTPUT_FOOTER = RuleCount # GitHub Actions: Using environment variable env : PSRULE_OUTPUT_FOOTER : RuleCount # Azure Pipelines: Using environment variable variables : - name : PSRULE_OUTPUT_FOOTER value : RuleCount","title":"Output.Footer"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#outputformat","text":"Configures the format that results will be presented in. This option applies to Invoke-PSRule , Assert-PSRule , Get-PSRule and Get-PSRuleBaseline . This options is ignored by other cmdlets. The following format options are available: None - Output is presented as an object using PowerShell defaults. This is the default. Yaml - Output is serialized as YAML. Json - Output is serialized as JSON. Markdown - Output is serialized as Markdown. NUnit3 - Output is serialized as NUnit3 (XML). Csv - Output is serialized as a comma separated values (CSV). The following columns are included for Detail output: RuleName, TargetName, TargetType, Outcome, OutcomeReason, Synopsis, Recommendation The following columns are included for Summary output: RuleName, Pass, Fail, Outcome, Synopsis, Recommendation Wide - Output is presented using the wide table format, which includes reason and wraps columns. The Wide format is ignored by Assert-PSRule . Get-PSRule only accepts None , Wide , Yaml and Json . Usage of other formats are treated as None . The Get-PSRuleBaseline cmdlet only accepts None or Yaml . The Export-PSRuleBaseline cmdlet only accepts Yaml . This option can be specified using: # PowerShell: Using the OutputFormat parameter $option = New-PSRuleOption -OutputFormat Yaml ; # PowerShell: Using the Output.Format hashtable key $option = New-PSRuleOption -Option @{ 'Output.Format' = 'Yaml' }; # PowerShell: Using the OutputFormat parameter to set YAML Set-PSRuleOption -OutputFormat Yaml ; # YAML: Using the output/format property output : format : Yaml # Bash: Using environment variable export PSRULE_OUTPUT_FORMAT = Yaml # GitHub Actions: Using environment variable env : PSRULE_OUTPUT_FORMAT : Yaml # Azure Pipelines: Using environment variable variables : - name : PSRULE_OUTPUT_FORMAT value : Yaml","title":"Output.Format"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#outputoutcome","text":"Filters output to include results with the specified outcome. The following outcome options are available: None - Results for rules that did not get processed are returned. Pass - Results for rules that passed are returned. Fail - Results for rules that failed are returned. Error - Results for rules that raised an error are returned. Processed - Results for rules that either passed, failed, or raised an error are returned. This is the default option. All - All results for rules are returned. This option can be specified using: # PowerShell: Using the OutputOutcome parameter $option = New-PSRuleOption -OutputOutcome Fail ; # PowerShell: Using the Output.Outcome hashtable key $option = New-PSRuleOption -Option @{ 'Output.Outcome' = 'Fail' }; # PowerShell: Using the OutputOutcome parameter to set YAML Set-PSRuleOption -OutputOutcome Fail ; # YAML: Using the output/outcome property output : outcome : 'Fail' # Bash: Using environment variable export PSRULE_OUTPUT_OUTCOME = Fail # GitHub Actions: Using environment variable env : PSRULE_OUTPUT_OUTCOME : Fail # Azure Pipelines: Using environment variable variables : - name : PSRULE_OUTPUT_OUTCOME value : Fail","title":"Output.Outcome"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#outputpath","text":"Specifies the output file path to write results. Directories along the file path will automatically be created if they do not exist. This option only applies to Invoke-PSRule . Invoke-PSRule also includes a parameter -OutputPath to set this option at runtime. If specified, the -OutputPath parameter take precedence, over this option. This option can be specified using: # PowerShell: Using the OutputPath parameter $option = New-PSRuleOption -OutputPath 'out/results.yaml' ; # PowerShell: Using the Output.Path hashtable key $option = New-PSRuleOption -Option @{ 'Output.Path' = 'out/results.yaml' }; # PowerShell: Using the OutputPath parameter to set YAML Set-PSRuleOption -OutputPath 'out/results.yaml' ; # YAML: Using the output/path property output : path : 'out/results.yaml' # Bash: Using environment variable export PSRULE_OUTPUT_PATH = out/results.yaml # GitHub Actions: Using environment variable env : PSRULE_OUTPUT_PATH : out/results.yaml # Azure Pipelines: Using environment variable variables : - name : PSRULE_OUTPUT_PATH value : out/results.yaml","title":"Output.Path"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#outputstyle","text":"Configures the style that results will be presented in. This option only applies to output generated from Assert-PSRule . Assert-PSRule also include a parameter -Style to set this option at runtime. If specified, the -Style parameter takes precedence, over this option. The following styles are available: Client - Output is written to the host directly in green/ red to indicate outcome. Plain - Output is written as an unformatted string. This option can be redirected to a file. AzurePipelines - Output is written for integration Azure Pipelines. GitHubActions - Output is written for integration GitHub Actions. VisualStudioCode - Output is written for integration with Visual Studio Code. Detect - Output style will be detected by checking the environment variables. This is the default. Detect uses the following logic: If the TF_BUILD environment variable is set to true , AzurePipelines will be used. If the GITHUB_ACTIONS environment variable is set to true , GitHubActions will be used. If the TERM_PROGRAM environment variable is set to vscode , VisualStudioCode will be used. Use Client . This option can be specified using: # PowerShell: Using the OutputStyle parameter $option = New-PSRuleOption -OutputStyle AzurePipelines ; # PowerShell: Using the Output.Style hashtable key $option = New-PSRuleOption -Option @{ 'Output.Style' = 'AzurePipelines' }; # PowerShell: Using the OutputStyle parameter to set YAML Set-PSRuleOption -OutputFormat AzurePipelines ; # YAML: Using the output/style property output : style : AzurePipelines # Bash: Using environment variable export PSRULE_OUTPUT_STYLE = AzurePipelines # GitHub Actions: Using environment variable env : PSRULE_OUTPUT_STYLE : AzurePipelines # Azure Pipelines: Using environment variable variables : - name : PSRULE_OUTPUT_STYLE value : AzurePipelines","title":"Output.Style"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#outputjsonindent","text":"Configures the indentation level for JSON output. This option applies to output generated from -OutputFormat Json for Get-PSRule and Invoke-PSRule . This option also applies to output generated from -OutputPath for Assert-PSRule . The range of indentation accepts a minimum of 0(machine first) spaces and a maximum of 4 spaces. This option can be specified using: # PowerShell: Using the OutputJsonIndent parameter $option = New-PSRuleOption -OutputJsonIndent 2 ; # PowerShell: Using the Output.JsonIndent hashtable key $option = New-PSRuleOption -Option @{ 'Output.JsonIndent' = 2 }; # PowerShell: Using the OutputStyle parameter to set YAML Set-PSRuleOption -OutputJsonIndent 2 ; # YAML: Using the output/jsonIndent property output : jsonIndent : 2 # Bash: Using environment variable export PSRULE_OUTPUT_JSONINDENT = 2 # PowerShell: Using environment variable $env:PSRULE_OUTPUT_JSONINDENT = 2 ; # GitHub Actions: Using environment variable env : PSRULE_OUTPUT_JSONINDENT : 2 # Azure Pipelines: Using environment variable variables : - name : PSRULE_OUTPUT_JSONINDENT value : 2","title":"Output.JsonIndent"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#requires","text":"Specifies module version constraints for running PSRule. When set PSRule will error if a module version is used that does not satisfy the requirements. The format for version constraints are the same as the Version assertion method. See [about_PSRule_Assert] for more information. Module version constraints a not enforced prior to PSRule v0.19.0. The version constraint for a rule module is enforced when the module is included with -Module . A version constraint does not require a rule module to be included. Use the Include.Module option to automatically include a rule module. This option can be specified using: # PowerShell: Using the Requires.module hashtable key $option = New-PSRuleOption -Option @{ 'Requires.PSRule' = '>=1.0.0' }; # YAML: Using the requires property requires : PSRule : '>=1.0.0' # Require v1.0.0 or greater. PSRule.Rules.Azure : '>=1.0.0' # Require v1.0.0 or greater. PSRule.Rules.CAF : '@pre >=0.1.0' # Require stable or pre-releases v0.1.0 or greater. This option can be configured using environment variables. To specify a module version constraint, prefix the module name with PSRULE_REQUIRES_ . When the module name includes a dot ( . ) use an underscore ( _ ) instead. # Bash: Using environment variable export PSRULE_REQUIRES_PSRULE = '>=1.0.0' export PSRULE_REQUIRES_PSRULE_RULES_AZURE = '>=1.0.0' export PSRULE_REQUIRES_PSRULE_RULES_CAF = '@pre >=0.1.0' # GitHub Actions: Using environment variable env : PSRULE_REQUIRES_PSRULE : '>=1.0.0' PSRULE_REQUIRES_PSRULE_RULES_AZURE : '>=1.0.0' PSRULE_REQUIRES_PSRULE_RULES_CAF : '@pre >=0.1.0' # Azure Pipelines: Using environment variable variables : - name : PSRULE_REQUIRES_PSRULE value : '>=1.0.0' - name : PSRULE_REQUIRES_PSRULE_RULES_AZURE value : '>=1.0.0' - name : PSRULE_REQUIRES_PSRULE_RULES_CAF value : '@pre >=0.1.0'","title":"Requires"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#rulebaseline","text":"The name of a default baseline to use for the module. Currently this option can only be set within a module configuration resource. For example: --- # Synopsis: Example module configuration for Enterprise.Rules module. apiVersion : github.com/microsoft/PSRule/v1 kind : ModuleConfig metadata : name : Enterprise.Rules spec : rule : baseline : Enterprise.Baseline1","title":"Rule.Baseline"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#ruleinclude","text":"The name of specific rules to evaluate. If this option is not specified all rules in search paths will be evaluated. This option can be overridden at runtime by using the -Name cmdlet parameter. This option can be specified using: # PowerShell: Using the Rule.Include hashtable key $option = New-PSRuleOption -Option @{ 'Rule.Include' = 'Rule1' , 'Rule2' }; # YAML: Using the rule/include property rule : include : - Rule1 - Rule2 # Bash: Using environment variable export PSRULE_RULE_INCLUDE = 'Rule1;Rule2' # GitHub Actions: Using environment variable env : PSRULE_RULE_INCLUDE : 'Rule1;Rule2' # Azure Pipelines: Using environment variable variables : - name : PSRULE_RULE_INCLUDE value : 'Rule1;Rule2'","title":"Rule.Include"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#ruleincludelocal","text":"Automatically include all local rules in the search path unless they have been explicitly excluded. This option will include local rules even when they do not match Rule.Include or Rule.Tag filters. By default, local rules will be filtered with Rule.Include and Rule.Tag filters. This option is useful when you want to include local rules not included in a baseline. This option can be specified using: # PowerShell: Using the RuleIncludeLocal parameter $option = New-PSRuleOption -RuleIncludeLocal $True ; # PowerShell: Using the Rule.IncludeLocal hashtable key $option = New-PSRuleOption -Option @{ 'Rule.IncludeLocal' = $True }; # PowerShell: Using the RuleIncludeLocal parameter to set YAML Set-PSRuleOption -RuleIncludeLocal $True ; # YAML: Using the rule/includeLocal property rule : includeLocal : true # Bash: Using environment variable export PSRULE_RULE_INCLUDELOCAL = true # GitHub Actions: Using environment variable env : PSRULE_RULE_INCLUDELOCAL : true # Azure Pipelines: Using environment variable variables : - name : PSRULE_RULE_INCLUDELOCAL value : true","title":"Rule.IncludeLocal"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#ruleexclude","text":"The name of specific rules to exclude from being evaluated. This will exclude rules specified by Rule.Include or discovered from a search path. This option can be specified using: # PowerShell: Using the Rule.Exclude hashtable key $option = New-PSRuleOption -Option @{ 'Rule.Exclude' = 'Rule3' , 'Rule4' }; # YAML: Using the rule/exclude property rule : exclude : - Rule3 - Rule4 # Bash: Using environment variable export PSRULE_RULE_EXCLUDE = 'Rule3;Rule4' # GitHub Actions: Using environment variable env : PSRULE_RULE_EXCLUDE : 'Rule3;Rule4' # Azure Pipelines: Using environment variable variables : - name : PSRULE_RULE_EXCLUDE value : 'Rule3;Rule4'","title":"Rule.Exclude"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#ruletag","text":"A set of required key value pairs (tags) that rules must have applied to them to be included. Multiple values can be specified for the same tag. When multiple values are used, only one must match. This option can be overridden at runtime by using the -Tag cmdlet parameter. This option can be specified using: # PowerShell: Using the Rule.Tag hashtable key $option = New-PSRuleOption -Option @{ 'Rule.Tag' = @{ severity = 'Critical' , 'Warning' } }; # YAML: Using the rule/tag property rule : tag : severity : Critical # YAML: Using the rule/tag property, with multiple values rule : tag : severity : - Critical - Warning In the example above, rules must have a tag of severity set to either Critical or Warning to be included.","title":"Rule.Tag"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#suppression","text":"In certain circumstances it may be necessary to exclude or suppress rules from processing objects that are in a known failed state. PSRule allows objects to be suppressed for a rule by TargetName. Objects that are suppressed are not processed by the rule at all but will continue to be processed by other rules. Rule suppression complements pre-filtering and pre-conditions. This option can be specified using: # PowerShell: Using the SuppressTargetName option with a hashtable $option = New-PSRuleOption -SuppressTargetName @{ 'storageAccounts.UseHttps' = 'TestObject1' , 'TestObject3' }; # YAML: Using the suppression property suppression : storageAccounts.UseHttps : targetName : - TestObject1 - TestObject3 In both of the above examples, TestObject1 and TestObject3 have been suppressed from being processed by a rule named storageAccounts.UseHttps . When to use rule suppression: A temporary exclusion for an object that is in a known failed state. When not to use rule suppression: An object should never be processed by any rule. Pre-filter the pipeline instead. The rule is not applicable because the object is the wrong type. Use pre-conditions on the rule instead. An example of pre-filtering: # Define objects to validate $items = @(); $items += [PSCustomObject] @{ Name = 'Fridge' ; Type = 'Equipment' ; Category = 'White goods' ; }; $items += [PSCustomObject] @{ Name = 'Apple' ; Type = 'Food' ; Category = 'Produce' ; }; $items += [PSCustomObject] @{ Name = 'Carrot' ; Type = 'Food' ; Category = 'Produce' ; }; # Example of pre-filtering, only food items are sent to Invoke-PSRule $items | Where-Object { $_ . Type -eq 'Food' } | Invoke-PSRule ; An example of pre-conditions: # A rule with a pre-condition to only process produce Rule 'isFruit' -If { $TargetObject . Category -eq 'Produce' } { # Condition to determine if the object is fruit $TargetObject . Name -in 'Apple' , 'Orange' , 'Pear' }","title":"Suppression"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#examples","text":"","title":"Examples"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#example-ps-ruleyaml","text":"# # PSRule example configuration # # Configure required module versions requires : PSRule.Rules.Azure : '>=1.1.0' # Configure convention options convention : include : - 'Convention1' # Configure execution options execution : aliasReferenceWarning : false languageMode : ConstrainedLanguage inconclusiveWarning : false notProcessedWarning : false suppressedRuleWarning : false # Configure include options include : module : - 'PSRule.Rules.Azure' path : [ ] # Configures input options input : format : Yaml ignoreGitPath : false objectPath : items pathIgnore : - '*.Designer.cs' targetType : - Microsoft.Compute/virtualMachines - Microsoft.Network/virtualNetworks # Configures outcome logging options logging : limitDebug : - Rule1 - Rule2 limitVerbose : - Rule1 - Rule2 ruleFail : Error rulePass : Information output : as : Summary banner : Minimal culture : - en-US encoding : UTF8 footer : RuleCount format : Json outcome : Fail style : GitHubActions # Configure rule suppression suppression : storageAccounts.UseHttps : targetName : - TestObject1 - TestObject3 # Configure baseline options binding : field : id : - ResourceId - AlternativeId ignoreCase : false nameSeparator : '::' preferTargetInfo : true targetName : - ResourceName - AlternateName targetType : - ResourceType - kind useQualifiedName : true configuration : appServiceMinInstanceCount : 2 rule : include : - rule1 - rule2 includeLocal : true exclude : - rule3 - rule4 tag : severity : - Critical - Warning","title":"Example ps-rule.yaml"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#default-ps-ruleyaml","text":"# # PSRule defaults # # Note: Only properties that differ from the default values need to be specified. # Configure required module versions requires : { } # Configure convention options convention : include : [ ] # Configure execution options execution : aliasReferenceWarning : true languageMode : FullLanguage inconclusiveWarning : true notProcessedWarning : true suppressedRuleWarning : true # Configure include options include : module : [ ] path : - '.ps-rule/' # Configures input options input : format : Detect ignoreGitPath : true objectPath : null pathIgnore : [ ] targetType : [ ] # Configures outcome logging options logging : limitDebug : [ ] limitVerbose : [ ] ruleFail : None rulePass : None output : as : Detail banner : Default culture : [ ] encoding : Default footer : Default format : None outcome : Processed style : Detect # Configure rule suppression suppression : { } # Configure baseline options binding : field : { } ignoreCase : true nameSeparator : '/' preferTargetInfo : false targetName : - TargetName - Name targetType : - PSObject.TypeNames[0] useQualifiedName : false configuration : { } rule : include : [ ] includeLocal : false exclude : [ ] tag : { }","title":"Default ps-rule.yaml"},{"location":"concepts/PSRule/en-US/about_PSRule_Options/#links","text":"Invoke-PSRule New-PSRuleOption Set-PSRuleOption","title":"Links"},{"location":"concepts/PSRule/en-US/about_PSRule_Rules/","text":"Rules # Describes PSRule rules including how to use and author them. Description # PSRule executes rules to validate an object from input either from a file or PowerShell pipeline. The PowerShell pipeline only available when running PSRule directly. PSRule can also be run from a continuous integration (CI) pipeline or Visual Studio Code. When using these methods, the PowerShell pipeline is not available. To evaluate an object PSRule can use rules defined in script or YAML. When using script rules: Each rule is defined PowerShell within a .Rule.ps1 file by using a Rule block. PowerShell variables, functions, and cmdlets can be used just like regular PowerShell scripts. Built-in assertion helpers can be used to quickly build out rules. Pre-conditions can be defined with using a script block, type binding, or YAML-based selector. To learn more about assertion helpers see about_PSRule_Assert . When using YAML rules: Each rule is defined in a .Rule.yaml file by using the Rule resource. YAML-based expressions can be used. Pre-conditions can be defined with using a type binding, or YAML-based selector. To learn more about YAML-based expressions see about_PSRule_Expressions . Using pre-conditions # Pre-conditions are used to determine if a rule should be executed. While pre-conditions are not required for each rule, it is a good practice to define them. If a rule does not specify a pre-condition it may be executed against an object it does not expect. Pre-conditions come in three forms: Script - A PowerShell script block that is executed and if true will cause the rule to be executed. Script block pre-conditions only work with script rules. To use a script block pre-condition, specify the -If script parameter on the Rule block. Type - A type string that is compared against the bound object type. When the type matches the rule will be executed. To use a type pre-conditions, specify the -Type script parameter or type YAML/JSON property. Selector - A YAML/JSON based expression that is evaluated against the object. When the expression matches the rule will be executed. To use a selector pre-conditions, specify the -With script parameter or with YAML/JSON property. Different forms of pre-conditions can be combined. When combining pre-conditions, different forms must be all true (logical AND). i.e. Script AND Type AND Selector must be all be true for the rule to be executed. Multiple Type and Selector pre-conditions can be specified. If multiple Type and Selector pre-conditions are specified, only one must be true (logical OR). For example: # Synopsis: An example script rule with pre-conditions. Rule 'ScriptRule' -If { $True } -Type 'CustomType1' , 'CustomType2' -With 'Selector.1' , 'Selector.2' { # Rule condition } --- # Synopsis: An example YAML rule with pre-conditions. apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'YamlRule' spec : type : - 'CustomType1' - 'CustomType2' with : - 'Selector.1' - 'Selector.2' condition : { } [ { // Synopsis: An example YAML rule with pre-conditions. \"apiVersion\": \"github.com/microsoft/PSRule/v1\", \"kind\": \"Rule\", \"metadata\": { \"name\": \"YamlRule\" }, \"spec\": { \"type\": [ \"CustomType1\", \"CustomType2\" ], \"with\": [ \"Selector.1\", \"Selector.2\" ], \"condition\": {} } } ] Pre-conditions are evaluated in the following order: Selector, Type, then Script. Defining script rules # To define a script rule use the Rule keyword followed by a name and a pair of squiggly brackets { . Within the { } one or more conditions can be used. Script rule must be defined within .Rule.ps1 files. Multiple rules can be defined in a single file by creating multiple Rule blocks. Rule blocks can not be nested within each other. Within the Rule block, define one or more conditions to determine pass or fail of the rule. Syntax: Rule [-Name] <string> [-Tag <hashtable>] [-When <string[]>] [-Type <string[]>] [-If <scriptBlock>] [-DependsOn <string[]>] [-Configure <hashtable>] [-ErrorAction <ActionPreference>] [-Body] { ... } Example: # Synopsis: Use a Standard load-balancer with AKS clusters. Rule 'Azure.AKS.StandardLB' -Type 'Microsoft.ContainerService/managedClusters' -Tag @{ release = 'GA' ; ruleSet = '2020_06' } { $Assert . HasFieldValue ( $TargetObject , 'Properties.networkProfile.loadBalancerSku' , 'standard' ); } Defining YAML rules # To define a YAML rule use the Rule resource in a YAML file. Each rule must be defined within a .Rule.yaml file following a standard schema. Multiple rules can be defined in a single YAML file by separating each rule with a --- . Within the Rule resource, the condition property specifies conditions to pass or fail the rule. Syntax: --- # Synopsis: {{ Synopsis }} apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : '{{ Name }}' tags : { } spec : type : [ ] with : [ ] condition : { } Example: --- # Synopsis: Use a Standard load-balancer with AKS clusters. apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'Azure.AKS.StandardLB' tags : release : 'GA' ruleSet : '2020_06' spec : type : - Microsoft.ContainerService/managedClusters condition : field : 'Properties.networkProfile.loadBalancerSku' equals : 'standard' Defining JSON rules # To define a JSON rule use the Rule resource in a JSON file. Each rule must be defined within a .Rule.jsonc file following a standard schema. One or more rules can be defined in a single JSON array separating each rule in a JSON object. Within the Rule resource, the condition property specifies conditions to pass or fail the rule. Rules can also be defined within .json files. We recommend using .jsonc to view JSON with Comments in Visual Studio Code. Syntax: [ { // Synopsis: {{ Synopsis }} \"apiVersion\": \"github.com/microsoft/PSRule/v1\", \"kind\": \"Rule\", \"metadata\": { \"name\": \"{{ Name }}\", \"tags\": {} }, \"spec\": { \"type\": [], \"with\": [], \"condition\": {} } } ] Example: [ { // Synopsis: Use a Standard load-balancer with AKS clusters. \"apiVersion\": \"github.com/microsoft/PSRule/v1\", \"kind\": \"Rule\", \"metadata\": { \"name\": \"Azure.AKS.StandardLB\", \"tags\": { \"release\": \"GA\", \"ruleSet\": \"2020_06\" } }, \"spec\": { \"type\": [ \"Microsoft.ContainerService/managedClusters\" ], \"condition\": { \"field\": \"Properties.networkProfile.loadBalancerSku\", \"equals\": \"standard\" } } } ] Links # Invoke-PSRule","title":"Rules"},{"location":"concepts/PSRule/en-US/about_PSRule_Rules/#rules","text":"Describes PSRule rules including how to use and author them.","title":"Rules"},{"location":"concepts/PSRule/en-US/about_PSRule_Rules/#description","text":"PSRule executes rules to validate an object from input either from a file or PowerShell pipeline. The PowerShell pipeline only available when running PSRule directly. PSRule can also be run from a continuous integration (CI) pipeline or Visual Studio Code. When using these methods, the PowerShell pipeline is not available. To evaluate an object PSRule can use rules defined in script or YAML. When using script rules: Each rule is defined PowerShell within a .Rule.ps1 file by using a Rule block. PowerShell variables, functions, and cmdlets can be used just like regular PowerShell scripts. Built-in assertion helpers can be used to quickly build out rules. Pre-conditions can be defined with using a script block, type binding, or YAML-based selector. To learn more about assertion helpers see about_PSRule_Assert . When using YAML rules: Each rule is defined in a .Rule.yaml file by using the Rule resource. YAML-based expressions can be used. Pre-conditions can be defined with using a type binding, or YAML-based selector. To learn more about YAML-based expressions see about_PSRule_Expressions .","title":"Description"},{"location":"concepts/PSRule/en-US/about_PSRule_Rules/#using-pre-conditions","text":"Pre-conditions are used to determine if a rule should be executed. While pre-conditions are not required for each rule, it is a good practice to define them. If a rule does not specify a pre-condition it may be executed against an object it does not expect. Pre-conditions come in three forms: Script - A PowerShell script block that is executed and if true will cause the rule to be executed. Script block pre-conditions only work with script rules. To use a script block pre-condition, specify the -If script parameter on the Rule block. Type - A type string that is compared against the bound object type. When the type matches the rule will be executed. To use a type pre-conditions, specify the -Type script parameter or type YAML/JSON property. Selector - A YAML/JSON based expression that is evaluated against the object. When the expression matches the rule will be executed. To use a selector pre-conditions, specify the -With script parameter or with YAML/JSON property. Different forms of pre-conditions can be combined. When combining pre-conditions, different forms must be all true (logical AND). i.e. Script AND Type AND Selector must be all be true for the rule to be executed. Multiple Type and Selector pre-conditions can be specified. If multiple Type and Selector pre-conditions are specified, only one must be true (logical OR). For example: # Synopsis: An example script rule with pre-conditions. Rule 'ScriptRule' -If { $True } -Type 'CustomType1' , 'CustomType2' -With 'Selector.1' , 'Selector.2' { # Rule condition } --- # Synopsis: An example YAML rule with pre-conditions. apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'YamlRule' spec : type : - 'CustomType1' - 'CustomType2' with : - 'Selector.1' - 'Selector.2' condition : { } [ { // Synopsis: An example YAML rule with pre-conditions. \"apiVersion\": \"github.com/microsoft/PSRule/v1\", \"kind\": \"Rule\", \"metadata\": { \"name\": \"YamlRule\" }, \"spec\": { \"type\": [ \"CustomType1\", \"CustomType2\" ], \"with\": [ \"Selector.1\", \"Selector.2\" ], \"condition\": {} } } ] Pre-conditions are evaluated in the following order: Selector, Type, then Script.","title":"Using pre-conditions"},{"location":"concepts/PSRule/en-US/about_PSRule_Rules/#defining-script-rules","text":"To define a script rule use the Rule keyword followed by a name and a pair of squiggly brackets { . Within the { } one or more conditions can be used. Script rule must be defined within .Rule.ps1 files. Multiple rules can be defined in a single file by creating multiple Rule blocks. Rule blocks can not be nested within each other. Within the Rule block, define one or more conditions to determine pass or fail of the rule. Syntax: Rule [-Name] <string> [-Tag <hashtable>] [-When <string[]>] [-Type <string[]>] [-If <scriptBlock>] [-DependsOn <string[]>] [-Configure <hashtable>] [-ErrorAction <ActionPreference>] [-Body] { ... } Example: # Synopsis: Use a Standard load-balancer with AKS clusters. Rule 'Azure.AKS.StandardLB' -Type 'Microsoft.ContainerService/managedClusters' -Tag @{ release = 'GA' ; ruleSet = '2020_06' } { $Assert . HasFieldValue ( $TargetObject , 'Properties.networkProfile.loadBalancerSku' , 'standard' ); }","title":"Defining script rules"},{"location":"concepts/PSRule/en-US/about_PSRule_Rules/#defining-yaml-rules","text":"To define a YAML rule use the Rule resource in a YAML file. Each rule must be defined within a .Rule.yaml file following a standard schema. Multiple rules can be defined in a single YAML file by separating each rule with a --- . Within the Rule resource, the condition property specifies conditions to pass or fail the rule. Syntax: --- # Synopsis: {{ Synopsis }} apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : '{{ Name }}' tags : { } spec : type : [ ] with : [ ] condition : { } Example: --- # Synopsis: Use a Standard load-balancer with AKS clusters. apiVersion : github.com/microsoft/PSRule/v1 kind : Rule metadata : name : 'Azure.AKS.StandardLB' tags : release : 'GA' ruleSet : '2020_06' spec : type : - Microsoft.ContainerService/managedClusters condition : field : 'Properties.networkProfile.loadBalancerSku' equals : 'standard'","title":"Defining YAML rules"},{"location":"concepts/PSRule/en-US/about_PSRule_Rules/#defining-json-rules","text":"To define a JSON rule use the Rule resource in a JSON file. Each rule must be defined within a .Rule.jsonc file following a standard schema. One or more rules can be defined in a single JSON array separating each rule in a JSON object. Within the Rule resource, the condition property specifies conditions to pass or fail the rule. Rules can also be defined within .json files. We recommend using .jsonc to view JSON with Comments in Visual Studio Code. Syntax: [ { // Synopsis: {{ Synopsis }} \"apiVersion\": \"github.com/microsoft/PSRule/v1\", \"kind\": \"Rule\", \"metadata\": { \"name\": \"{{ Name }}\", \"tags\": {} }, \"spec\": { \"type\": [], \"with\": [], \"condition\": {} } } ] Example: [ { // Synopsis: Use a Standard load-balancer with AKS clusters. \"apiVersion\": \"github.com/microsoft/PSRule/v1\", \"kind\": \"Rule\", \"metadata\": { \"name\": \"Azure.AKS.StandardLB\", \"tags\": { \"release\": \"GA\", \"ruleSet\": \"2020_06\" } }, \"spec\": { \"type\": [ \"Microsoft.ContainerService/managedClusters\" ], \"condition\": { \"field\": \"Properties.networkProfile.loadBalancerSku\", \"equals\": \"standard\" } } } ]","title":"Defining JSON rules"},{"location":"concepts/PSRule/en-US/about_PSRule_Rules/#links","text":"Invoke-PSRule","title":"Links"},{"location":"concepts/PSRule/en-US/about_PSRule_Selectors/","text":"Selectors # Describes PSRule Selectors including how to use and author them. Description # PSRule executes rules to validate an object from input. When evaluating an object from input, PSRule can use selectors to perform complex matches of an object. A selector is a YAML/JSON based expression that evaluates an object. Each selector is comprised of nested conditions, operators, and comparison properties. Selectors must use one or more available conditions with a comparison property to evaluate the object. Optionally a condition can be nested in an operator. Operators can be nested within other operators. The following conditions are available: Contains Count Equals EndsWith Exists Greater GreaterOrEquals HasDefault HasSchema HasValue In IsLower IsString IsUpper Less LessOrEquals Match NotEquals NotIn NotMatch SetOf StartsWith Subset Version The following operators are available: AllOf AnyOf Not The following comparison properties are available: Field Name Type To learn more about conditions, operators, and properties see about_PSRule_Expressions . Currently the following limitations apply: Selectors can evaluate: Fields of the target object. Type and name binding of the target object by using name and type comparison properties. State variables such has $PSRule can not be evaluated. Bound fields can not be evaluated. Using selectors as pre-conditions # Selectors can be referenced by name as a rule pre-condition by using the -With parameter. For example: Rule 'RuleWithSelector' -With 'BasicSelector' { # Rule condition } Selector pre-conditions can be used together with type and script block pre-conditions. If one or more selector pre-conditions are used, they are evaluated before type or script block pre-conditions. Defining selectors # Selectors can be defined with either YAML or JSON format, and can be included with a module or standalone .Rule.yaml or .Rule.jsonc file. In either case, define a selector within a file ending with the .Rule.yaml or .Rule.jsonc extension. A selector can be defined side-by-side with other resources such as baselines or module configurations. Selectors can also be defined within .json files. We recommend using .jsonc to view JSON with Comments in Visual Studio Code. Use the following template to define a selector: --- # Synopsis: {{ Synopsis }} apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : '{{ Name }}' spec : if : { } [ { // Synopsis: {{ Synopsis }} \"apiVersion\": \"github.com/microsoft/PSRule/v1\", \"kind\": \"Selector\", \"metadata\": { \"name\": \"{{ Name }}\" }, \"spec\": { \"if\": {} } } ] Within the if object, one or more conditions or logical operators can be used. Examples # Example Selectors.Rule.yaml # # Example Selectors.Rule.yaml --- # Synopsis: Require the CustomValue field. apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : RequireCustomValue spec : if : field : 'CustomValue' exists : true --- # Synopsis: Require a Name or AlternativeName. apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : RequireName spec : if : anyOf : - field : 'AlternateName' exists : true - field : 'Name' exists : true --- # Synopsis: Require a specific CustomValue apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : RequireSpecificCustomValue spec : if : field : 'CustomValue' in : - 'Value1' - 'Value2' Example Selectors.Rule.jsonc # // Example Selectors.Rule.jsonc [ { // Synopsis: Require the CustomValue field. \"apiVersion\": \"github.com/microsoft/PSRule/v1\", \"kind\": \"Selector\", \"metadata\": { \"name\": \"RequireCustomValue\" }, \"spec\": { \"if\": { \"field\": \"CustomValue\", \"exists\": true } } }, { // Synopsis: Require a Name or AlternativeName. \"apiVersion\": \"github.com/microsoft/PSRule/v1\", \"kind\": \"Selector\", \"metadata\": { \"name\": \"RequireName\" }, \"spec\": { \"if\": { \"anyOf\": [ { \"field\": \"AlternateName\", \"exists\": true }, { \"field\": \"Name\", \"exists\": true } ] } } }, { // Synopsis: Require a specific CustomValue \"apiVersion\": \"github.com/microsoft/PSRule/v1\", \"kind\": \"Selector\", \"metadata\": { \"name\": \"RequireSpecificCustomValue\" }, \"spec\": { \"if\": { \"field\": \"CustomValue\", \"in\": [ \"Value1\", \"Value2\" ] } } } ] Links # Invoke-PSRule","title":"Selectors"},{"location":"concepts/PSRule/en-US/about_PSRule_Selectors/#selectors","text":"Describes PSRule Selectors including how to use and author them.","title":"Selectors"},{"location":"concepts/PSRule/en-US/about_PSRule_Selectors/#description","text":"PSRule executes rules to validate an object from input. When evaluating an object from input, PSRule can use selectors to perform complex matches of an object. A selector is a YAML/JSON based expression that evaluates an object. Each selector is comprised of nested conditions, operators, and comparison properties. Selectors must use one or more available conditions with a comparison property to evaluate the object. Optionally a condition can be nested in an operator. Operators can be nested within other operators. The following conditions are available: Contains Count Equals EndsWith Exists Greater GreaterOrEquals HasDefault HasSchema HasValue In IsLower IsString IsUpper Less LessOrEquals Match NotEquals NotIn NotMatch SetOf StartsWith Subset Version The following operators are available: AllOf AnyOf Not The following comparison properties are available: Field Name Type To learn more about conditions, operators, and properties see about_PSRule_Expressions . Currently the following limitations apply: Selectors can evaluate: Fields of the target object. Type and name binding of the target object by using name and type comparison properties. State variables such has $PSRule can not be evaluated. Bound fields can not be evaluated.","title":"Description"},{"location":"concepts/PSRule/en-US/about_PSRule_Selectors/#using-selectors-as-pre-conditions","text":"Selectors can be referenced by name as a rule pre-condition by using the -With parameter. For example: Rule 'RuleWithSelector' -With 'BasicSelector' { # Rule condition } Selector pre-conditions can be used together with type and script block pre-conditions. If one or more selector pre-conditions are used, they are evaluated before type or script block pre-conditions.","title":"Using selectors as pre-conditions"},{"location":"concepts/PSRule/en-US/about_PSRule_Selectors/#defining-selectors","text":"Selectors can be defined with either YAML or JSON format, and can be included with a module or standalone .Rule.yaml or .Rule.jsonc file. In either case, define a selector within a file ending with the .Rule.yaml or .Rule.jsonc extension. A selector can be defined side-by-side with other resources such as baselines or module configurations. Selectors can also be defined within .json files. We recommend using .jsonc to view JSON with Comments in Visual Studio Code. Use the following template to define a selector: --- # Synopsis: {{ Synopsis }} apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : '{{ Name }}' spec : if : { } [ { // Synopsis: {{ Synopsis }} \"apiVersion\": \"github.com/microsoft/PSRule/v1\", \"kind\": \"Selector\", \"metadata\": { \"name\": \"{{ Name }}\" }, \"spec\": { \"if\": {} } } ] Within the if object, one or more conditions or logical operators can be used.","title":"Defining selectors"},{"location":"concepts/PSRule/en-US/about_PSRule_Selectors/#examples","text":"","title":"Examples"},{"location":"concepts/PSRule/en-US/about_PSRule_Selectors/#example-selectorsruleyaml","text":"# Example Selectors.Rule.yaml --- # Synopsis: Require the CustomValue field. apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : RequireCustomValue spec : if : field : 'CustomValue' exists : true --- # Synopsis: Require a Name or AlternativeName. apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : RequireName spec : if : anyOf : - field : 'AlternateName' exists : true - field : 'Name' exists : true --- # Synopsis: Require a specific CustomValue apiVersion : github.com/microsoft/PSRule/v1 kind : Selector metadata : name : RequireSpecificCustomValue spec : if : field : 'CustomValue' in : - 'Value1' - 'Value2'","title":"Example Selectors.Rule.yaml"},{"location":"concepts/PSRule/en-US/about_PSRule_Selectors/#example-selectorsrulejsonc","text":"// Example Selectors.Rule.jsonc [ { // Synopsis: Require the CustomValue field. \"apiVersion\": \"github.com/microsoft/PSRule/v1\", \"kind\": \"Selector\", \"metadata\": { \"name\": \"RequireCustomValue\" }, \"spec\": { \"if\": { \"field\": \"CustomValue\", \"exists\": true } } }, { // Synopsis: Require a Name or AlternativeName. \"apiVersion\": \"github.com/microsoft/PSRule/v1\", \"kind\": \"Selector\", \"metadata\": { \"name\": \"RequireName\" }, \"spec\": { \"if\": { \"anyOf\": [ { \"field\": \"AlternateName\", \"exists\": true }, { \"field\": \"Name\", \"exists\": true } ] } } }, { // Synopsis: Require a specific CustomValue \"apiVersion\": \"github.com/microsoft/PSRule/v1\", \"kind\": \"Selector\", \"metadata\": { \"name\": \"RequireSpecificCustomValue\" }, \"spec\": { \"if\": { \"field\": \"CustomValue\", \"in\": [ \"Value1\", \"Value2\" ] } } } ]","title":"Example Selectors.Rule.jsonc"},{"location":"concepts/PSRule/en-US/about_PSRule_Selectors/#links","text":"Invoke-PSRule","title":"Links"},{"location":"concepts/PSRule/en-US/about_PSRule_SuppressionGroups/","text":"Suppression Groups # Describes PSRule Suppression Groups including how to use and author them. Description # PSRule executes rules to validate an object from input. When an evaluating an object from input, PSRule can use suppression groups to suppress rules based on a Selector . Defining suppression groups # Suppression groups can be defined with either YAML or JSON format, and can be included with a module or a standalone .Rule.yaml or .Rule.jsonc file. In either case, define a suppression group within a file ending with the .Rule.yaml or .Rule.jsonc extension. A suppression group can be defined side-by-side with other resources such as rules, baselines or module configurations. Suppression groups can also be defined within .json files. We recommend using .jsonc to view JSON with Comments in Visual Studio Code. Use the following template to define a suppression group: --- # Synopsis: {{ Synopsis }} apiVersion : github.com/microsoft/PSRule/v1 kind : SuppressionGroup metadata : name : '{{ Name }}' spec : rule : [] if : { } [ { // Synopsis: {{ Synopsis }} \"apiVersion\": \"github.com/microsoft/PSRule/v1\", \"kind\": \"SuppressionGroup\", \"metadata\": { \"name\": \"{{ Name }}\" }, \"spec\": { \"rule\": [], \"if\": {} } } ] Within the rule array, one or more rule names can be used. If no rules are specified, suppression will occur for all rules. Within the if object, one or more conditions or logical operators can be used. When the if condition is true the object will be suppressed for the current rule. Examples # Example SuppressionGroups.Rule.yaml # # Example SuppressionGroups.Rule.yaml --- # Synopsis: Suppress with target name apiVersion : github.com/microsoft/PSRule/v1 kind : SuppressionGroup metadata : name : SuppressWithTargetName spec : rule : - 'FromFile1' - 'FromFile2' if : name : '.' in : - 'TestObject1' - 'TestObject2' --- # Synopsis: Suppress with target type apiVersion : github.com/microsoft/PSRule/v1 kind : SuppressionGroup metadata : name : SuppressWithTestType spec : rule : - 'FromFile3' - 'FromFile5' if : type : '.' equals : 'TestType' Example SuppressionGroups.Rule.jsonc # // Example SuppressionGroups.Rule.jsonc [ { // Synopsis: Suppress with target name \"apiVersion\": \"github.com/microsoft/PSRule/v1\", \"kind\": \"SuppressionGroup\", \"metadata\": { \"name\": \"SuppressWithTargetName\" }, \"spec\": { \"rule\": [ \"FromFile1\", \"FromFile2\" ], \"if\": { \"name\": \".\", \"in\": [ \"TestObject1\", \"TestObject2\" ] } } }, { // Synopsis: Suppress with target type \"apiVersion\": \"github.com/microsoft/PSRule/v1\", \"kind\": \"SuppressionGroup\", \"metadata\": { \"name\": \"SuppressWithTestType\" }, \"spec\": { \"rule\": [ \"FromFile3\", \"FromFile5\" ], \"if\": { \"type\": \".\", \"equals\": \"TestType\" } } } ] Links # Invoke-PSRule","title":"Suppression Groups"},{"location":"concepts/PSRule/en-US/about_PSRule_SuppressionGroups/#suppression-groups","text":"Describes PSRule Suppression Groups including how to use and author them.","title":"Suppression Groups"},{"location":"concepts/PSRule/en-US/about_PSRule_SuppressionGroups/#description","text":"PSRule executes rules to validate an object from input. When an evaluating an object from input, PSRule can use suppression groups to suppress rules based on a Selector .","title":"Description"},{"location":"concepts/PSRule/en-US/about_PSRule_SuppressionGroups/#defining-suppression-groups","text":"Suppression groups can be defined with either YAML or JSON format, and can be included with a module or a standalone .Rule.yaml or .Rule.jsonc file. In either case, define a suppression group within a file ending with the .Rule.yaml or .Rule.jsonc extension. A suppression group can be defined side-by-side with other resources such as rules, baselines or module configurations. Suppression groups can also be defined within .json files. We recommend using .jsonc to view JSON with Comments in Visual Studio Code. Use the following template to define a suppression group: --- # Synopsis: {{ Synopsis }} apiVersion : github.com/microsoft/PSRule/v1 kind : SuppressionGroup metadata : name : '{{ Name }}' spec : rule : [] if : { } [ { // Synopsis: {{ Synopsis }} \"apiVersion\": \"github.com/microsoft/PSRule/v1\", \"kind\": \"SuppressionGroup\", \"metadata\": { \"name\": \"{{ Name }}\" }, \"spec\": { \"rule\": [], \"if\": {} } } ] Within the rule array, one or more rule names can be used. If no rules are specified, suppression will occur for all rules. Within the if object, one or more conditions or logical operators can be used. When the if condition is true the object will be suppressed for the current rule.","title":"Defining suppression groups"},{"location":"concepts/PSRule/en-US/about_PSRule_SuppressionGroups/#examples","text":"","title":"Examples"},{"location":"concepts/PSRule/en-US/about_PSRule_SuppressionGroups/#example-suppressiongroupsruleyaml","text":"# Example SuppressionGroups.Rule.yaml --- # Synopsis: Suppress with target name apiVersion : github.com/microsoft/PSRule/v1 kind : SuppressionGroup metadata : name : SuppressWithTargetName spec : rule : - 'FromFile1' - 'FromFile2' if : name : '.' in : - 'TestObject1' - 'TestObject2' --- # Synopsis: Suppress with target type apiVersion : github.com/microsoft/PSRule/v1 kind : SuppressionGroup metadata : name : SuppressWithTestType spec : rule : - 'FromFile3' - 'FromFile5' if : type : '.' equals : 'TestType'","title":"Example SuppressionGroups.Rule.yaml"},{"location":"concepts/PSRule/en-US/about_PSRule_SuppressionGroups/#example-suppressiongroupsrulejsonc","text":"// Example SuppressionGroups.Rule.jsonc [ { // Synopsis: Suppress with target name \"apiVersion\": \"github.com/microsoft/PSRule/v1\", \"kind\": \"SuppressionGroup\", \"metadata\": { \"name\": \"SuppressWithTargetName\" }, \"spec\": { \"rule\": [ \"FromFile1\", \"FromFile2\" ], \"if\": { \"name\": \".\", \"in\": [ \"TestObject1\", \"TestObject2\" ] } } }, { // Synopsis: Suppress with target type \"apiVersion\": \"github.com/microsoft/PSRule/v1\", \"kind\": \"SuppressionGroup\", \"metadata\": { \"name\": \"SuppressWithTestType\" }, \"spec\": { \"rule\": [ \"FromFile3\", \"FromFile5\" ], \"if\": { \"type\": \".\", \"equals\": \"TestType\" } } } ]","title":"Example SuppressionGroups.Rule.jsonc"},{"location":"concepts/PSRule/en-US/about_PSRule_SuppressionGroups/#links","text":"Invoke-PSRule","title":"Links"},{"location":"concepts/PSRule/en-US/about_PSRule_Variables/","text":"Variables # Describes the automatic variables that can be used within PSRule rule definitions. Description # PSRule lets you define rules using PowerShell blocks. A rule is defined within script files by using the rule keyword. Within a rule definition, PSRule exposes a number of automatic variables that can be read to assist with rule execution. Overwriting these variables or variable properties is not supported. These variables are only available while Invoke-PSRule is executing. The following variables are available for use: $Assert $Configuration $LocalizedData $PSRule $Rule $TargetObject Assert # An assertion helper with methods to evaluate objects. The $Assert object provides a set of built-in methods and provides a consistent variable for extension. Each $Assert method returns an AssertResult object that contains the result of the condition. The following built-in assertion methods are provided: Contains - The field value must contain at least one of the strings. EndsWith - The field value must match at least one suffix. FileHeader - The file must contain a comment header. FilePath - The file path must exist. Greater - The field value must be greater. GreaterOrEqual - The field value must be greater or equal to. HasDefaultValue - The object should not have the field or the field value is set to the default value. HasField - The object must have any of the specified fields. HasFields - The object must have all of the specified fields. HasFieldValue - The object must have the specified field and that field is not empty. HasJsonSchema - The object must reference a JSON schema with the $schema field. In - The field value must be included in the set. IsArray - The field value must be an array. IsBoolean - The field value must be a boolean. IsInteger - The field value must be an integer. IsLower - The field value must include only lowercase characters. IsNumeric - The field value must be a numeric type. IsString - The field value must be a string. IsUpper - The field value must include only uppercase characters. JsonSchema - The object must validate successfully against a JSON schema. Less - The field value must be less. LessOrEqual - The field value must be less or equal to. Match - The field value matches a regular expression pattern. NotIn - The field value must not be included in the set. NotMatch - The field value does not match a regular expression pattern. NullOrEmpty - The object must not have the specified field or it must be empty. TypeOf - The field value must be of the specified type. StartsWith - The field value must match at least one prefix. Version - The field value must be a semantic version string. The $Assert variable can only be used within a rule definition block. For detailed information on the assertion helper see about_PSRule_Assert . Syntax: $Assert Examples: # Synopsis: Determine if $TargetObject is valid against the provided schema Rule 'UseJsonSchema' { $Assert . JsonSchema ( $TargetObject , 'schemas/PSRule-options.schema.json' ) } Configuration # A dynamic object with properties names that map to configuration values set in the baseline. When accessing configuration: Configuration keys are case sensitive. Configuration values are read only. Configuration values can be accessed through helper methods. The following helper methods are available: GetStringValues(string configurationKey) - Returns an array of strings, based on configurationKey . Syntax: $Configuration .< configurationKey > $Configuration . GetStringValues (< configurationKey >) Examples: # Synopsis: This rule uses a threshold stored as $Configuration.appServiceMinInstanceCount Rule 'appServicePlan.MinInstanceCount' -If { $TargetObject . ResourceType -eq 'Microsoft.Web/serverfarms' } { $TargetObject . Sku . capacity -ge $Configuration . appServiceMinInstanceCount } -Configure @{ appServiceMinInstanceCount = 2 } LocalizedData # A dynamic object with properties names that map to localized data messages in a .psd1 file. When using localized data, PSRule loads localized strings as a hashtable from PSRule-rules.psd1 . The following logic is used to locate PSRule-rules.psd1 : If the rules are loose (not part of a module), PSRule will search for PSRule-rules.psd1 in the .\\<culture>\\ subdirectory relative to where the rule script .ps1 file is located. When the rules are shipped as part of a module, PSRule will search for PSRule-rules.psd1 in the .\\<culture>\\ subdirectory relative to where the module manifest .psd1 file is located. When accessing localized data: Message names are case sensitive. Message values are read only. Syntax: $LocalizedData .< messageName > Examples: # Data for rules stored in PSRule-rules.psd1 @{ WithLocalizedDataMessage = 'LocalizedMessage for en-ZZ. Format={0}.' } # Synopsis: Use -f to generate a formatted localized warning Rule 'WithLocalizedData' { Write-Warning -Message ( $LocalizedData . WithLocalizedDataMessage -f $TargetObject . Type ) } This rule returns a warning message similar to: LocalizedMessage for en-ZZ. Format=TestType. PSRule # An object representing the current context during execution. The following properties are available for read access: Badges - A helper to generate badges within PSRule. This property can only be called within the -End block of a convention. Field - A hashtable of custom bound fields. See option Binding.Field for more information. TargetObject - The object currently being processed on the pipeline. TargetName - The name of the object currently being processed on the pipeline. This property will automatically default to TargetName or Name properties of the object if they exist. TargetType - The type of the object currently being processed on the pipeline. This property will automatically bind to PSObject.TypeNames[0] by default. Source - A collection of sources for the object currently being processed on the pipeline. Output - The output of all rules. This property can only be called within the -End block of a convention. The following properties are available for read/ write access: Data - A hashtable of custom data. This property can be populated during rule or begin/ process convention execution. Custom data is not used by PSRule directly, and is intended to be used by downstream processes that need to interpret PSRule results. To bind fields that already exist on the target object use custom binding and Binding.Field . Use custom data to store data that must be calculated during rule execution. The following helper methods are available: GetContent(PSObject sourceObject) - Returns the content of a file as one or more objects. The parameter sourceObject should be a InputFileInfo , FileInfo , or Uri object. GetContentField(PSObject sourceObject, string field) - Returns the content of a file as one or more objects. The parameter sourceObject should be a InputFileInfo , FileInfo , or Uri object. The parameter field is an field within each object to return. If the field does not exist on the object, an object is not returned. GetContentFirstOrDefault(PSObject sourceObject) - Returns the content of a file as on object. The parameter sourceObject should be a InputFileInfo , FileInfo , or Uri object. If more than one object is contained in the file, only the first object is returned. When the source file contains no objects null is returned. Import(PSObject[] sourceObject) - Imports one or more source objects into the pipeline. This method can only be called within the -Begin block of a convention. Use this method to expand an object into child objects that will be processed independently. Objects imported using this method will be excluded from the Input.ObjectPath option if set. AddService(string id, object service) - Add a service to the current context. The service can be retrieved using $PSRule.GetService(id) . The service object will be available to all rules and cleaned up after all rules are executed. Services should implement the IDisposable interface to perform additional cleanup. This method can only be called within the -Initialize block of a convention. GetService(string id) - Retrieves a service previously added by a convention. GetPath(object sourceObject, string path) - Evalute an object path expression and returns the resulting objects. The file format is detected based on the same file formats as the option Input.Format . i.e. Yaml, Json, Markdown, and PowerShell Data. Syntax: $PSRule Examples: # Synopsis: This rule determines if the target object matches the naming convention Rule 'NamingConvention' { $PSRule . TargetName . ToLower () -ceq $PSRule . TargetName } # Synopsis: Use allowed environment tags Rule 'CustomData' { Recommend 'Environment must be set to an allowed value' Within 'Tags.environment' 'production' , 'test' , 'development' if ( $TargetObject . Tags . environment -in 'prod' ) { $PSRule . Data [ 'targetEnvironment' ] = 'production' } elseif ( $TargetObject . Tags . environment -in 'dev' , 'develop' ) { $PSRule . Data [ 'targetEnvironment' ] = 'development' } elseif ( $TargetObject . Tags . environment -in 'tst' , 'testing' ) { $PSRule . Data [ 'targetEnvironment' ] = 'test' } } Rule # An object representing the current rule during execution. The following properties are available for read access: RuleName - The name of the rule. RuleId - A unique identifier for the rule. Syntax: $Rule Examples: # Synopsis: This rule determines if the target object matches the naming convention Rule 'resource.NamingConvention' { $PSRule . TargetName . ToLower () -ceq $PSRule . TargetName } TargetObject # The value of the pipeline object currently being processed. $TargetObject is set by using the -InputObject parameter of Invoke-PSRule . When more than one input object is set, each object will be processed sequentially. Syntax: $TargetObject Examples: # Synopsis: Check that sku capacity is set to at least 2 Rule 'HasMinInstances' { $TargetObject . Sku . capacity -ge 2 } Links # Invoke-PSRule","title":"Variables"},{"location":"concepts/PSRule/en-US/about_PSRule_Variables/#variables","text":"Describes the automatic variables that can be used within PSRule rule definitions.","title":"Variables"},{"location":"concepts/PSRule/en-US/about_PSRule_Variables/#description","text":"PSRule lets you define rules using PowerShell blocks. A rule is defined within script files by using the rule keyword. Within a rule definition, PSRule exposes a number of automatic variables that can be read to assist with rule execution. Overwriting these variables or variable properties is not supported. These variables are only available while Invoke-PSRule is executing. The following variables are available for use: $Assert $Configuration $LocalizedData $PSRule $Rule $TargetObject","title":"Description"},{"location":"concepts/PSRule/en-US/about_PSRule_Variables/#assert","text":"An assertion helper with methods to evaluate objects. The $Assert object provides a set of built-in methods and provides a consistent variable for extension. Each $Assert method returns an AssertResult object that contains the result of the condition. The following built-in assertion methods are provided: Contains - The field value must contain at least one of the strings. EndsWith - The field value must match at least one suffix. FileHeader - The file must contain a comment header. FilePath - The file path must exist. Greater - The field value must be greater. GreaterOrEqual - The field value must be greater or equal to. HasDefaultValue - The object should not have the field or the field value is set to the default value. HasField - The object must have any of the specified fields. HasFields - The object must have all of the specified fields. HasFieldValue - The object must have the specified field and that field is not empty. HasJsonSchema - The object must reference a JSON schema with the $schema field. In - The field value must be included in the set. IsArray - The field value must be an array. IsBoolean - The field value must be a boolean. IsInteger - The field value must be an integer. IsLower - The field value must include only lowercase characters. IsNumeric - The field value must be a numeric type. IsString - The field value must be a string. IsUpper - The field value must include only uppercase characters. JsonSchema - The object must validate successfully against a JSON schema. Less - The field value must be less. LessOrEqual - The field value must be less or equal to. Match - The field value matches a regular expression pattern. NotIn - The field value must not be included in the set. NotMatch - The field value does not match a regular expression pattern. NullOrEmpty - The object must not have the specified field or it must be empty. TypeOf - The field value must be of the specified type. StartsWith - The field value must match at least one prefix. Version - The field value must be a semantic version string. The $Assert variable can only be used within a rule definition block. For detailed information on the assertion helper see about_PSRule_Assert . Syntax: $Assert Examples: # Synopsis: Determine if $TargetObject is valid against the provided schema Rule 'UseJsonSchema' { $Assert . JsonSchema ( $TargetObject , 'schemas/PSRule-options.schema.json' ) }","title":"Assert"},{"location":"concepts/PSRule/en-US/about_PSRule_Variables/#configuration","text":"A dynamic object with properties names that map to configuration values set in the baseline. When accessing configuration: Configuration keys are case sensitive. Configuration values are read only. Configuration values can be accessed through helper methods. The following helper methods are available: GetStringValues(string configurationKey) - Returns an array of strings, based on configurationKey . Syntax: $Configuration .< configurationKey > $Configuration . GetStringValues (< configurationKey >) Examples: # Synopsis: This rule uses a threshold stored as $Configuration.appServiceMinInstanceCount Rule 'appServicePlan.MinInstanceCount' -If { $TargetObject . ResourceType -eq 'Microsoft.Web/serverfarms' } { $TargetObject . Sku . capacity -ge $Configuration . appServiceMinInstanceCount } -Configure @{ appServiceMinInstanceCount = 2 }","title":"Configuration"},{"location":"concepts/PSRule/en-US/about_PSRule_Variables/#localizeddata","text":"A dynamic object with properties names that map to localized data messages in a .psd1 file. When using localized data, PSRule loads localized strings as a hashtable from PSRule-rules.psd1 . The following logic is used to locate PSRule-rules.psd1 : If the rules are loose (not part of a module), PSRule will search for PSRule-rules.psd1 in the .\\<culture>\\ subdirectory relative to where the rule script .ps1 file is located. When the rules are shipped as part of a module, PSRule will search for PSRule-rules.psd1 in the .\\<culture>\\ subdirectory relative to where the module manifest .psd1 file is located. When accessing localized data: Message names are case sensitive. Message values are read only. Syntax: $LocalizedData .< messageName > Examples: # Data for rules stored in PSRule-rules.psd1 @{ WithLocalizedDataMessage = 'LocalizedMessage for en-ZZ. Format={0}.' } # Synopsis: Use -f to generate a formatted localized warning Rule 'WithLocalizedData' { Write-Warning -Message ( $LocalizedData . WithLocalizedDataMessage -f $TargetObject . Type ) } This rule returns a warning message similar to: LocalizedMessage for en-ZZ. Format=TestType.","title":"LocalizedData"},{"location":"concepts/PSRule/en-US/about_PSRule_Variables/#psrule","text":"An object representing the current context during execution. The following properties are available for read access: Badges - A helper to generate badges within PSRule. This property can only be called within the -End block of a convention. Field - A hashtable of custom bound fields. See option Binding.Field for more information. TargetObject - The object currently being processed on the pipeline. TargetName - The name of the object currently being processed on the pipeline. This property will automatically default to TargetName or Name properties of the object if they exist. TargetType - The type of the object currently being processed on the pipeline. This property will automatically bind to PSObject.TypeNames[0] by default. Source - A collection of sources for the object currently being processed on the pipeline. Output - The output of all rules. This property can only be called within the -End block of a convention. The following properties are available for read/ write access: Data - A hashtable of custom data. This property can be populated during rule or begin/ process convention execution. Custom data is not used by PSRule directly, and is intended to be used by downstream processes that need to interpret PSRule results. To bind fields that already exist on the target object use custom binding and Binding.Field . Use custom data to store data that must be calculated during rule execution. The following helper methods are available: GetContent(PSObject sourceObject) - Returns the content of a file as one or more objects. The parameter sourceObject should be a InputFileInfo , FileInfo , or Uri object. GetContentField(PSObject sourceObject, string field) - Returns the content of a file as one or more objects. The parameter sourceObject should be a InputFileInfo , FileInfo , or Uri object. The parameter field is an field within each object to return. If the field does not exist on the object, an object is not returned. GetContentFirstOrDefault(PSObject sourceObject) - Returns the content of a file as on object. The parameter sourceObject should be a InputFileInfo , FileInfo , or Uri object. If more than one object is contained in the file, only the first object is returned. When the source file contains no objects null is returned. Import(PSObject[] sourceObject) - Imports one or more source objects into the pipeline. This method can only be called within the -Begin block of a convention. Use this method to expand an object into child objects that will be processed independently. Objects imported using this method will be excluded from the Input.ObjectPath option if set. AddService(string id, object service) - Add a service to the current context. The service can be retrieved using $PSRule.GetService(id) . The service object will be available to all rules and cleaned up after all rules are executed. Services should implement the IDisposable interface to perform additional cleanup. This method can only be called within the -Initialize block of a convention. GetService(string id) - Retrieves a service previously added by a convention. GetPath(object sourceObject, string path) - Evalute an object path expression and returns the resulting objects. The file format is detected based on the same file formats as the option Input.Format . i.e. Yaml, Json, Markdown, and PowerShell Data. Syntax: $PSRule Examples: # Synopsis: This rule determines if the target object matches the naming convention Rule 'NamingConvention' { $PSRule . TargetName . ToLower () -ceq $PSRule . TargetName } # Synopsis: Use allowed environment tags Rule 'CustomData' { Recommend 'Environment must be set to an allowed value' Within 'Tags.environment' 'production' , 'test' , 'development' if ( $TargetObject . Tags . environment -in 'prod' ) { $PSRule . Data [ 'targetEnvironment' ] = 'production' } elseif ( $TargetObject . Tags . environment -in 'dev' , 'develop' ) { $PSRule . Data [ 'targetEnvironment' ] = 'development' } elseif ( $TargetObject . Tags . environment -in 'tst' , 'testing' ) { $PSRule . Data [ 'targetEnvironment' ] = 'test' } }","title":"PSRule"},{"location":"concepts/PSRule/en-US/about_PSRule_Variables/#rule","text":"An object representing the current rule during execution. The following properties are available for read access: RuleName - The name of the rule. RuleId - A unique identifier for the rule. Syntax: $Rule Examples: # Synopsis: This rule determines if the target object matches the naming convention Rule 'resource.NamingConvention' { $PSRule . TargetName . ToLower () -ceq $PSRule . TargetName }","title":"Rule"},{"location":"concepts/PSRule/en-US/about_PSRule_Variables/#targetobject","text":"The value of the pipeline object currently being processed. $TargetObject is set by using the -InputObject parameter of Invoke-PSRule . When more than one input object is set, each object will be processed sequentially. Syntax: $TargetObject Examples: # Synopsis: Check that sku capacity is set to at least 2 Rule 'HasMinInstances' { $TargetObject . Sku . capacity -ge 2 }","title":"TargetObject"},{"location":"concepts/PSRule/en-US/about_PSRule_Variables/#links","text":"Invoke-PSRule","title":"Links"},{"location":"keywords/PSRule/en-US/about_PSRule_Keywords/","text":"Keywords # Describes the language keywords that can be used within PSRule rule definitions. Description # PSRule lets you define rules using PowerShell blocks. To define a rule use the Rule keyword. Rule - Creates a rule definition. The following are the built-in keywords that can be used within a rule definition: AnyOf - Assert that any of the child expressions must be true. AllOf - Assert that all of the child expressions must be true. Exists - Assert that a field or property must exist. Match - Assert that the field must match any of the regular expressions. Reason - Return a reason for why the rule failed. Recommend - Return a recommendation to resolve the issue and pass the rule. TypeOf - Assert that the object must be of a specific type. Within - Assert that the field must match any of the values. A subset of built-in keywords can be used within script preconditions: Exists - Assert that a field or property must exist. Match - Assert that the field must match any of the regular expressions. TypeOf - Assert that the object must be of a specific type. Within - Assert that the field must match any of the values. Rule # A Rule definition describes an individual business rule that will be executed against each input object. Input objects can be passed on the PowerShell pipeline or supplied from file. To define a Rule use the Rule keyword followed by a name and a pair of squiggly brackets { . Within the { } one or more conditions can be used. Conditions determine if the input object either Pass or Fail the rule. Syntax: Rule [-Name] <string> [-Ref <string>] [-Alias <string[]>] [-Tag <hashtable>] [-When <string[]>] [-Type <string[]>] [-If <scriptBlock>] [-DependsOn <string[]>] [-Configure <hashtable>] [-ErrorAction <ActionPreference>] [-Body] { ... } Name - The name of the rule definition. Each rule name must be unique. When packaging rules within a module, rule names must only be unique within the module. Ref - An optional stable and opaque identifier that can be used to reference the rule. Alias - A list of alternative names that can be used to reference the rule. Tag - A hashtable of key/ value metadata that can be used to filter and identify rules and rule results. When - A selector precondition that must evaluate true before the rule is executed. Type - A type precondition that must match the TargetType of the pipeline object before the rule is executed. If - A script precondition that must evaluate to $True before the rule is executed. DependsOn - A list of rules this rule depends on. Rule dependencies must execute successfully before this rule is executed. Configure - A set of default configuration values. These values are only used when the baseline configuration does not contain the key. ErrorAction - The action to take when an error occur. Only a subset of preferences are supported, either Stop or Ignore . When -ErrorAction is not specified the default preference is Stop . When errors are ignored a rule will pass or fail based on the rule condition. Uncaught exceptions will still cause rule return an error outcome. Body - A script block that specifies one or more conditions that are required for the rule to Pass . A condition is any valid PowerShell that return either $True or $False . Optionally, PSRule keywords can be used to help build out conditions quickly. When a rule contains more then one condition, all must return $True for the rule to Pass . If any one condition returns $False the rule has failed. The following restrictions apply: Rule conditions should only return $True or $False . Other objects should be caught with Out-Null or null assigned like $Null = SomeCommand . The Rule keyword can not be nested in a Rule definition. Variables and functions defined within .Rule.ps1 files, but outside the Rule definition block are not accessible unless the Global scope is applied. Functions and variables within the caller's scope (the scope calling Invoke-PSRule , Get-PSRule , Test-PSRuleTarget ) are not accessible. Cmdlets that require user interaction are not supported, i.e. Read-Host . Script preconditions can contain Exists , Match , TypeOf and Within keywords. Examples: # Synopsis: This rule checks for the presence of a name field Rule 'NameMustExist' { Exists 'Name' } # Synopsis: This rule checks that the title field is valid, when the rule NameMustExist is successful Rule 'TitleIsValid' -DependsOn 'NameMustExist' { Within 'Title' 'Mr' , 'Miss' , 'Mrs' , 'Ms' } # Synopsis: This rule uses a threshold stored as $Configuration.minInstanceCount Rule 'HasMinInstances' { $TargetObject . Sku . capacity -ge $Configuration . minInstanceCount } -Configure @{ minInstanceCount = 2 } # Synopsis: This rule still passes because errors are ignored Rule 'WithRuleErrorActionIgnore' -ErrorAction Ignore { Write-Error 'Some error' ; $True ; } Exists # The Exists assertion is used within a Rule definition to assert that a field or property must exist on the pipeline object. Syntax: Exists [-Field] <string[]> [-CaseSensitive] [-Not] [-All] [-Reason <string>] [-InputObject <PSObject>] Field - One or more fields/ properties that must exist on the pipeline object. CaseSensitive - The field name must match exact case. Not - Instead of checking if the field names exists they should not exist. All - All fields must exist on the pipeline object, instead of only one. Reason - A custom reason provided if the condition fails. InputObject - Supports objects being piped directly. Examples: # Synopsis: Checks for the presence of a name property Rule 'nameMustExist' { Exists 'Name' } # Synopsis: Checks for the presence of name nested under the metadata property Rule 'nameMustExist' { Exists 'metadata.name' } # Synopsis: Checks for the presence of name nested under the metadata property Rule 'nameMustExist' { $TargetObject . metadata | Exists 'name' } # Synopsis: Checks that the NotName property does not exist Rule 'NotNameMustNotExist' { Exists -Not 'NotName' } # Synopsis: Checks one of Name or AlternativeName properties exist Rule 'EitherMustExist' { Exists 'Name' , 'AlternativeName' } # Synopsis: Checks that both Name and Type properties exist Rule 'AllMustExist' { Exists 'Name' , 'Type' -All } Output: If any the specified fields exists then Exists will return $True , otherwise $False . If -Not is used, then if any of the fields exist then Exists will return $False otherwise $True . If -All is used, then then all of the fields must exist, or not with the -Not switch. If all fields exist then Exists will return $True , otherwise $False . If -Not is used with -All , if all of the fields exist Exists will return $False otherwise $True . Match # The Match assertion is used within a Rule definition to assert that the value of a field or property from pipeline data must match one or more regular expressions. To optionally perform a case sensitive match use the -CaseSensitive switch, otherwise a case insensitive match will be used. Syntax: Match [-Field] <string> [-Expression] <string[]> [-CaseSensitive] [-Not] [-Reason <string>] [-InputObject <PSObject>] Field - The name of the field that will be evaluated on the pipeline object. Expression - One or more regular expressions that will be used to match the value of the field. CaseSensitive - The field value must match exact case. Not - Instead of checking the field value matches, the field value must not match any of the expressions. Reason - A custom reason provided if the condition fails. InputObject - Supports objects being piped directly. Examples: # Synopsis: Check that PhoneNumber is complete and formatted correctly Rule 'validatePhoneNumber' { Match 'PhoneNumber' '^(\\+61|0)([0-9] {0,1}){8}[0-9]$' } Output: If any of the specified regular expressions match the field value then Match returns $True , otherwise $False . When -Not is used, if any of the regular expressions match the field value with Match return $False , otherwise $True . Within # The Within assertion is used within a Rule definition to assert that the value of a field or property from pipeline data must equal an item from a supplied list of allowed values. To optionally perform a case sensitive match use the -CaseSensitive switch, otherwise a case insensitive match will be used. Syntax: Within [-Field] <string> [-Not] [-Like] [-Value] <PSObject[]> [-CaseSensitive] [-Reason <string>] [-InputObject <PSObject>] Field - The name of the field that will be evaluated on the pipeline object. Value - A list of values that the field value must match. CaseSensitive - The field value must match exact case. Only applies when the field value and allowed values are strings. Not - Instead of checking the field value matches, the field value must not match any of the supplied values. Like - Instead of using an exact match, a wildcard match is used. This switch can only be used when Value a string type. Reason - A custom reason provided if the condition fails. InputObject - Supports objects being piped directly. Examples: # Synopsis: Ensure that the title field has one of the allowed values Rule 'validateTitle' { Within 'Title' 'Mr' , 'Miss' , 'Mrs' , 'Ms' } # Synopsis: Ensure that the title field is not one of the specified values Rule 'validateTitle' { Within 'Title' -Not 'Mr' , 'Sir' } # Synopsis: Ensure that the title field has one of the allowed values Rule 'validateTitle' { Within 'Title' -Like 'Mr' , 'M*s' } Output: If any of the values match the field value then Within returns $True , otherwise $False . When -Not is used, if any of the values match the field value with Within return $False , otherwise $True . When -Like is used, the field value is matched against one or more wildcard expressions. AllOf # The AllOf assertion is used within a Rule definition to aggregate the result of assertions within a pair of squiggly brackets { } . AllOf is functionally equivalent to a binary and , where when all of the contained assertions return $True , AllOf will return $True . Syntax: AllOf [-Body] { <assertion> [<assertion>] ... } Body - A script block definition of the containing one or more PSRule keywords and PowerShell expressions. Examples: # Synopsis: The Name field must exist and have a value of either John or Jane Rule 'nameCheck' { AllOf { Exists 'Name' Within 'Name' 'John' , 'Jane' } } Output: If all of the assertions return $True AllOf will return $True , otherwise $False . AnyOf # The AnyOf assertion is used within a Rule definition to aggregate the result of assertions within a pair of squiggly brackets { } . AnyOf is functionally equivalent to a binary or , where if any of the contained assertions returns $True , AnyOf will return $True . Syntax: AnyOf [-Body] { <assertion> [<assertion>] ... } Body - A script block definition of the containing one or more PSRule keywords and PowerShell expressions. Examples: # Synopsis: The Last or Surname field must exist Rule 'personCheck' { AnyOf { Exists 'Last' Exists 'Surname' } } Output: If any of the assertions return $True AnyOf will return $True , otherwise $False . TypeOf # The TypeOf assertion is used within a Rule definition to evaluate if the pipeline object matches one or more of the supplied type names. Syntax: TypeOf [-TypeName] <string[]> [-Reason <string>] [-InputObject <PSObject>] TypeName - One or more type names which will be evaluated against the pipeline object. TypeName is case sensitive. Reason - A custom reason provided if the condition fails. InputObject - Supports objects being piped directly. Examples: # Synopsis: The object must be a hashtable Rule 'objectType' { TypeOf 'System.Collections.Hashtable' } Output: If any the specified type names match the pipeline object then TypeOf will return $True , otherwise $False . Reason # The Reason keyword is used within a Rule definition to provide a message that indicates the reason the rule failed. The reason is included in detailed results. A reason is only included when the rule fails or errors. The outcomes Pass and None do not include reason. Use this keyword when you want to implement custom logic. Built-in keywords including Exists , Match , Within and TypeOf automatically include a reason when they fail. Syntax: Reason [-Text] <string> Text - A message that includes the reason for the failure. Examples: # Synopsis: Provide reason the rule failed Rule 'objectRecommend' { Reason 'A minimum of two (2) instances are required' $TargetObject . count -ge 2 } Output: None. Recommend # The Recommend keyword is used within a Rule definition to provide a recommendation to resolve the issue and pass the rule. This may include manual steps to change that state of the object or the desired state accessed by the rule. The recommendation can only be set once per rule. Each object will use the same recommendation. Syntax: Recommend [-Text] <string> Text - A message that includes the process to resolve the issue and pass the rule. Examples: # Synopsis: Provide recommendation to resolve the issue Rule 'objectRecommend' { Recommend 'Use at least two (2) instances' $TargetObject . count -ge 2 } Output: None. Examples # # Synopsis: App Service Plan has multiple instances Rule 'appServicePlan.MinInstanceCount' -If { $TargetObject . ResourceType -eq 'Microsoft.Web/serverfarms' } { Recommend 'Use at least two (2) instances' $TargetObject . Sku . capacity -ge 2 } Links # [Invoke-PSRule]","title":"Keywords"},{"location":"keywords/PSRule/en-US/about_PSRule_Keywords/#keywords","text":"Describes the language keywords that can be used within PSRule rule definitions.","title":"Keywords"},{"location":"keywords/PSRule/en-US/about_PSRule_Keywords/#description","text":"PSRule lets you define rules using PowerShell blocks. To define a rule use the Rule keyword. Rule - Creates a rule definition. The following are the built-in keywords that can be used within a rule definition: AnyOf - Assert that any of the child expressions must be true. AllOf - Assert that all of the child expressions must be true. Exists - Assert that a field or property must exist. Match - Assert that the field must match any of the regular expressions. Reason - Return a reason for why the rule failed. Recommend - Return a recommendation to resolve the issue and pass the rule. TypeOf - Assert that the object must be of a specific type. Within - Assert that the field must match any of the values. A subset of built-in keywords can be used within script preconditions: Exists - Assert that a field or property must exist. Match - Assert that the field must match any of the regular expressions. TypeOf - Assert that the object must be of a specific type. Within - Assert that the field must match any of the values.","title":"Description"},{"location":"keywords/PSRule/en-US/about_PSRule_Keywords/#rule","text":"A Rule definition describes an individual business rule that will be executed against each input object. Input objects can be passed on the PowerShell pipeline or supplied from file. To define a Rule use the Rule keyword followed by a name and a pair of squiggly brackets { . Within the { } one or more conditions can be used. Conditions determine if the input object either Pass or Fail the rule. Syntax: Rule [-Name] <string> [-Ref <string>] [-Alias <string[]>] [-Tag <hashtable>] [-When <string[]>] [-Type <string[]>] [-If <scriptBlock>] [-DependsOn <string[]>] [-Configure <hashtable>] [-ErrorAction <ActionPreference>] [-Body] { ... } Name - The name of the rule definition. Each rule name must be unique. When packaging rules within a module, rule names must only be unique within the module. Ref - An optional stable and opaque identifier that can be used to reference the rule. Alias - A list of alternative names that can be used to reference the rule. Tag - A hashtable of key/ value metadata that can be used to filter and identify rules and rule results. When - A selector precondition that must evaluate true before the rule is executed. Type - A type precondition that must match the TargetType of the pipeline object before the rule is executed. If - A script precondition that must evaluate to $True before the rule is executed. DependsOn - A list of rules this rule depends on. Rule dependencies must execute successfully before this rule is executed. Configure - A set of default configuration values. These values are only used when the baseline configuration does not contain the key. ErrorAction - The action to take when an error occur. Only a subset of preferences are supported, either Stop or Ignore . When -ErrorAction is not specified the default preference is Stop . When errors are ignored a rule will pass or fail based on the rule condition. Uncaught exceptions will still cause rule return an error outcome. Body - A script block that specifies one or more conditions that are required for the rule to Pass . A condition is any valid PowerShell that return either $True or $False . Optionally, PSRule keywords can be used to help build out conditions quickly. When a rule contains more then one condition, all must return $True for the rule to Pass . If any one condition returns $False the rule has failed. The following restrictions apply: Rule conditions should only return $True or $False . Other objects should be caught with Out-Null or null assigned like $Null = SomeCommand . The Rule keyword can not be nested in a Rule definition. Variables and functions defined within .Rule.ps1 files, but outside the Rule definition block are not accessible unless the Global scope is applied. Functions and variables within the caller's scope (the scope calling Invoke-PSRule , Get-PSRule , Test-PSRuleTarget ) are not accessible. Cmdlets that require user interaction are not supported, i.e. Read-Host . Script preconditions can contain Exists , Match , TypeOf and Within keywords. Examples: # Synopsis: This rule checks for the presence of a name field Rule 'NameMustExist' { Exists 'Name' } # Synopsis: This rule checks that the title field is valid, when the rule NameMustExist is successful Rule 'TitleIsValid' -DependsOn 'NameMustExist' { Within 'Title' 'Mr' , 'Miss' , 'Mrs' , 'Ms' } # Synopsis: This rule uses a threshold stored as $Configuration.minInstanceCount Rule 'HasMinInstances' { $TargetObject . Sku . capacity -ge $Configuration . minInstanceCount } -Configure @{ minInstanceCount = 2 } # Synopsis: This rule still passes because errors are ignored Rule 'WithRuleErrorActionIgnore' -ErrorAction Ignore { Write-Error 'Some error' ; $True ; }","title":"Rule"},{"location":"keywords/PSRule/en-US/about_PSRule_Keywords/#exists","text":"The Exists assertion is used within a Rule definition to assert that a field or property must exist on the pipeline object. Syntax: Exists [-Field] <string[]> [-CaseSensitive] [-Not] [-All] [-Reason <string>] [-InputObject <PSObject>] Field - One or more fields/ properties that must exist on the pipeline object. CaseSensitive - The field name must match exact case. Not - Instead of checking if the field names exists they should not exist. All - All fields must exist on the pipeline object, instead of only one. Reason - A custom reason provided if the condition fails. InputObject - Supports objects being piped directly. Examples: # Synopsis: Checks for the presence of a name property Rule 'nameMustExist' { Exists 'Name' } # Synopsis: Checks for the presence of name nested under the metadata property Rule 'nameMustExist' { Exists 'metadata.name' } # Synopsis: Checks for the presence of name nested under the metadata property Rule 'nameMustExist' { $TargetObject . metadata | Exists 'name' } # Synopsis: Checks that the NotName property does not exist Rule 'NotNameMustNotExist' { Exists -Not 'NotName' } # Synopsis: Checks one of Name or AlternativeName properties exist Rule 'EitherMustExist' { Exists 'Name' , 'AlternativeName' } # Synopsis: Checks that both Name and Type properties exist Rule 'AllMustExist' { Exists 'Name' , 'Type' -All } Output: If any the specified fields exists then Exists will return $True , otherwise $False . If -Not is used, then if any of the fields exist then Exists will return $False otherwise $True . If -All is used, then then all of the fields must exist, or not with the -Not switch. If all fields exist then Exists will return $True , otherwise $False . If -Not is used with -All , if all of the fields exist Exists will return $False otherwise $True .","title":"Exists"},{"location":"keywords/PSRule/en-US/about_PSRule_Keywords/#match","text":"The Match assertion is used within a Rule definition to assert that the value of a field or property from pipeline data must match one or more regular expressions. To optionally perform a case sensitive match use the -CaseSensitive switch, otherwise a case insensitive match will be used. Syntax: Match [-Field] <string> [-Expression] <string[]> [-CaseSensitive] [-Not] [-Reason <string>] [-InputObject <PSObject>] Field - The name of the field that will be evaluated on the pipeline object. Expression - One or more regular expressions that will be used to match the value of the field. CaseSensitive - The field value must match exact case. Not - Instead of checking the field value matches, the field value must not match any of the expressions. Reason - A custom reason provided if the condition fails. InputObject - Supports objects being piped directly. Examples: # Synopsis: Check that PhoneNumber is complete and formatted correctly Rule 'validatePhoneNumber' { Match 'PhoneNumber' '^(\\+61|0)([0-9] {0,1}){8}[0-9]$' } Output: If any of the specified regular expressions match the field value then Match returns $True , otherwise $False . When -Not is used, if any of the regular expressions match the field value with Match return $False , otherwise $True .","title":"Match"},{"location":"keywords/PSRule/en-US/about_PSRule_Keywords/#within","text":"The Within assertion is used within a Rule definition to assert that the value of a field or property from pipeline data must equal an item from a supplied list of allowed values. To optionally perform a case sensitive match use the -CaseSensitive switch, otherwise a case insensitive match will be used. Syntax: Within [-Field] <string> [-Not] [-Like] [-Value] <PSObject[]> [-CaseSensitive] [-Reason <string>] [-InputObject <PSObject>] Field - The name of the field that will be evaluated on the pipeline object. Value - A list of values that the field value must match. CaseSensitive - The field value must match exact case. Only applies when the field value and allowed values are strings. Not - Instead of checking the field value matches, the field value must not match any of the supplied values. Like - Instead of using an exact match, a wildcard match is used. This switch can only be used when Value a string type. Reason - A custom reason provided if the condition fails. InputObject - Supports objects being piped directly. Examples: # Synopsis: Ensure that the title field has one of the allowed values Rule 'validateTitle' { Within 'Title' 'Mr' , 'Miss' , 'Mrs' , 'Ms' } # Synopsis: Ensure that the title field is not one of the specified values Rule 'validateTitle' { Within 'Title' -Not 'Mr' , 'Sir' } # Synopsis: Ensure that the title field has one of the allowed values Rule 'validateTitle' { Within 'Title' -Like 'Mr' , 'M*s' } Output: If any of the values match the field value then Within returns $True , otherwise $False . When -Not is used, if any of the values match the field value with Within return $False , otherwise $True . When -Like is used, the field value is matched against one or more wildcard expressions.","title":"Within"},{"location":"keywords/PSRule/en-US/about_PSRule_Keywords/#allof","text":"The AllOf assertion is used within a Rule definition to aggregate the result of assertions within a pair of squiggly brackets { } . AllOf is functionally equivalent to a binary and , where when all of the contained assertions return $True , AllOf will return $True . Syntax: AllOf [-Body] { <assertion> [<assertion>] ... } Body - A script block definition of the containing one or more PSRule keywords and PowerShell expressions. Examples: # Synopsis: The Name field must exist and have a value of either John or Jane Rule 'nameCheck' { AllOf { Exists 'Name' Within 'Name' 'John' , 'Jane' } } Output: If all of the assertions return $True AllOf will return $True , otherwise $False .","title":"AllOf"},{"location":"keywords/PSRule/en-US/about_PSRule_Keywords/#anyof","text":"The AnyOf assertion is used within a Rule definition to aggregate the result of assertions within a pair of squiggly brackets { } . AnyOf is functionally equivalent to a binary or , where if any of the contained assertions returns $True , AnyOf will return $True . Syntax: AnyOf [-Body] { <assertion> [<assertion>] ... } Body - A script block definition of the containing one or more PSRule keywords and PowerShell expressions. Examples: # Synopsis: The Last or Surname field must exist Rule 'personCheck' { AnyOf { Exists 'Last' Exists 'Surname' } } Output: If any of the assertions return $True AnyOf will return $True , otherwise $False .","title":"AnyOf"},{"location":"keywords/PSRule/en-US/about_PSRule_Keywords/#typeof","text":"The TypeOf assertion is used within a Rule definition to evaluate if the pipeline object matches one or more of the supplied type names. Syntax: TypeOf [-TypeName] <string[]> [-Reason <string>] [-InputObject <PSObject>] TypeName - One or more type names which will be evaluated against the pipeline object. TypeName is case sensitive. Reason - A custom reason provided if the condition fails. InputObject - Supports objects being piped directly. Examples: # Synopsis: The object must be a hashtable Rule 'objectType' { TypeOf 'System.Collections.Hashtable' } Output: If any the specified type names match the pipeline object then TypeOf will return $True , otherwise $False .","title":"TypeOf"},{"location":"keywords/PSRule/en-US/about_PSRule_Keywords/#reason","text":"The Reason keyword is used within a Rule definition to provide a message that indicates the reason the rule failed. The reason is included in detailed results. A reason is only included when the rule fails or errors. The outcomes Pass and None do not include reason. Use this keyword when you want to implement custom logic. Built-in keywords including Exists , Match , Within and TypeOf automatically include a reason when they fail. Syntax: Reason [-Text] <string> Text - A message that includes the reason for the failure. Examples: # Synopsis: Provide reason the rule failed Rule 'objectRecommend' { Reason 'A minimum of two (2) instances are required' $TargetObject . count -ge 2 } Output: None.","title":"Reason"},{"location":"keywords/PSRule/en-US/about_PSRule_Keywords/#recommend","text":"The Recommend keyword is used within a Rule definition to provide a recommendation to resolve the issue and pass the rule. This may include manual steps to change that state of the object or the desired state accessed by the rule. The recommendation can only be set once per rule. Each object will use the same recommendation. Syntax: Recommend [-Text] <string> Text - A message that includes the process to resolve the issue and pass the rule. Examples: # Synopsis: Provide recommendation to resolve the issue Rule 'objectRecommend' { Recommend 'Use at least two (2) instances' $TargetObject . count -ge 2 } Output: None.","title":"Recommend"},{"location":"keywords/PSRule/en-US/about_PSRule_Keywords/#examples","text":"# Synopsis: App Service Plan has multiple instances Rule 'appServicePlan.MinInstanceCount' -If { $TargetObject . ResourceType -eq 'Microsoft.Web/serverfarms' } { Recommend 'Use at least two (2) instances' $TargetObject . Sku . capacity -ge 2 }","title":"Examples"},{"location":"keywords/PSRule/en-US/about_PSRule_Keywords/#links","text":"[Invoke-PSRule]","title":"Links"},{"location":"scenarios/","text":"Getting started with PSRule # Define a rule # To define a rule, use a Rule block saved to a file with the .Rule.ps1 extension. Rule 'NameOfRule' { # Rule conditions } Within the body of the rule provide one or more conditions. A condition is valid PowerShell that results in $True or $False . For example: Rule 'isFruit' { # Condition to determine if the object is fruit $TargetObject . Name -in 'Apple' , 'Orange' , 'Pear' } An optional result message can be added to by using the Recommend keyword. Rule 'isFruit' { # An recommendation to display in output Recommend 'Fruit is only Apple, Orange and Pear' # Condition to determine if the object is fruit $TargetObject . Name -in 'Apple' , 'Orange' , 'Pear' } The rule is saved to a file named isFruit.Rule.ps1 file. One or more rules can be defined within a single file. Execute a rule # To execute the rule use Invoke-PSRule . For example: # Define objects to validate $items = @(); $items += [PSCustomObject] @{ Name = 'Fridge' }; $items += [PSCustomObject] @{ Name = 'Apple' }; # Validate each item using rules saved in current working path $items | Invoke-PSRule ; The output of this example is: TargetName: Fridge RuleName Outcome Recommendation -------- ------- -------------- isFruit Fail Fruit is only Apple, Orange and Pear TargetName: Apple RuleName Outcome Recommendation -------- ------- -------------- isFruit Pass Fruit is only Apple, Orange and Pear Additional options # To filter results to only non-fruit results, use Invoke-PSRule -Outcome Fail . Passed, failed and error results are shown by default. # Only show non-fruit results $items | Invoke-PSRule -Outcome Fail ; For a summary of results for each rule use Invoke-PSRule -As Summary . For example: # Show rule summary $items | Invoke-PSRule -As Summary ; The output of this example is: RuleName Pass Fail Outcome -------- ---- ---- ------- isFruit 1 1 Fail An optional failure reason can be added to the rule block by using the Reason keyword. Rule 'isFruit' { # An recommendation to display in output Recommend 'Fruit is only Apple, Orange and Pear' # An failure reason to display for non-fruit Reason \" $( $PSRule . TargetName ) is not fruit.\" # Condition to determine if the object is fruit $TargetObject . Name -in 'Apple' , 'Orange' , 'Pear' } To include the reason with output use Invoke-PSRule -OutputFormat Wide . For example: # Show failure reason for failing results $items | Invoke-PSRule -OutputFormat Wide ; The output of this example is: TargetName: Fridge RuleName Outcome Reason Recommendation -------- ------- ------ -------------- isFruit Fail Fridge is not fruit. Fruit is only Apple, Orange and Pear TargetName: Apple RuleName Outcome Reason Recommendation -------- ------- ------ -------------- isFruit Pass Fruit is only Apple, Orange and Pear The final rule is saved to isFruit.Rule.ps1 . Scenarios # For walk through examples of PSRule usage see: Validate Azure resource configuration Validate Azure resources tags Validate Kubernetes resources Using within continuous integration Packaging rules in a module Writing rule help","title":"Getting started with PSRule"},{"location":"scenarios/#getting-started-with-psrule","text":"","title":"Getting started with PSRule"},{"location":"scenarios/#define-a-rule","text":"To define a rule, use a Rule block saved to a file with the .Rule.ps1 extension. Rule 'NameOfRule' { # Rule conditions } Within the body of the rule provide one or more conditions. A condition is valid PowerShell that results in $True or $False . For example: Rule 'isFruit' { # Condition to determine if the object is fruit $TargetObject . Name -in 'Apple' , 'Orange' , 'Pear' } An optional result message can be added to by using the Recommend keyword. Rule 'isFruit' { # An recommendation to display in output Recommend 'Fruit is only Apple, Orange and Pear' # Condition to determine if the object is fruit $TargetObject . Name -in 'Apple' , 'Orange' , 'Pear' } The rule is saved to a file named isFruit.Rule.ps1 file. One or more rules can be defined within a single file.","title":"Define a rule"},{"location":"scenarios/#execute-a-rule","text":"To execute the rule use Invoke-PSRule . For example: # Define objects to validate $items = @(); $items += [PSCustomObject] @{ Name = 'Fridge' }; $items += [PSCustomObject] @{ Name = 'Apple' }; # Validate each item using rules saved in current working path $items | Invoke-PSRule ; The output of this example is: TargetName: Fridge RuleName Outcome Recommendation -------- ------- -------------- isFruit Fail Fruit is only Apple, Orange and Pear TargetName: Apple RuleName Outcome Recommendation -------- ------- -------------- isFruit Pass Fruit is only Apple, Orange and Pear","title":"Execute a rule"},{"location":"scenarios/#additional-options","text":"To filter results to only non-fruit results, use Invoke-PSRule -Outcome Fail . Passed, failed and error results are shown by default. # Only show non-fruit results $items | Invoke-PSRule -Outcome Fail ; For a summary of results for each rule use Invoke-PSRule -As Summary . For example: # Show rule summary $items | Invoke-PSRule -As Summary ; The output of this example is: RuleName Pass Fail Outcome -------- ---- ---- ------- isFruit 1 1 Fail An optional failure reason can be added to the rule block by using the Reason keyword. Rule 'isFruit' { # An recommendation to display in output Recommend 'Fruit is only Apple, Orange and Pear' # An failure reason to display for non-fruit Reason \" $( $PSRule . TargetName ) is not fruit.\" # Condition to determine if the object is fruit $TargetObject . Name -in 'Apple' , 'Orange' , 'Pear' } To include the reason with output use Invoke-PSRule -OutputFormat Wide . For example: # Show failure reason for failing results $items | Invoke-PSRule -OutputFormat Wide ; The output of this example is: TargetName: Fridge RuleName Outcome Reason Recommendation -------- ------- ------ -------------- isFruit Fail Fridge is not fruit. Fruit is only Apple, Orange and Pear TargetName: Apple RuleName Outcome Reason Recommendation -------- ------- ------ -------------- isFruit Pass Fruit is only Apple, Orange and Pear The final rule is saved to isFruit.Rule.ps1 .","title":"Additional options"},{"location":"scenarios/#scenarios","text":"For walk through examples of PSRule usage see: Validate Azure resource configuration Validate Azure resources tags Validate Kubernetes resources Using within continuous integration Packaging rules in a module Writing rule help","title":"Scenarios"},{"location":"scenarios/azure-resources/azure-resources/","text":"Validate Azure resource configuration # PSRule makes it easy to validate Infrastructure as Code (IaC) such as Azure resources. For example, Azure resources can be validated to match and internal standard or baseline. Note A pre-built module to validate Azure resources already exists. This scenario demonstrates the process and features of PSRule for illustration purposes. Consider using or contributing these pre-built rule modules instead: PSRule.Rules.Azure PSRule.Rules.CAF This scenario covers the following: Defining a basic rule. Adding a recommendation. Using script pre-conditions. Using helper functions. In this scenario we will use a JSON file: resources.json - An export for the Azure resource properties saved for offline use. To generate a similar resources.json file of your own, the use following command. # Get all resources using the Az modules. Alternatively use Get-AzureRmResource if using AzureRm modules. # This command also requires authentication with Connect-AzAccount or Connect-AzureRmAccount Get-AzResource -ExpandProperties | ConvertTo-Json -Depth 10 | Set-Content -path .\\ resources . json ; For this example we ran this command: Get-AzResource -ExpandProperties | ConvertTo-Json -Depth 10 | Set-Content -path docs / scenarios / azure-resources / resources . json ; Define rules # To validate our Azure resources we need to define some rules. Rules are defined by using the Rule keyword in a file ending with the .Rule.ps1 extension. So start we are going to define a storageAccounts.UseHttps rule, which will validate that Azure Storage resources have a Secure Transfer Required enabled. In the example below: We use storageAccounts.UseHttps directly after the Rule keyword to name the rule definition. Each rule must be named uniquely. The # Synopsis: comment is used to add additional metadata interpreted by PSRule. One or more conditions are defined within the curly braces { } . The rule definition is saved within a file named storageAccounts.Rule.ps1 . # Synopsis: Configure storage accounts to only accept encrypted traffic i.e. HTTPS/SMB Rule 'storageAccounts.UseHttps' { # Rule conditions go here } Set rule condition # Conditions can be any valid PowerShell expression that results in a $True or $False , just like an If statement, but without specifically requiring the If keyword to be used. Several PSRule keywords such as Exists and AllOf can supplement PowerShell to quickly build out rules that are easy to read. In resources.json one of our example storage accounts has a property Properties.supportsHttpsTrafficOnly as shown below, which will be how our rule will pass $True or fail $False Azure resources that we throw at it. { \"Name\" : \"storage\" , \"ResourceName\" : \"storage\" , \"ResourceType\" : \"Microsoft.Storage/storageAccounts\" , \"Kind\" : \"Storage\" , \"ResourceGroupName\" : \"test-rg\" , \"Location\" : \"eastus2\" , \"Properties\" : { \"supportsHttpsTrafficOnly\" : false } } In the example below: We use the $TargetObject variable to get the object on the pipeline and access it's properties. The condition will return $True or $False back to the pipeline, where: $True - the object passed the validation check $False - the object failed the validation check # Synopsis: Configure storage accounts to only accept encrypted traffic i.e. HTTPS/SMB Rule 'storageAccounts.UseHttps' { # This property returns true or false, so nothing more needs to be done $TargetObject . Properties . supportsHttpsTrafficOnly # Alternatively this could be written as: # $TargetObject.Properties.supportsHttpsTrafficOnly -eq $True } Add rule recommendation # Additionally to provide feedback to the person or process running the rules, we can use the Recommend keyword to set a message that appears in results. If a recommend message is not provided the synopsis will be used instead. In the example below: Directly after the Recommend keyword is a message to help understand why the rule failed or passed. # Synopsis: Configure storage accounts to only accept encrypted traffic i.e. HTTPS/SMB Rule 'storageAccounts.UseHttps' { Recommend 'Storage accounts should only allow secure traffic' $TargetObject . Properties . supportsHttpsTrafficOnly } Filter with preconditions # So far our rule works for a Storage Account, but there are many type of resources that could be returned by calling Get-AzResource . Most of these resources won't have the Properties.supportsHttpsTrafficOnly property, and if it did, it may use different configuration options instead of just true and false . This is where preconditions help out. Preconditions can be specified by using the -If parameter when defining a rule. When the rule is executed, if the precondition is $True then the rule is processed, otherwise it is skipped. In the example below: A check against $TargetObject.ResourceType ensured that our rule is only processed for Storage Accounts. # Synopsis: Configure storage accounts to only accept encrypted traffic i.e. HTTPS/SMB Rule 'storageAccounts.UseHttps' -If { $TargetObject . ResourceType -eq 'Microsoft.Storage/storageAccounts' } { Recommend 'Storage accounts should only allow secure traffic' $TargetObject . Properties . supportsHttpsTrafficOnly } Skipped rules have the outcome None and are not included in output by default. To include skipped rules use the -Outcome All parameter. Execute rules # With a rule defined, the next step is to execute it. To execute rules, pipe the target object to Invoke-PSRule . For example: # Read resources in from file $resources = Get-Content -Path .\\ resources . json | ConvertFrom-Json ; # Process resources $resources | Invoke-PSRule ; PSRule natively supports reading from YAML and JSON files so this command-line can be simplified to: Invoke-PSRule -InputPath .\\ resources . json ; You will notice, we didn't specify the rule. By default PSRule will look for any .Rule.ps1 files in the current working path. Invoke-PSRule supports -Path , -Name and -Tag parameters that can be used to specify the path to look for rules in or filter rules if you want to run a subset of the rules. For this example we ran these commands: Invoke-PSRule -Path docs / scenarios / azure-resources -InputPath docs / scenarios / azure-resources / resources . json ; Our output looked like this: TargetName: storage RuleName Outcome Recommendation -------- ------- -------------- storageAccounts.UseHttps Fail Storage accounts should only allow secure traffic In our case storageAccounts.UseHttps returns a Fail outcome because our storage account has supportsHttpsTrafficOnly = false , which is exactly what should happen. Define helper functions # Using helper functions is completely optional and not required in many cases. However, you may prefer to use helper functions when rule conditions or preconditions are complex and hard to understand. To use helper functions use a function block within a file with a .Rule.ps1 extension. Any code within .Rule.ps1 files called by Invoke-PSRule will be executed, however to make it available for use within a rule, a global scope modifier must be used. For functions this is done by prefixing the function name with global: . For example: function global: NameOfFunction { # Function body } In our example, we are going to define a ResourceType function in a file named common.Rule.ps1 . This function will be used by preconditions to check the type of Azure resource. # A custom function to filter by resource type function global: ResourceType { param ( [String] $ResourceType ) process { return $TargetObject . ResourceType -eq $ResourceType ; } } Updating our existing storageAccounts.UseHttps rule, our rule definition becomes: # Synopsis: Configure storage accounts to only accept encrypted traffic i.e. HTTPS/SMB Rule 'storageAccounts.UseHttps' -If { ResourceType 'Microsoft.Storage/storageAccounts' } { Recommend 'Storage accounts should only allow secure traffic' $TargetObject . Properties . supportsHttpsTrafficOnly } More information # storageAccounts.Rule.ps1 - Example rules for validating Azure Storage. appService.Rule.ps1 - Example rules for validating Azure App Service. resources.json - Offline export of Azure resources. common.Rule.ps1 - ResourceType helper function.","title":"Validate Azure resource configuration"},{"location":"scenarios/azure-resources/azure-resources/#validate-azure-resource-configuration","text":"PSRule makes it easy to validate Infrastructure as Code (IaC) such as Azure resources. For example, Azure resources can be validated to match and internal standard or baseline. Note A pre-built module to validate Azure resources already exists. This scenario demonstrates the process and features of PSRule for illustration purposes. Consider using or contributing these pre-built rule modules instead: PSRule.Rules.Azure PSRule.Rules.CAF This scenario covers the following: Defining a basic rule. Adding a recommendation. Using script pre-conditions. Using helper functions. In this scenario we will use a JSON file: resources.json - An export for the Azure resource properties saved for offline use. To generate a similar resources.json file of your own, the use following command. # Get all resources using the Az modules. Alternatively use Get-AzureRmResource if using AzureRm modules. # This command also requires authentication with Connect-AzAccount or Connect-AzureRmAccount Get-AzResource -ExpandProperties | ConvertTo-Json -Depth 10 | Set-Content -path .\\ resources . json ; For this example we ran this command: Get-AzResource -ExpandProperties | ConvertTo-Json -Depth 10 | Set-Content -path docs / scenarios / azure-resources / resources . json ;","title":"Validate Azure resource configuration"},{"location":"scenarios/azure-resources/azure-resources/#define-rules","text":"To validate our Azure resources we need to define some rules. Rules are defined by using the Rule keyword in a file ending with the .Rule.ps1 extension. So start we are going to define a storageAccounts.UseHttps rule, which will validate that Azure Storage resources have a Secure Transfer Required enabled. In the example below: We use storageAccounts.UseHttps directly after the Rule keyword to name the rule definition. Each rule must be named uniquely. The # Synopsis: comment is used to add additional metadata interpreted by PSRule. One or more conditions are defined within the curly braces { } . The rule definition is saved within a file named storageAccounts.Rule.ps1 . # Synopsis: Configure storage accounts to only accept encrypted traffic i.e. HTTPS/SMB Rule 'storageAccounts.UseHttps' { # Rule conditions go here }","title":"Define rules"},{"location":"scenarios/azure-resources/azure-resources/#set-rule-condition","text":"Conditions can be any valid PowerShell expression that results in a $True or $False , just like an If statement, but without specifically requiring the If keyword to be used. Several PSRule keywords such as Exists and AllOf can supplement PowerShell to quickly build out rules that are easy to read. In resources.json one of our example storage accounts has a property Properties.supportsHttpsTrafficOnly as shown below, which will be how our rule will pass $True or fail $False Azure resources that we throw at it. { \"Name\" : \"storage\" , \"ResourceName\" : \"storage\" , \"ResourceType\" : \"Microsoft.Storage/storageAccounts\" , \"Kind\" : \"Storage\" , \"ResourceGroupName\" : \"test-rg\" , \"Location\" : \"eastus2\" , \"Properties\" : { \"supportsHttpsTrafficOnly\" : false } } In the example below: We use the $TargetObject variable to get the object on the pipeline and access it's properties. The condition will return $True or $False back to the pipeline, where: $True - the object passed the validation check $False - the object failed the validation check # Synopsis: Configure storage accounts to only accept encrypted traffic i.e. HTTPS/SMB Rule 'storageAccounts.UseHttps' { # This property returns true or false, so nothing more needs to be done $TargetObject . Properties . supportsHttpsTrafficOnly # Alternatively this could be written as: # $TargetObject.Properties.supportsHttpsTrafficOnly -eq $True }","title":"Set rule condition"},{"location":"scenarios/azure-resources/azure-resources/#add-rule-recommendation","text":"Additionally to provide feedback to the person or process running the rules, we can use the Recommend keyword to set a message that appears in results. If a recommend message is not provided the synopsis will be used instead. In the example below: Directly after the Recommend keyword is a message to help understand why the rule failed or passed. # Synopsis: Configure storage accounts to only accept encrypted traffic i.e. HTTPS/SMB Rule 'storageAccounts.UseHttps' { Recommend 'Storage accounts should only allow secure traffic' $TargetObject . Properties . supportsHttpsTrafficOnly }","title":"Add rule recommendation"},{"location":"scenarios/azure-resources/azure-resources/#filter-with-preconditions","text":"So far our rule works for a Storage Account, but there are many type of resources that could be returned by calling Get-AzResource . Most of these resources won't have the Properties.supportsHttpsTrafficOnly property, and if it did, it may use different configuration options instead of just true and false . This is where preconditions help out. Preconditions can be specified by using the -If parameter when defining a rule. When the rule is executed, if the precondition is $True then the rule is processed, otherwise it is skipped. In the example below: A check against $TargetObject.ResourceType ensured that our rule is only processed for Storage Accounts. # Synopsis: Configure storage accounts to only accept encrypted traffic i.e. HTTPS/SMB Rule 'storageAccounts.UseHttps' -If { $TargetObject . ResourceType -eq 'Microsoft.Storage/storageAccounts' } { Recommend 'Storage accounts should only allow secure traffic' $TargetObject . Properties . supportsHttpsTrafficOnly } Skipped rules have the outcome None and are not included in output by default. To include skipped rules use the -Outcome All parameter.","title":"Filter with preconditions"},{"location":"scenarios/azure-resources/azure-resources/#execute-rules","text":"With a rule defined, the next step is to execute it. To execute rules, pipe the target object to Invoke-PSRule . For example: # Read resources in from file $resources = Get-Content -Path .\\ resources . json | ConvertFrom-Json ; # Process resources $resources | Invoke-PSRule ; PSRule natively supports reading from YAML and JSON files so this command-line can be simplified to: Invoke-PSRule -InputPath .\\ resources . json ; You will notice, we didn't specify the rule. By default PSRule will look for any .Rule.ps1 files in the current working path. Invoke-PSRule supports -Path , -Name and -Tag parameters that can be used to specify the path to look for rules in or filter rules if you want to run a subset of the rules. For this example we ran these commands: Invoke-PSRule -Path docs / scenarios / azure-resources -InputPath docs / scenarios / azure-resources / resources . json ; Our output looked like this: TargetName: storage RuleName Outcome Recommendation -------- ------- -------------- storageAccounts.UseHttps Fail Storage accounts should only allow secure traffic In our case storageAccounts.UseHttps returns a Fail outcome because our storage account has supportsHttpsTrafficOnly = false , which is exactly what should happen.","title":"Execute rules"},{"location":"scenarios/azure-resources/azure-resources/#define-helper-functions","text":"Using helper functions is completely optional and not required in many cases. However, you may prefer to use helper functions when rule conditions or preconditions are complex and hard to understand. To use helper functions use a function block within a file with a .Rule.ps1 extension. Any code within .Rule.ps1 files called by Invoke-PSRule will be executed, however to make it available for use within a rule, a global scope modifier must be used. For functions this is done by prefixing the function name with global: . For example: function global: NameOfFunction { # Function body } In our example, we are going to define a ResourceType function in a file named common.Rule.ps1 . This function will be used by preconditions to check the type of Azure resource. # A custom function to filter by resource type function global: ResourceType { param ( [String] $ResourceType ) process { return $TargetObject . ResourceType -eq $ResourceType ; } } Updating our existing storageAccounts.UseHttps rule, our rule definition becomes: # Synopsis: Configure storage accounts to only accept encrypted traffic i.e. HTTPS/SMB Rule 'storageAccounts.UseHttps' -If { ResourceType 'Microsoft.Storage/storageAccounts' } { Recommend 'Storage accounts should only allow secure traffic' $TargetObject . Properties . supportsHttpsTrafficOnly }","title":"Define helper functions"},{"location":"scenarios/azure-resources/azure-resources/#more-information","text":"storageAccounts.Rule.ps1 - Example rules for validating Azure Storage. appService.Rule.ps1 - Example rules for validating Azure App Service. resources.json - Offline export of Azure resources. common.Rule.ps1 - ResourceType helper function.","title":"More information"},{"location":"scenarios/azure-tags/azure-tags/","text":"Azure resource tagging example # This is an example of how PSRule can be used to validate tags on Azure resources to match an internal tagging standard. This scenario covers the following: Defining a basic rule. Basic usage of Exists , Within and Match keywords. Using configuration in a rule definition. Setting configuration in YAML. Running rules with configuration. In this scenario we will use a JSON file: resources.json - An export of Azure resource properties saved for offline use. To generate a similar file of your own, the use following command. # Get all resources using the Az modules. Alternatively use Get-AzureRmResource if using AzureRm modules. # This command also requires authentication with Connect-AzAccount or Connect-AzureRmAccount Get-AzResource -ExpandProperties | ConvertTo-Json -Depth 10 | Set-Content -Path .\\ resources . json ; For this example, we ran this command: Get-AzResource -ExpandProperties | ConvertTo-Json -Depth 10 | Set-Content -Path docs / scenarios / azure-resources / resources . json ; Define rules # To validate our Azure resources, we need to define some rules. Rules are defined by using the Rule keyword in a file ending with the .Rule.ps1 extension. Our business rules for Azure resource tagging can be defined with the following dot points: Tag names should be easy to read and understand. Tag names will use lower-camel/ pascal casing. The following mandatory tags will be used: environment: An operational environment for systems and services. Valid environments are production , testing and development . costCentre: A allocation account within financial systems used for charging costs to a business unit. A cost centre is a number with 5 digits and can't start with a 0. businessUnit: The name of the organizational unit or team that owns the application/ solution. To start we are going to define an environmentTag rule, which will ensure that the environment tag exists and that the value only uses allowed values. In the example below: We use environmentTag directly after the Rule keyword to name the rule definition. Each rule must be named uniquely. The # Synopsis: comment is used to add additional metadata interpreted by PSRule. One or more conditions are defined within the curly braces { } . The rule definition is saved within a file named azureTags.Rule.ps1 . # Synopsis: Resource must have environment tag Rule 'environmentTag' { # Rule conditions go here } Check that tag exists # Conditions can be any valid PowerShell expression that results in a $True or $False , just like an If statement, but without specifically requiring the If keyword to be used. In resources.json one of our example storage accounts has the Tags property as shown below, this is how Azure Resource Manager stores tags for a resource. We will use this property as the basis of our rules to determine if the resource is tagged and what the tag value is. { \"Name\" : \"storage\" , \"ResourceName\" : \"storage\" , \"ResourceType\" : \"Microsoft.Storage/storageAccounts\" , \"Tags\" : { \"role\" : \"deployment\" , \"environment\" : \"production\" } } PSRule also defines several additional keywords to supplement PowerShell. These additional keywords help to create readable rules that can be built out quickly. In the example below: We use the Exists keyword to check if the environment tag exists. The -CaseSensitive switch is also used to ensure that the tag name uses lowercase. The condition will return $True or $False back to the pipeline, where: $True - the environment tag exists. $False - the environment tag does not exist. # Synopsis: Resource must have environment tag Rule 'environmentTag' { Exists 'Tags.environment' -CaseSensitive } Tag uses only allowed values # In our scenario, we have three environments that our environment tag could be set to. In the next example we will ensure that only allowed environment values are used. In the example below: We use the Within keyword to check if the environment tag uses any of the allowed values. The -CaseSensitive switch is also used to ensure that the tag value is only a lowercase environment name. The condition will return $True or $False back to the pipeline, where: $True - an allowed environment is used. $False - the environment tag does not use one of the allowed values. # Synopsis: Resource must have environment tag Rule 'environmentTag' { Exists 'Tags.environment' -CaseSensitive Within 'Tags.environment' 'production' , 'test' , 'development' -CaseSensitive } Alternatively, instead of using the Within keyword the -cin operator could be used. Within provides additional verbose logging, however either syntax is valid. In the example below: $TargetObject automatic variable is used to get the pipeline object being evaluated. We use the -cin operator to check the environment tag only uses allowed values. The -cin operator performs a cases sensitive match on production , test and development . The condition will return $True or $False back to the pipeline, where: $True - an allowed environment is used. $False - the environment tag does not use one of the allowed values. # Synopsis: Resource must have environment tag Rule 'environmentTag' { Exists 'Tags.environment' -CaseSensitive $TargetObject . Tags . environment -cin 'production' , 'test' , 'development' } Tag value matches regular expression # For our second rule ( costCentreTag ), the costCentre tag value must be 5 numbers. We can validate this by using a regular expression. In the example below: We use the Match keyword to check if the costCentre tag uses a numeric only value with 5 digits, not starting with 0. The condition will return $True or $False back to the pipeline, where: $True - the costCentre tag value matches the regular expression. $False - the costCentre tag value does not use match the regular expression. # Synopsis: Resource must have costCentre tag Rule 'costCentreTag' { Exists 'Tags.costCentre' -CaseSensitive Match 'Tags.costCentre' '^([1-9][0-9]{4})$' } An alternative way to write the rule would be to use the -match operator instead of the Match keyword. Like the Within keyword, the Match keyword provides additional verbose logging that the -match operator does not provide. In the example below: $TargetObject automatic variable is used to get the pipeline object being evaluated. We use the -match operator to check the costCentre tag value matches the regular expression. The condition will return $True or $False back to the pipeline, where: $True - the costCentre tag value matches the regular expression. $False - the costCentre tag value does not use match the regular expression. # Synopsis: Resource must have costCentre tag Rule 'costCentreTag' { Exists 'Tags.costCentre' -CaseSensitive $TargetObject . Tags . costCentre -match '^([1-9][0-9]{4})$' } Use business unit name from configuration # For our third rule ( businessUnitTag ), the businessUnit must match a valid business unit. A list of business units will be referenced from configuration instead of hard coded in the rule. Configuration can be used within rule definitions by defining configuration in a YAML file then using the automatic variable $Configuration . In the example below: We use the Within keyword to check if the businessUnit tag uses any of the allowed values. allowedBusinessUnits configuration value can be referenced using the syntax $Configuration.allowedBusinessUnits . The rule definition is defined in azureTags.Rule.ps1 . YAML configuration is defined in ps-rule.yaml . An extract from azureTags.Rule.ps1 : # Synopsis: Resource must have businessUnit tag Rule 'businessUnitTag' { Exists 'Tags.businessUnit' -CaseSensitive Within 'Tags.businessUnit' $Configuration . allowedBusinessUnits } An extract from ps-rule.yaml : # Configure business units that are allowed configuration : allowedBusinessUnits : - 'IT Operations' - 'Finance' - 'HR' Execute rules # With a rule defined, the next step is to execute it. To execute rules, pipe the target object to Invoke-PSRule . For example: # Read resources in from file $resources = Get-Content -Path .\\ resources . json | ConvertFrom-Json ; # Evaluate each resource against tagging rules $resources | Invoke-PSRule -Option .\\ ps-rule . yaml ; The ps-rule.yaml will automatically discovered if it exists in the current working path (i.e. .\\ps-rule.yaml ). Alternatively it can be specified with the -Option parameter as show above. PSRule natively supports reading from YAML and JSON files so this command-line can be simplified to: # Evaluate each resource against tagging rules Invoke-PSRule -InputPath .\\ resources . json ; You will notice, we didn't specify the rule. By default PSRule will look for any .Rule.ps1 files in the current working path. Invoke-PSRule supports -Path , -Name and -Tag parameters that can be used to specify the path to look for rules in or filter rules if you want to run a subset of the rules. The -Option parameter allows us to specify a specific YAML configuration file to use. For this example, we ran these commands: # Evaluate each resource against tagging rules Invoke-PSRule -Path docs / scenarios / azure-tags -InputPath docs / scenarios / azure-tags / resources . json -Outcome Fail -Option docs / scenarios / azure-tags / ps-rule . yaml ; Our output looked like this: TargetName: storage RuleName Outcome Recommendation -------- ------- -------------- costCentreTag Fail Resource must have costCentre tag businessUnitTag Fail Resource must have businessUnit tag TargetName: web-app RuleName Outcome Recommendation -------- ------- -------------- environmentTag Fail Resource must have environment tag costCentreTag Fail Resource must have costCentre tag TargetName: web-app/staging RuleName Outcome Recommendation -------- ------- -------------- environmentTag Fail Resource must have environment tag costCentreTag Fail Resource must have costCentre tag Any resources that don't follow the tagging standard are reported with an outcome of Fail . More information # azureTags.Rule.ps1 - Example rules for validating Azure resource tagging standard rules. resources.json - Offline export of Azure resources. ps-rule.yaml - A YAML configuration file for PSRule.","title":"Azure resource tagging example"},{"location":"scenarios/azure-tags/azure-tags/#azure-resource-tagging-example","text":"This is an example of how PSRule can be used to validate tags on Azure resources to match an internal tagging standard. This scenario covers the following: Defining a basic rule. Basic usage of Exists , Within and Match keywords. Using configuration in a rule definition. Setting configuration in YAML. Running rules with configuration. In this scenario we will use a JSON file: resources.json - An export of Azure resource properties saved for offline use. To generate a similar file of your own, the use following command. # Get all resources using the Az modules. Alternatively use Get-AzureRmResource if using AzureRm modules. # This command also requires authentication with Connect-AzAccount or Connect-AzureRmAccount Get-AzResource -ExpandProperties | ConvertTo-Json -Depth 10 | Set-Content -Path .\\ resources . json ; For this example, we ran this command: Get-AzResource -ExpandProperties | ConvertTo-Json -Depth 10 | Set-Content -Path docs / scenarios / azure-resources / resources . json ;","title":"Azure resource tagging example"},{"location":"scenarios/azure-tags/azure-tags/#define-rules","text":"To validate our Azure resources, we need to define some rules. Rules are defined by using the Rule keyword in a file ending with the .Rule.ps1 extension. Our business rules for Azure resource tagging can be defined with the following dot points: Tag names should be easy to read and understand. Tag names will use lower-camel/ pascal casing. The following mandatory tags will be used: environment: An operational environment for systems and services. Valid environments are production , testing and development . costCentre: A allocation account within financial systems used for charging costs to a business unit. A cost centre is a number with 5 digits and can't start with a 0. businessUnit: The name of the organizational unit or team that owns the application/ solution. To start we are going to define an environmentTag rule, which will ensure that the environment tag exists and that the value only uses allowed values. In the example below: We use environmentTag directly after the Rule keyword to name the rule definition. Each rule must be named uniquely. The # Synopsis: comment is used to add additional metadata interpreted by PSRule. One or more conditions are defined within the curly braces { } . The rule definition is saved within a file named azureTags.Rule.ps1 . # Synopsis: Resource must have environment tag Rule 'environmentTag' { # Rule conditions go here }","title":"Define rules"},{"location":"scenarios/azure-tags/azure-tags/#check-that-tag-exists","text":"Conditions can be any valid PowerShell expression that results in a $True or $False , just like an If statement, but without specifically requiring the If keyword to be used. In resources.json one of our example storage accounts has the Tags property as shown below, this is how Azure Resource Manager stores tags for a resource. We will use this property as the basis of our rules to determine if the resource is tagged and what the tag value is. { \"Name\" : \"storage\" , \"ResourceName\" : \"storage\" , \"ResourceType\" : \"Microsoft.Storage/storageAccounts\" , \"Tags\" : { \"role\" : \"deployment\" , \"environment\" : \"production\" } } PSRule also defines several additional keywords to supplement PowerShell. These additional keywords help to create readable rules that can be built out quickly. In the example below: We use the Exists keyword to check if the environment tag exists. The -CaseSensitive switch is also used to ensure that the tag name uses lowercase. The condition will return $True or $False back to the pipeline, where: $True - the environment tag exists. $False - the environment tag does not exist. # Synopsis: Resource must have environment tag Rule 'environmentTag' { Exists 'Tags.environment' -CaseSensitive }","title":"Check that tag exists"},{"location":"scenarios/azure-tags/azure-tags/#tag-uses-only-allowed-values","text":"In our scenario, we have three environments that our environment tag could be set to. In the next example we will ensure that only allowed environment values are used. In the example below: We use the Within keyword to check if the environment tag uses any of the allowed values. The -CaseSensitive switch is also used to ensure that the tag value is only a lowercase environment name. The condition will return $True or $False back to the pipeline, where: $True - an allowed environment is used. $False - the environment tag does not use one of the allowed values. # Synopsis: Resource must have environment tag Rule 'environmentTag' { Exists 'Tags.environment' -CaseSensitive Within 'Tags.environment' 'production' , 'test' , 'development' -CaseSensitive } Alternatively, instead of using the Within keyword the -cin operator could be used. Within provides additional verbose logging, however either syntax is valid. In the example below: $TargetObject automatic variable is used to get the pipeline object being evaluated. We use the -cin operator to check the environment tag only uses allowed values. The -cin operator performs a cases sensitive match on production , test and development . The condition will return $True or $False back to the pipeline, where: $True - an allowed environment is used. $False - the environment tag does not use one of the allowed values. # Synopsis: Resource must have environment tag Rule 'environmentTag' { Exists 'Tags.environment' -CaseSensitive $TargetObject . Tags . environment -cin 'production' , 'test' , 'development' }","title":"Tag uses only allowed values"},{"location":"scenarios/azure-tags/azure-tags/#tag-value-matches-regular-expression","text":"For our second rule ( costCentreTag ), the costCentre tag value must be 5 numbers. We can validate this by using a regular expression. In the example below: We use the Match keyword to check if the costCentre tag uses a numeric only value with 5 digits, not starting with 0. The condition will return $True or $False back to the pipeline, where: $True - the costCentre tag value matches the regular expression. $False - the costCentre tag value does not use match the regular expression. # Synopsis: Resource must have costCentre tag Rule 'costCentreTag' { Exists 'Tags.costCentre' -CaseSensitive Match 'Tags.costCentre' '^([1-9][0-9]{4})$' } An alternative way to write the rule would be to use the -match operator instead of the Match keyword. Like the Within keyword, the Match keyword provides additional verbose logging that the -match operator does not provide. In the example below: $TargetObject automatic variable is used to get the pipeline object being evaluated. We use the -match operator to check the costCentre tag value matches the regular expression. The condition will return $True or $False back to the pipeline, where: $True - the costCentre tag value matches the regular expression. $False - the costCentre tag value does not use match the regular expression. # Synopsis: Resource must have costCentre tag Rule 'costCentreTag' { Exists 'Tags.costCentre' -CaseSensitive $TargetObject . Tags . costCentre -match '^([1-9][0-9]{4})$' }","title":"Tag value matches regular expression"},{"location":"scenarios/azure-tags/azure-tags/#use-business-unit-name-from-configuration","text":"For our third rule ( businessUnitTag ), the businessUnit must match a valid business unit. A list of business units will be referenced from configuration instead of hard coded in the rule. Configuration can be used within rule definitions by defining configuration in a YAML file then using the automatic variable $Configuration . In the example below: We use the Within keyword to check if the businessUnit tag uses any of the allowed values. allowedBusinessUnits configuration value can be referenced using the syntax $Configuration.allowedBusinessUnits . The rule definition is defined in azureTags.Rule.ps1 . YAML configuration is defined in ps-rule.yaml . An extract from azureTags.Rule.ps1 : # Synopsis: Resource must have businessUnit tag Rule 'businessUnitTag' { Exists 'Tags.businessUnit' -CaseSensitive Within 'Tags.businessUnit' $Configuration . allowedBusinessUnits } An extract from ps-rule.yaml : # Configure business units that are allowed configuration : allowedBusinessUnits : - 'IT Operations' - 'Finance' - 'HR'","title":"Use business unit name from configuration"},{"location":"scenarios/azure-tags/azure-tags/#execute-rules","text":"With a rule defined, the next step is to execute it. To execute rules, pipe the target object to Invoke-PSRule . For example: # Read resources in from file $resources = Get-Content -Path .\\ resources . json | ConvertFrom-Json ; # Evaluate each resource against tagging rules $resources | Invoke-PSRule -Option .\\ ps-rule . yaml ; The ps-rule.yaml will automatically discovered if it exists in the current working path (i.e. .\\ps-rule.yaml ). Alternatively it can be specified with the -Option parameter as show above. PSRule natively supports reading from YAML and JSON files so this command-line can be simplified to: # Evaluate each resource against tagging rules Invoke-PSRule -InputPath .\\ resources . json ; You will notice, we didn't specify the rule. By default PSRule will look for any .Rule.ps1 files in the current working path. Invoke-PSRule supports -Path , -Name and -Tag parameters that can be used to specify the path to look for rules in or filter rules if you want to run a subset of the rules. The -Option parameter allows us to specify a specific YAML configuration file to use. For this example, we ran these commands: # Evaluate each resource against tagging rules Invoke-PSRule -Path docs / scenarios / azure-tags -InputPath docs / scenarios / azure-tags / resources . json -Outcome Fail -Option docs / scenarios / azure-tags / ps-rule . yaml ; Our output looked like this: TargetName: storage RuleName Outcome Recommendation -------- ------- -------------- costCentreTag Fail Resource must have costCentre tag businessUnitTag Fail Resource must have businessUnit tag TargetName: web-app RuleName Outcome Recommendation -------- ------- -------------- environmentTag Fail Resource must have environment tag costCentreTag Fail Resource must have costCentre tag TargetName: web-app/staging RuleName Outcome Recommendation -------- ------- -------------- environmentTag Fail Resource must have environment tag costCentreTag Fail Resource must have costCentre tag Any resources that don't follow the tagging standard are reported with an outcome of Fail .","title":"Execute rules"},{"location":"scenarios/azure-tags/azure-tags/#more-information","text":"azureTags.Rule.ps1 - Example rules for validating Azure resource tagging standard rules. resources.json - Offline export of Azure resources. ps-rule.yaml - A YAML configuration file for PSRule.","title":"More information"},{"location":"scenarios/benchmark/results-v0.17.0/","text":"BenchmarkDotNet = v0.12.1, OS=Windows 10.0.18363.778 (1909/November2018Update/19H2) Intel Core i7-6600U CPU 2.60GHz (Skylake), 1 CPU, 4 logical and 2 physical cores .NET Core SDK = 3.1.201 [Host] : .NET Core 2.1.17 (CoreCLR 4.6.28619.01, CoreFX 4.6.28619.01), X64 RyuJIT DefaultJob : .NET Core 2.1.17 (CoreCLR 4.6.28619.01, CoreFX 4.6.28619.01), X64 RyuJIT | Method | Mean | Error | StdDev | Median | Gen 0 | Gen 1 | Gen 2 | Allocated | |------------------------- |-----------:|----------:|----------:|-----------:|-----------:|------:|------:|------------:| | Invoke | 111.140 ms | 2.1935 ms | 4.5786 ms | 109.312 ms | 8200.0000 | - | - | 16839.42 KB | | InvokeIf | 117.141 ms | 2.2703 ms | 2.2298 ms | 116.398 ms | 9600.0000 | - | - | 19980.62 KB | | InvokeType | 108.648 ms | 0.7983 ms | 0.7467 ms | 108.584 ms | 8200.0000 | - | - | 16870.67 KB | | InvokeSummary | 107.300 ms | 0.8612 ms | 0.8056 ms | 107.115 ms | 8000.0000 | - | - | 16784.76 KB | | Get | 9.003 ms | 0.0643 ms | 0.0602 ms | 9.010 ms | 140.6250 | - | - | 307.96 KB | | GetHelp | 8.902 ms | 0.0831 ms | 0.0649 ms | 8.899 ms | 140.6250 | - | - | 306.34 KB | | Within | 179.522 ms | 1.5483 ms | 1.4483 ms | 179.981 ms | 15666.6667 | - | - | 32400.38 KB | | WithinBulk | 247.883 ms | 2.6279 ms | 2.1944 ms | 248.124 ms | 28500.0000 | - | - | 59306.73 KB | | WithinLike | 238.815 ms | 2.5538 ms | 1.9939 ms | 239.245 ms | 29333.3333 | - | - | 60580.58 KB | | DefaultTargetNameBinding | 2.124 ms | 0.0214 ms | 0.0200 ms | 2.129 ms | 85.9375 | - | - | 179.69 KB | | CustomTargetNameBinding | 2.463 ms | 0.0483 ms | 0.0452 ms | 2.458 ms | 179.6875 | - | - | 375 KB | | NestedTargetNameBinding | 2.433 ms | 0.0370 ms | 0.0328 ms | 2.420 ms | 179.6875 | - | - | 375 KB |","title":"Results v0.17.0"},{"location":"scenarios/benchmark/results-v0.19.0/","text":"BenchmarkDotNet = v0.12.1, OS=Windows 10.0.19041.450 (2004/?/20H1) Intel Core i7-1065G7 CPU 1.30GHz, 1 CPU, 8 logical and 4 physical cores .NET Core SDK = 3.1.401 [Host] : .NET Core 3.1.7 (CoreCLR 4.700.20.36602, CoreFX 4.700.20.37001), X64 RyuJIT DefaultJob : .NET Core 3.1.7 (CoreCLR 4.700.20.36602, CoreFX 4.700.20.37001), X64 RyuJIT | Method | Mean | Error | StdDev | Gen 0 | Gen 1 | Gen 2 | Allocated | |------------------------- |-------------:|------------:|------------:|-----------:|---------:|------:|------------:| | Invoke | 40,943.5 \u03bcs | 581.23 \u03bcs | 515.25 \u03bcs | 4000.0000 | 500.0000 | - | 16452.28 KB | | InvokeIf | 42,806.0 \u03bcs | 477.29 \u03bcs | 423.11 \u03bcs | 4500.0000 | 500.0000 | - | 18703.12 KB | | InvokeType | 40,470.1 \u03bcs | 484.16 \u03bcs | 429.19 \u03bcs | 4000.0000 | 538.4615 | - | 16452.27 KB | | InvokeSummary | 39,768.8 \u03bcs | 462.14 \u03bcs | 385.91 \u03bcs | 4000.0000 | 153.8462 | - | 16397.82 KB | | Get | 11,145.4 \u03bcs | 402.59 \u03bcs | 1,187.03 \u03bcs | 46.8750 | - | - | 252.11 KB | | GetHelp | 10,169.1 \u03bcs | 625.02 \u03bcs | 1,842.88 \u03bcs | 46.8750 | - | - | 250.51 KB | | Within | 78,993.5 \u03bcs | 799.51 \u03bcs | 667.63 \u03bcs | 8000.0000 | 400.0000 | - | 32791.83 KB | | WithinBulk | 118,800.8 \u03bcs | 1,637.36 \u03bcs | 1,531.59 \u03bcs | 14333.3333 | 333.3333 | - | 59817.29 KB | | WithinLike | 106,796.3 \u03bcs | 2,067.20 \u03bcs | 2,538.71 \u03bcs | 11333.3333 | - | - | 47311.07 KB | | DefaultTargetNameBinding | 698.2 \u03bcs | 7.51 \u03bcs | 7.02 \u03bcs | 38.0859 | - | - | 156.25 KB | | CustomTargetNameBinding | 884.7 \u03bcs | 7.11 \u03bcs | 6.65 \u03bcs | 85.9375 | - | - | 351.56 KB | | NestedTargetNameBinding | 883.9 \u03bcs | 14.44 \u03bcs | 12.80 \u03bcs | 85.9375 | - | - | 351.56 KB |","title":"Results v0.19.0"},{"location":"scenarios/benchmark/results-v0.20.0/","text":"BenchmarkDotNet = v0.12.1, OS=Windows 10.0.19041.450 (2004/?/20H1) Intel Core i7-1065G7 CPU 1.30GHz, 1 CPU, 8 logical and 4 physical cores .NET Core SDK = 3.1.401 [Host] : .NET Core 3.1.7 (CoreCLR 4.700.20.36602, CoreFX 4.700.20.37001), X64 RyuJIT DefaultJob : .NET Core 3.1.7 (CoreCLR 4.700.20.36602, CoreFX 4.700.20.37001), X64 RyuJIT | Method | Mean | Error | StdDev | Gen 0 | Gen 1 | Gen 2 | Allocated | |------------------------- |-------------:|------------:|------------:|-----------:|----------:|------:|------------:| | Invoke | 42,162.8 \u03bcs | 827.36 \u03bcs | 1,263.47 \u03bcs | 3833.3333 | - | - | 15952 KB | | InvokeIf | 45,646.4 \u03bcs | 912.31 \u03bcs | 1,924.38 \u03bcs | 4416.6667 | 416.6667 | - | 18202.98 KB | | InvokeType | 41,825.5 \u03bcs | 810.73 \u03bcs | 901.12 \u03bcs | 3833.3333 | - | - | 15952 KB | | InvokeSummary | 41,133.3 \u03bcs | 777.97 \u03bcs | 895.91 \u03bcs | 3833.3333 | 500.0000 | - | 15897.56 KB | | Get | 10,054.3 \u03bcs | 396.83 \u03bcs | 1,170.07 \u03bcs | 46.8750 | - | - | 252.11 KB | | GetHelp | 10,581.4 \u03bcs | 448.15 \u03bcs | 1,321.38 \u03bcs | 46.8750 | - | - | 250.51 KB | | Within | 81,215.1 \u03bcs | 1,532.85 \u03bcs | 1,433.83 \u03bcs | 7750.0000 | 250.0000 | - | 32290.62 KB | | WithinBulk | 123,301.6 \u03bcs | 2,451.51 \u03bcs | 3,958.73 \u03bcs | 14000.0000 | 1000.0000 | - | 59317.29 KB | | WithinLike | 109,738.9 \u03bcs | 1,933.95 \u03bcs | 1,809.02 \u03bcs | 11333.3333 | 1000.0000 | - | 46811.07 KB | | DefaultTargetNameBinding | 696.0 \u03bcs | 12.06 \u03bcs | 10.69 \u03bcs | 38.0859 | - | - | 156.25 KB | | CustomTargetNameBinding | 845.6 \u03bcs | 11.75 \u03bcs | 10.42 \u03bcs | 85.9375 | - | - | 351.56 KB | | NestedTargetNameBinding | 856.0 \u03bcs | 12.29 \u03bcs | 10.90 \u03bcs | 85.9375 | - | - | 351.56 KB |","title":"Results v0.20.0"},{"location":"scenarios/benchmark/results-v0.21.0/","text":"BenchmarkDotNet = v0.12.1, OS=Windows 10.0.19042 Intel Core i7-1065G7 CPU 1.30GHz, 1 CPU, 8 logical and 4 physical cores .NET Core SDK = 3.1.403 [Host] : .NET Core 3.1.9 (CoreCLR 4.700.20.47201, CoreFX 4.700.20.47203), X64 RyuJIT DefaultJob : .NET Core 3.1.9 (CoreCLR 4.700.20.47201, CoreFX 4.700.20.47203), X64 RyuJIT | Method | Mean | Error | StdDev | Gen 0 | Gen 1 | Gen 2 | Allocated | |------------------------- |-------------:|------------:|------------:|-----------:|---------:|------:|------------:| | Invoke | 41,409.3 \u03bcs | 743.11 \u03bcs | 1,089.24 \u03bcs | 3916.6667 | 500.0000 | - | 16124.02 KB | | InvokeIf | 43,138.3 \u03bcs | 510.44 \u03bcs | 426.24 \u03bcs | 4416.6667 | 83.3333 | - | 18374.86 KB | | InvokeType | 41,511.3 \u03bcs | 703.93 \u03bcs | 963.55 \u03bcs | 3923.0769 | 230.7692 | - | 16144.62 KB | | InvokeSummary | 40,319.9 \u03bcs | 795.95 \u03bcs | 705.59 \u03bcs | 3900.0000 | 500.0000 | - | 16124.26 KB | | Get | 9,873.7 \u03bcs | 392.08 \u03bcs | 1,149.89 \u03bcs | 46.8750 | - | - | 253.44 KB | | GetHelp | 9,943.1 \u03bcs | 406.36 \u03bcs | 1,198.17 \u03bcs | 46.8750 | - | - | 251.84 KB | | Within | 76,627.6 \u03bcs | 1,527.91 \u03bcs | 1,759.54 \u03bcs | 7800.0000 | - | - | 32460.47 KB | | WithinBulk | 115,374.0 \u03bcs | 2,279.41 \u03bcs | 3,269.07 \u03bcs | 14333.3333 | - | - | 59488.54 KB | | WithinLike | 102,684.3 \u03bcs | 1,482.11 \u03bcs | 1,313.85 \u03bcs | 11500.0000 | 750.0000 | - | 46983.1 KB | | DefaultTargetNameBinding | 673.8 \u03bcs | 4.27 \u03bcs | 3.79 \u03bcs | 38.0859 | - | - | 156.25 KB | | CustomTargetNameBinding | 888.9 \u03bcs | 15.31 \u03bcs | 12.78 \u03bcs | 85.9375 | - | - | 351.56 KB | | NestedTargetNameBinding | 901.3 \u03bcs | 9.04 \u03bcs | 8.01 \u03bcs | 85.9375 | - | - | 351.56 KB |","title":"Results v0.21.0"},{"location":"scenarios/benchmark/results-v0.22.0/","text":"BenchmarkDotNet = v0.12.1, OS=Windows 10.0.19042 Intel Core i7-1065G7 CPU 1.30GHz, 1 CPU, 8 logical and 4 physical cores .NET Core SDK = 3.1.403 [Host] : .NET Core 3.1.9 (CoreCLR 4.700.20.47201, CoreFX 4.700.20.47203), X64 RyuJIT DefaultJob : .NET Core 3.1.9 (CoreCLR 4.700.20.47201, CoreFX 4.700.20.47203), X64 RyuJIT | Method | Mean | Error | StdDev | Gen 0 | Gen 1 | Gen 2 | Allocated | |------------------------- |-------------:|------------:|------------:|-----------:|---------:|------:|------------:| | Invoke | 40,804.1 \u03bcs | 656.89 \u03bcs | 614.45 \u03bcs | 3916.6667 | 500.0000 | - | 16124.02 KB | | InvokeIf | 42,768.8 \u03bcs | 843.79 \u03bcs | 704.61 \u03bcs | 4461.5385 | 76.9231 | - | 18374.92 KB | | InvokeType | 40,487.0 \u03bcs | 609.33 \u03bcs | 1,034.69 \u03bcs | 3923.0769 | 538.4615 | - | 16124.02 KB | | InvokeSummary | 40,403.1 \u03bcs | 806.53 \u03bcs | 714.97 \u03bcs | 3923.0769 | 538.4615 | - | 16124.26 KB | | Assert | 41,551.0 \u03bcs | 684.23 \u03bcs | 640.03 \u03bcs | 4000.0000 | 153.8462 | - | 16538.36 KB | | Get | 10,180.9 \u03bcs | 402.29 \u03bcs | 1,186.17 \u03bcs | 46.8750 | - | - | 231.12 KB | | GetHelp | 9,941.1 \u03bcs | 409.65 \u03bcs | 1,207.87 \u03bcs | 46.8750 | - | - | 229.52 KB | | Within | 75,818.3 \u03bcs | 1,504.74 \u03bcs | 2,297.90 \u03bcs | 7800.0000 | 600.0000 | - | 32468.28 KB | | WithinBulk | 112,731.0 \u03bcs | 1,239.66 \u03bcs | 1,035.17 \u03bcs | 14333.3333 | 666.6667 | - | 59496.35 KB | | WithinLike | 101,227.7 \u03bcs | 1,990.03 \u03bcs | 2,854.05 \u03bcs | 11333.3333 | - | - | 46623.62 KB | | DefaultTargetNameBinding | 654.3 \u03bcs | 10.46 \u03bcs | 9.78 \u03bcs | 38.0859 | - | - | 156.25 KB | | CustomTargetNameBinding | 854.3 \u03bcs | 16.30 \u03bcs | 15.25 \u03bcs | 85.9375 | - | - | 351.56 KB | | NestedTargetNameBinding | 945.7 \u03bcs | 18.78 \u03bcs | 19.29 \u03bcs | 85.9375 | - | - | 351.57 KB | | AssertHasFieldValue | 1,036.2 \u03bcs | 13.63 \u03bcs | 12.08 \u03bcs | 121.0938 | - | - | 500 KB |","title":"Results v0.22.0"},{"location":"scenarios/benchmark/results-v0.3.0/","text":"BenchmarkDotNet = v0.11.3, OS=Windows 10.0.17763.195 (1809/October2018Update/Redstone5) Intel Core i7-6600U CPU 2.60GHz (Skylake), 1 CPU, 4 logical and 2 physical cores .NET Core SDK = 2.2.100 [Host] : .NET Core 2.1.6 (CoreCLR 4.6.27019.06, CoreFX 4.6.27019.05), 64bit RyuJIT DefaultJob : .NET Core 2.1.6 (CoreCLR 4.6.27019.06, CoreFX 4.6.27019.05), 64bit RyuJIT | Method | Mean | Error | StdDev | Gen 0/1k Op | Gen 1/1k Op | Gen 2/1k Op | Allocated Memory/Op | |-------------- |-----------:|----------:|----------:|------------:|------------:|------------:|--------------------:| | Invoke | 117.257 ms | 2.1959 ms | 2.1567 ms | 8400.0000 | 400.0000 | - | 17355.83 KB | | InvokeIf | 128.418 ms | 3.0122 ms | 3.8095 ms | 9750.0000 | 500.0000 | - | 20301.73 KB | | InvokeSummary | 116.479 ms | 1.9241 ms | 1.7998 ms | 8400.0000 | - | - | 17301.03 KB | | Get | 8.921 ms | 0.0864 ms | 0.0766 ms | 93.7500 | - | - | 203.82 KB |","title":"Results v0.3.0"},{"location":"scenarios/benchmark/results-v1.0.1/","text":"BenchmarkDotNet = v0.12.1, OS=Windows 10.0.19042 Intel Core i7-1065G7 CPU 1.30GHz, 1 CPU, 8 logical and 4 physical cores .NET Core SDK = 5.0.102 [Host] : .NET Core 3.1.11 (CoreCLR 4.700.20.56602, CoreFX 4.700.20.56604), X64 RyuJIT DefaultJob : .NET Core 3.1.11 (CoreCLR 4.700.20.56602, CoreFX 4.700.20.56604), X64 RyuJIT | Method | Mean | Error | StdDev | Median | Gen 0 | Gen 1 | Gen 2 | Allocated | |------------------------- |-------------:|------------:|------------:|-------------:|-----------:|---------:|------:|------------:| | Invoke | 39,343.5 \u03bcs | 781.08 \u03bcs | 835.75 \u03bcs | 39,287.2 \u03bcs | 3923.0769 | 538.4615 | - | 16124.02 KB | | InvokeIf | 41,264.0 \u03bcs | 545.97 \u03bcs | 483.99 \u03bcs | 41,148.4 \u03bcs | 4461.5385 | 76.9231 | - | 18374.92 KB | | InvokeType | 39,514.4 \u03bcs | 755.90 \u03bcs | 670.09 \u03bcs | 39,343.8 \u03bcs | 3923.0769 | 538.4615 | - | 16124.02 KB | | InvokeSummary | 39,251.4 \u03bcs | 605.30 \u03bcs | 566.20 \u03bcs | 39,143.5 \u03bcs | 3916.6667 | 500.0000 | - | 16124.26 KB | | Assert | 40,662.2 \u03bcs | 776.24 \u03bcs | 688.12 \u03bcs | 40,589.9 \u03bcs | 4000.0000 | 333.3333 | - | 16538.53 KB | | Get | 8,570.8 \u03bcs | 429.97 \u03bcs | 1,267.78 \u03bcs | 8,872.7 \u03bcs | 46.8750 | - | - | 231.12 KB | | GetHelp | 9,235.4 \u03bcs | 295.56 \u03bcs | 871.45 \u03bcs | 9,238.7 \u03bcs | 46.8750 | - | - | 229.52 KB | | Within | 75,171.4 \u03bcs | 744.98 \u03bcs | 660.41 \u03bcs | 75,223.5 \u03bcs | 7750.0000 | 750.0000 | - | 32468.28 KB | | WithinBulk | 110,726.9 \u03bcs | 2,142.74 \u03bcs | 2,200.44 \u03bcs | 109,801.1 \u03bcs | 14500.0000 | 500.0000 | - | 59496.51 KB | | WithinLike | 101,989.2 \u03bcs | 2,007.91 \u03bcs | 4,056.09 \u03bcs | 100,288.9 \u03bcs | 11250.0000 | - | - | 46623.25 KB | | DefaultTargetNameBinding | 626.0 \u03bcs | 11.49 \u03bcs | 10.75 \u03bcs | 622.9 \u03bcs | 38.0859 | - | - | 156.25 KB | | CustomTargetNameBinding | 796.3 \u03bcs | 7.48 \u03bcs | 7.00 \u03bcs | 797.0 \u03bcs | 85.9375 | - | - | 351.56 KB | | NestedTargetNameBinding | 806.1 \u03bcs | 12.12 \u03bcs | 10.12 \u03bcs | 805.3 \u03bcs | 85.9375 | - | - | 351.56 KB | | AssertHasFieldValue | 900.6 \u03bcs | 14.51 \u03bcs | 12.87 \u03bcs | 901.2 \u03bcs | 122.0703 | - | - | 500 KB |","title":"Results v1.0.1"},{"location":"scenarios/benchmark/results-v1.1.0/","text":"BenchmarkDotNet = v0.12.1, OS=Windows 10.0.19042 Intel Core i7-1065G7 CPU 1.30GHz, 1 CPU, 8 logical and 4 physical cores .NET Core SDK = 5.0.103 [Host] : .NET Core 3.1.12 (CoreCLR 4.700.21.6504, CoreFX 4.700.21.6905), X64 RyuJIT DefaultJob : .NET Core 3.1.12 (CoreCLR 4.700.21.6504, CoreFX 4.700.21.6905), X64 RyuJIT | Method | Mean | Error | StdDev | Gen 0 | Gen 1 | Gen 2 | Allocated | |------------------------- |-------------:|------------:|------------:|-----------:|---------:|------:|------------:| | Invoke | 40,327.3 \u03bcs | 801.24 \u03bcs | 1,013.31 \u03bcs | 3923.0769 | 538.4615 | - | 16124.02 KB | | InvokeIf | 42,943.9 \u03bcs | 849.72 \u03bcs | 1,396.11 \u03bcs | 4461.5385 | 76.9231 | - | 18374.92 KB | | InvokeType | 40,880.7 \u03bcs | 783.51 \u03bcs | 1,452.28 \u03bcs | 3900.0000 | - | - | 16149.45 KB | | InvokeSummary | 39,101.4 \u03bcs | 431.56 \u03bcs | 336.93 \u03bcs | 3916.6667 | 500.0000 | - | 16124.26 KB | | Assert | 41,917.1 \u03bcs | 831.37 \u03bcs | 1,192.33 \u03bcs | 4076.9231 | 461.5385 | - | 16780.81 KB | | Get | 9,643.0 \u03bcs | 428.32 \u03bcs | 1,262.91 \u03bcs | 54.6875 | 7.8125 | - | 231.12 KB | | GetHelp | 9,271.5 \u03bcs | 372.94 \u03bcs | 1,099.63 \u03bcs | 46.8750 | - | - | 229.52 KB | | Within | 76,020.5 \u03bcs | 954.22 \u03bcs | 744.99 \u03bcs | 7800.0000 | 600.0000 | - | 32468.65 KB | | WithinBulk | 112,135.7 \u03bcs | 2,189.72 \u03bcs | 2,342.97 \u03bcs | 14500.0000 | 500.0000 | - | 59499.77 KB | | WithinLike | 101,928.4 \u03bcs | 1,952.97 \u03bcs | 2,398.43 \u03bcs | 11333.3333 | - | - | 46623.57 KB | | DefaultTargetNameBinding | 655.6 \u03bcs | 13.11 \u03bcs | 25.87 \u03bcs | 38.0859 | - | - | 156.25 KB | | CustomTargetNameBinding | 822.1 \u03bcs | 16.06 \u03bcs | 19.11 \u03bcs | 85.9375 | - | - | 351.56 KB | | NestedTargetNameBinding | 878.9 \u03bcs | 16.63 \u03bcs | 17.08 \u03bcs | 85.9375 | - | - | 351.56 KB | | AssertHasFieldValue | 923.2 \u03bcs | 17.81 \u03bcs | 19.05 \u03bcs | 122.0703 | 0.9766 | - | 500.26 KB |","title":"Results v1.1.0"},{"location":"scenarios/benchmark/results-v1.10.0/","text":"BenchmarkDotNet = v0.13.1, OS=Windows 10.0.22000 Intel Core i7-1065G7 CPU 1.30GHz, 1 CPU, 8 logical and 4 physical cores .NET SDK = 5.0.404 [Host] : .NET Core 3.1.22 (CoreCLR 4.700.21.56803, CoreFX 4.700.21.57101), X64 RyuJIT DefaultJob : .NET Core 3.1.22 (CoreCLR 4.700.21.56803, CoreFX 4.700.21.57101), X64 RyuJIT | Method | Mean | Error | StdDev | Gen 0 | Gen 1 | Allocated | |------------------------- |-------------:|------------:|------------:|-----------:|----------:|----------:| | Invoke | 50,742.5 \u03bcs | 908.47 \u03bcs | 709.27 \u03bcs | 4100.0000 | 400.0000 | 17,758 KB | | InvokeIf | 53,048.6 \u03bcs | 698.34 \u03bcs | 619.06 \u03bcs | 4500.0000 | 200.0000 | 20,008 KB | | InvokeType | 50,575.6 \u03bcs | 794.27 \u03bcs | 663.25 \u03bcs | 4000.0000 | 200.0000 | 17,760 KB | | InvokeSummary | 50,449.0 \u03bcs | 698.80 \u03bcs | 619.47 \u03bcs | 4100.0000 | 400.0000 | 17,758 KB | | Assert | 52,152.6 \u03bcs | 765.95 \u03bcs | 678.99 \u03bcs | 4200.0000 | 300.0000 | 18,462 KB | | Get | 5,793.8 \u03bcs | 86.70 \u03bcs | 81.10 \u03bcs | 78.1250 | - | 364 KB | | GetHelp | 5,799.6 \u03bcs | 76.72 \u03bcs | 71.77 \u03bcs | 85.9375 | 7.8125 | 364 KB | | Within | 89,538.2 \u03bcs | 1,754.26 \u03bcs | 1,555.11 \u03bcs | 8000.0000 | 1000.0000 | 34,102 KB | | WithinBulk | 128,126.9 \u03bcs | 1,928.80 \u03bcs | 1,709.83 \u03bcs | 14666.6667 | 1333.3333 | 61,131 KB | | WithinLike | 112,174.1 \u03bcs | 1,132.30 \u03bcs | 1,003.76 \u03bcs | 11666.6667 | 1666.6667 | 48,258 KB | | DefaultTargetNameBinding | 695.6 \u03bcs | 13.57 \u03bcs | 14.52 \u03bcs | 38.0859 | - | 156 KB | | CustomTargetNameBinding | 851.0 \u03bcs | 10.35 \u03bcs | 8.64 \u03bcs | 85.9375 | - | 352 KB | | NestedTargetNameBinding | 961.5 \u03bcs | 17.83 \u03bcs | 15.80 \u03bcs | 85.9375 | - | 352 KB | | AssertHasFieldValue | 3,033.5 \u03bcs | 60.15 \u03bcs | 66.85 \u03bcs | 253.9063 | 7.8125 | 1,040 KB |","title":"Results v1.10.0"},{"location":"scenarios/benchmark/results-v1.11.0/","text":"BenchmarkDotNet = v0.13.1, OS=Windows 10.0.22000 Intel Core i7-1065G7 CPU 1.30GHz, 1 CPU, 8 logical and 4 physical cores .NET SDK = 5.0.404 [Host] : .NET Core 3.1.22 (CoreCLR 4.700.21.56803, CoreFX 4.700.21.57101), X64 RyuJIT DefaultJob : .NET Core 3.1.22 (CoreCLR 4.700.21.56803, CoreFX 4.700.21.57101), X64 RyuJIT | Method | Mean | Error | StdDev | Gen 0 | Gen 1 | Allocated | |------------------------- |-------------:|------------:|------------:|-----------:|----------:|----------:| | Invoke | 50,529.4 \u03bcs | 1,006.40 \u03bcs | 941.38 \u03bcs | 4000.0000 | 444.4444 | 17,758 KB | | InvokeIf | 51,974.4 \u03bcs | 667.26 \u03bcs | 591.51 \u03bcs | 4500.0000 | 200.0000 | 20,008 KB | | InvokeType | 49,901.2 \u03bcs | 679.83 \u03bcs | 567.69 \u03bcs | 4000.0000 | 363.6364 | 17,758 KB | | InvokeSummary | 51,198.9 \u03bcs | 862.22 \u03bcs | 922.57 \u03bcs | 4000.0000 | 363.6364 | 17,758 KB | | Assert | 52,136.6 \u03bcs | 588.93 \u03bcs | 550.88 \u03bcs | 4100.0000 | 300.0000 | 18,461 KB | | Get | 5,710.0 \u03bcs | 111.69 \u03bcs | 104.47 \u03bcs | 85.9375 | 7.8125 | 364 KB | | GetHelp | 5,777.4 \u03bcs | 97.83 \u03bcs | 91.51 \u03bcs | 85.9375 | 7.8125 | 364 KB | | Within | 88,106.3 \u03bcs | 1,752.66 \u03bcs | 1,799.86 \u03bcs | 8000.0000 | 1000.0000 | 34,102 KB | | WithinBulk | 125,319.9 \u03bcs | 2,303.80 \u03bcs | 2,154.98 \u03bcs | 14666.6667 | 1000.0000 | 61,133 KB | | WithinLike | 115,376.3 \u03bcs | 1,866.04 \u03bcs | 1,654.20 \u03bcs | 11666.6667 | 1666.6667 | 48,258 KB | | DefaultTargetNameBinding | 669.5 \u03bcs | 6.52 \u03bcs | 6.10 \u03bcs | 38.0859 | - | 156 KB | | CustomTargetNameBinding | 837.6 \u03bcs | 6.70 \u03bcs | 6.27 \u03bcs | 85.9375 | - | 352 KB | | NestedTargetNameBinding | 854.1 \u03bcs | 9.50 \u03bcs | 7.42 \u03bcs | 85.9375 | - | 352 KB | | AssertHasFieldValue | 2,967.0 \u03bcs | 38.88 \u03bcs | 34.47 \u03bcs | 253.9063 | 7.8125 | 1,040 KB |","title":"Results v1.11.0"},{"location":"scenarios/benchmark/results-v2.0.0-pre.2/","text":"BenchmarkDotNet = v0.13.1, OS=Windows 10.0.22000 Intel Core i7-1065G7 CPU 1.30GHz, 1 CPU, 8 logical and 4 physical cores .NET SDK = 5.0.404 [Host] : .NET Core 3.1.22 (CoreCLR 4.700.21.56803, CoreFX 4.700.21.57101), X64 RyuJIT DefaultJob : .NET Core 3.1.22 (CoreCLR 4.700.21.56803, CoreFX 4.700.21.57101), X64 RyuJIT | Method | Mean | Error | StdDev | Median | Gen 0 | Gen 1 | Allocated | |------------------------- |-----------------:|----------------:|----------------:|-----------------:|-----------:|----------:|----------:| | Invoke | 50,690,403.5 ns | 1,008,643.42 ns | 842,262.94 ns | 50,510,218.2 ns | 4000.0000 | 272.7273 | 17,758 KB | | InvokeIf | 51,910,565.7 ns | 684,957.47 ns | 607,196.95 ns | 52,036,680.0 ns | 4500.0000 | 200.0000 | 20,008 KB | | InvokeType | 50,323,385.8 ns | 419,714.32 ns | 327,685.33 ns | 50,448,415.0 ns | 4100.0000 | 400.0000 | 17,758 KB | | InvokeSummary | 49,852,085.7 ns | 932,333.23 ns | 826,489.12 ns | 49,792,581.8 ns | 4000.0000 | 363.6364 | 17,758 KB | | Assert | 51,774,439.2 ns | 534,962.40 ns | 446,717.83 ns | 51,741,530.0 ns | 4100.0000 | 300.0000 | 18,461 KB | | Get | 6,153,688.9 ns | 110,055.91 ns | 102,946.36 ns | 6,122,121.1 ns | 85.9375 | - | 367 KB | | GetHelp | 6,191,583.5 ns | 95,299.61 ns | 84,480.62 ns | 6,188,469.5 ns | 85.9375 | - | 367 KB | | Within | 92,791,338.3 ns | 1,666,664.31 ns | 1,558,998.83 ns | 92,849,275.0 ns | 8250.0000 | 1000.0000 | 34,197 KB | | WithinBulk | 136,104,105.9 ns | 2,647,952.81 ns | 4,275,950.21 ns | 135,769,100.0 ns | 14000.0000 | 2000.0000 | 61,224 KB | | WithinLike | 117,091,166.7 ns | 1,955,451.58 ns | 1,733,456.89 ns | 116,485,916.7 ns | 11666.6667 | 1666.6667 | 48,352 KB | | DefaultTargetNameBinding | 713,149.3 ns | 8,563.98 ns | 8,010.75 ns | 712,249.0 ns | 38.0859 | - | 156 KB | | CustomTargetNameBinding | 948,598.4 ns | 17,400.93 ns | 21,369.90 ns | 938,536.5 ns | 85.9375 | - | 352 KB | | NestedTargetNameBinding | 867,820.4 ns | 6,230.42 ns | 5,523.11 ns | 868,881.9 ns | 85.9375 | - | 352 KB | | AssertHasFieldValue | 3,522,024.3 ns | 70,142.49 ns | 133,453.38 ns | 3,464,502.7 ns | 253.9063 | 7.8125 | 1,040 KB | | PathTokenize | 863.4 ns | 17.13 ns | 27.66 ns | 852.0 ns | 0.2632 | - | 1 KB | | PathExpressionBuild | 546.2 ns | 4.86 ns | 4.55 ns | 546.4 ns | 0.3500 | - | 1 KB | | PathExpressionGet | 375,272.2 ns | 4,983.35 ns | 3,890.67 ns | 375,397.7 ns | 17.0898 | - | 70 KB |","title":"Results v2.0.0 pre.2"},{"location":"scenarios/benchmark/results-v2.0.0-pre.3/","text":"BenchmarkDotNet = v0.13.1, OS=Windows 10.0.22000 Intel Core i7-1065G7 CPU 1.30GHz, 1 CPU, 8 logical and 4 physical cores .NET SDK = 5.0.404 [Host] : .NET Core 3.1.22 (CoreCLR 4.700.21.56803, CoreFX 4.700.21.57101), X64 RyuJIT DefaultJob : .NET Core 3.1.22 (CoreCLR 4.700.21.56803, CoreFX 4.700.21.57101), X64 RyuJIT | Method | Mean | Error | StdDev | Gen 0 | Gen 1 | Allocated | |------------------------- |-----------------:|----------------:|----------------:|-----------:|----------:|----------:| | Invoke | 53,201,973.3 ns | 965,400.91 ns | 903,036.61 ns | 4100.0000 | 400.0000 | 17,758 KB | | InvokeIf | 54,266,264.0 ns | 516,824.36 ns | 483,437.83 ns | 4500.0000 | 200.0000 | 20,008 KB | | InvokeType | 53,299,662.9 ns | 1,041,990.81 ns | 1,240,415.94 ns | 4000.0000 | 400.0000 | 17,758 KB | | InvokeSummary | 52,364,196.7 ns | 741,213.07 ns | 693,331.17 ns | 4100.0000 | 400.0000 | 17,758 KB | | Assert | 53,926,665.9 ns | 1,048,995.55 ns | 929,907.24 ns | 4111.1111 | 222.2222 | 18,461 KB | | Get | 6,213,169.1 ns | 119,598.34 ns | 117,461.56 ns | 85.9375 | 7.8125 | 366 KB | | GetHelp | 6,185,384.7 ns | 121,492.72 ns | 144,628.44 ns | 85.9375 | 7.8125 | 366 KB | | Within | 91,044,076.7 ns | 1,250,486.23 ns | 1,169,705.59 ns | 8250.0000 | 1000.0000 | 34,198 KB | | WithinBulk | 131,636,590.3 ns | 2,585,126.29 ns | 3,361,394.39 ns | 14666.6667 | 1666.6667 | 61,224 KB | | WithinLike | 117,834,564.4 ns | 2,208,102.68 ns | 2,065,460.62 ns | 11666.6667 | 1666.6667 | 48,352 KB | | DefaultTargetNameBinding | 696,752.1 ns | 9,049.16 ns | 8,021.84 ns | 38.0859 | - | 156 KB | | CustomTargetNameBinding | 881,022.4 ns | 12,940.79 ns | 11,471.67 ns | 85.9375 | - | 352 KB | | NestedTargetNameBinding | 876,321.2 ns | 7,650.01 ns | 6,781.54 ns | 85.9375 | - | 352 KB | | AssertHasFieldValue | 3,076,694.5 ns | 30,768.35 ns | 25,692.97 ns | 253.9063 | 7.8125 | 1,040 KB | | PathTokenize | 869.1 ns | 16.88 ns | 25.27 ns | 0.2632 | - | 1 KB | | PathExpressionBuild | 529.8 ns | 8.39 ns | 7.44 ns | 0.3500 | - | 1 KB | | PathExpressionGet | 358,678.4 ns | 4,814.17 ns | 4,020.05 ns | 17.0898 | - | 70 KB |","title":"Results v2.0.0 pre.3"},{"location":"scenarios/benchmark/results-v2.0.0-pre/","text":"BenchmarkDotNet = v0.13.1, OS=Windows 10.0.22000 Intel Core i7-1065G7 CPU 1.30GHz, 1 CPU, 8 logical and 4 physical cores .NET SDK = 5.0.404 [Host] : .NET Core 3.1.22 (CoreCLR 4.700.21.56803, CoreFX 4.700.21.57101), X64 RyuJIT DefaultJob : .NET Core 3.1.22 (CoreCLR 4.700.21.56803, CoreFX 4.700.21.57101), X64 RyuJIT | Method | Mean | Error | StdDev | Median | Gen 0 | Gen 1 | Allocated | |------------------------- |-----------------:|----------------:|----------------:|-----------------:|-----------:|----------:|----------:| | Invoke | 57,242,675.2 ns | 1,046,305.99 ns | 1,659,552.18 ns | 56,566,420.0 ns | 4000.0000 | 400.0000 | 17,758 KB | | InvokeIf | 55,980,115.4 ns | 1,025,771.27 ns | 856,565.47 ns | 55,884,877.8 ns | 4555.5556 | 222.2222 | 20,009 KB | | InvokeType | 54,975,254.3 ns | 1,092,979.70 ns | 2,105,800.83 ns | 54,328,650.0 ns | 4000.0000 | 400.0000 | 17,758 KB | | InvokeSummary | 54,241,116.2 ns | 1,084,485.01 ns | 1,065,109.29 ns | 54,387,930.0 ns | 4100.0000 | 400.0000 | 17,758 KB | | Assert | 56,276,886.0 ns | 1,125,031.59 ns | 1,295,588.05 ns | 56,145,355.0 ns | 4100.0000 | 300.0000 | 18,461 KB | | Get | 6,151,314.0 ns | 119,861.25 ns | 179,402.68 ns | 6,120,217.2 ns | 85.9375 | 7.8125 | 364 KB | | GetHelp | 6,099,816.5 ns | 71,918.32 ns | 63,753.72 ns | 6,103,212.5 ns | 85.9375 | 7.8125 | 364 KB | | Within | 96,332,873.3 ns | 1,229,258.29 ns | 1,149,848.97 ns | 96,156,225.0 ns | 8250.0000 | 1000.0000 | 34,196 KB | | WithinBulk | 150,572,688.2 ns | 2,948,247.26 ns | 4,760,869.78 ns | 149,014,300.0 ns | 14000.0000 | 2000.0000 | 61,224 KB | | WithinLike | 131,081,361.1 ns | 2,560,132.70 ns | 4,277,406.62 ns | 130,734,100.0 ns | 11000.0000 | 2000.0000 | 48,351 KB | | DefaultTargetNameBinding | 782,038.6 ns | 15,156.92 ns | 23,146.22 ns | 777,590.8 ns | 37.1094 | - | 156 KB | | CustomTargetNameBinding | 938,919.9 ns | 12,345.26 ns | 10,943.75 ns | 939,380.4 ns | 85.9375 | - | 352 KB | | NestedTargetNameBinding | 915,123.7 ns | 8,567.18 ns | 7,153.98 ns | 917,281.0 ns | 85.9375 | - | 352 KB | | AssertHasFieldValue | 3,080,458.7 ns | 57,566.72 ns | 112,279.46 ns | 3,037,285.5 ns | 253.9063 | 7.8125 | 1,040 KB | | PathTokenize | 822.9 ns | 8.02 ns | 7.50 ns | 821.9 ns | 0.2632 | - | 1 KB | | PathExpressionBuild | 557.2 ns | 11.17 ns | 26.34 ns | 546.3 ns | 0.3500 | - | 1 KB | | PathExpressionGet | 364,673.4 ns | 4,007.73 ns | 3,748.84 ns | 364,478.3 ns | 17.0898 | - | 70 KB |","title":"Results v2.0.0 pre"},{"location":"scenarios/kubernetes-resources/kubernetes-resources/","text":"Kubernetes resource validation example # This is an example of how PSRule can be used to validate Kubernetes resources to match an internal metadata and configuration standard. Note A pre-built module to validate Kubernetes resources already exists. This scenario demonstrates the process and features of PSRule for illustration purposes. Consider using or contributing these pre-built rule modules instead: PSRule.Rules.Kubernetes This scenario covers the following: Defining a basic rule. Configuring custom binding. Using a type precondition. Running rules using YAML input. In this scenario we will use a YAML file: resources.yaml - A Kubernetes manifest containing deployments and services. Define rules # To validate our Kubernetes resources, we need to define some rules. Rules are defined by using the Rule keyword in a file ending with the .Rule.ps1 extension. Our business rules for configuration Kubernetes resources can be defined with the following dot points: The following recommended labels will be used on all services and deployments: app.kubernetes.io/name - the name of the application/ service. app.kubernetes.io/version - the version of the service. app.kubernetes.io/component - identifies the type of component, valid options are web , api , database and gateway For web or api deployments, a minimum of two (2) replicas must be used. Deployments must use container images with a specific version tag, and not latest . Deployments must declare minimum and maximum memory/ CPU resources. In the example below: We use metadata.Name directly after the Rule keyword to name the rule definition. Each rule must be named uniquely. The # Synopsis: comment is used to add additional metadata interpreted by PSRule. One or more conditions are defined within the curly braces { } . The rule definition is saved within a file named kubernetes.Rule.ps1 . # Synopsis: Must have the app.kubernetes.io/name label Rule 'metadata.Name' { # Rule conditions go here } Check that the label exists # In the next step, we define one or more conditions. Conditions can be: Any valid PowerShell that returns a true (pass) when the condition is met or false (fail) when the condition is not met. More than one condition can be defined, if any condition returns false then the whole rule fails. PSRule includes several convenience keywords such as AllOf , AnyOf , Exists , Match , TypeOf and Within that make conditions faster to define, easier to understand and troubleshoot. However, use of these keywords is optional. In the example below: We use the Exists keyword to check that the resource has the app.kubernetes.io/name label set. By default, PSRule will step through nested properties separated by a . . i.e. labels is a property of metadata . Kubernetes supports and recommends label namespaces, which often use . in their name. PSRule supports this by enclosing the field name ( app.kubernetes.io/name ) in apostrophes ( ' ) so that app.kubernetes.io/name is checked instead of app . # Synopsis: Must have the app.kubernetes.io/name label Rule 'metadata.Name' { Exists \"metadata.labels.'app.kubernetes.io/name'\" } We have also defined something similar for the version and component labels. In the example below: Double apostrophes ( '' ) are used to enclose app.kubernetes.io/name because the field name uses ' at the start and end of the string instead of \" in the previous example. The Within keyword is used to validate that the app.kubernetes.io/component only uses one of four (4) allowed values. # Synopsis: Must have the app.kubernetes.io/version label Rule 'metadata.Version' { Exists 'metadata.labels.''app.kubernetes.io/version''' } # Synopsis: Must have the app.kubernetes.io/component label Rule 'metadata.Component' { Exists 'metadata.labels.''app.kubernetes.io/component''' Within 'metadata.labels.''app.kubernetes.io/component''' 'web' , 'api' , 'database' , 'gateway' -CaseSensitive } Use custom binding # Before processing rules, PSRule binds TargetName and TargetType properties to the pipeline object. These properties are used for filtering and displaying results. The default properties that PSRule binds are different from how Kubernetes resources are structured. Kubernetes uses: metadata.name to store the name of a resource. kind to store the type of resource. The default bindings can be updated by providing custom property names or a custom script. To change binding property names set the Binding.TargetName and Binding.TargetType configuration options. The following example shows how to set the options using a YAML configuration file: TargetName is bound to metadata.name TargetType is bound to kind binding : targetName : - metadata.name targetType : - kind These options can be set in the file .\\ps-rule.yaml to be automatically loaded at when PSRule cmdlets are called. To set these configuration options either edit the file manually or use the following command. # Set options in ps-rule.yaml Set-PSRuleOption -TargetName 'metadata.Name' -TargetType 'kind' ; Alternatively, these options can be set at runtime using the hashtable syntax. # Save options to a variable $option = New-PSRuleOption -TargetName 'metadata.Name' -TargetType 'kind' ; These options will be passed to Invoke-PSRule using the -Option parameter in a later step. Define preconditions # Currently the metadata.Name rule defined in a previous step will be executed for any type of object. Kubernetes has many types of built-in resource such as Services , Deployments , Namespaces , Pods and ClusterRoles . By defining a precondition, we can ensure that the rule is only processed for Services or Deployments to match our business rules. PSRule supports two types of preconditions, either type ( -Type ) or script block ( -If ). Type preconditions are one or more type names that PSRule compares to the TargetType binding, where: One of the type names names equal TargetType the rule will be processed. None of the type names equal TargetType the rule be skipped. Script block preconditions is a PowerShell script block that returns true or false , where: True - Continue processing the rule. False - Skip processing the rule. Preconditions are evaluated once per rule for each object. In the example below: We update our metadata.Name rule to use the -Type parameter to specify a type precondition of either Deployment or Service . In a previous step, TypeName was bound to the kind property which will be Deployment or Service for these resource types. # Synopsis: Must have the app.kubernetes.io/name label Rule 'metadata.Name' -Type 'Deployment' , 'Service' { Exists \"metadata.labels.'app.kubernetes.io/name'\" } Using a type precondition satisfies our business rules and will deliver faster performance then using a script block. An example using a script block precondition is also shown below. # Synopsis: Must have the app.kubernetes.io/name label Rule 'metadata.Name' -If { $TargetObject . kind -eq 'Deployment' -or $TargetObject . kind -eq 'Service' } { Exists \"metadata.labels.'app.kubernetes.io/name'\" } Complete remaining rules # The remaining rule definitions from our defined business rules are included below. Each follows a similar pattern and builds on the previous sections. In the example below: The built-in variable $TargetObject is used to get the current pipeline object. Built-in keywords like Exists automatically default to $TargetObject , but can be piped alternative input as shown in the rule definition named deployment.ResourcesSet . # Synopsis: Deployments use a minimum of 2 replicas Rule 'deployment.HasMinimumReplicas' -Type 'Deployment' { Exists 'spec.replicas' $TargetObject . spec . replicas -ge 2 } # Synopsis: Deployments use specific tags Rule 'deployment.NotLatestImage' -Type 'Deployment' { foreach ( $container in $TargetObject . spec . template . spec . containers ) { $container . image -like '*:*' -and $container . image -notlike '*:latest' } } # Synopsis: Resource requirements are set for each container Rule 'deployment.ResourcesSet' -Type 'Deployment' { foreach ( $container in $TargetObject . spec . template . spec . containers ) { $container | Exists 'resources.requests.cpu' $container | Exists 'resources.requests.memory' $container | Exists 'resources.limits.cpu' $container | Exists 'resources.limits.memory' } } Execute rules # With some rules defined, the next step is to execute them. For this example, we'll use Invoke-PSRule to get the result for each rule. The Test-PSRuleTarget cmdlet can be used if only a true or false is required. In our example we are using the YAML format to store Kubernetes resources. PSRule has built-in support for YAML so we can import these files directly from disk or process output from a command such as kubectl . In the examples below: The -InputPath parameter is used to load objects from disk as YAML. YAML is automatically detected based on the .yaml file extension. Alternatively the -Foramt Yaml parameter can be used. Binding parameters are read from ps-rule.yaml in the current working path. Alternatively the -Option parameter could be used to specify an alternative file path. kubectl is called with the -o yaml to output resources as YAML. kubectl is piped to Out-String to convert the multi-line output to a single string. The -Format parameter informs PSRule that the string is YAML and it should convert the string into structured objects. The -ObjectPath parameter is used with the output from kubectl . This is required because the output from kubectl is a collection of resources instead of individual resources. Specifically -ObjectPath items gets the resources from the items property of the output. # Validate resources from file Invoke-PSRule -InputPath resources . yaml ; # Validate resources directly from kubectl output kubectl get services -o yaml | Out-String | Invoke-PSRule -Format Yaml -ObjectPath items ; For this example, we limited the output to failed results with the following command: # Validate resources from file Invoke-PSRule -Path docs / scenarios / kubernetes-resources -InputPath docs / scenarios / kubernetes-resources / resources . yaml -Option docs / scenarios / kubernetes-resources / ps-rule . yaml -Outcome Fail ; The resulting output is: TargetName: app1-cache RuleName Outcome Recommendation -------- ------- -------------- deployment.HasMinimumReplicas Fail Deployments use a minimum of 2 replicas deployment.NotLatestImage Fail Deployments use specific tags deployment.ResourcesSet Fail Resource requirements are set for each container TargetName: app1-cache-service RuleName Outcome Recommendation -------- ------- -------------- metadata.Name Fail Must have the app.kubernetes.io/name label metadata.Version Fail Must have the app.kubernetes.io/version label metadata.Component Fail Must have the app.kubernetes.io/component label TargetName: app1-ui RuleName Outcome Recommendation -------- ------- -------------- metadata.Version Fail Must have the app.kubernetes.io/version label More information # kubernetes.Rule.ps1 - Example rules for validating Kubernetes resources. resources.yaml - An example Kubernetes manifest. ps-rule.yaml - PSRule options configuration file.","title":"Kubernetes resource validation example"},{"location":"scenarios/kubernetes-resources/kubernetes-resources/#kubernetes-resource-validation-example","text":"This is an example of how PSRule can be used to validate Kubernetes resources to match an internal metadata and configuration standard. Note A pre-built module to validate Kubernetes resources already exists. This scenario demonstrates the process and features of PSRule for illustration purposes. Consider using or contributing these pre-built rule modules instead: PSRule.Rules.Kubernetes This scenario covers the following: Defining a basic rule. Configuring custom binding. Using a type precondition. Running rules using YAML input. In this scenario we will use a YAML file: resources.yaml - A Kubernetes manifest containing deployments and services.","title":"Kubernetes resource validation example"},{"location":"scenarios/kubernetes-resources/kubernetes-resources/#define-rules","text":"To validate our Kubernetes resources, we need to define some rules. Rules are defined by using the Rule keyword in a file ending with the .Rule.ps1 extension. Our business rules for configuration Kubernetes resources can be defined with the following dot points: The following recommended labels will be used on all services and deployments: app.kubernetes.io/name - the name of the application/ service. app.kubernetes.io/version - the version of the service. app.kubernetes.io/component - identifies the type of component, valid options are web , api , database and gateway For web or api deployments, a minimum of two (2) replicas must be used. Deployments must use container images with a specific version tag, and not latest . Deployments must declare minimum and maximum memory/ CPU resources. In the example below: We use metadata.Name directly after the Rule keyword to name the rule definition. Each rule must be named uniquely. The # Synopsis: comment is used to add additional metadata interpreted by PSRule. One or more conditions are defined within the curly braces { } . The rule definition is saved within a file named kubernetes.Rule.ps1 . # Synopsis: Must have the app.kubernetes.io/name label Rule 'metadata.Name' { # Rule conditions go here }","title":"Define rules"},{"location":"scenarios/kubernetes-resources/kubernetes-resources/#check-that-the-label-exists","text":"In the next step, we define one or more conditions. Conditions can be: Any valid PowerShell that returns a true (pass) when the condition is met or false (fail) when the condition is not met. More than one condition can be defined, if any condition returns false then the whole rule fails. PSRule includes several convenience keywords such as AllOf , AnyOf , Exists , Match , TypeOf and Within that make conditions faster to define, easier to understand and troubleshoot. However, use of these keywords is optional. In the example below: We use the Exists keyword to check that the resource has the app.kubernetes.io/name label set. By default, PSRule will step through nested properties separated by a . . i.e. labels is a property of metadata . Kubernetes supports and recommends label namespaces, which often use . in their name. PSRule supports this by enclosing the field name ( app.kubernetes.io/name ) in apostrophes ( ' ) so that app.kubernetes.io/name is checked instead of app . # Synopsis: Must have the app.kubernetes.io/name label Rule 'metadata.Name' { Exists \"metadata.labels.'app.kubernetes.io/name'\" } We have also defined something similar for the version and component labels. In the example below: Double apostrophes ( '' ) are used to enclose app.kubernetes.io/name because the field name uses ' at the start and end of the string instead of \" in the previous example. The Within keyword is used to validate that the app.kubernetes.io/component only uses one of four (4) allowed values. # Synopsis: Must have the app.kubernetes.io/version label Rule 'metadata.Version' { Exists 'metadata.labels.''app.kubernetes.io/version''' } # Synopsis: Must have the app.kubernetes.io/component label Rule 'metadata.Component' { Exists 'metadata.labels.''app.kubernetes.io/component''' Within 'metadata.labels.''app.kubernetes.io/component''' 'web' , 'api' , 'database' , 'gateway' -CaseSensitive }","title":"Check that the label exists"},{"location":"scenarios/kubernetes-resources/kubernetes-resources/#use-custom-binding","text":"Before processing rules, PSRule binds TargetName and TargetType properties to the pipeline object. These properties are used for filtering and displaying results. The default properties that PSRule binds are different from how Kubernetes resources are structured. Kubernetes uses: metadata.name to store the name of a resource. kind to store the type of resource. The default bindings can be updated by providing custom property names or a custom script. To change binding property names set the Binding.TargetName and Binding.TargetType configuration options. The following example shows how to set the options using a YAML configuration file: TargetName is bound to metadata.name TargetType is bound to kind binding : targetName : - metadata.name targetType : - kind These options can be set in the file .\\ps-rule.yaml to be automatically loaded at when PSRule cmdlets are called. To set these configuration options either edit the file manually or use the following command. # Set options in ps-rule.yaml Set-PSRuleOption -TargetName 'metadata.Name' -TargetType 'kind' ; Alternatively, these options can be set at runtime using the hashtable syntax. # Save options to a variable $option = New-PSRuleOption -TargetName 'metadata.Name' -TargetType 'kind' ; These options will be passed to Invoke-PSRule using the -Option parameter in a later step.","title":"Use custom binding"},{"location":"scenarios/kubernetes-resources/kubernetes-resources/#define-preconditions","text":"Currently the metadata.Name rule defined in a previous step will be executed for any type of object. Kubernetes has many types of built-in resource such as Services , Deployments , Namespaces , Pods and ClusterRoles . By defining a precondition, we can ensure that the rule is only processed for Services or Deployments to match our business rules. PSRule supports two types of preconditions, either type ( -Type ) or script block ( -If ). Type preconditions are one or more type names that PSRule compares to the TargetType binding, where: One of the type names names equal TargetType the rule will be processed. None of the type names equal TargetType the rule be skipped. Script block preconditions is a PowerShell script block that returns true or false , where: True - Continue processing the rule. False - Skip processing the rule. Preconditions are evaluated once per rule for each object. In the example below: We update our metadata.Name rule to use the -Type parameter to specify a type precondition of either Deployment or Service . In a previous step, TypeName was bound to the kind property which will be Deployment or Service for these resource types. # Synopsis: Must have the app.kubernetes.io/name label Rule 'metadata.Name' -Type 'Deployment' , 'Service' { Exists \"metadata.labels.'app.kubernetes.io/name'\" } Using a type precondition satisfies our business rules and will deliver faster performance then using a script block. An example using a script block precondition is also shown below. # Synopsis: Must have the app.kubernetes.io/name label Rule 'metadata.Name' -If { $TargetObject . kind -eq 'Deployment' -or $TargetObject . kind -eq 'Service' } { Exists \"metadata.labels.'app.kubernetes.io/name'\" }","title":"Define preconditions"},{"location":"scenarios/kubernetes-resources/kubernetes-resources/#complete-remaining-rules","text":"The remaining rule definitions from our defined business rules are included below. Each follows a similar pattern and builds on the previous sections. In the example below: The built-in variable $TargetObject is used to get the current pipeline object. Built-in keywords like Exists automatically default to $TargetObject , but can be piped alternative input as shown in the rule definition named deployment.ResourcesSet . # Synopsis: Deployments use a minimum of 2 replicas Rule 'deployment.HasMinimumReplicas' -Type 'Deployment' { Exists 'spec.replicas' $TargetObject . spec . replicas -ge 2 } # Synopsis: Deployments use specific tags Rule 'deployment.NotLatestImage' -Type 'Deployment' { foreach ( $container in $TargetObject . spec . template . spec . containers ) { $container . image -like '*:*' -and $container . image -notlike '*:latest' } } # Synopsis: Resource requirements are set for each container Rule 'deployment.ResourcesSet' -Type 'Deployment' { foreach ( $container in $TargetObject . spec . template . spec . containers ) { $container | Exists 'resources.requests.cpu' $container | Exists 'resources.requests.memory' $container | Exists 'resources.limits.cpu' $container | Exists 'resources.limits.memory' } }","title":"Complete remaining rules"},{"location":"scenarios/kubernetes-resources/kubernetes-resources/#execute-rules","text":"With some rules defined, the next step is to execute them. For this example, we'll use Invoke-PSRule to get the result for each rule. The Test-PSRuleTarget cmdlet can be used if only a true or false is required. In our example we are using the YAML format to store Kubernetes resources. PSRule has built-in support for YAML so we can import these files directly from disk or process output from a command such as kubectl . In the examples below: The -InputPath parameter is used to load objects from disk as YAML. YAML is automatically detected based on the .yaml file extension. Alternatively the -Foramt Yaml parameter can be used. Binding parameters are read from ps-rule.yaml in the current working path. Alternatively the -Option parameter could be used to specify an alternative file path. kubectl is called with the -o yaml to output resources as YAML. kubectl is piped to Out-String to convert the multi-line output to a single string. The -Format parameter informs PSRule that the string is YAML and it should convert the string into structured objects. The -ObjectPath parameter is used with the output from kubectl . This is required because the output from kubectl is a collection of resources instead of individual resources. Specifically -ObjectPath items gets the resources from the items property of the output. # Validate resources from file Invoke-PSRule -InputPath resources . yaml ; # Validate resources directly from kubectl output kubectl get services -o yaml | Out-String | Invoke-PSRule -Format Yaml -ObjectPath items ; For this example, we limited the output to failed results with the following command: # Validate resources from file Invoke-PSRule -Path docs / scenarios / kubernetes-resources -InputPath docs / scenarios / kubernetes-resources / resources . yaml -Option docs / scenarios / kubernetes-resources / ps-rule . yaml -Outcome Fail ; The resulting output is: TargetName: app1-cache RuleName Outcome Recommendation -------- ------- -------------- deployment.HasMinimumReplicas Fail Deployments use a minimum of 2 replicas deployment.NotLatestImage Fail Deployments use specific tags deployment.ResourcesSet Fail Resource requirements are set for each container TargetName: app1-cache-service RuleName Outcome Recommendation -------- ------- -------------- metadata.Name Fail Must have the app.kubernetes.io/name label metadata.Version Fail Must have the app.kubernetes.io/version label metadata.Component Fail Must have the app.kubernetes.io/component label TargetName: app1-ui RuleName Outcome Recommendation -------- ------- -------------- metadata.Version Fail Must have the app.kubernetes.io/version label","title":"Execute rules"},{"location":"scenarios/kubernetes-resources/kubernetes-resources/#more-information","text":"kubernetes.Rule.ps1 - Example rules for validating Kubernetes resources. resources.yaml - An example Kubernetes manifest. ps-rule.yaml - PSRule options configuration file.","title":"More information"},{"location":"scenarios/validation-pipeline/validation-pipeline/","text":"Using within continuous integration # PSRule supports several features that make it easy to a continuous integration (CI) pipeline. When added to a pipeline, PSRule can validate files, template and objects dynamically. This scenario covers the following: Installing within a CI pipeline. Validating objects. Formatting output. Failing the pipeline. Generating NUnit output. Additional options. Installing within a CI pipeline # Typically, PSRule is not pre-installed on CI worker nodes and must be installed. If your CI pipeline runs on a persistent virtual machine that you control, consider pre-installing PSRule. The following examples focus on installing PSRule dynamically during execution of the pipeline. Which is suitable for cloud-based CI worker nodes. To install PSRule within a CI pipeline execute the Install-Module PowerShell cmdlet. In the example below: When installing modules on Windows, modules will be installed into Program Files by default, which requires administrator permissions. Depending on your environment, the CI worker process may not have administrative permissions. Instead we can install PSRule for the current context running the CI pipeline by using the -Scope CurrentUser parameter. By default, this cmdlet will install the module from the PowerShell Gallery which is not trusted by default. Since a CI pipeline is not interactive, use the -Force switch to suppress the confirmation prompt. Install-Module -Name PSRule -Scope CurrentUser -Force ; In some cases, installing NuGet and PowerShellGet may be required to connect to the PowerShell Gallery. The NuGet package provider can be installed using the Install-PackageProvider PowerShell cmdlet. Install-PackageProvider -Name NuGet -Scope CurrentUser -Force ; Install-Module PowerShellGet -MinimumVersion '2.2.1' -Scope CurrentUser -Force -AllowClobber ; The example below includes both steps together with checks: if ( $Null -eq ( Get-PackageProvider -Name NuGet -ErrorAction SilentlyContinue )) { Install-PackageProvider -Name NuGet -Scope CurrentUser -Force ; } if ( $Null -eq ( Get-InstalledModule -Name PowerShellGet -MinimumVersion '2.2.1' -ErrorAction Ignore )) { Install-Module PowerShellGet -MinimumVersion '2.2.1' -Scope CurrentUser -Force -AllowClobber ; } if ( $Null -eq ( Get-InstalledModule -Name PSRule -MinimumVersion '0.12.0' -ErrorAction SilentlyContinue )) { Install-Module -Name PSRule -Scope CurrentUser -MinimumVersion '0.12.0' -Force ; } See the change log for the latest version. Validating objects # To validate objects use Invoke-PSRule , Assert-PSRule or Test-PSRuleTarget . In a CI pipeline, Assert-PSRule is recommended. Assert-PSRule outputs preformatted results ideal for use within a CI pipeline. For rules within the same source control repository, put rules in the .ps-rule directory. A directory .ps-rule in the repository root, is used by convention. In the following example, objects are validated against rules from the ./.ps-rule/ directory: $items | Assert-PSRule -Path './.ps-rule/' Example output: -> ObjectFromFile.psd1 : System.IO.FileInfo [PASS] File.Header [PASS] File.Encoding [WARN] Target object 'ObjectFromFile.yaml' has not been processed because no matching rules were found. [WARN] Target object 'ObjectFromNestedFile.yaml' has not been processed because no matching rules were found. [WARN] Target object 'Baseline.Rule.yaml' has not been processed because no matching rules were found. -> FromFile.Rule.ps1 : System.IO.FileInfo [FAIL] File.Header [PASS] File.Encoding In the next example, objects from file are validated against pre-defined rules from a module: Assert-PSRule -InputPath .\\ resources -*. json -Module PSRule . Rules . Azure ; Formatting output # When executing a CI pipeline, feedback on any validation failures is important. The Assert-PSRule cmdlet provides easy to read formatted output instead of PowerShell objects. Additionally, Assert-PSRule supports styling formatted output for Azure Pipelines and GitHub Actions. Use the -Style AzurePipelines or -Style GitHubActions parameter to style output. For example: $items | Assert-PSRule -Path './.ps-rule/' -Style AzurePipelines ; Failing the pipeline # When using PSRule within a CI pipeline, a failed rule should stop the pipeline. When using Assert-PSRule if any rules fail, an error will be generated. Assert-PSRule : One or more rules reported failure. At line:1 char:10 + $items | Assert-PSRule -Path ./.ps-rule/ + ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ + CategoryInfo : InvalidData: (:) [Assert-PSRule], FailPipelineException + FullyQualifiedErrorId : PSRule.Fail,Assert-PSRule A single PowerShell error is typically enough to stop a CI pipeline. If you are using a different configuration additionally -ErrorAction Stop can be used. For example: $items | Assert-PSRule -Path './.ps-rule/' -ErrorAction Stop ; Using -ErrorAction Stop will stop the current script and return an exit code of 1. To continue running the current script but return an exit code, use: try { $items | Assert-PSRule -Path './.ps-rule/' -ErrorAction Stop ; } catch { $Host . SetShouldExit ( 1 ); } Generating NUnit output # NUnit is a popular unit test framework for .NET. NUnit generates a test report format that is widely interpreted by CI systems. While PSRule does not use NUnit directly, it support outputting validation results in the NUnit3 format. Using a common format allows integration with any system that supports the NUnit3 for publishing test results. To generate an NUnit report: Use the -OutputFormat NUnit3 parameter. Use the -OutputPath parameter to specify the path of the report file to write. $items | Assert-PSRule -Path './.ps-rule/' -OutputFormat NUnit3 -OutputPath reports / rule-report . xml ; The output path will be created if it does not exist. Publishing NUnit report with Azure DevOps # With Azure DevOps, an NUnit report can be published using Publish Test Results task . An example YAML snippet is included below: # PSRule results - task : PublishTestResults@2 displayName : 'Publish PSRule results' inputs : testRunTitle : 'PSRule' testRunner : NUnit testResultsFiles : 'reports/rule-report.xml' mergeTestResults : true publishRunAttachments : true condition : succeededOrFailed() Complete example # Putting each of these steps together. Install dependencies # # Install dependencies for connecting to PowerShell Gallery if ( $Null -eq ( Get-PackageProvider -Name NuGet -ErrorAction SilentlyContinue )) { Install-PackageProvider -Name NuGet -Force -Scope CurrentUser ; } if ( $Null -eq ( Get-InstalledModule -Name PowerShellGet -MinimumVersion '2.2.1' -ErrorAction SilentlyContinue )) { Install-Module PowerShellGet -MinimumVersion '2.2.1' -Scope CurrentUser -Force -AllowClobber ; } Validate files # # Install PSRule module if ( $Null -eq ( Get-InstalledModule -Name PSRule -MinimumVersion '0.12.0' -ErrorAction SilentlyContinue )) { Install-Module -Name PSRule -Scope CurrentUser -MinimumVersion '0.12.0' -Force ; } # Validate files $assertParams = @{ Path = './.ps-rule/' Style = 'AzurePipelines' OutputFormat = 'NUnit3' OutputPath = 'reports/rule-report.xml' } $items = Get-ChildItem -Recurse -Path .\\ src \\,.\\ tests \\ -Include *. ps1 ,*. psd1 ,*. psm1 ,*. yaml ; $items | Assert-PSRule $assertParams -ErrorAction Stop ; Azure DevOps Pipeline # steps : # Install dependencies - powershell : ./pipeline-deps.ps1 displayName : 'Install dependencies' # Validate templates - powershell : ./validate-files.ps1 displayName : 'Validate files' # Publish pipeline results - task : PublishTestResults@2 displayName : 'Publish PSRule results' inputs : testRunTitle : 'PSRule' testRunner : NUnit testResultsFiles : 'reports/rule-report.xml' mergeTestResults : true publishRunAttachments : true condition : succeededOrFailed() Additional options # Using Invoke-Build # Invoke-Build is a build automation cmdlet that can be installed from the PowerShell Gallery by installing the InvokeBuild module. Within Invoke-Build, each build process is broken into tasks. The following example shows an example of using PSRule with Invoke-Build tasks. # Synopsis: Install PSRule task PSRule { if ( $Null -eq ( Get-InstalledModule -Name PSRule -MinimumVersion '0.12.0' -ErrorAction SilentlyContinue )) { Install-Module -Name PSRule -Scope CurrentUser -MinimumVersion '0.12.0' -Force ; } } # Synopsis: Validate files task ValidateFiles PSRule , { $assertParams = @{ Path = './.ps-rule/' Style = 'AzurePipelines' OutputFormat = 'NUnit3' OutputPath = 'reports/rule-report.xml' } $items = Get-ChildItem -Recurse -Path .\\ src \\,.\\ tests \\ -Include *. ps1 ,*. psd1 ,*. psm1 ,*. yaml ; $items | Assert-PSRule @assertParams -ErrorAction Stop ; } # Synopsis: Run all build tasks task Build ValidateFiles Invoke-Build Build ; Calling from Pester # Pester is a unit test framework for PowerShell that can be installed from the PowerShell Gallery. Typically, Pester unit tests are built for a particular pipeline. PSRule can complement Pester unit tests by providing dynamic and sharable rules that are easy to reuse. By using -If or -Type pre-conditions, rules can dynamically provide validation for a range of use cases. When calling PSRule from Pester use Invoke-PSRule instead of Assert-PSRule . Invoke-PSRule returns validation result objects that can be tested by Pester Should conditions. Additionally, the Logging.RuleFail option can be included to generate an error message for each failing rule. For example: Describe 'Azure' { Context 'Resource templates' { It 'Use content rules' { $invokeParams = @{ Path = './.ps-rule/' OutputFormat = 'NUnit3' OutputPath = 'reports/rule-report.xml' } $items = Get-ChildItem -Recurse -Path .\\ src \\,.\\ tests \\ -Include *. ps1 ,*. psd1 ,*. psm1 ,*. yaml ; Invoke-PSRule @invokeParams -Outcome Fail , Error | Should -BeNullOrEmpty ; } } } More information # pipeline-deps.ps1 - Example script installing pipeline dependencies. file.Rule.ps1 - Example rules for validating script files. validate-files.ps1 - Example script for running files validation. azure-pipelines.yaml - An example Azure DevOps Pipeline.","title":"Using within continuous integration"},{"location":"scenarios/validation-pipeline/validation-pipeline/#using-within-continuous-integration","text":"PSRule supports several features that make it easy to a continuous integration (CI) pipeline. When added to a pipeline, PSRule can validate files, template and objects dynamically. This scenario covers the following: Installing within a CI pipeline. Validating objects. Formatting output. Failing the pipeline. Generating NUnit output. Additional options.","title":"Using within continuous integration"},{"location":"scenarios/validation-pipeline/validation-pipeline/#installing-within-a-ci-pipeline","text":"Typically, PSRule is not pre-installed on CI worker nodes and must be installed. If your CI pipeline runs on a persistent virtual machine that you control, consider pre-installing PSRule. The following examples focus on installing PSRule dynamically during execution of the pipeline. Which is suitable for cloud-based CI worker nodes. To install PSRule within a CI pipeline execute the Install-Module PowerShell cmdlet. In the example below: When installing modules on Windows, modules will be installed into Program Files by default, which requires administrator permissions. Depending on your environment, the CI worker process may not have administrative permissions. Instead we can install PSRule for the current context running the CI pipeline by using the -Scope CurrentUser parameter. By default, this cmdlet will install the module from the PowerShell Gallery which is not trusted by default. Since a CI pipeline is not interactive, use the -Force switch to suppress the confirmation prompt. Install-Module -Name PSRule -Scope CurrentUser -Force ; In some cases, installing NuGet and PowerShellGet may be required to connect to the PowerShell Gallery. The NuGet package provider can be installed using the Install-PackageProvider PowerShell cmdlet. Install-PackageProvider -Name NuGet -Scope CurrentUser -Force ; Install-Module PowerShellGet -MinimumVersion '2.2.1' -Scope CurrentUser -Force -AllowClobber ; The example below includes both steps together with checks: if ( $Null -eq ( Get-PackageProvider -Name NuGet -ErrorAction SilentlyContinue )) { Install-PackageProvider -Name NuGet -Scope CurrentUser -Force ; } if ( $Null -eq ( Get-InstalledModule -Name PowerShellGet -MinimumVersion '2.2.1' -ErrorAction Ignore )) { Install-Module PowerShellGet -MinimumVersion '2.2.1' -Scope CurrentUser -Force -AllowClobber ; } if ( $Null -eq ( Get-InstalledModule -Name PSRule -MinimumVersion '0.12.0' -ErrorAction SilentlyContinue )) { Install-Module -Name PSRule -Scope CurrentUser -MinimumVersion '0.12.0' -Force ; } See the change log for the latest version.","title":"Installing within a CI pipeline"},{"location":"scenarios/validation-pipeline/validation-pipeline/#validating-objects","text":"To validate objects use Invoke-PSRule , Assert-PSRule or Test-PSRuleTarget . In a CI pipeline, Assert-PSRule is recommended. Assert-PSRule outputs preformatted results ideal for use within a CI pipeline. For rules within the same source control repository, put rules in the .ps-rule directory. A directory .ps-rule in the repository root, is used by convention. In the following example, objects are validated against rules from the ./.ps-rule/ directory: $items | Assert-PSRule -Path './.ps-rule/' Example output: -> ObjectFromFile.psd1 : System.IO.FileInfo [PASS] File.Header [PASS] File.Encoding [WARN] Target object 'ObjectFromFile.yaml' has not been processed because no matching rules were found. [WARN] Target object 'ObjectFromNestedFile.yaml' has not been processed because no matching rules were found. [WARN] Target object 'Baseline.Rule.yaml' has not been processed because no matching rules were found. -> FromFile.Rule.ps1 : System.IO.FileInfo [FAIL] File.Header [PASS] File.Encoding In the next example, objects from file are validated against pre-defined rules from a module: Assert-PSRule -InputPath .\\ resources -*. json -Module PSRule . Rules . Azure ;","title":"Validating objects"},{"location":"scenarios/validation-pipeline/validation-pipeline/#formatting-output","text":"When executing a CI pipeline, feedback on any validation failures is important. The Assert-PSRule cmdlet provides easy to read formatted output instead of PowerShell objects. Additionally, Assert-PSRule supports styling formatted output for Azure Pipelines and GitHub Actions. Use the -Style AzurePipelines or -Style GitHubActions parameter to style output. For example: $items | Assert-PSRule -Path './.ps-rule/' -Style AzurePipelines ;","title":"Formatting output"},{"location":"scenarios/validation-pipeline/validation-pipeline/#failing-the-pipeline","text":"When using PSRule within a CI pipeline, a failed rule should stop the pipeline. When using Assert-PSRule if any rules fail, an error will be generated. Assert-PSRule : One or more rules reported failure. At line:1 char:10 + $items | Assert-PSRule -Path ./.ps-rule/ + ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ + CategoryInfo : InvalidData: (:) [Assert-PSRule], FailPipelineException + FullyQualifiedErrorId : PSRule.Fail,Assert-PSRule A single PowerShell error is typically enough to stop a CI pipeline. If you are using a different configuration additionally -ErrorAction Stop can be used. For example: $items | Assert-PSRule -Path './.ps-rule/' -ErrorAction Stop ; Using -ErrorAction Stop will stop the current script and return an exit code of 1. To continue running the current script but return an exit code, use: try { $items | Assert-PSRule -Path './.ps-rule/' -ErrorAction Stop ; } catch { $Host . SetShouldExit ( 1 ); }","title":"Failing the pipeline"},{"location":"scenarios/validation-pipeline/validation-pipeline/#generating-nunit-output","text":"NUnit is a popular unit test framework for .NET. NUnit generates a test report format that is widely interpreted by CI systems. While PSRule does not use NUnit directly, it support outputting validation results in the NUnit3 format. Using a common format allows integration with any system that supports the NUnit3 for publishing test results. To generate an NUnit report: Use the -OutputFormat NUnit3 parameter. Use the -OutputPath parameter to specify the path of the report file to write. $items | Assert-PSRule -Path './.ps-rule/' -OutputFormat NUnit3 -OutputPath reports / rule-report . xml ; The output path will be created if it does not exist.","title":"Generating NUnit output"},{"location":"scenarios/validation-pipeline/validation-pipeline/#publishing-nunit-report-with-azure-devops","text":"With Azure DevOps, an NUnit report can be published using Publish Test Results task . An example YAML snippet is included below: # PSRule results - task : PublishTestResults@2 displayName : 'Publish PSRule results' inputs : testRunTitle : 'PSRule' testRunner : NUnit testResultsFiles : 'reports/rule-report.xml' mergeTestResults : true publishRunAttachments : true condition : succeededOrFailed()","title":"Publishing NUnit report with Azure DevOps"},{"location":"scenarios/validation-pipeline/validation-pipeline/#complete-example","text":"Putting each of these steps together.","title":"Complete example"},{"location":"scenarios/validation-pipeline/validation-pipeline/#install-dependencies","text":"# Install dependencies for connecting to PowerShell Gallery if ( $Null -eq ( Get-PackageProvider -Name NuGet -ErrorAction SilentlyContinue )) { Install-PackageProvider -Name NuGet -Force -Scope CurrentUser ; } if ( $Null -eq ( Get-InstalledModule -Name PowerShellGet -MinimumVersion '2.2.1' -ErrorAction SilentlyContinue )) { Install-Module PowerShellGet -MinimumVersion '2.2.1' -Scope CurrentUser -Force -AllowClobber ; }","title":"Install dependencies"},{"location":"scenarios/validation-pipeline/validation-pipeline/#validate-files","text":"# Install PSRule module if ( $Null -eq ( Get-InstalledModule -Name PSRule -MinimumVersion '0.12.0' -ErrorAction SilentlyContinue )) { Install-Module -Name PSRule -Scope CurrentUser -MinimumVersion '0.12.0' -Force ; } # Validate files $assertParams = @{ Path = './.ps-rule/' Style = 'AzurePipelines' OutputFormat = 'NUnit3' OutputPath = 'reports/rule-report.xml' } $items = Get-ChildItem -Recurse -Path .\\ src \\,.\\ tests \\ -Include *. ps1 ,*. psd1 ,*. psm1 ,*. yaml ; $items | Assert-PSRule $assertParams -ErrorAction Stop ;","title":"Validate files"},{"location":"scenarios/validation-pipeline/validation-pipeline/#azure-devops-pipeline","text":"steps : # Install dependencies - powershell : ./pipeline-deps.ps1 displayName : 'Install dependencies' # Validate templates - powershell : ./validate-files.ps1 displayName : 'Validate files' # Publish pipeline results - task : PublishTestResults@2 displayName : 'Publish PSRule results' inputs : testRunTitle : 'PSRule' testRunner : NUnit testResultsFiles : 'reports/rule-report.xml' mergeTestResults : true publishRunAttachments : true condition : succeededOrFailed()","title":"Azure DevOps Pipeline"},{"location":"scenarios/validation-pipeline/validation-pipeline/#additional-options","text":"","title":"Additional options"},{"location":"scenarios/validation-pipeline/validation-pipeline/#using-invoke-build","text":"Invoke-Build is a build automation cmdlet that can be installed from the PowerShell Gallery by installing the InvokeBuild module. Within Invoke-Build, each build process is broken into tasks. The following example shows an example of using PSRule with Invoke-Build tasks. # Synopsis: Install PSRule task PSRule { if ( $Null -eq ( Get-InstalledModule -Name PSRule -MinimumVersion '0.12.0' -ErrorAction SilentlyContinue )) { Install-Module -Name PSRule -Scope CurrentUser -MinimumVersion '0.12.0' -Force ; } } # Synopsis: Validate files task ValidateFiles PSRule , { $assertParams = @{ Path = './.ps-rule/' Style = 'AzurePipelines' OutputFormat = 'NUnit3' OutputPath = 'reports/rule-report.xml' } $items = Get-ChildItem -Recurse -Path .\\ src \\,.\\ tests \\ -Include *. ps1 ,*. psd1 ,*. psm1 ,*. yaml ; $items | Assert-PSRule @assertParams -ErrorAction Stop ; } # Synopsis: Run all build tasks task Build ValidateFiles Invoke-Build Build ;","title":"Using Invoke-Build"},{"location":"scenarios/validation-pipeline/validation-pipeline/#calling-from-pester","text":"Pester is a unit test framework for PowerShell that can be installed from the PowerShell Gallery. Typically, Pester unit tests are built for a particular pipeline. PSRule can complement Pester unit tests by providing dynamic and sharable rules that are easy to reuse. By using -If or -Type pre-conditions, rules can dynamically provide validation for a range of use cases. When calling PSRule from Pester use Invoke-PSRule instead of Assert-PSRule . Invoke-PSRule returns validation result objects that can be tested by Pester Should conditions. Additionally, the Logging.RuleFail option can be included to generate an error message for each failing rule. For example: Describe 'Azure' { Context 'Resource templates' { It 'Use content rules' { $invokeParams = @{ Path = './.ps-rule/' OutputFormat = 'NUnit3' OutputPath = 'reports/rule-report.xml' } $items = Get-ChildItem -Recurse -Path .\\ src \\,.\\ tests \\ -Include *. ps1 ,*. psd1 ,*. psm1 ,*. yaml ; Invoke-PSRule @invokeParams -Outcome Fail , Error | Should -BeNullOrEmpty ; } } }","title":"Calling from Pester"},{"location":"scenarios/validation-pipeline/validation-pipeline/#more-information","text":"pipeline-deps.ps1 - Example script installing pipeline dependencies. file.Rule.ps1 - Example rules for validating script files. validate-files.ps1 - Example script for running files validation. azure-pipelines.yaml - An example Azure DevOps Pipeline.","title":"More information"},{"location":"specs/design-spec/","text":"PSRule design specification (draft) # This document is intended as a working technical specification for PSRule. What is PSRule? # PSRule is an engine, shipped as a PowerShell module designed to validate infrastructure as code (IaC). Additionally, PSRule can validate any PowerShell object, allowing almost any custom scenario to be supported. PSRule natively supports common infrastructure code artifacts with the following file formats: YAML ( .yaml or .yml ). JSON ( .json ). PowerShell Data Files ( .psd1 ). Markdown front matter ( .md or .markdown ). While some infrastructure as code languages implement their own custom language, many support output into a standard artifact format. i.e. terraform show -json Project objectives # Extensible : Provide an execution environment (tools and language) to validate infrastructure code. Handling of common concerns such as input/ output/ reporting should be handled by the engine. Language must be flexible enough to support a wide range of use cases. DevOps : Validation should support and enhance DevOps workflows by providing fast feedback in pull requests. Allow quality gates to be implemented between environments such development, test, and production. Cross-platform : A wide range of platforms can be used to author and deploy infrastructure code. PSRule must support rule validation and authoring on Linux, MacOS, and Windows. Runs in a Linux container. For continuous integration (CI) systems that do not support PowerShell, run in a container. Reusable : Validation should plug and play, reusable across teams and organizations. Any reusable validation will have exceptions. Rules must be able to be disabled where they are not applicable. Language specification # PSRule is rooted in PowerShell. This provides significant benefits and flexibility including: Reuses existing skills within Microsoft and customers who already know how to author PowerShell scripts. Builds on existing PowerShell community; allowing existing integrations and cmdlets to be used. PowerShell already has an established model for distributing packages (modules). This includes options for trust and hosting (publicly or privately). To ensure these benefits remain, the following must be true: Rules can be written using standard PowerShell operators and conventions. Minimal knowledge of PSRule should be required to author rules. Rules validate an object graph. Whether an object originates from a YAML or JSON file should be abstract. Future cases # PowerShell offers complete flexibility to build simple to complex rules. However, rule authors may be unfamiliar with PowerShell. Authoring rules in YAML or JSON with a defined schema will allow additional options for basic rules. Concepts # Rule definitions # Rule definitions or rules are defined using PowerShell. Rules can be created in a PowerShell script file with the .Rule.ps1 extension. Rule files can be created and used individually or bundled as a module. Each rule: Implements a test for one or more conditions against an object. When all conditions return true the rule passes, if not the rule fails. Is evaluated by executing the rule within a sandbox that provides context to each rule. Such as the deserialized object being processed and configuration. Can specify preconditions which determine if a rule should be evaluated based on the object being processed. Rules only run against the objects they are designed to test. For example: Rule 'NameOfRule' { # <Rule conditions> } # Synopsis: Configure storage accounts to only accept encrypted traffic i.e. HTTPS/SMB Rule 'StorageAccounts.UseHttps' -Type 'Microsoft.Storage/storageAccounts' { $TargetObject . Properties . supportsHttpsTrafficOnly -eq $True } PSRule engine # Distributed as a PowerShell module, all source code is included within this repository. This included cmdlets and an execution sandbox where rules are evaluated. PSRule is designed to be self contained, requiring only PowerShell to run. By itself PSRule doesn't implement any specific rules. Custom rules can be defined and evaluated from PowerShell script files. Reusable rules can be distributed using PowerShell modules. Use PowerShellGet to install modules from public and private sources. PSRule extends PowerShell with domain specific language (DSL) keywords, cmdlets, and automatic variables. These language features are only available within the sandbox. Stubs are exported from PSRule module to provide command completion during authoring. In additional to rules, a number of resources can be used within PSRule. Resources are defined in YAML files with the .Rule.yaml file extension. You can create one or many resource within a single .Rule.yaml file. PSRule supports the following resources: Baseline - A reusable group of rules and configuration defaults for a given scenario. Selector - A reusable filter to determine which objects a rule should be run against. A special ModuleConfig resource can also be defined to configure defaults for a module. Keywords and variables # TBA Baselines # A baseline is a resource defined in YAML that determines which rules to run for a given scenario. One or more baselines can be included in a .Rule.yaml file. Baselines can be created individually or bundled in a module. Common use cases where baselines are helpful include: Separation of rules or features in development. For infrastructure code or rules early in their lifecycle, a recommend practice may not be fully ratified. Baselines allow rules to be distributed but not executed by default. Progressive adoption. If validation has been added for a new use case, it may not be possible to adopt all rules at once. Baselines act as checkpoints to allow validation of a subset of rules. Execution # Execution within PSRule occurs within a pipeline. The PSRule pipeline is similar to PowerShell and contains a begin , process , and end stage. Begin : TBA Process : TBA End : TBA Three execution pipelines exist, Invoke , Assert , or Test . Differences between each of these pipeline is minimal and mostly deals with how output is presented. Invoke : Returns output as pipeline objects so they can be natively processed by PowerShell code. Assert : Returns output as styled text to provide readable results within a CI pipeline. Test : Returns true or false based on pass or fail of each object. Use this option to use filter objects from a PowerShell pipeline. Execution sandbox # The execution sandbox is implemented using PowerShell runspaces. Runspaces are a PowerShell feature which enable partial isolation within a PowerShell process. PSRule uses two discrete runspaces: In the parent runspace where PSRule is called using Invoke-PSRule , Assert-PSRule , or Test-PSRule . The parent runspace is responsible for all input and output. The sandbox runspace is where rules execute. PSRule keywords and automatic variables are implemented in the sandbox. Flow control within the PSRule pipeline maintains context for each object as it is processed by rules. Input and output are proxied between the two discrete runspaces to maintain runspace separation. This separation allows rules to be executed without polluting the state of the parent runspace. Rule evaluation # TBA Configuration # PSRule has built-in support for configuration of the engine and rules. Configuration can be set by: Configuring the default ps-rule.yaml file. Setting at runtime by passing a -Option parameter to PSRule cmdlets. Engine options # Configuration of the PSRule engine is referred to as options. Each option changes the default that PSRule uses during execution. The supported options that can be configured for PSRule are described in the about_PSRule_Options topic. Rule configuration # Separately, rules can optionally define configuration that can skip or change the rule conditions. Rule configuration is a key/ value pair. Integration # TBA","title":"PSRule design specification (draft)"},{"location":"specs/design-spec/#psrule-design-specification-draft","text":"This document is intended as a working technical specification for PSRule.","title":"PSRule design specification (draft)"},{"location":"specs/design-spec/#what-is-psrule","text":"PSRule is an engine, shipped as a PowerShell module designed to validate infrastructure as code (IaC). Additionally, PSRule can validate any PowerShell object, allowing almost any custom scenario to be supported. PSRule natively supports common infrastructure code artifacts with the following file formats: YAML ( .yaml or .yml ). JSON ( .json ). PowerShell Data Files ( .psd1 ). Markdown front matter ( .md or .markdown ). While some infrastructure as code languages implement their own custom language, many support output into a standard artifact format. i.e. terraform show -json","title":"What is PSRule?"},{"location":"specs/design-spec/#project-objectives","text":"Extensible : Provide an execution environment (tools and language) to validate infrastructure code. Handling of common concerns such as input/ output/ reporting should be handled by the engine. Language must be flexible enough to support a wide range of use cases. DevOps : Validation should support and enhance DevOps workflows by providing fast feedback in pull requests. Allow quality gates to be implemented between environments such development, test, and production. Cross-platform : A wide range of platforms can be used to author and deploy infrastructure code. PSRule must support rule validation and authoring on Linux, MacOS, and Windows. Runs in a Linux container. For continuous integration (CI) systems that do not support PowerShell, run in a container. Reusable : Validation should plug and play, reusable across teams and organizations. Any reusable validation will have exceptions. Rules must be able to be disabled where they are not applicable.","title":"Project objectives"},{"location":"specs/design-spec/#language-specification","text":"PSRule is rooted in PowerShell. This provides significant benefits and flexibility including: Reuses existing skills within Microsoft and customers who already know how to author PowerShell scripts. Builds on existing PowerShell community; allowing existing integrations and cmdlets to be used. PowerShell already has an established model for distributing packages (modules). This includes options for trust and hosting (publicly or privately). To ensure these benefits remain, the following must be true: Rules can be written using standard PowerShell operators and conventions. Minimal knowledge of PSRule should be required to author rules. Rules validate an object graph. Whether an object originates from a YAML or JSON file should be abstract.","title":"Language specification"},{"location":"specs/design-spec/#future-cases","text":"PowerShell offers complete flexibility to build simple to complex rules. However, rule authors may be unfamiliar with PowerShell. Authoring rules in YAML or JSON with a defined schema will allow additional options for basic rules.","title":"Future cases"},{"location":"specs/design-spec/#concepts","text":"","title":"Concepts"},{"location":"specs/design-spec/#rule-definitions","text":"Rule definitions or rules are defined using PowerShell. Rules can be created in a PowerShell script file with the .Rule.ps1 extension. Rule files can be created and used individually or bundled as a module. Each rule: Implements a test for one or more conditions against an object. When all conditions return true the rule passes, if not the rule fails. Is evaluated by executing the rule within a sandbox that provides context to each rule. Such as the deserialized object being processed and configuration. Can specify preconditions which determine if a rule should be evaluated based on the object being processed. Rules only run against the objects they are designed to test. For example: Rule 'NameOfRule' { # <Rule conditions> } # Synopsis: Configure storage accounts to only accept encrypted traffic i.e. HTTPS/SMB Rule 'StorageAccounts.UseHttps' -Type 'Microsoft.Storage/storageAccounts' { $TargetObject . Properties . supportsHttpsTrafficOnly -eq $True }","title":"Rule definitions"},{"location":"specs/design-spec/#psrule-engine","text":"Distributed as a PowerShell module, all source code is included within this repository. This included cmdlets and an execution sandbox where rules are evaluated. PSRule is designed to be self contained, requiring only PowerShell to run. By itself PSRule doesn't implement any specific rules. Custom rules can be defined and evaluated from PowerShell script files. Reusable rules can be distributed using PowerShell modules. Use PowerShellGet to install modules from public and private sources. PSRule extends PowerShell with domain specific language (DSL) keywords, cmdlets, and automatic variables. These language features are only available within the sandbox. Stubs are exported from PSRule module to provide command completion during authoring. In additional to rules, a number of resources can be used within PSRule. Resources are defined in YAML files with the .Rule.yaml file extension. You can create one or many resource within a single .Rule.yaml file. PSRule supports the following resources: Baseline - A reusable group of rules and configuration defaults for a given scenario. Selector - A reusable filter to determine which objects a rule should be run against. A special ModuleConfig resource can also be defined to configure defaults for a module.","title":"PSRule engine"},{"location":"specs/design-spec/#keywords-and-variables","text":"TBA","title":"Keywords and variables"},{"location":"specs/design-spec/#baselines","text":"A baseline is a resource defined in YAML that determines which rules to run for a given scenario. One or more baselines can be included in a .Rule.yaml file. Baselines can be created individually or bundled in a module. Common use cases where baselines are helpful include: Separation of rules or features in development. For infrastructure code or rules early in their lifecycle, a recommend practice may not be fully ratified. Baselines allow rules to be distributed but not executed by default. Progressive adoption. If validation has been added for a new use case, it may not be possible to adopt all rules at once. Baselines act as checkpoints to allow validation of a subset of rules.","title":"Baselines"},{"location":"specs/design-spec/#execution","text":"Execution within PSRule occurs within a pipeline. The PSRule pipeline is similar to PowerShell and contains a begin , process , and end stage. Begin : TBA Process : TBA End : TBA Three execution pipelines exist, Invoke , Assert , or Test . Differences between each of these pipeline is minimal and mostly deals with how output is presented. Invoke : Returns output as pipeline objects so they can be natively processed by PowerShell code. Assert : Returns output as styled text to provide readable results within a CI pipeline. Test : Returns true or false based on pass or fail of each object. Use this option to use filter objects from a PowerShell pipeline.","title":"Execution"},{"location":"specs/design-spec/#execution-sandbox","text":"The execution sandbox is implemented using PowerShell runspaces. Runspaces are a PowerShell feature which enable partial isolation within a PowerShell process. PSRule uses two discrete runspaces: In the parent runspace where PSRule is called using Invoke-PSRule , Assert-PSRule , or Test-PSRule . The parent runspace is responsible for all input and output. The sandbox runspace is where rules execute. PSRule keywords and automatic variables are implemented in the sandbox. Flow control within the PSRule pipeline maintains context for each object as it is processed by rules. Input and output are proxied between the two discrete runspaces to maintain runspace separation. This separation allows rules to be executed without polluting the state of the parent runspace.","title":"Execution sandbox"},{"location":"specs/design-spec/#rule-evaluation","text":"TBA","title":"Rule evaluation"},{"location":"specs/design-spec/#configuration","text":"PSRule has built-in support for configuration of the engine and rules. Configuration can be set by: Configuring the default ps-rule.yaml file. Setting at runtime by passing a -Option parameter to PSRule cmdlets.","title":"Configuration"},{"location":"specs/design-spec/#engine-options","text":"Configuration of the PSRule engine is referred to as options. Each option changes the default that PSRule uses during execution. The supported options that can be configured for PSRule are described in the about_PSRule_Options topic.","title":"Engine options"},{"location":"specs/design-spec/#rule-configuration","text":"Separately, rules can optionally define configuration that can skip or change the rule conditions. Rule configuration is a key/ value pair.","title":"Rule configuration"},{"location":"specs/design-spec/#integration","text":"TBA","title":"Integration"}]}