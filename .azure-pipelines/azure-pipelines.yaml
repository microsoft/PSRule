# Azure DevOps
# Build pipeline for PSRule

strategy:
  matrix:
    Linux:
      imageName: 'ubuntu-16.04'
    MacOS:
      imageName: 'macos-10.13'
    Windows:
      imageName: 'vs2017-win2016'
      publishModule: 'true'
      analysis: 'true'
      coverage: 'true'

variables:
  buildConfiguration: 'Release'
  version: '0.7.0'

# Use build number format, i.e. 0.1.0-B181101
name: $(version)-B$(date:yyMM)$(rev:rr)

trigger:
- master

pool:
  vmImage: $(imageName)

steps:

# Install pipeline dependencies and build module
- powershell: ./.azure-pipelines/pipeline-build.ps1 -File ./pipeline.build.ps1 -Configuration $(buildConfiguration) -ModuleVersion $(Build.BuildNumber) -ReleaseVersion "$(Release.Version)"
  displayName: 'Build module'

# Run module benchmark
- powershell: ./.azure-pipelines/pipeline-build.ps1 -Task Benchmark -File ./pipeline.build.ps1 -Configuration $(buildConfiguration) -ModuleVersion $(Build.BuildNumber) -ReleaseVersion "$(Release.Version)"
  displayName: 'Benchmark'
  condition: eq(variables['benchmark'], 'true')

# Run SonarCloud analysis
- powershell: dotnet tool install --global dotnet-sonarscanner
  displayName: 'Install Sonar scanner'
  condition: and(ne(variables['Build.Reason'], 'PullRequest'), eq(variables['analysis'], 'true'))

- script: dotnet sonarscanner begin /k:"BernieWhite_PSRule" /o:"berniewhite-github" /d:sonar.host.url="https://sonarcloud.io" /d:sonar.login=$(sonarQubeToken) /v:"$(Build.BuildNumber)"
  displayName: 'Prepare SonarCloud'
  condition: and(ne(variables['Build.Reason'], 'PullRequest'), eq(variables['analysis'], 'true'))

- script: dotnet build
  displayName: 'Build solution for analysis'
  condition: and(ne(variables['Build.Reason'], 'PullRequest'), eq(variables['analysis'], 'true'))

- script: dotnet sonarscanner end /d:sonar.login=$(sonarQubeToken)
  displayName: 'Complete SonarCloud'
  condition: and(ne(variables['Build.Reason'], 'PullRequest'), eq(variables['analysis'], 'true'))

# DotNet test results
- task: PublishTestResults@2
  displayName: 'Publish unit test results'
  inputs:
    testRunTitle: 'DotNet on $(imageName)'
    testRunner: VSTest
    testResultsFiles: 'reports/*.trx'
    mergeTestResults: true
    platform: $(imageName)
    configuration: $(buildConfiguration)
    publishRunAttachments: true
  condition: succeededOrFailed()

# Pester test results
- task: PublishTestResults@2
  displayName: 'Publish Pester results'
  inputs:
    testRunTitle: 'Pester on $(imageName)'
    testRunner: NUnit
    testResultsFiles: 'reports/pester-unit.xml'
    mergeTestResults: true
    platform: $(imageName)
    configuration: $(buildConfiguration)
    publishRunAttachments: true
  condition: succeededOrFailed()

# PSRule results
- task: PublishTestResults@2
  displayName: 'Publish PSRule results'
  inputs:
    testRunTitle: 'PSRule on $(imageName)'
    testRunner: NUnit
    testResultsFiles: 'reports/rule.report.xml'
    mergeTestResults: true
    platform: $(imageName)
    configuration: $(buildConfiguration)
    publishRunAttachments: true
  condition: succeededOrFailed()

# Publish Code Coverage Results
- task: PublishCodeCoverageResults@1
  displayName: 'Publish Pester code coverage'
  inputs:
    codeCoverageTool: 'JaCoCo'
    summaryFileLocation: 'reports/pester-coverage.xml'
    #reportDirectory: # Optional
    #additionalCodeCoverageFiles: # Optional
    #failIfCoverageEmpty: false # Optional
  condition: eq(variables['coverage'], 'true')

# Generate artifacts
- task: PublishBuildArtifacts@1
  displayName: 'Publish PSRule module'
  inputs:
    PathtoPublish: out/modules/PSRule
    ArtifactName: PSRule
  condition: and(succeeded(), eq(variables['publishModule'], 'true'))
